{"project": "qemu", "commit_id": "d44168fffa07fc57e61a37da65e9348661dec887", "target": 1, "func": "static USBDevice *usb_net_init(const char *cmdline)\n\n{\n\n    USBDevice *dev;\n\n    QemuOpts *opts;\n\n    int idx;\n\n\n\n    opts = qemu_opts_parse(&qemu_net_opts, cmdline, NULL);\n\n    if (!opts) {\n\n\n\n    qemu_opt_set(opts, \"type\", \"nic\");\n\n    qemu_opt_set(opts, \"model\", \"usb\");\n\n\n\n    idx = net_client_init(NULL, opts, 0);\n\n    if (idx == -1) {\n\n\n\n\n\n    dev = usb_create(NULL /* FIXME */, \"usb-net\");\n\n\n\n\n    qdev_set_nic_properties(&dev->qdev, &nd_table[idx]);\n\n    qdev_init_nofail(&dev->qdev);\n\n    return dev;\n", "idx": 4093, "substitutes": {"usb_net_init": ["usb_net_Init", "usb_netlyInit", "usb_network_bind", "usb_netlyinit", "usb_netlybind", "usb_network_Init", "usb_network_create", "usb_netlycreate", "usb_net_bind", "usb_net_create", "usb_network_init"], "cmdline": ["mdlines", "commandstring", " cmdlines", "commandLINE", "cmdstring", "commandline", "CmdLine", " cmdLINE", "cmdLine", "cmdLINE", "cmdlines", "mdLINE", " cmdLine", "Cmdstring", "mdline", "commandlines", "commandLine", "Cmdline", " cmdstring", "mdLine"], "dev": ["db", "ev", "des", "instance", "mem", "devices", "usb", "end", "att", "cam", "pad", "DEV", "den", "conn", " Dev", "nt", "ve", " device", "die", " conn", "d", "util", "plug", " prod", "var", "sd", "del", "val", "data", "hw", "ach", "w", "go", "adv", "debug", "rem", "device", "van", "ow", "env", "ad", "v", "vo", "ot", "DE", "Device", "dd", "final", "new", "dn", "serv", "disc", "doc", "priv", "test", "fo", "de", "gu", "tech", "obj", "dis", "di", "ver", "Dev", "wd", "def", "od"], "opts": ["optrs", " opss", "optss", "optgs", "opTS", " opters", "prors", "optms", "optt", " copTS", "optts", "cops", " copters", "optters", "iopt", "prots", "iopts", "opms", "opcs", "prot", "OPps", "opss", "opfs", "opths", "proTS", "copts", "OPcs", " copcs", "optfs", " optrs", " optfs", "optTS", " copt", "optct", " copts", "OPs", "optths", " opt", "opt", "oprs", "opct", "copps", " opTS", " opct", "OPms", "opgs", "OPths", "optps", "iopgs", " coprs", " optts", " opths", " optss", "OPts", " oprs", "iopTS", "opters", "opps", "optcs", "copms", " opcs", " opgs", " opfs", "OPct", "ops"], "idx": ["idxf", "idi", "IDix", " idy", "midix", "idsx", " idxf", "Idxf", "midx", " idi", "ridxs", " idix", "IDxs", "IDi", "IDdx", "idsxs", "Idy", " idxs", "iddx", "IDx", "idsix", "riddx", "Iddx", "ridx", "idix", "idsdx", "ridix", "IDxf", "idy", "Idxs", " iddx", "Idix", "Idx", "midxs", "IDy", "midi", "idxs"]}}
{"project": "FFmpeg", "commit_id": "238ddd6482d7aea2e917760a9bef291030a11e61", "target": 1, "func": "static void pkt_dump_internal(void *avcl, FILE *f, int level, const AVPacket *pkt,\n\n                              int dump_payload, AVRational time_base)\n\n{\n\n    HEXDUMP_PRINT(\"stream #%d:\\n\", pkt->stream_index);\n\n    HEXDUMP_PRINT(\"  keyframe=%d\\n\", (pkt->flags & AV_PKT_FLAG_KEY) != 0);\n\n    HEXDUMP_PRINT(\"  duration=%0.3f\\n\", pkt->duration * av_q2d(time_base));\n\n    /* DTS is _always_ valid after av_read_frame() */\n\n    HEXDUMP_PRINT(\"  dts=\");\n\n    if (pkt->dts == AV_NOPTS_VALUE)\n\n        HEXDUMP_PRINT(\"N/A\");\n\n    else\n\n        HEXDUMP_PRINT(\"%0.3f\", pkt->dts * av_q2d(time_base));\n\n    /* PTS may not be known if B-frames are present. */\n\n    HEXDUMP_PRINT(\"  pts=\");\n\n    if (pkt->pts == AV_NOPTS_VALUE)\n\n        HEXDUMP_PRINT(\"N/A\");\n\n    else\n\n        HEXDUMP_PRINT(\"%0.3f\", pkt->pts * av_q2d(time_base));\n\n    HEXDUMP_PRINT(\"\\n\");\n\n    HEXDUMP_PRINT(\"  size=%d\\n\", pkt->size);\n\n    if (dump_payload)\n\n        av_hex_dump(f, pkt->data, pkt->size);\n\n}\n", "idx": 4095, "substitutes": {"avcl": [" avCl", "savCl", " avc", "afCl", "savcl", " avfl", "savc", "avc", "avCl", "affl", "savfl", "afc", "afcl", "avfl"], "f": ["cf", "uf", "b", "ff", "c", "h", "fx", "i", "lf", "file", "buffer", "fc", "d", "p", "F", "o", "fp", "t", "w", "rf", "bf", "v", "fac", "fed", "m", "fn", "fb", "tf", "sf", "fs", "fi", "e", "fr", "fd"], "level": ["depth", "type", "offset", "link", "len", "fl", "lc", "func", "vel", "scale", "vl", "limit", "tag", "debug", "style", "layer", "mode", "lev", "priority", "where", "levels", "lvl", "version", "Level", "hl", "length", "le", "flag"], "pkt": ["patchkt", "pek", "patchempt", "perkt", "permcht", "opnt", "ppcmd", "pingacket", "procmd", "proacket", "portkat", "perct", "pet", "pingkt", "powerek", "prkt", "pct", "Pwk", " pek", "pdu", " pkat", "opunct", "powerempt", "opet", "powerkt", "portct", "pcht", "opkt", "pracket", "proct", "ppacket", "Pkat", "Pcht", "pant", "patchek", "pingunct", " punct", " pant", "ppnt", " pwk", " pct", "Pct", "prft", "pcmd", "powerant", "Packet", "opcmd", "powernt", "Pnt", "prnt", " pempt", "pwk", "ppkt", "pempt", " pnt", "prekt", "permkt", "percmd", "pft", "pkat", "opwk", "Pkt", " pcht", "opacket", "preacket", "precmd", "powercmd", "ppft", "pnt", "punct", "Pcmd", "portkt", " pcmd", "pinget", "portcmd", "patchnt", " pdu", "packet", "Pant", "permcmd", "permacket", " pft", "powerdu", "peracket", "prent", "prokt", " pet", " packet", "Pdu"], "dump_payload": ["dump_payLOAD", "dump_payl", "dump_Payl", "dump_workl", "dump_ayl", "dump_ayline", "dump_publoads", "dump_publine", "dump_workload", "dump_pubload", "dump_Payloads", "dump2Payl", "dump2payload", "dump2payline", "dump_publ", "dump_payloads", "dump2payloads", "dump2Payload", "dump_PayLOAD", "dump2payl", "dump_workLOAD", "dump_Payline", "dump_ayload", "dump_Payload", "dump_ayloads", "dump_payline", "dump2Payloads", "dump2Payline", "dump_workloads", "dump_pubLOAD"], "time_base": ["time8bas", " time_back", "time9link", "time_bar", "time2based", "Time_base", " time_bar", " time_based", "time2back", "window_base", "time8ase", "time9bas", "time8bi", "time_bas", "window8ase", "time_based", "window8bas", "time9bar", "window_ase", "time_ase", "time_bi", "time_Base", "time_back", "time_link", "window8base", "window_bi", "Time_Base", "time2bas", " time_bas", "Time_bas", "window8bi", "time9base", "time8base", " time_link", "time2base", "window_bas"]}}
{"project": "qemu", "commit_id": "d20a580bc0eac9d489884f6d2ed28105880532b6", "target": 0, "func": "static void handle_mousewheel(SDL_Event *ev)\n\n{\n\n    struct sdl2_console *scon = get_scon_from_window(ev->key.windowID);\n\n    SDL_MouseWheelEvent *wev = &ev->wheel;\n\n    InputButton btn;\n\n\n\n    if (wev->y > 0) {\n\n        btn = INPUT_BUTTON_WHEEL_UP;\n\n    } else if (wev->y < 0) {\n\n        btn = INPUT_BUTTON_WHEEL_DOWN;\n\n    } else {\n\n        return;\n\n    }\n\n\n\n    qemu_input_queue_btn(scon->dcl.con, btn, true);\n\n    qemu_input_event_sync();\n\n    qemu_input_queue_btn(scon->dcl.con, btn, false);\n\n    qemu_input_event_sync();\n\n}\n", "idx": 4104, "substitutes": {"ev": ["event", "esc", "ell", "ov", "eb", "Ev", "cam", "eas", "em", "ve", "ek", "except", "exc", "er", "eg", "ent", "ele", "cmd", "ech", "inv", "ie", "vent", "dev", "ec", "ew", "iq", "eng", "eh", "ep", "hw", "err", "ever", "el", "crit", "sv", "esp", "veh", "v", "ef", "resp", "vc", "serv", "EV", "eva", "ee", "ex", "e", "eve", "enc", "vet", "env"], "scon": ["sconn", " sconst", "Sdon", "stsCon", "scons", "gescon", "gesco", " sCon", " sdon", "stscon", "wscon", "dsco", "gesconn", " sconn", "dsCon", "dscon", "wscons", "SCon", "stscons", "sco", "Sconst", "wsdon", "Sconn", " scons", "Sco", "Scon", "sdon", "sconst", "dsdon", "wsCon", "sCon", " sco", "gesconst", "stsdon"], "wev": [" weev", "vev", "hev", "weev", " seev", "uef", "wevs", "vevs", " weva", " sex", " wef", "vex", "theyva", "heb", "wef", "weva", "heva", "veva", "web", "nwev", "wex", " wevich", " sev", "theyv", "theyvich", " wex", "veb", "nwb", "ueva", "veev", " wevs", "wevich", "uevich", "heev", "nwv", "nwva", "uev", "theyf", " sevs"], "btn": ["output", "widget", "ck", "butt", "b", "bn", "layout", "bj", "usb", "pb", "cli", "bg", "kt", "wx", "toggle", "buffer", "msg", "bh", "fc", "cmd", "bp", "focus", "tn", "bd", "typ", "lu", "og", "cb", "label", "bt", "button", "fl", "sync", "fp", "bolt", "bool", "tag", "pkg", "mu", "attr", "token", "txt", "sbm", "status", "resp", "rl", "fn", "tab", "ack", "bs", "fb", "ko", "batch", "bl", "jp", "tap", "obj", "conv", "ctr", "pin", "tk", "ctrl", "tp", "addon", "fw"]}}
{"project": "qemu", "commit_id": "0c0eb30260b424d2a68603b89f1d829db18772c2", "target": 1, "func": "static void init_virtio_dev(TestServer *s)\n\n{\n\n    QPCIBus *bus;\n\n    QVirtioPCIDevice *dev;\n\n    uint32_t features;\n\n\n\n    bus = qpci_init_pc(NULL);\n\n    g_assert_nonnull(bus);\n\n\n\n    dev = qvirtio_pci_device_find(bus, VIRTIO_ID_NET);\n\n    g_assert_nonnull(dev);\n\n\n\n    qvirtio_pci_device_enable(dev);\n\n    qvirtio_reset(&dev->vdev);\n\n    qvirtio_set_acknowledge(&dev->vdev);\n\n    qvirtio_set_driver(&dev->vdev);\n\n\n\n    features = qvirtio_get_features(&dev->vdev);\n\n    features = features & VIRTIO_NET_F_MAC;\n\n    qvirtio_set_features(&dev->vdev, features);\n\n\n\n    qvirtio_set_driver_ok(&dev->vdev);\n\n}\n", "idx": 4141, "substitutes": {"s": ["rs", "gs", "ses", "ssl", "h", "os", "er", "ps", "p", "is", "ts", "ds", "t", "w", "sv", "sb", "services", "stats", "spec", "ss", "su", "sq", "socket", "fs", "S", "sis"], "bus": ["user", "bur", "chain", "b", "root", "way", "usb", " BUS", "c", "http", "pc", "h", "back", "ctx", "bc", "BUS", "box", "sys", "buf", "cs", "US", "os", "p", "Bus", "util", "plug", "uses", "cus", "bu", "proc", "board", "mount", "soc", "proxy", "host", "ch", "bridge", "ac", "bs", "serv", "local", "bug", "cat", "loop", "us", "gen", "boot", "lock", "conn"], "dev": ["db", "ev", "cast", "form", "des", "mem", "window", "usb", "end", "av", "cam", "pad", "DEV", "den", "dem", "pro", "buf", "ve", "nt", "client", "conn", "prop", "d", "addr", "order", "vol", "sd", "var", "val", "row", "temp", "w", "go", "th", "adv", "debug", "rem", "device", "van", "out", "env", "v", "watch", "vo", "dd", "Dev", "port", "ac", "comment", "der", "serv", "off", "build", "doc", "priv", "rent", "sky", "desc", "test", "obj", "tech", "de", "gu", "dest", "stick", "ver", "cho", "def", "develop"], "features": [" dimensions", " interfaces", "fields", "feat", "results", "relations", "weights", "times", "devices", "fts", "abilities", "ats", "ints", "Features", "ributes", " attributes", "cs", "sections", "acts", " products", "actions", "ensions", "frames", "tests", "details", "bugs", "settings", "rows", "eatures", "drivers", "types", "utils", "issues", "mas", " capabilities", " ports", "ids", "events", "orts", "services", "plugins", "xs", "ances", "facts", " Features", "properties", "feature", "bits", "states", "ATURES", "reports", " feature", " facts", "forms", "fs", " feat", "fixes", "flags", "versions", "length", "performance", " flags", " events", " details", "tools", "faces", "lists"]}}
{"project": "FFmpeg", "commit_id": "9f36ea57ae6eefb42432220feab0350494f4144c", "target": 1, "func": "int av_packet_split_side_data(AVPacket *pkt){\n\n    if (!pkt->side_data_elems && pkt->size >12 && AV_RB64(pkt->data + pkt->size - 8) == FF_MERGE_MARKER){\n\n        int i;\n\n        unsigned int size;\n\n        uint8_t *p;\n\n\n\n        p = pkt->data + pkt->size - 8 - 5;\n\n        for (i=1; ; i++){\n\n            size = AV_RB32(p);\n\n            if (size>INT_MAX || p - pkt->data < size)\n\n                return 0;\n\n            if (p[4]&128)\n\n                break;\n\n            p-= size+5;\n\n        }\n\n\n\n        pkt->side_data = av_malloc_array(i, sizeof(*pkt->side_data));\n\n        if (!pkt->side_data)\n\n            return AVERROR(ENOMEM);\n\n\n\n        p= pkt->data + pkt->size - 8 - 5;\n\n        for (i=0; ; i++){\n\n            size= AV_RB32(p);\n\n            av_assert0(size<=INT_MAX && p - pkt->data >= size);\n\n            pkt->side_data[i].data = av_mallocz(size + AV_INPUT_BUFFER_PADDING_SIZE);\n\n            pkt->side_data[i].size = size;\n\n            pkt->side_data[i].type = p[4]&127;\n\n            if (!pkt->side_data[i].data)\n\n                return AVERROR(ENOMEM);\n\n            memcpy(pkt->side_data[i].data, p-size, size);\n\n            pkt->size -= size + 5;\n\n            if(p[4]&128)\n\n                break;\n\n            p-= size+5;\n\n        }\n\n        pkt->size -= 8;\n\n        pkt->side_data_elems = i+1;\n\n        return 1;\n\n    }\n\n    return 0;\n\n}\n", "idx": 4159, "substitutes": {"pkt": [" pkg", "patchkt", "packtext", "wpelt", "pwp", "apgt", "patchunct", "pcast", " punc", "facket", "packkt", "preq", "payett", "upman", "tacket", "pict", "pingacket", "portett", "partett", "punc", "pman", "apkt", "actett", "patchkg", "repkg", "expkt", "actfeat", "cacket", "repacket", "pareq", "patchett", "pingkg", "formendor", "actkt", "pet", "Pwd", "pingkt", "ckt", "prkt", "ptx", "pakt", "fkg", "ccmd", "pac", "statact", " pmsg", "Pvert", "Pth", "opunct", "pfeat", " pconn", "upunct", "opconn", "pendor", "respkt", "picast", "apnt", " pett", "paacet", "wpkg", "repcmd", "partkt", "formacket", "upett", "upnt", "opkt", "postconn", "paict", "apacket", "cpkt", "pracket", "paunc", "upkg", "pwd", "postfeat", "apman", "wpconn", "pikt", "tkt", "wpwp", "apreq", "ipunct", "actkg", "statkg", "pvt", "pant", "pingunct", " punct", "pingvert", "pingconn", "pagt", "commth", "apwd", " ptext", "apkg", "ipkt", "paett", "pelt", "wpkt", "paykg", "pth", "pacet", "pcmd", "formkg", "expnt", "paykt", "portict", "formelt", "paacket", "Packet", "upkt", "pacmd", " pac", "paynt", "Pnt", "payict", "apvt", "packacket", "prnt", "partkg", "expmsg", "pkg", "formac", "formkt", "pact", " pnt", " ptx", "partfeat", " preq", "pett", "Pman", "payacet", "expett", "statkt", "ptext", "apcmd", "Pconn", "pmsg", "opacket", "paunct", "ipacket", "apunct", "tnt", "cpkg", "ckg", "postkt", "repkt", "pvert", "postett", "payendor", "Pet", "resptext", "pnt", "pawp", "commvert", " pact", "Pmsg", "respacket", " pvt", "cpunct", "punct", "pingth", "portkt", "pingcmd", " pcmd", "apwp", "wpacket", "upwd", " pendor", "pinget", " pcast", "respcast", "patx", "wpgt", "tconn", "packet", "pingunc", "fkt", "wpett", "postkg", "portacet", "statcast", "felt", "packcast", "cpett", "upacket", "ipkg", "payacket", "piact", "pikg", "prvt", "commkt", "pgt", "Ptx", "commet", "expacket", "payac", "postacket", "pconn", " packet", "Pkt"], "i": ["chain", "ei", "ice", "im", "gi", "zi", "ind", "hi", "pi", "I", "batch", "io", "in", "by", "j", "iri", "di", "\u0438", "x", "ic", "um", "mi", "xi", "index", "ri", "bi", "ki", "ti", "out", "v", "ai", "m", "ia", "us", "l", "ci", "it", "u", "at", "ip", "li", "ami", "is", "o", "s", "y", "fi", "ii", "init", "ij", "ini", "uri", "b", "cli", "qi", "si", "ie", "n", "multi", "from", "err", "me", "ui", "id", "ji", "phi", "ims", "ix", "status", "f", "sim", "ex", "iu", "e"], "size": ["bytes", "tree", "empty", "SIZE", "when", "c", "scope", "description", "see", "network", "general", "t", "pi", "value", "dimension", "south", "message", "sum", "ne", "source", "g", "zone", "ose", "notice", "zero", "index", "position", "unit", "reason", "span", "send", "start", "max", "timeout", "code", "v", "m", "loss", "date", "version", "address", "time", "length", "l", "large", "power", "end", "type", "shift", "offset", "equal", "len", "use", "total", "limit", "to", "sv", "style", "align", "s", "small", "scroll", "capacity", "shape", "ize", "engine", "name", "form", "sp", "window", "fee", "get", "Size", "set", "buffer", "si", "body", "n", "group", "data", "height", "scale", "number", "id", "space", "sh", "status", "gravity", "block", "new", "now", "sn", "storage", "member", "cache", "count", "area", "sample", "e", "global", "z", "format", "needed", "sized", "speed"], "p": ["pid", "att", "c", "h", "pro", "d", "ps", "php", "fp", "t", "pi", "pe", "pg", "jp", "P", "j", "post", "q", "wp", "up", "g", "op", "pl", "pre", "ap", "lp", "v", "port", "m", "parse", "np", "dp", "conv", "pp", "a", "l", "peer", "u", "pc", "pt", "at", "ip", "progress", "pa", "partial", "r", "pm", "pkg", "s", "y", "mp", "sp", "app", "b", "cp", "ping", "pb", "br", "rep", "pod", "bp", "n", "vp", "data", "pr", "ptr", "cache", "f", "point", "public", "e", "tp"]}}
{"project": "qemu", "commit_id": "d3ac1a87b228bcd231d19acf1ebe9844b7639237", "target": 1, "func": "static void usb_msd_cancel_io(USBDevice *dev, USBPacket *p)\n\n{\n\n    MSDState *s = DO_UPCAST(MSDState, dev, dev);\n\n    scsi_req_cancel(s->req);\n\n}\n", "idx": 4165, "substitutes": {"dev": ["iv", "db", "ev", "des", "app", "mem", "md", "ctx", "h", "cam", "pad", "DEV", "dem", "sys", "buf", "ve", "os", "raw", "d", "cmd", "sd", "data", "hw", "o", "pi", "w", "proc", "device", "out", "v", "ad", "req", "dd", "port", "home", "test", "io", "de", "unknown", "pp", "dis", "ver", "Dev", "conn", "def", "od"], "p": ["q", "sp", "b", "cp", "pb", "c", "pc", "h", "i", "d", "pa", "g", "bp", "fp", "t", "r", "w", "proc", "pkg", "lp", "v", "m", "np", "f", "dp", "P", "pp", "tp"], "s": ["rs", "so", "q", "ses", "sp", "gs", "b", "ns", "sol", "c", "h", "sam", "sys", "qs", "set", "cs", "state", "os", "ps", "n", "is", "ts", "ds", "t", "se", "es", "syn", "sv", "ls", "stats", "sl", "spec", "sa", "ss", "south", "sq", "fs", "S", "sts", "j", "a"]}}
{"project": "qemu", "commit_id": "4508d81a788f451c83604e1d0033243e191d71a7", "target": 1, "func": "ram_addr_t ppc405_set_bootinfo (CPUState *env, ppc4xx_bd_info_t *bd,\n\n                                uint32_t flags)\n\n{\n\n    ram_addr_t bdloc;\n\n    int i, n;\n\n\n\n    /* We put the bd structure at the top of memory */\n\n    if (bd->bi_memsize >= 0x01000000UL)\n\n        bdloc = 0x01000000UL - sizeof(struct ppc4xx_bd_info_t);\n\n    else\n\n        bdloc = bd->bi_memsize - sizeof(struct ppc4xx_bd_info_t);\n\n    stl_phys(bdloc + 0x00, bd->bi_memstart);\n\n    stl_phys(bdloc + 0x04, bd->bi_memsize);\n\n    stl_phys(bdloc + 0x08, bd->bi_flashstart);\n\n    stl_phys(bdloc + 0x0C, bd->bi_flashsize);\n\n    stl_phys(bdloc + 0x10, bd->bi_flashoffset);\n\n    stl_phys(bdloc + 0x14, bd->bi_sramstart);\n\n    stl_phys(bdloc + 0x18, bd->bi_sramsize);\n\n    stl_phys(bdloc + 0x1C, bd->bi_bootflags);\n\n    stl_phys(bdloc + 0x20, bd->bi_ipaddr);\n\n    for (i = 0; i < 6; i++)\n\n        stb_phys(bdloc + 0x24 + i, bd->bi_enetaddr[i]);\n\n    stw_phys(bdloc + 0x2A, bd->bi_ethspeed);\n\n    stl_phys(bdloc + 0x2C, bd->bi_intfreq);\n\n    stl_phys(bdloc + 0x30, bd->bi_busfreq);\n\n    stl_phys(bdloc + 0x34, bd->bi_baudrate);\n\n    for (i = 0; i < 4; i++)\n\n        stb_phys(bdloc + 0x38 + i, bd->bi_s_version[i]);\n\n    for (i = 0; i < 32; i++)\n\n        stb_phys(bdloc + 0x3C + i, bd->bi_s_version[i]);\n\n    stl_phys(bdloc + 0x5C, bd->bi_plb_busfreq);\n\n    stl_phys(bdloc + 0x60, bd->bi_pci_busfreq);\n\n    for (i = 0; i < 6; i++)\n\n        stb_phys(bdloc + 0x64 + i, bd->bi_pci_enetaddr[i]);\n\n    n = 0x6A;\n\n    if (flags & 0x00000001) {\n\n        for (i = 0; i < 6; i++)\n\n            stb_phys(bdloc + n++, bd->bi_pci_enetaddr2[i]);\n\n    }\n\n    stl_phys(bdloc + n, bd->bi_opbfreq);\n\n    n += 4;\n\n    for (i = 0; i < 2; i++) {\n\n        stl_phys(bdloc + n, bd->bi_iic_fast[i]);\n\n        n += 4;\n\n    }\n\n\n\n    return bdloc;\n\n}\n", "idx": 4166, "substitutes": {"env": ["ev", "et", "ses", "buf", "con", "te", "ec", "dev", "ed", "pl", " st", "pe", "el", "proc", "code", "en", "txt", "vd", "sh", "ch", "vs", "tx", "ptr", "cur", "de", "e", "ld", "shell"], "bd": ["db", "deb", "BD", "gb", "des", "b", "bn", "dat", " BD", "md", "bg", "br", "ond", "bc", "bro", "disabled", "don", "nd", "box", "nuts", "ben", "bh", "d", "dt", "bind", "ded", "sd", "gd", "ds", "lib", "dev", "bo", "bt", "fl", "bi", "th", "edd", "bb", "el", "bar", "board", "py", "sb", "rb", "bf", "od", "bin", "vd", "sh", "dd", "done", "bs", "nb", "cond", "disc", "cd", "desc", "bl", "bel", "pd", "rd", "de", "hd", "kb", "td", "ld", "dis", "non", "shell", "def", "amb", "ba"], "flags": ["fields", "ns", " fmt", "ags", "files", "fu", " features", "ps", "settings", "ts", "ds", " options", " bits", " fs", "options", "atts", "args", "bits", " args", "Flags", "FLAG", "fs", " props", " attributes", " flag", "fd", " fields", "flag"], "bdloc": ["bcloc", "bardfc", "bbLOC", "boloc", "blconn", "blloc", "bosc", "eddlocation", "blzero", "BDLoc", "bcval", "rodko", "breg", "borec", "bedalloc", "gdlib", "ldLOC", "blerr", "bdfc", "bcerr", "bolit", "bllocation", "bLoc", "blfc", "dbprop", "boreg", "bedloc", "bbloc", "bedlocation", "dcoord", "bdco", "bdreg", "blpl", "bardlocation", "bolocation", "bcco", "bderr", "bllib", "bcpl", "bdLoc", "eddLOC", "bardco", "hdlocation", "dLoc", "bapos", "blok", "blc", "bdko", "bazip", "bdzip", "bdabs", "bbpl", "hdLOC", "bblib", "bloc", "bberr", "bcsc", "bcnz", "bbprop", "bardloc", "rodlit", "bcfc", "eddcoord", "hdlocal", "bdcoord", "bdlib", "bllocal", "ldlocation", "bllit", "BDLOC", "bdesc", "bcutil", "bdprop", "bcabs", "bloci", "bclit", "boval", "bcconn", "rodloc", "bautil", "BDlocation", "bdrec", "bbok", "ldloc", "blreg", "bareg", "blval", "bdoci", "rodlocation", "BDloc", "dbloc", "bldesc", "blutil", "djloc", "bdlocal", "bdsc", "blabs", "balit", "djreg", "ldreg", "bclocal", "bdconn", "bdutil", "bcok", "dloc", "bdzero", "hdlc", "blrec", "bdLOC", "bclc", "ldzip", "djpos", "balocation", "bcdesc", "rodreg", "bbval", "bdpos", "baloc", "gdconn", "bedoci", "bdalloc", "dlocation", "gdloc", "bcalloc", "bdnz", "dbreg", "bdpl", "blocation", "bcpos", "boabs", "gdabs", "bdlit", "bardko", "hdLoc", "bardlit", "bczero", "bclib", "hdloc", "bcoci", "eddloc", "bofc", "bcprop", "bclocation", "bcrec", "bcreg", "djlocation", "bopl", "bbzero", "balocal", "dLOC", "ldcoord", "banz", "blLOC", "baco", "bddesc", "blko", "bdlc", "bcLOC", "bbreg", "bdval", "bdok", "bLOC", "bardnz", "bapl", "bafc", "dbLOC", "bczip", "balc", "bllc", "rodsc", "blalloc", "bdlocation"], "i": ["asi", "chain", "ei", " ii", "gi", "zi", "key", "hi", "pi", "I", "io", "in", "j", "x", "\u0438", "di", "this", "ic", "q", "um", "mi", "er", "g", "xi", "index", "ri", "bi", "ki", "ti", "v", "ai", "m", "remote", "us", "ico", "ci", "it", "ity", "u", "ip", "li", "ami", "p", "is", "dr", "try", "y", "fi", "ii", "name", "init", "ini", "ij", "uri", "b", "cli", "oi", "qi", "si", "ie", "iq", "multi", "me", "ui", "id", "ji", "phi", "ix", "eu", "status", "print", "sim", "ex", "iu", "e", "gu", "point", "ni"], "n": ["ns", "c", " ni", "nn", "p", "g", "no", "nc", "len", "na", "o", "t", "nu", "N", "Ni", "nm", "cn", "num", "v", "m", "nb", "sn", "nan", "count", "j", "ne", "ni", "l"]}}
{"project": "qemu", "commit_id": "92cb05574b7bd489be81f9c58497dc7dfe5d8859", "target": 0, "func": "bool virtio_ipl_disk_is_valid(void)\n\n{\n\n    return blk_cfg.blk_size && (virtio_disk_is_scsi() || virtio_disk_is_eckd());\n\n}\n", "idx": 4173, "substitutes": {}}
{"project": "qemu", "commit_id": "c60bf3391bf4cb79b7adc6650094e21671ddaabd", "target": 0, "func": "static void bdrv_password_cb(Monitor *mon, const char *password, void *opaque)\n\n{\n\n    BlockDriverState *bs = opaque;\n\n    int ret = 0;\n\n\n\n    if (bdrv_set_key(bs, password) != 0) {\n\n        monitor_printf(mon, \"invalid password\\n\");\n\n        ret = -EPERM;\n\n    }\n\n    if (mon->password_completion_cb)\n\n        mon->password_completion_cb(mon->password_opaque, ret);\n\n\n\n    monitor_read_command(mon, 1);\n\n}\n", "idx": 4178, "substitutes": {"mon": ["rain", "mate", "MON", "ain", "mn", "mot", "dat", "monkey", "mun", "md", "tem", "sam", "met", "don", "wat", "den", "mat", "store", "con", "comm", "mi", "ann", "my", "ston", "mark", "util", "co", "mut", "mt", "mond", "ms", "mint", "chron", "on", "monitor", "meter", "bo", "mont", "pers", "mas", "san", "irm", "mu", "dm", "von", " monitor", "num", "man", "mos", "ai", "m", "mitter", "mit", "Mon", "om", "serv", "demon", "mm", "cat", "manager", "tom", "sim", "min", "di", "ver", "mons", "mx", "admin"], "password": ["user", "padding", "prefix", "pty", "PASS", "paste", "description", "login", "picture", "words", "key", "crypt", " Password", "username", "value", "word", "past", "wordpress", "sword", "token", "REDACTED", "command", "secret", "phrase", "Password", "pattern", "hello", "pass", "email", "hash", "wd", "text", "private", "auth"], "opaque": ["ipaques", "paque", "psolete", " Opacity", " Opaque", "ipaque", "opque", " Opacement", "opaques", "compaques", "opacement", "compque", "opsolete", "ipque", "pacement", "opacity", "OPaque", "OPaques", "oplacity", "pacity", "compaque", " Opsolete", "OPque", "oplaque", "oplsolete", "oplacement"], "bs": ["asis", "gs", "bis", "ns", "ubs", "pb", "bos", "its", "acs", "ats", "bc", "sys", "cs", "aps", "bh", "ps", "als", "ms", "bp", "has", "ts", "is", "BS", " os", "aus", "bi", "js", "mas", "bb", "ths", "ls", "ons", "sb", "bid", "bits", "aos", "fs", "us", "oss", "bm", "bas", "obs", "lbs"]}}
{"project": "FFmpeg", "commit_id": "9c3a8693a20da3ad89a327bf778e13c2cd74c81c", "target": 0, "func": "dshow_cycle_devices(AVFormatContext *avctx, ICreateDevEnum *devenum,\n\n                    enum dshowDeviceType devtype, IBaseFilter **pfilter)\n\n{\n\n    struct dshow_ctx *ctx = avctx->priv_data;\n\n    IBaseFilter *device_filter = NULL;\n\n    IEnumMoniker *classenum = NULL;\n\n    IMoniker *m = NULL;\n\n    const char *device_name = ctx->device_name[devtype];\n\n    int skip = (devtype == VideoDevice) ? ctx->video_device_number\n\n                                        : ctx->audio_device_number;\n\n    int r;\n\n\n\n    const GUID *device_guid[2] = { &CLSID_VideoInputDeviceCategory,\n\n                                   &CLSID_AudioInputDeviceCategory };\n\n    const char *devtypename = (devtype == VideoDevice) ? \"video\" : \"audio\";\n\n\n\n    r = ICreateDevEnum_CreateClassEnumerator(devenum, device_guid[devtype],\n\n                                             (IEnumMoniker **) &classenum, 0);\n\n    if (r != S_OK) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Could not enumerate %s devices.\\n\",\n\n               devtypename);\n\n        return AVERROR(EIO);\n\n    }\n\n\n\n    while (!device_filter && IEnumMoniker_Next(classenum, 1, &m, NULL) == S_OK) {\n\n        IPropertyBag *bag = NULL;\n\n        char *buf = NULL;\n\n        VARIANT var;\n\n\n\n        r = IMoniker_BindToStorage(m, 0, 0, &IID_IPropertyBag, (void *) &bag);\n\n        if (r != S_OK)\n\n            goto fail1;\n\n\n\n        var.vt = VT_BSTR;\n\n        r = IPropertyBag_Read(bag, L\"FriendlyName\", &var, NULL);\n\n        if (r != S_OK)\n\n            goto fail1;\n\n\n\n        buf = dup_wchar_to_utf8(var.bstrVal);\n\n\n\n        if (pfilter) {\n\n            if (strcmp(device_name, buf))\n\n                goto fail1;\n\n\n\n            if (!skip--)\n\n                IMoniker_BindToObject(m, 0, 0, &IID_IBaseFilter, (void *) &device_filter);\n\n        } else {\n\n            av_log(avctx, AV_LOG_INFO, \" \\\"%s\\\"\\n\", buf);\n\n        }\n\n\n\nfail1:\n\n        if (buf)\n\n            av_free(buf);\n\n        if (bag)\n\n            IPropertyBag_Release(bag);\n\n        IMoniker_Release(m);\n\n    }\n\n\n\n    IEnumMoniker_Release(classenum);\n\n\n\n    if (pfilter) {\n\n        if (!device_filter) {\n\n            av_log(avctx, AV_LOG_ERROR, \"Could not find %s device.\\n\",\n\n                   devtypename);\n\n            return AVERROR(EIO);\n\n        }\n\n        *pfilter = device_filter;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 4196, "substitutes": {"ctx": ["cf", "dc", "loc", "gc", "ct", "ctl", "mem", "cp", "conf", "wx", "sys", "comm", "msg", "p", "cm", "cmd", "co", "addr", "tm", "context", "cb", "hw", "t", "history", "xc", "cc", "pkg", "txt", "handle", "cfg", "config", "resp", "tx", "cv", "tmp", "ca", "pool", "jp", "np", "mc", "obj", "xp", "Context", "x", "ctrl", "conn", "today", "abc", "tc", "act"], "device_filter": [" device_transform", "device__name", "devicelytransform", "resource_name", "device_type", "property2map", "property_Filter", "resource_filter", "property2filter", "device_Filter", "device__ref", "device2filter", "property_filter", "devicelylimit", "property2Filter", " device_limit", "resource_ref", "device2Filter", "device2map", "device_limit", "device__filter", "device_transform", "device__type", "devicelyfilter", "property_map", "resource_type", "device_map", "device_ref"], "classenum": ["groupenum", "Classen", "CLASSum", "processenum", "classesum", "groupnum", "classeseng", "processnum", "Classenum", "Classinal", "CLASSenum", "groupum", " classum", "classum", "classinal", "Classum", "CLASSeng", "Classnum", "groupinal", "classeng", "processen", "Classeng", " classen", "classen", "classesenum", " classnum", "processum", " classinal", "classnum"], "m": ["mn", "b", "mem", "gm", "c", "h", "ma", "i", "em", "M", "mi", "mr", "msg", "map", "g", "p", "cm", "mt", "ms", "n", "d", "tm", "t", "w", "module", "mu", "dm", "sm", "k", "v", "man", "mb", "mm", "am", "y", "mc", "manager", "mod", "vm", "j", "bm", "mx", "l", "mp"], "device_name": ["device_Name", "project_def", "deviceetytype", "device2number", "device2names", "device_def", "device_type", "device2name", "dev_number", "Device_name", "device_NAME", "dev_type", "deviceetyname", "device_names", "dev_name", "device2type", "device_id", "project_type", "project_default", "Device_Name", "project_name", "dev_names", "Device_NAME", "deviceetydefault", "device_number", "device_default", "deviceetydef", "Device_id"], "r": ["rs", "vr", "result", "q", "error", "repl", "ar", "it", "lr", " R", "sr", "kr", "c", "RR", "h", "br", "run", "nr", "i", "ry", "mr", "rn", "er", "actor", "p", "g", "rank", "n", "or", "tr", "usr", "t", " err", "err", "w", "dr", "rc", "after", "rr", "attr", "pr", "rem", "rb", "ir", "cr", "rar", "ren", "rt", "status", "re", "ror", "R", "rg", "f", " rc", "rd", "rec", "fr", "j", "Error", "arr", "res", "hr"], "device_guid": ["device_guids", "device_uuId", "device_seid", "device_gaad", "device_guID", "device_GuID", "device_uuids", "device_GuId", "device_uuID", "device_uuid", "device_sead", "device_cuID", "device_gaids", "device_cuids", "device_seids", "device_cuId", "device_cuid", "device_Guids", "device_gaid", "device_uuad", "device_guId", "device_guad", "device_Guid"], "devtypename": ["devtyppenename", "devTyrenname", "devtypername", "devtyppename", "devTyrename", "devtypenname", "devtyperAME", "devtypenename", "devTyrenAME", "devtylename", "devtyppenAME", "devtypenAME", "devtyternAME", "devTypename", "devtyternename", "devtytername", "devtyptername", "devtyrename", "devTyrenename", "devtyperame", "devTypenename", "devtyrenname", "devtypternename", "devtylenname", "devtylenAME", "devTypenname", "devtylenename", "devtyrenename", "devtyperename", "devtyternname", "devtyppenname", "devtypternname", "devtypternAME", "devTypenAME", "devtyrenAME"], "bag": ["widget", "folder", "package", "gc", "buff", "b", "ab", "jar", "pb", "pack", "zag", "band", "box", "binary", "bank", "pad", "buffer", "ball", "bed", "map", "card", "wb", "comb", "bow", "zip", "bar", "pkg", "sb", "grab", "container", "pak", "tab", "batch", "storage", "grid", "ag", "bags", "rag", "car", "bin"], "buf": ["db", "uf", "buff", "b", "next", "mem", "window", "BU", "br", "cam", "bc", "box", "cmp", "Buffer", "buffer", "msg", "seq", "prop", "p", "cmd", "cb", "data", "wb", "queue", "bound", "rw", "err", "w", "str", "rc", "vec", "ref", "bar", "pkg", "pg", "Buff", "mu", "rb", "txt", "orig", "mb", "new", "browser", "tmp", "cv", "batch", "pool", "bl", "np", "conv", "bin"], "var": ["iv", "vr", "cast", "par", "vard", "ser", "ar", "ars", "term", "br", "av", "star", "null", "box", "pack", "tar", "map", "rad", "addr", "vol", "dev", "AR", "val", "row", "usr", "t", "temp", "col", "w", "str", "let", "tag", "ref", "bar", "pkg", "expr", "iter", "v", "txt", "Var", "browser", "V", "tab", "art", "serv", "tmp", "y", "mod", "obj", "variable", "ver", "car"], "skip": ["counter", " skipping", " seek", "read", "depth", "sp", "error", "step", " sp", "run", "offset", "find", "ip", "seek", "chip", "zero", "index", " sk", "stop", "scale", "limit", " Skip", "Skip", "ips", " skipped", " snap", "send", "start", "iter", " iter", "sk", "status", "spec", "sleep", "scan", "pass", "jump", "strip", "loop", "serial", " sr", "check", "snap", "write", " scan", "disable"]}}
{"project": "FFmpeg", "commit_id": "a755b725ec1d657609c8bd726ce37e7cf193d03f", "target": 0, "func": "static int do_decode(AVCodecContext *avctx, AVPacket *pkt)\n\n{\n\n    int got_frame;\n\n    int ret;\n\n\n\n    av_assert0(!avctx->internal->buffer_frame->buf[0]);\n\n\n\n    if (!pkt)\n\n        pkt = avctx->internal->buffer_pkt;\n\n\n\n    // This is the lesser evil. The field is for compatibility with legacy users\n\n    // of the legacy API, and users using the new API should not be forced to\n\n    // even know about this field.\n\n    avctx->refcounted_frames = 1;\n\n\n\n    // Some codecs (at least wma lossless) will crash when feeding drain packets\n\n    // after EOF was signaled.\n\n    if (avctx->internal->draining_done)\n\n        return AVERROR_EOF;\n\n\n\n    if (avctx->codec_type == AVMEDIA_TYPE_VIDEO) {\n\n        ret = avcodec_decode_video2(avctx, avctx->internal->buffer_frame,\n\n                                    &got_frame, pkt);\n\n        if (ret >= 0 && !(avctx->flags & AV_CODEC_FLAG_TRUNCATED))\n\n            ret = pkt->size;\n\n    } else if (avctx->codec_type == AVMEDIA_TYPE_AUDIO) {\n\n        ret = avcodec_decode_audio4(avctx, avctx->internal->buffer_frame,\n\n                                    &got_frame, pkt);\n\n    } else {\n\n        ret = AVERROR(EINVAL);\n\n    }\n\n\n\n    if (ret == AVERROR(EAGAIN))\n\n        ret = pkt->size;\n\n\n\n    if (ret < 0)\n\n        return ret;\n\n\n\n    if (avctx->internal->draining && !got_frame)\n\n        avctx->internal->draining_done = 1;\n\n\n\n    if (ret >= pkt->size) {\n\n        av_packet_unref(avctx->internal->buffer_pkt);\n\n    } else {\n\n        int consumed = ret;\n\n\n\n        if (pkt != avctx->internal->buffer_pkt) {\n\n            av_packet_unref(avctx->internal->buffer_pkt);\n\n            if ((ret = av_packet_ref(avctx->internal->buffer_pkt, pkt)) < 0)\n\n                return ret;\n\n        }\n\n\n\n        avctx->internal->buffer_pkt->data += consumed;\n\n        avctx->internal->buffer_pkt->size -= consumed;\n\n        avctx->internal->buffer_pkt->pts   = AV_NOPTS_VALUE;\n\n        avctx->internal->buffer_pkt->dts   = AV_NOPTS_VALUE;\n\n    }\n\n\n\n    if (got_frame)\n\n        av_assert0(avctx->internal->buffer_frame->buf[0]);\n\n\n\n    return 0;\n\n}\n", "idx": 4198, "substitutes": {"avctx": ["avernp", "AVctx", "wavcmp", "avercheck", " avcmp", "AVnc", "iverloc", "vrctl", "avcp", "vrctx", "varsys", "ajctx", "avefc", "avcontext", "aveconn", "afcmd", "avjac", "ajnp", " avcol", "afca", "avecf", "avectl", "averctl", "wavcfg", "evcontext", " avcf", "vercu", "iverkw", "vrfc", "avecol", "avcfg", "vrconn", "iverconn", "avercol", "savsys", "devtx", "avcu", "avermk", "savcp", "ivercu", "averctx", "afctl", "avnp", "iverconfig", "AVcontext", "avcmd", "averwx", "afcheck", "afctx", "vrcfg", "devcontext", "avejac", "savctx", "varcheck", "devcu", "avmk", "ivercontext", "iversys", "avloc", "ajcontext", "avercf", "avconn", " avcp", "wavcheck", "evctx", "avecontext", "navtx", "vrcu", "navctx", "evtx", "wavsys", "averconfig", "avectx", "verctx", "navctl", "navcu", "wavctx", "avcheck", "averreq", "avcf", "navnc", "evca", "avctl", "wavcontext", "avertx", "navcmd", " avkw", "avecmd", "averkw", "savctrl", "navcontext", "navmk", "avca", "avpkg", "iverpkg", "verctrl", "wavnp", "avesys", "vrtx", "aveca", "vertx", "avtx", "aveconfig", "avercfg", "vercontext", "averloc", "avercp", "averconn", " avcontext", "aftx", "wavcmd", "avercu", "avercontext", "savctl", "ajwp", "devcmd", "ivtx", "varwx", "avecheck", " avtx", "iverctx", " avpkg", "avcol", " avca", " avcfg", "avwp", " avctl", "wavtx", "wavpkg", "vrcontext", "ajloc", "ivercfg", "averfc", "ajconn", "avectrl", "avercmp", "averjac", "afpkg", "avsys", "avctrl", "avnc", "avereq", "vrcmp", "vrsys", " avcu", "aversys", "versys", "afcmp", "avreq", "avecmp", "avercmd", "wavwp", "vartx", "avfc", " avreq", "avetx", "ivercheck", " avcheck", "avecfg", "iverjac", "devmk", "varctx", "ivcu", "AVtx", "savcontext", "avconfig", "iverwx", "ivcfg", " avnc", "wavctl", "avcmp", "ajcfg", "averwp", "varpkg", "averca", "avepkg", "afcontext", "avwx", "devctx", "ivctx", "avkw"], "pkt": [" pkg", "ck", "cnt", "kacket", "pbacket", "ppwk", "Pkg", "pdt", "proacket", "prodt", "apkt", "kct", "cacket", "pet", "ckt", " pdt", "prkt", "ppqt", "pakt", "pct", "paramunct", "pdu", "ppct", "upnt", "padu", "pbkt", "apacket", "pracket", "ppkg", "upkg", "pront", "proct", "pbct", "ppacket", "dk", "pant", "kkt", " punct", "apk", "pqt", "apkg", "ppnt", " pwk", " pelt", " pct", "paramkg", "pelt", "Pct", "cct", "pbunct", "Packet", "ppunct", "upkt", "ppdt", "prokg", "Pnt", "prnt", "dkt", "ppkt", "pwk", "pkg", "paramkt", " pnt", "paramwk", "pk", "ppdu", "dacket", "ppet", "upelt", "prct", "ckg", "kkg", "pnt", "punct", "ppelt", " pdu", "packet", "dkg", " pqt", "paqt", "proet", "prokt", " pet", " packet", "Pkt"], "got_frame": ["got_label", "fetched_feature", "fetched___frame", " got_component", "get_label", "gone_point", "gotexistingframe", "got_channel", "got_Frame", "gone_frame", " got_Frame", "got12frame", "get_role", "got12role", "got___frames", "gotexistingshot", "got___Frame", "drawn_zo", "gone_frames", "fetched_frame", "got_feature", "got_component", "got12label", "fetched___channel", " got_frames", "got_frames", "got_zo", "got___component", "drawn_frame", "get_frame", "drawn_shot", "got_part", "got_role", "got___feature", "gotexistingzo", "gone_part", "drawn_frames", "fetched___feature", "got___frame", "got_point", "gotexistingframes", "got___channel", "fetched_channel", "got_shot"], "ret": ["uf", "gc", "att", "det", "round", "ts", "ured", "url", "alt", "t", "iter", "num", "txt", "reset", "secure", "tmp", "eval", "cat", "jp", "j", "elt", "flag", "gt", "success", "mem", "mel", "ter", "nt", "compl", "orted", "dt", "over", "out", "max", "port", "desc", "ort", "alf", "back", "vers", "progress", "mt", "len", "val", "tr", "usr", "rev", "rem", "rest", "try", "rt", "lt", "final", "re", "reg", "ft", "net", "hash", "ll", "res", "deg", "rm", "result", "repl", "pret", "get", "cont", "sys", "mat", "ext", "cmd", "rets", "aux", "err", "ref", "plain", "not", "fun", "status", "resp", "img", "tf", "RET", "f", "Ret", "nz", "arg", "arr", "def"]}}
{"project": "qemu", "commit_id": "e8f1f9db8787be08e0ae3ed5a94da68966dbfff1", "target": 0, "func": "void net_host_device_remove(Monitor *mon, int vlan_id, const char *device)\n\n{\n\n    VLANState *vlan;\n\n    VLANClientState *vc;\n\n\n\n    vlan = qemu_find_vlan(vlan_id);\n\n\n\n   for(vc = vlan->first_client; vc != NULL; vc = vc->next)\n\n        if (!strcmp(vc->name, device))\n\n            break;\n\n\n\n    if (!vc) {\n\n        monitor_printf(mon, \"can't find device %s\\n\", device);\n\n        return;\n\n    }\n\n    qemu_del_vlan_client(vc);\n\n}\n", "idx": 4209, "substitutes": {"mon": ["MON", "mn", "mot", "monkey", "mun", "tem", "sam", "met", "wat", "mat", "con", "mi", "ann", "util", "mir", "mut", "mt", "monitor", "meter", "mont", "san", "mer", "mu", " Mon", "dm", "man", "mons", "ai", "om", "Mon", "serv", "mm", "cond", "min", "com", "dom", "onet"], "vlan_id": ["vane_mid", "vlanableids", "vlan_tag", "vnet_id", "vlanpooltag", "vlan_Id", "vane_Id", "vlanableid", "vane_ids", "vnet_info", "vlan2id", "vlanpoolid", "vlan_ids", "vaneableids", "vaneableId", "vane_id", "vlan2info", "vlan_info", "vlanableId", "vaneablemid", "vlan_mid", "vlanablemid", "vlan2Id", "vnet_tag", "vaneableid", "vnet_Id", "vlanpoolinfo", "vlanpoolId", "vlan2tag"], "device": ["package", "android", "node", "phy", "pod", "pad", "DEV", "scope", "model", "template", " Device", "plugin", "display", "connection", "link", "location", "dev", "network", "property", "data", "slave", "number", "value", "unit", "attribute", "VICE", "module", "resource", "mode", "component", "feature", "Device", "command", "product", "controller", "remote", "hello", "address", "serial", "hid", "family", "directory", "interface", "door", "name", "sequence"], "vlan": ["wLAN", "vlen", "evlan", " vlad", " volt", "vran", "volt", "evran", " vnet", " vann", "evLAN", "vlad", "evlad", "Vlad", "evolt", "vann", " vLAN", "Volt", " vran", "vLAN", "wnet", "vnet", "Vran", "Vnet", "Vlen", "wlan", "VLAN", "Vann", "wran", "Vlan", "evann", " vlen", "evlen"], "vc": ["fw", "iv", "cf", "vr", "dc", "ic", "vv", "gc", "ev", "lv", "att", "cp", "voc", "c", "wcs", "pc", "ib", "av", "bc", "cont", "cs", "client", "comm", "ve", "cow", "fc", "ht", "util", "vp", "nc", "vin", "WC", "cb", "lc", "ce", "cc", "xc", "rc", "irm", "coll", "sv", "ls", "ship", "umi", "von", "cn", "v", "VC", "vd", "dq", "rl", "cil", "ich", "serv", "cv", "jp", "ju", "mc", "vt", "fi", "vm", "liv", "lic", "ll", "ctrl", "cu", "tc", "vec"]}}
{"project": "qemu", "commit_id": "82ca891283a08cddd659b534592fe00f2159bc74", "target": 0, "func": "static void vfio_bar_write(void *opaque, hwaddr addr,\n\n                           uint64_t data, unsigned size)\n\n{\n\n    VFIOBAR *bar = opaque;\n\n    union {\n\n        uint8_t byte;\n\n        uint16_t word;\n\n        uint32_t dword;\n\n        uint64_t qword;\n\n    } buf;\n\n\n\n    switch (size) {\n\n    case 1:\n\n        buf.byte = data;\n\n        break;\n\n    case 2:\n\n        buf.word = cpu_to_le16(data);\n\n        break;\n\n    case 4:\n\n        buf.dword = cpu_to_le32(data);\n\n        break;\n\n    default:\n\n        hw_error(\"vfio: unsupported write size, %d bytes\\n\", size);\n\n        break;\n\n    }\n\n\n\n    if (pwrite(bar->fd, &buf, size, bar->fd_offset + addr) != size) {\n\n        error_report(\"%s(,0x%\"HWADDR_PRIx\", 0x%\"PRIx64\", %d) failed: %m\",\n\n                     __func__, addr, data, size);\n\n    }\n\n\n\n    DPRINTF(\"%s(BAR%d+0x%\"HWADDR_PRIx\", 0x%\"PRIx64\", %d)\\n\",\n\n            __func__, bar->nr, addr, data, size);\n\n\n\n    /*\n\n     * A read or write to a BAR always signals an INTx EOI.  This will\n\n     * do nothing if not pending (including not in INTx mode).  We assume\n\n     * that a BAR access is in response to an interrupt and that BAR\n\n     * accesses will service the interrupt.  Unfortunately, we don't know\n\n     * which access will service the interrupt, so we're potentially\n\n     * getting quite a few host interrupts per guest interrupt.\n\n     */\n\n    vfio_eoi(container_of(bar, VFIODevice, bars[bar->nr]));\n\n}\n", "idx": 4211, "substitutes": {"opaque": [" oposter", "opoid", "iopacity", " opane", "oposter", " opacity", "opaques", "iopane", "ogaques", "OPoid", "Opacity", "opacity", "OPaque", "OPaques", " opaques", "Opaque", "ogoster", "Opane", "ogoid", "iopaque", "opane", "OPoster", "ioposter", "Oposter", " opoid", "ogaque"], "addr": ["rs", "mem", "src", "lr", "ctx", "br", "pad", "offset", " address", "at", "ip", "cmd", "add", "mt", "arp", "or", "url", "row", "index", "usr", "hw", "r", "dh", "err", "dr", "id", "pos", "ref", "debug", "inter", "attr", "pkg", "align", "start", "host", "ad", "Address", "ix", "handle", "rt", "ack", "tx", "ptr", "alias", "address", "ord", "adr", "ace", "res", "work", "coord", "name", "loc"], "data": ["share", "bytes", "error", "padding", "empty", "dat", "mem", "window", "step", "type", "pad", "rel", "buffer", "msg", "raw", "map", "extra", "d", "p", "no", " DATA", "len", "rew", "ata", "zero", "Data", "str", "value", "w", "pos", "mu", "attr", "align", "device", "out", "ad", "bits", "frame", "block", "done", "action", "ret", "batch", "tx", "cache", "address", "ord", "DATA", "obj", "hash", "length", "format", "res", "trans", "text", "def", "image", "ops", "da", "bin"], "size": ["sp", "error", "empty", "SIZE", "mem", "window", "weight", "fee", "type", "shift", "sha", "Size", "offset", "set", "see", "g", "sy", "equal", "n", "len", "zero", "sent", "t", "height", "scale", "number", "value", "unit", "reason", "space", "style", "send", "s", "max", "num", "code", "dim", "sym", "sh", "small", "loss", "sn", "gz", "capacity", "count", "address", "message", "shape", "sum", "ize", "unknown", "time", "length", "z", "format", "news", "name"], "bar": ["bag", " bars", " ah", " ay", "hub", "piece", " batch", "pair", "queue", "comb", " vec", " hist", " oy", "watch", " foo", "worker", "bridge", " b", "foo", " br", " buck", "pause", "batch", "pas", "bill", "by", "coord", "car", " ret", "job", "pad", "store", " job", "bart", "good", "ay", "bars", "bench", "tick", "grab", "item", "rage", "ca", "hello", "bug", " ax", "ar", "bg", "cor", "var", " tab", "usr", "ax", "nob", "org", " block", " buffer", "que", " ab", " Bar", "gob", "b", "ab", "br", "box", "Bar", "bp", "aux", "row", " ch", " toolbar", "block", "tab", "handler", "chan", "hist", "arg", " barr"], "buf": ["bag", "uf", "buff", "b", "mem", "window", "pb", "ctx", "br", "box", "Buffer", "buffer", "msg", "map", "seq", "cmd", "fg", "good", "len", "var", "aux", "cb", "usr", "queue", "tr", "err", "w", "vec", "pos", "pkg", "ref", "iter", "txt", "cap", "req", "port", "block", "alloc", "tab", "foo", "off", "tmp", "cv", "tx", "batch", "img", "pool", "bl", "area", "ptr", "cur", "doc", "obj", "broad", "env", "ba"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void mcf5208evb_init(QEMUMachineInitArgs *args)\n\n{\n\n    ram_addr_t ram_size = args->ram_size;\n\n    const char *cpu_model = args->cpu_model;\n\n    const char *kernel_filename = args->kernel_filename;\n\n    CPUM68KState *env;\n\n    int kernel_size;\n\n    uint64_t elf_entry;\n\n    target_phys_addr_t entry;\n\n    qemu_irq *pic;\n\n    MemoryRegion *address_space_mem = get_system_memory();\n\n    MemoryRegion *ram = g_new(MemoryRegion, 1);\n\n    MemoryRegion *sram = g_new(MemoryRegion, 1);\n\n\n\n    if (!cpu_model)\n\n        cpu_model = \"m5208\";\n\n    env = cpu_init(cpu_model);\n\n    if (!env) {\n\n        fprintf(stderr, \"Unable to find m68k CPU definition\\n\");\n\n        exit(1);\n\n    }\n\n\n\n    /* Initialize CPU registers.  */\n\n    env->vbr = 0;\n\n    /* TODO: Configure BARs.  */\n\n\n\n    /* DRAM at 0x40000000 */\n\n    memory_region_init_ram(ram, \"mcf5208.ram\", ram_size);\n\n    vmstate_register_ram_global(ram);\n\n    memory_region_add_subregion(address_space_mem, 0x40000000, ram);\n\n\n\n    /* Internal SRAM.  */\n\n    memory_region_init_ram(sram, \"mcf5208.sram\", 16384);\n\n    vmstate_register_ram_global(sram);\n\n    memory_region_add_subregion(address_space_mem, 0x80000000, sram);\n\n\n\n    /* Internal peripherals.  */\n\n    pic = mcf_intc_init(address_space_mem, 0xfc048000, env);\n\n\n\n    mcf_uart_mm_init(address_space_mem, 0xfc060000, pic[26], serial_hds[0]);\n\n    mcf_uart_mm_init(address_space_mem, 0xfc064000, pic[27], serial_hds[1]);\n\n    mcf_uart_mm_init(address_space_mem, 0xfc068000, pic[28], serial_hds[2]);\n\n\n\n    mcf5208_sys_init(address_space_mem, pic);\n\n\n\n    if (nb_nics > 1) {\n\n        fprintf(stderr, \"Too many NICs\\n\");\n\n        exit(1);\n\n    }\n\n    if (nd_table[0].used)\n\n        mcf_fec_init(address_space_mem, &nd_table[0],\n\n                     0xfc030000, pic + 36);\n\n\n\n    /*  0xfc000000 SCM.  */\n\n    /*  0xfc004000 XBS.  */\n\n    /*  0xfc008000 FlexBus CS.  */\n\n    /* 0xfc030000 FEC.  */\n\n    /*  0xfc040000 SCM + Power management.  */\n\n    /*  0xfc044000 eDMA.  */\n\n    /* 0xfc048000 INTC.  */\n\n    /*  0xfc058000 I2C.  */\n\n    /*  0xfc05c000 QSPI.  */\n\n    /* 0xfc060000 UART0.  */\n\n    /* 0xfc064000 UART0.  */\n\n    /* 0xfc068000 UART0.  */\n\n    /*  0xfc070000 DMA timers.  */\n\n    /* 0xfc080000 PIT0.  */\n\n    /* 0xfc084000 PIT1.  */\n\n    /*  0xfc088000 EPORT.  */\n\n    /*  0xfc08c000 Watchdog.  */\n\n    /*  0xfc090000 clock module.  */\n\n    /*  0xfc0a0000 CCM + reset.  */\n\n    /*  0xfc0a4000 GPIO.  */\n\n    /* 0xfc0a8000 SDRAM controller.  */\n\n\n\n    /* Load kernel.  */\n\n    if (!kernel_filename) {\n\n        fprintf(stderr, \"Kernel image must be specified\\n\");\n\n        exit(1);\n\n    }\n\n\n\n    kernel_size = load_elf(kernel_filename, NULL, NULL, &elf_entry,\n\n                           NULL, NULL, 1, ELF_MACHINE, 0);\n\n    entry = elf_entry;\n\n    if (kernel_size < 0) {\n\n        kernel_size = load_uimage(kernel_filename, &entry, NULL, NULL);\n\n    }\n\n    if (kernel_size < 0) {\n\n        kernel_size = load_image_targphys(kernel_filename, 0x40000000,\n\n                                          ram_size);\n\n        entry = 0x40000000;\n\n    }\n\n    if (kernel_size < 0) {\n\n        fprintf(stderr, \"qemu: could not load kernel '%s'\\n\", kernel_filename);\n\n        exit(1);\n\n    }\n\n\n\n    env->pc = entry;\n\n}\n", "idx": 4213, "substitutes": {"args": ["gs", "names", "points", "ars", "ants", "ns", "orders", "md", "amps", "ags", "locks", "aws", "apps", "cs", "aps", "actions", "ians", "cmd", "ms", "words", "yes", "ts", "settings", "yrs", "eds", "arms", "vals", "js", "ins", "atts", "Args", "ras", "bits", "ams", "config", "vs", "GS", "limits", "doc", "parts", "fs", "arg", "flags", "changes", "arr", "params", "conn"], "cpu_model": ["cpuThefilename", "cpu00domain", "kernel_mode", "cpuPmethod", "cpuThemachine", "cpu_module", "pu_model", "cpuetymachine", "cpu_method", "pu_models", "cpuetytype", "gpu_machine", "cpu_record", "kernel_model", " cpu_filename", "cpu_name", "cpuThetype", "cpu_domain", "pu_name", "pu_record", "cpuetymodels", "gpu_model", "kernel_mod", "cpuPmachine", "kernel_domain", "cpuPmodel", "pu_machine", "cpu00mode", " cpu_type", " cpu_machine", "cpu00mod", "pu_module", "cpu_type", "cpu00model", "cpu_models", "cpu_machine", "cpuThemodel", "gpu_mode", "gpu_method", "pu_type", "cpu_filename", "cpuPmode", "cpu_mod", "cpu_mode", "cpuetymodel"], "kernel_filename": ["kernel_profile", "kernelitysource", "kernelacsource", "kernel_source", "system_file", "system_username", "kernel_file", "kernel_username", "kernelityfilename", "system_source", "kernelityfile", "kernelablefilename", "kernelacfilename", "system_filename", "kernelableusername", "system_profile", "kernel_files", "kernelityprofile", "kernelacfile", "kernelacprofile", "system_files", "kernelablefile", "kernelablefiles"], "env": ["iv", "ev", "export", "event", "et", "esc", "sw", "sp", "mem", "window", "end", "ped", "ctx", "here", "Ev", "cam", "eas", "eni", "conn", "em", "era", "exc", "er", "eg", "ent", "ec", "ew", "dev", "viron", "eng", "context", "environment", "ds", "hw", "ep", "server", "pe", "js", "proc", "sv", "esp", "en", "org", "v", "nv", "ef", "eu", "vs", "ptr", "jp", "vt", "obj", "vm", "e", "enc", "shell"], "kernel_size": ["kernel_count", "kernel2len", " kernel2size", " kernel_count", " kernel_len", "kernel2name", "kernel_name", " kernel2len", " kernel_name", " kernel2name", " kernel2count", "kernel2count", "kernel_len", "kernel2size"], "elf_entry": ["elfseqsize", "elf_cell", "elf_size", "elfseqcell", "elf_record", "rel_size", "elfseqrecord", "elfseqentry", "rel_entry", "rel_record", "rel_cell"], "entry": ["par", "error", "conf", "channel", "ries", "field", "nr", "ry", "rance", "connection", "row", "index", "pointer", "ary", "elta", "import", "value", "byte", "start", "slot", "pixel", "cell", "ptr", "address", "count", "info", "second"], "pic": ["ic", "sp", "magic", "wp", "Pic", "ics", "pb", "ping", "pc", "pen", "eric", "cam", "pan", "anc", "sys", "fig", "pict", "mi", "fc", "er", "virt", "p", "ps", "pa", "pick", "pins", "pol", "picture", "wic", "ds", "xi", "mic", "phys", "pi", "pers", "js", "syn", "py", "wit", "png", "pr", "style", "nic", "lp", "txt", "plain", "jac", "shot", "pot", "img", "maker", "doc", "kit", "jp", "ig", "pas", " Pic", "fi", "pse", "xp", "mc", "iac", "pres", "lic", "pin", "spr", "hog", "tick", "capt", "script"], "address_space_mem": ["address_pace_mem", "address_pace_hist", "address_machine_mem", "address_machine_em", "address_space_Mem", "address_pace_err", "address_space0sum", "address_space_em", "address_space_nm", "address_store_mem", "address_space_sum", "address_block", "addressportblock", "address_machine_mi", "addressmopblock", "address_space___memory", "address_space_res", "addressmop_", "address_space___err", "address_space_emb", "address_space__sum", "address_space_mb", "address_space__em", "locationmopblock", "address_pace0sum", "address_pace_sum", "address_spaceLres", "location_block", "address_pace0mem", "address_space_err", "address_space___Mem", "address_space__addr", "address_pace_num", "address_space_sys", "address_spaceLnm", "address_pace0hist", "address_space__mi", "address_space_hist", "address_space_ms", "address_space__mem", "address_system_memory", "address_space___mem", "address_store_emb", "address_pace_mb", "address_space0hist", "address_space___emb", "address_space_num", "address_store_Mem", "address_space___ms", "address__", "address_space_memory", "address_spaceLmem", "addressport_", "locationmop_", "address_pace_memory", "address_space_ram", "address_space_addr", "location__", "address_store_ms", "address_pace_em", "address_space0mem", "address_system_mem", "address_machine_addr", "address_system_mb", "address_pace_sys", "address_space___num", "address_space__hist", "address_space_mi"], "ram": ["rain", "jam", "gb", "um", "region", "mem", "iam", "tem", "cam", "sam", "tar", "ra", "dem", "ma", "sc", "arm", "raw", "RAM", "rank", "lam", "gram", "sd", "ran", "row", "process", "rum", "red", "na", "space", "rem", "rb", "lim", "memory", "ras", "mb", "mm", "am", "ru", "sky", "gem", "sum", "sim", "gra", "res", "rom", "ro", "def", "rm"], "sram": ["Smb", "sssam", "asram", " slam", "ssam", "Sgram", "svram", " smb", "Smem", " sgram", "svgram", "smb", "asgram", "ssgram", "slam", "aslam", "assam", "svream", "sslam", "ssream", "ssmem", "sgram", "ssram", "Sram", "Sream", "smem", "svsam", " ssam", "sream", " sream"]}}
{"project": "qemu", "commit_id": "9bada8971173345ceb37ed1a47b00a01a4dd48cf", "target": 0, "func": "static QObject *parse_escape(JSONParserContext *ctxt, va_list *ap)\n\n{\n\n    QObject *token;\n\n    const char *val;\n\n\n\n    if (ap == NULL) {\n\n        return NULL;\n\n    }\n\n\n\n    token = parser_context_pop_token(ctxt);\n\n    assert(token && token_get_type(token) == JSON_ESCAPE);\n\n    val = token_get_value(token);\n\n\n\n    if (!strcmp(val, \"%p\")) {\n\n        return va_arg(*ap, QObject *);\n\n    } else if (!strcmp(val, \"%i\")) {\n\n        return QOBJECT(qbool_from_bool(va_arg(*ap, int)));\n\n    } else if (!strcmp(val, \"%d\")) {\n\n        return QOBJECT(qint_from_int(va_arg(*ap, int)));\n\n    } else if (!strcmp(val, \"%ld\")) {\n\n        return QOBJECT(qint_from_int(va_arg(*ap, long)));\n\n    } else if (!strcmp(val, \"%lld\") ||\n\n               !strcmp(val, \"%I64d\")) {\n\n        return QOBJECT(qint_from_int(va_arg(*ap, long long)));\n\n    } else if (!strcmp(val, \"%s\")) {\n\n        return QOBJECT(qstring_from_str(va_arg(*ap, const char *)));\n\n    } else if (!strcmp(val, \"%f\")) {\n\n        return QOBJECT(qfloat_from_double(va_arg(*ap, double)));\n\n    }\n\n    return NULL;\n\n}\n", "idx": 4217, "substitutes": {"ctxt": ["ctct", "ktxt", "catxt", "CTtx", "pttx", "contct", "CTxt", "catct", "CTtxt", "cattx", "ptxt", "cttx", "pttxt", "CTct", "cattxt", "conttxt", "cttxt", "ctext", "ktext", "kttx", "contxt", "CText", "ptext", "conttx", "kttxt"], "ap": ["aug", "aw", "apa", "rap", "sp", "app", "ar", "ab", "wp", "att", "ats", "av", "pan", "rep", "sam", "alg", "aps", "aj", "ip", "map", "pa", "bp", "ak", "arp", "ep", "ach", "ax", "each", "ast", "api", "Ap", "ad", "appy", "cap", "hap", "apache", "ac", "al", "art", " sap", "am", "np", "tap", "amp", "apt", "ag", "snap", "AP", "oa", "tp", "gap", "ape", "mp"], "token": ["single", "header", "tree", "event", "form", "call", "empty", "node", "type", "oken", "field", "state", "ok", "template", "annot", "at", "util", "tg", "table", "mt", "stat", "typ", "tn", "ski", "context", "row", "label", "t", "key", "Token", "number", "record", "word", "initial", "list", "bar", "span", "forward", "start", "normal", "kn", "handle", "complete", "block", "TN", "fn", "sn", "item", "local", "TO", "KEN", "tf", "rule", "operator", "prototype", "atom", "info", "variable", "tool", "name", "object", "trigger"], "val": ["iv", "grad", "lv", "mem", "it", "sol", "gold", "rel", "Val", "buf", "ve", "tl", "lex", "valid", "msg", "prop", "p", "util", "bil", "vol", "ele", "pol", "typ", "len", "var", "dev", "lu", "bo", "pl", "rol", "vals", "kl", "sel", "col", "value", "bal", "str", "ref", "el", "ver", "old", "sv", "err", "pr", "oval", "v", "txt", "pal", "cal", "aval", "req", "vc", "reg", "serv", "tx", "fb", "eval", "lit", "al", "bl", "fail", "cur", "VAL", "test", "text", "x", "il", "cho", "elt", "vec"]}}
{"project": "qemu", "commit_id": "149f54b53b7666a3facd45e86eece60ce7d3b114", "target": 0, "func": "static inline uint64_t ldq_phys_internal(hwaddr addr,\n\n                                         enum device_endian endian)\n\n{\n\n    uint8_t *ptr;\n\n    uint64_t val;\n\n    MemoryRegionSection *section;\n\n\n\n    section = phys_page_find(address_space_memory.dispatch, addr >> TARGET_PAGE_BITS);\n\n\n\n    if (!(memory_region_is_ram(section->mr) ||\n\n          memory_region_is_romd(section->mr))) {\n\n        /* I/O case */\n\n        addr = memory_region_section_addr(section, addr);\n\n\n\n        /* XXX This is broken when device endian != cpu endian.\n\n               Fix and add \"endian\" variable check */\n\n#ifdef TARGET_WORDS_BIGENDIAN\n\n        val = io_mem_read(section->mr, addr, 4) << 32;\n\n        val |= io_mem_read(section->mr, addr + 4, 4);\n\n#else\n\n        val = io_mem_read(section->mr, addr, 4);\n\n        val |= io_mem_read(section->mr, addr + 4, 4) << 32;\n\n#endif\n\n    } else {\n\n        /* RAM case */\n\n        ptr = qemu_get_ram_ptr((memory_region_get_ram_addr(section->mr)\n\n                                & TARGET_PAGE_MASK)\n\n                               + memory_region_section_addr(section, addr));\n\n        switch (endian) {\n\n        case DEVICE_LITTLE_ENDIAN:\n\n            val = ldq_le_p(ptr);\n\n            break;\n\n        case DEVICE_BIG_ENDIAN:\n\n            val = ldq_be_p(ptr);\n\n            break;\n\n        default:\n\n            val = ldq_p(ptr);\n\n            break;\n\n        }\n\n    }\n\n    return val;\n\n}\n", "idx": 4218, "substitutes": {"addr": ["arm", "add", "oad", "url", "alt", "pos", "ack", "art", "ag", "adr", "coord", "x", "work", "loc", "rs", "mem", "lr", "asm", "sha", "pad", "store", " address", "index", "inter", "expr", "ac", "load", "arity", "address", "eth", "ace", "nl", "a", "urg", "adder", "ar", "src", "offset", "msg", "at", "ip", "map", "p", "mt", "usr", "hw", "r", "dh", "dr", "rc", "pkg", "attr", "align", "org", "host", "Address", "rt", "ash", "alloc", "ord", "hash", "net", "res", "act", "i", "cmd", "arp", "err", "id", "ref", "ad", "handle", "dist", "ix", "adj", "tx", "gz", "alias", "obj", "point", "arr", "hop"], "endian": ["endIAN", "mentians", "mentian", "ENDric", "endsians", " endians", "engian", " endia", "engia", "mentness", "mentia", "endsian", "endsric", "EndIAN", "ENDIAN", "endia", "Endians", "endians", "endness", "engians", " endness", "engness", "endsIAN", "endric", "ENDian", "ENDians", "Endric", "Endian"], "ptr": ["vr", "rod", "sp", "cert", "ped", "dep", "pc", "ctx", "err", "rep", "offset", "pad", "rel", "pt", "cont", "pointers", "p", "ps", "rect", "cmd", "seek", "ts", "var", "ind", "pointer", "tr", "index", "func", "pi", "r", "dh", "prime", "dr", "js", "ref", "pos", "inter", "pipe", "proc", "attr", "pr", "Ptr", "handle", "req", "port", "alloc", "jp", "address", "np", "point", "td", "fr", "adr", "ctr", "arr", "tp", "deg", "loc"], "val": [" res", "rel", "valid", " value", "alt", "trace", "value", "crit", "lev", " var", "aval", "ret", "eval", "test", "x", "loc", "elt", " ret", "mem", "ell", "Val", "pol", "pl", "vals", "sel", "str", "el", "v", " aval", "lit", " arg", "l", "update", "it", " update", "pt", " v", "prop", "util", "p", " al", "vol", "len", " el", "label", "rol", "bal", "cal", "al", "bl", "fail", "VAL", "res", "il", "cho", "all", "pret", "als", "data", "ival", " Val", "err", "ref", "id", "pr", "slot", "pal", "status", "resp", "tx", "vt", "point", " eval", "arr"], "section": ["example", "event", "function", "step", "state", "description", "sections", "year", "link", "pair", "se", "tag", "module", "reader", "comment", "entry", "mod", "test", "size", "activity", "j", "journal", "service", "instance", "region", "job", "page", "option", "index", "Section", "position", "port", "config", "part", "action", "version", "local", "our", "pool", "address", "header", "error", "prefix", "day", "line", "record", "sector", "param", "definition", "name", "portion", "side", "term", "set", "division", "sect", "table", "behavior", "group", "row", "element", "number", "slot", "man", "feature", "status", "block", "tab", "area", "member", "global", "ment", "lock", "setting", "format", "second"]}}
{"project": "qemu", "commit_id": "200668ba0839e664f0e4d0bcdc55ab5a163a418a", "target": 0, "func": "void main_loop_wait(int nonblocking)\n\n{\n\n    fd_set rfds, wfds, xfds;\n\n    int ret, nfds;\n\n    struct timeval tv;\n\n    int timeout;\n\n\n\n    if (nonblocking)\n\n        timeout = 0;\n\n    else {\n\n        timeout = qemu_calculate_timeout();\n\n        qemu_bh_update_timeout(&timeout);\n\n    }\n\n\n\n    os_host_main_loop_wait(&timeout);\n\n\n\n    tv.tv_sec = timeout / 1000;\n\n    tv.tv_usec = (timeout % 1000) * 1000;\n\n\n\n    /* poll any events */\n\n    /* XXX: separate device handlers from system ones */\n\n    nfds = -1;\n\n    FD_ZERO(&rfds);\n\n    FD_ZERO(&wfds);\n\n    FD_ZERO(&xfds);\n\n    qemu_iohandler_fill(&nfds, &rfds, &wfds, &xfds);\n\n    slirp_select_fill(&nfds, &rfds, &wfds, &xfds);\n\n\n\n    qemu_mutex_unlock_iothread();\n\n    ret = select(nfds + 1, &rfds, &wfds, &xfds, &tv);\n\n    qemu_mutex_lock_iothread();\n\n\n\n    qemu_iohandler_poll(&rfds, &wfds, &xfds, ret);\n\n    slirp_select_poll(&rfds, &wfds, &xfds, (ret < 0));\n\n\n\n    qemu_run_all_timers();\n\n\n\n    /* Check bottom-halves last in case any of the earlier events triggered\n\n       them.  */\n\n    qemu_bh_poll();\n\n\n\n}\n", "idx": 4221, "substitutes": {"nonblocking": ["onusing", " nonusing", " nonblocks", "nonblocks", "Nonblocks", " nonblock", " NONusing", "anoblocking", "onblocking", "Nonblock", " nonforcing", " NONblocking", "onforcing", "nonusing", "anoblocks", "anoblock", " NONforcing", "nonblock", "nonforcing", "Nonblocking"], "rfds": ["rfears", "fwargs", "rfcs", "rfps", "fwDS", "rafensions", "cfds", "rfd", "fwcs", "fgvs", "rafns", "rafrs", "rbrs", "fgs", "rafd", "rfs", "rfjs", "fwrs", "rfns", "fgjs", "fwds", "fwd", "rbds", "rfDS", "rafs", "cfDS", "rafps", "rbjs", "fwjs", "rbbs", "rafbs", "cfargs", "rafDS", "fwvs", "rfrs", "rbns", "rafcs", "fwears", "fgensions", "fwps", "fws", "fgargs", "cfs", "rfensions", "fgds", "fgrs", "rafds", "rbd", "fwbs", "rbps", "fwensions", "fwns", "rafjs", "rfvs", "fgears", "rbcs", "rafargs", "rafears", "rfbs", "rafvs", "rfargs"], "wfds": ["awfeds", "awfseds", "wlfms", "rwxfers", "webfds", "wcfns", "wftes", "wfgdds", "swxfys", "swfds", "wxfers", "wfsdds", "wufonds", "wwds", "wrfths", "wfseds", "winfdds", "ewfths", "wlfuds", "winfonds", "wxfms", "wfps", "rwfds", "wvds", "wkths", "wxfds", "wcfrs", "wfwors", "awfsargs", "wlfors", "wfrs", "wlfys", "wxfuds", "wwtes", "ewfuds", "ewfds", "wufdds", "ewxfjs", "wkjs", "wxfDS", "swfys", "wfns", "wfwys", "swxfDS", "winfds", "wufads", "wfgonds", "ewxfds", "rwxfns", "nfsds", "weblftes", "wfgads", "wfsds", "wufds", "wxfrs", "wfsargs", "wwps", "winufads", "wxfeds", "rwfers", "wfwargs", "awfsds", "awfys", "wvns", "nfsuds", "ewfjs", "rwfns", "wvys", "wfjs", "awfargs", "wrfds", "wrfuds", "wfgds", "wfstes", "awfds", "wkds", "nfms", "winfads", "swxfns", "wfwtes", "wfys", "wlfDS", "wvDS", "wfms", "webftes", "ewxfuds", "nfsms", "swfDS", "wfwds", "wrfjs", "nfuds", "wxfths", "awfsys", "wfors", "webfps", "wfeds", "swxfds", "ewxfths", "wfths", "wfsuds", "weblfps", "wdfrs", "wfads", "wwors", "wxftes", "nfstes", "weblfds", "wfweds", "nftes", "wfsads", "wxfys", "wlftes", "wfsonds", "wdfns", "swfns", "wfsys", "wkuds", "wxfargs", "wlfns", "wfDS", "wxfjs", "winufdds", "rwxfrs", "wcfds", "wdfds", "weblfors", "rwfrs", "wxfns", "wfsms", "webfors", "wlfds", "wfonds", "wfdds", "winufds", "wcfers", "wfargs", "rwxfds", "wfers", "winufonds", "wdfers", "wfuds", "wlfps", "wfwps"], "xfds": ["uffks", "fbrs", "fwDs", "fwards", "fwdds", "rfcs", "rafda", "xfks", "xffds", "cfdds", "cfds", "fwcs", "fxDs", "fgDs", "rafns", "fxards", "xfrs", "xfdds", "xffcs", "fweds", "fgdays", "fwda", "fxds", "fwrs", "fxuds", "fxns", "uffuds", "fbdays", "fwds", "fwd", "fifda", "xfeds", "xfda", "fxeds", "fxks", "xfuds", "xffeds", "rfuds", "fxd", "rafcs", "xfd", "xfns", "fifeds", "fxcs", "fgards", "uffcs", "fgaults", "xfDs", "fifcs", "uffds", "fgrs", "xfdays", "fgds", "rafds", "fifns", "fxdds", "xfcs", "fifrs", "xfaults", "fxrs", "fifdays", "fwns", "xffns", "fifaults", "fifds", "rfks", "fgcs", "cfrs", "fbaults", "cfd", "fbds", "xfards"], "ret": ["gt", "success", "result", "ct", "it", "reply", "back", "det", "nt", "dt", "rect", "mt", " Ret", "rets", "len", "tn", "no", "val", "tr", "usr", "alt", "t", "r", "err", "rc", "ref", "inter", "rem", "pert", "out", "iter", "num", "rt", "reset", "lt", "status", "re", "resp", "rm", "tmp", "RET", "vt", "Ret", "ft", "arg", "j", "res", "flag", "def", "tt", "elt", "unt"], "nfds": ["nxfdays", "nFds", "Nxfns", "nfsrs", "Nfys", "nsfrs", "nfsbs", "nvds", " nxfdays", "nbrfdes", "nfrs", "nvdes", "ncfx", "nbrfds", "Nfbs", "nxfns", "nbfdes", "nrfds", "nbrfrs", "nlfx", "nscfrs", "nsfdos", " nfdays", "nFbs", "Nfrs", "Nxfbs", "Nfns", "Nfds", "nbfods", "nfdos", "nfsys", "nxfdes", "nfcds", "Nfods", "nscfdos", "nvrs", "nxfys", "nfsds", "ncfids", " nxfrs", "nFys", "nbrfods", "nsfids", "nfsns", "nlfds", "nscfds", "ncfdays", "nxfdos", "nfns", " nfx", "nFns", "nfids", " nxfx", "nlfrs", "nrfods", "nlfdays", "nxfids", "nferrs", "nxfx", "Nxfys", "nbfrs", "nfx", "nfbs", "nfcrs", "nrfrs", "nfys", "nvods", "Nxfrs", "Nxfds", "nbfds", "nferds", "nxfds", "nxfods", " nfrs", "nrfdes", "ncfrs", " nxfds", "nfcbs", "ncfds", "nscfids", "nxfbs", "nxfrs", "ncfdos", "nferdos", "nfdays", "nfsods", "nfods", "Nxfods", "nfcods", "nferids", "nfdes", "nsfds"], "tv": ["vv", "ev", "event", "pb", "volt", "gov", "nr", " v", "tg", "dt", "timer", "tm", "tn", "vp", "ts", " t", "cb", " TV", "opt", "txt", "v", "tz", "sec", "watch", "TV", "rt", "xml", "tmp", "cv", "tx", "yt", "tf", "poll", "vt", "qt", "td", "html", "tk", "json", "news", "tp", "tt", "tc"], "timeout": ["policy", "service", "sp", "Timeout", "error", "wait", "it", "window", "range", "type", "T", "buffer", "dt", "timer", "duration", "n", "ts", "settings", "connection", "option", "course", "total", "t", "history", "seconds", "OUT", "server", "number", "bolt", "limit", "value", "unit", "attribute", "height", "options", "opt", "delay", "span", "out", "max", "v", "watch", "slot", "status", "scroll", "period", "frequency", "tmp", "version", "response", "print", "capacity", "spin", "size", "time", "directory", "lock", "resolution", "json", "latest", "tt", "tc", "sequence"]}}
{"project": "qemu", "commit_id": "88be7b4be4aa17c88247e162bdd7577ea79db94f", "target": 1, "func": "void bdrv_invalidate_cache_all(Error **errp)\n\n{\n\n    BlockDriverState *bs;\n\n    Error *local_err = NULL;\n\n    BdrvNextIterator *it = NULL;\n\n\n\n    while ((it = bdrv_next(it, &bs)) != NULL) {\n\n        AioContext *aio_context = bdrv_get_aio_context(bs);\n\n\n\n        aio_context_acquire(aio_context);\n\n        bdrv_invalidate_cache(bs, &local_err);\n\n        aio_context_release(aio_context);\n\n        if (local_err) {\n\n            error_propagate(errp, local_err);\n\n            return;\n\n        }\n\n    }\n\n}\n", "idx": 4253, "substitutes": {"errp": [" errP", "eorpa", "arrp", "risknp", "arrnp", "arrP", "riskP", "riskp", "arrping", "riskpa", "errpa", " errnp", " errping", "arrpa", "errP", "errnp", "eorP", "eorping", "errping", " errpa", "eorp"], "bs": ["boxes", "as", "rs", "gs", "bis", "b", "bn", "ists", "ns", "ubs", "blog", "pb", "ics", "its", "bos", "bg", "ats", "acs", "bc", "sys", "bsp", "cs", "bh", "base", "ps", "bp", "ts", "ds", "BS", "bt", "es", "bi", "aus", "lb", "js", "bb", "ls", "sb", "bf", "bps", "ubis", "bits", "vs", "ss", "bl", "fs", "bm", "bas", "obs", "lbs"], "local_err": ["local___msg", " local_msg", "Local_err", " local_reason", "local_rr", "localErmsg", "localErrr", " local_rr", "local_str", "local___rr", "Local_msg", "local___er", "Local_er", "localErerr", "local_er", " local_str", "localmyrr", "localmyerr", "local_msg", "local_reason", " local_result", "Local_rr", "localErstr", " local_er", "local___err", "local_result", "localmyreason", "localmyer"], "it": ["init", "ic", "q", "ert", "wait", "ITS", "est", "its", "ib", "h", "lat", "i", "pit", "at", "ip", "p", "n", "sit", "ind", "ed", "t", "ut", "r", "iti", "el", "id", "IT", "ir", "iter", "out", "ait", "shot", "mit", "al", "quit", "ul", "itted", "item", "yt", "ist", "lit", "It", "hit", "ex", "in", "j", "il", "l"], "aio_context": ["aIO_thread", "aio___ctx", "aio___thread", "aio___client", "aIO_status", "aio_instance", "aible_context", "aible_handle", "aible_config", "aIO_client", "aio___context", "aio_object", "aio____config", "aIO_ctx", "aio_status", "aio_thread", "aio____handle", "aio_client", "aio___instance", "aible_object", "aIO_instance", "aio____object", "aIO_context", "aio___status", "aio_config", "aio_ctx", "aio____context", "aio_handle"]}}
{"project": "FFmpeg", "commit_id": "ec07efa70012845e8642df67a4a773f510a17088", "target": 1, "func": "static int parse_adaptation_sets(AVFormatContext *s)\n\n{\n\n    WebMDashMuxContext *w = s->priv_data;\n\n    char *p = w->adaptation_sets;\n\n    char *q;\n\n    enum { new_set, parsed_id, parsing_streams } state;\n\n    if (!w->adaptation_sets) {\n\n        av_log(s, AV_LOG_ERROR, \"The 'adaptation_sets' option must be set.\\n\");\n\n        return AVERROR(EINVAL);\n\n    }\n\n    // syntax id=0,streams=0,1,2 id=1,streams=3,4 and so on\n\n    state = new_set;\n\n    while (p < w->adaptation_sets + strlen(w->adaptation_sets)) {\n\n        if (*p == ' ')\n\n            continue;\n\n        else if (state == new_set && !strncmp(p, \"id=\", 3)) {\n\n            void *mem = av_realloc(w->as, sizeof(*w->as) * (w->nb_as + 1));\n\n            if (mem == NULL)\n\n                return AVERROR(ENOMEM);\n\n            w->as = mem;\n\n            ++w->nb_as;\n\n            w->as[w->nb_as - 1].nb_streams = 0;\n\n            w->as[w->nb_as - 1].streams = NULL;\n\n            p += 3; // consume \"id=\"\n\n            q = w->as[w->nb_as - 1].id;\n\n            while (*p != ',') *q++ = *p++;\n\n            *q = 0;\n\n            p++;\n\n            state = parsed_id;\n\n        } else if (state == parsed_id && !strncmp(p, \"streams=\", 8)) {\n\n            p += 8; // consume \"streams=\"\n\n            state = parsing_streams;\n\n        } else if (state == parsing_streams) {\n\n            struct AdaptationSet *as = &w->as[w->nb_as - 1];\n\n            q = p;\n\n            while (*q != '\\0' && *q != ',' && *q != ' ') q++;\n\n            as->streams = av_realloc(as->streams, sizeof(*as->streams) * ++as->nb_streams);\n\n            if (as->streams == NULL)\n\n                return AVERROR(ENOMEM);\n\n            as->streams[as->nb_streams - 1] = to_integer(p, q - p + 1);\n\n            if (as->streams[as->nb_streams - 1] < 0) return -1;\n\n            if (*q == '\\0') break;\n\n            if (*q == ' ') state = new_set;\n\n            p = ++q;\n\n        } else {\n\n            return -1;\n\n        }\n\n    }\n\n    return 0;\n\n}\n", "idx": 4255, "substitutes": {"s": ["rs", "Ws", "gs", "b", "sg", "less", "ns", "conf", "c", "ats", "h", "sys", "cs", "comm", "os", "ps", "ms", "ts", "ds", "t", "es", "r", "js", "sv", "ls", "sb", "v", "m", "hs", "ss", "sq", "f", "fs", "S", "sts", "z", "aws", "source"], "w": ["aw", "sw", "weights", "wp", "wal", "window", "wa", "wcs", "h", "wat", "wx", "raw", "we", "g", "util", "W", "words", "rew", "ew", "wr", "etc", "var", "workers", "ww", "wb", "hw", "wt", "rw", "t", "wk", "r", "wn", "tw", "iw", "word", "web", "th", "lang", "kw", "wall", "v", "man", "args", "writer", "worker", "wi", "saw", "wo", "y", "wh", "f", "ex", "write", "z", "wl", "history", "wd", "work", "x", "l", "nw", "fw"], "p": ["ph", "pid", "peer", "par", "sp", "b", "wp", "cp", "ping", "pb", "c", "u", "pc", "h", "up", "pad", "i", "pro", "pt", "pod", "ip", "progress", "ps", "pa", "pat", "bp", "n", "d", "vp", "g", "op", "pl", "perm", "fp", "t", "ep", "pi", "pers", "r", "pe", "pm", "pos", "pre", "pkg", "pg", "ap", "pr", "lp", "v", "port", "m", "dq", "part", "y", "jp", "np", "f", "dp", "xp", "pp", "P", "point", "j", "x", "a", "tp", "l"], "q": ["qual", "pid", "quant", "quote", "ping", "c", "u", "pc", "h", "i", "qs", "pt", "qi", "ip", "d", "g", "iq", "queue", "quality", "Q", "r", "pe", "query", "pkg", "pg", "qv", "ue", "k", "qa", "eq", "v", "qq", "qu", "dq", "m", "ch", "requ", "vc", "comment", "quiet", "quit", "aq", "sq", "f", "quest", "que", "qt", "e", "pp", "z", "j"], "state": ["policy", "event", "function", "step", "note", "scope", "see", "pair", "key", "t", "State", "trace", "pe", "tag", "section", "role", "comment", "test", "operator", "size", "success", "store", "base", "option", "index", "process", "are", "go", "position", "start", "out", "stats", "port", "m", "command", "part", "action", "version", "local", "length", "ace", "a", "l", "color", "race", "peer", "error", "power", "type", "progress", "no", "val", "debug", "style", "change", "st", "al", "close", "hash", "name", "STATE", "ate", "set", "only", "te", "stat", "err", "commit", "mode", "component", "status", "states", "print", "cache", "count", "e"], "mem": ["buff", "mn", "im", "asm", " Mem", "mat", "em", "ram", "store", "mi", "my", "arm", "raw", "map", "mt", "ms", "tm", "val", "phys", "temp", "go", "me", "ref", "sm", "ap", "nm", "Mem", "lim", "dim", "memory", "emb", "mb", "m", "alloc", "tab", "reg", "ret", "mm", "pool", "cache", "address", "mc", "mod", "sum", "vm", "ll", "bm", "il", "mx", "mp"], "as": ["was", "asers", "asi", "c", "ma", "buf", "ads", "ps", "ts", "As", "jas", "js", "ast", "ras", "ams", "pas", "ems", "ares", "marks", "names", "of", "rs", "asm", "ias", "os", "ms", "es", "mas", "asha", "an", "au", "sa", "ac", "am", "AS", "us", "ask", "aws", "a", "ows", "oss", "aw", "ar", "ars", "ns", "ats", "vers", "ags", "at", "modules", "is", "has", "var", "les", "asks", "aos", "bs", "al", "nas", "bas", "ase", "all", "cast", "ass", "cas", "ab", "acs", "eas", "aps", "raw", "als", "aus", "ls", "ess", "nos", "mos", "las", "new", "ais"], "nb_as": ["nb__ms", "nb_mas", "nbPrs", "nb__ras", "n__as", "nb___as", "kBplasi", "nb___AS", "nr_as", "n__mas", "NB_As", "nr_las", "nb___ras", "kB_has", "nb5asi", "nb_pas", "kBplhas", "nr_aos", "n_as", "kB_pas", "nb__rs", "NB_as", "nbPaos", "n_ras", "kBplpas", "kBplas", "n__ras", "nbplhas", "nb5as", "nb__As", "NB__ms", "n__ids", "nb5has", "nb_ras", "nr_ras", "nb_las", "nb_rs", "NB_asc", "nb___las", "nb__mas", "nbPas", "n_ids", "nb_has", "nb5pas", "nb_ac", "NB_ac", "nb_ids", "nb_asc", "kB_asi", "nbplasi", "nb_ms", "kB_as", "n_mas", "nb_asi", "NB_ms", "NB_ras", "nb__ids", "nb_aos", "nb__as", "nbplas", "NB__As", "nb_AS", "nb__aos", "nr_AS", "nr_rs", "nbplpas", "NB__as", "nb_As", "nbPras"]}}
{"project": "qemu", "commit_id": "e549e7161f37416ff66971d77d021d30057045ca", "target": 1, "func": "static QObject *parse_keyword(JSONParserContext *ctxt)\n\n{\n\n    QObject *token, *ret;\n\n    JSONParserContext saved_ctxt = parser_context_save(ctxt);\n\n\n\n    token = parser_context_pop_token(ctxt);\n\n    if (token == NULL) {\n\n        goto out;\n\n    }\n\n\n\n    if (token_get_type(token) != JSON_KEYWORD) {\n\n        goto out;\n\n    }\n\n\n\n    if (token_is_keyword(token, \"true\")) {\n\n        ret = QOBJECT(qbool_from_int(true));\n\n    } else if (token_is_keyword(token, \"false\")) {\n\n        ret = QOBJECT(qbool_from_int(false));\n\n\n\n    } else {\n\n        parse_error(ctxt, token, \"invalid keyword `%s'\", token_get_value(token));\n\n        goto out;\n\n    }\n\n\n\n    return ret;\n\n\n\nout: \n\n    parser_context_restore(ctxt, saved_ctxt);\n\n\n\n    return NULL;\n\n}", "idx": 4256, "substitutes": {"ctxt": ["conttx", "curxt", "mttxt", "uttx", "ctx", "actxt", "actect", "mtect", "curXT", "ctpt", "actctx", "uttxt", "acttx", "curtxt", "actext", "acttxt", "ctXT", "ctxtx", "cttx", "curtx", "actpt", "mtxt", "cXT", "mttx", "curect", "curext", "utctx", "ctxtxt", "ctctx", "conttxt", "contpt", "cttxt", "utxt", "ctext", "ctxpt", "ctxxt", "contxt", "ctect", "ctxext", "actXT", "ctxctx", "cxt"], "token": ["tree", "event", "note", "kt", "tar", "tower", "piece", "pair", "t", "key", "word", "tag", "txt", "reset", "TO", "current", "message", "operator", "prototype", "source", "next", "oken", "iterator", "typ", "context", "resource", "span", "start", "normal", "scan", "item", "local", "KEN", "info", "interrupted", "text", "json", "header", "error", "channel", "target", "type", "field", "template", "twitter", "no", "ski", "final", "response", "topic", "session", "language", "trigger", "single", "user", "node", "none", "buffer", "ok", "table", "tn", "document", "row", "data", "element", "wt", "Token", "temp", "input", "number", "initial", "list", "handle", "component", "character", "complete", "spec", "rule", "tf", "atom", "termin", "variable", "tool"], "ret": ["gt", "result", "rot", "uf", "pret", "ert", "mem", "att", "it", "cont", "det", "rel", "set", "nt", "dt", "cmd", "mt", " Ret", "rets", "val", "tr", "t", "alt", "bool", "ref", "rev", "rem", "rest", "out", "txt", "rt", "mb", "resp", "re", "lt", "reg", "report", "lit", "print", "RET", "jp", "cat", "Ret", "obj", "ft", "ll", "res", "arr", " RET", "flag", "def", "rm", "elt", "unt"]}}
{"project": "FFmpeg", "commit_id": "5b29af624fe8be5379fd649019a04ff44bfde04f", "target": 0, "func": "static int aac_encode_frame(AVCodecContext *avctx,\n\n                            uint8_t *frame, int buf_size, void *data)\n\n{\n\n    AACEncContext *s = avctx->priv_data;\n\n    int16_t *samples = s->samples, *samples2, *la;\n\n    ChannelElement *cpe;\n\n    int i, j, chans, tag, start_ch;\n\n    const uint8_t *chan_map = aac_chan_configs[avctx->channels-1];\n\n    int chan_el_counter[4];\n\n    FFPsyWindowInfo windows[AAC_MAX_CHANNELS];\n\n\n\n    if (s->last_frame)\n\n        return 0;\n\n    if (data) {\n\n        if (!s->psypp) {\n\n            memcpy(s->samples + 1024 * avctx->channels, data,\n\n                   1024 * avctx->channels * sizeof(s->samples[0]));\n\n        } else {\n\n            start_ch = 0;\n\n            samples2 = s->samples + 1024 * avctx->channels;\n\n            for (i = 0; i < chan_map[0]; i++) {\n\n                tag = chan_map[i+1];\n\n                chans = tag == TYPE_CPE ? 2 : 1;\n\n                ff_psy_preprocess(s->psypp, (uint16_t*)data + start_ch,\n\n                                  samples2 + start_ch, start_ch, chans);\n\n                start_ch += chans;\n\n            }\n\n        }\n\n    }\n\n    if (!avctx->frame_number) {\n\n        memcpy(s->samples, s->samples + 1024 * avctx->channels,\n\n               1024 * avctx->channels * sizeof(s->samples[0]));\n\n        return 0;\n\n    }\n\n\n\n    start_ch = 0;\n\n    for (i = 0; i < chan_map[0]; i++) {\n\n        FFPsyWindowInfo* wi = windows + start_ch;\n\n        tag      = chan_map[i+1];\n\n        chans    = tag == TYPE_CPE ? 2 : 1;\n\n        cpe      = &s->cpe[i];\n\n        for (j = 0; j < chans; j++) {\n\n            IndividualChannelStream *ics = &cpe->ch[j].ics;\n\n            int k;\n\n            int cur_channel = start_ch + j;\n\n            samples2 = samples + cur_channel;\n\n            la       = samples2 + (448+64) * avctx->channels;\n\n            if (!data)\n\n                la = NULL;\n\n            if (tag == TYPE_LFE) {\n\n                wi[j].window_type[0] = ONLY_LONG_SEQUENCE;\n\n                wi[j].window_shape   = 0;\n\n                wi[j].num_windows    = 1;\n\n                wi[j].grouping[0]    = 1;\n\n            } else {\n\n                wi[j] = ff_psy_suggest_window(&s->psy, samples2, la, cur_channel,\n\n                                              ics->window_sequence[0]);\n\n            }\n\n            ics->window_sequence[1] = ics->window_sequence[0];\n\n            ics->window_sequence[0] = wi[j].window_type[0];\n\n            ics->use_kb_window[1]   = ics->use_kb_window[0];\n\n            ics->use_kb_window[0]   = wi[j].window_shape;\n\n            ics->num_windows        = wi[j].num_windows;\n\n            ics->swb_sizes          = s->psy.bands    [ics->num_windows == 8];\n\n            ics->num_swb            = tag == TYPE_LFE ? 12 : s->psy.num_bands[ics->num_windows == 8];\n\n            for (k = 0; k < ics->num_windows; k++)\n\n                ics->group_len[k] = wi[j].grouping[k];\n\n\n\n            apply_window_and_mdct(avctx, s, &cpe->ch[j], samples2);\n\n        }\n\n        start_ch += chans;\n\n    }\n\n    do {\n\n        int frame_bits;\n\n        init_put_bits(&s->pb, frame, buf_size*8);\n\n        if ((avctx->frame_number & 0xFF)==1 && !(avctx->flags & CODEC_FLAG_BITEXACT))\n\n            put_bitstream_info(avctx, s, LIBAVCODEC_IDENT);\n\n        start_ch = 0;\n\n        memset(chan_el_counter, 0, sizeof(chan_el_counter));\n\n        for (i = 0; i < chan_map[0]; i++) {\n\n            FFPsyWindowInfo* wi = windows + start_ch;\n\n            tag      = chan_map[i+1];\n\n            chans    = tag == TYPE_CPE ? 2 : 1;\n\n            cpe      = &s->cpe[i];\n\n            put_bits(&s->pb, 3, tag);\n\n            put_bits(&s->pb, 4, chan_el_counter[tag]++);\n\n            for (j = 0; j < chans; j++) {\n\n                s->cur_channel = start_ch + j;\n\n                ff_psy_set_band_info(&s->psy, s->cur_channel, cpe->ch[j].coeffs, &wi[j]);\n\n                s->coder->search_for_quantizers(avctx, s, &cpe->ch[j], s->lambda);\n\n            }\n\n            cpe->common_window = 0;\n\n            if (chans > 1\n\n                && wi[0].window_type[0] == wi[1].window_type[0]\n\n                && wi[0].window_shape   == wi[1].window_shape) {\n\n\n\n                cpe->common_window = 1;\n\n                for (j = 0; j < wi[0].num_windows; j++) {\n\n                    if (wi[0].grouping[j] != wi[1].grouping[j]) {\n\n                        cpe->common_window = 0;\n\n                        break;\n\n                    }\n\n                }\n\n            }\n\n            s->cur_channel = start_ch;\n\n            if (cpe->common_window && s->coder->search_for_ms)\n\n                s->coder->search_for_ms(s, cpe, s->lambda);\n\n            adjust_frame_information(s, cpe, chans);\n\n            if (chans == 2) {\n\n                put_bits(&s->pb, 1, cpe->common_window);\n\n                if (cpe->common_window) {\n\n                    put_ics_info(s, &cpe->ch[0].ics);\n\n                    encode_ms_info(&s->pb, cpe);\n\n                }\n\n            }\n\n            for (j = 0; j < chans; j++) {\n\n                s->cur_channel = start_ch + j;\n\n                encode_individual_channel(avctx, s, &cpe->ch[j], cpe->common_window);\n\n            }\n\n            start_ch += chans;\n\n        }\n\n\n\n        frame_bits = put_bits_count(&s->pb);\n\n        if (frame_bits <= 6144 * avctx->channels - 3) {\n\n            s->psy.bitres.bits = frame_bits / avctx->channels;\n\n            break;\n\n        }\n\n\n\n        s->lambda *= avctx->bit_rate * 1024.0f / avctx->sample_rate / frame_bits;\n\n\n\n    } while (1);\n\n\n\n    put_bits(&s->pb, 3, TYPE_END);\n\n    flush_put_bits(&s->pb);\n\n    avctx->frame_bits = put_bits_count(&s->pb);\n\n\n\n    // rate control stuff\n\n    if (!(avctx->flags & CODEC_FLAG_QSCALE)) {\n\n        float ratio = avctx->bit_rate * 1024.0f / avctx->sample_rate / avctx->frame_bits;\n\n        s->lambda *= ratio;\n\n        s->lambda = FFMIN(s->lambda, 65536.f);\n\n    }\n\n\n\n    if (!data)\n\n        s->last_frame = 1;\n\n    memcpy(s->samples, s->samples + 1024 * avctx->channels,\n\n           1024 * avctx->channels * sizeof(s->samples[0]));\n\n    return put_bits_count(&s->pb)>>3;\n\n}\n", "idx": 4260, "substitutes": {"avctx": ["AVctx", "abcv", "afcomp", "ajcv", "ahctl", "afconf", "afaddr", "ajctx", " avcv", "ahpid", "avcontext", "afcmd", "avjac", "ajdoc", "ahcontext", "avcv", "afobj", "avcomp", "avpid", "avcfg", "svcontext", "devtx", " avobj", "afjac", "afctl", "AVcontext", "avcmd", "ajctl", "afctx", "devcontext", "ajpid", "avdoc", "ajcomp", "ajcontext", "ahjac", "avecontext", "avectx", "avaddr", "wavctx", "avctl", "wavcontext", "avconf", "ajaddr", "ahtx", "abctl", "svctx", "ahaddr", "avtx", "ahconf", "ahdoc", "abcontext", "ahobj", " avcontext", "aftx", "afpid", "aveobj", "ahctx", " avtx", "ajobj", " avcfg", "ajcmd", " avctl", "wavtx", "afdoc", "AVctl", "svtx", "abctx", "ahcomp", "ajtx", "devctl", "avecfg", "avobj", "AVtx", "ajjac", "wavctl", "svcmd", "ajcfg", " avconf", "afcontext", "devctx"], "frame": ["header", "rame", "event", "chain", "call", "window", "channel", "Frame", "fram", "fe", "state", "seq", "frames", "seed", "context", "code", "video", "feature", "block", "fb", "version", "f", "sample", "time", "face", "length", "image", "sequence"], "buf_size": ["buf_length", "buf_len", "bufogsize", "bufoglen", " buf_width", "buf2length", "buf2width", " buf_len", "bufoglength", "buf2size", " buf_length", "buf_width", "bufogwidth", "buf2len"], "data": ["output", "bytes", "result", "error", "padding", "empty", "dat", "window", "channel", "any", "none", "multiple", "only", "buf", "mat", "buffer", "valid", "raw", "d", "p", "table", "no", " DATA", "media", "ata", "zero", "tif", "t", "r", "Data", "str", "value", "record", "bool", "to", "input", "mu", "out", "video", "block", "new", "array", "done", "response", "batch", "cache", "DATA", "message", "size", "info", "format", "res", "text", "a", "json", "name", "image", "da", "bin"], "s": ["sw", "less", "c", "h", "sc", "d", "ps", "ts", "settings", "t", "utils", "js", "w", "sb", "xs", "ss", "changes", "series", "sports", "comments", "as", "rs", "ses", "os", "g", "ms", "tests", "ains", "es", "v", "stats", "bits", "m", "vs", "aws", "a", "l", "ops", "gs", "ns", "ctx", "ats", "cs", "comm", "actions", "p", "is", "sv", "hs", "bs", "sq", "parts", "fs", "S", "b", "its", "sys", "qs", "set", "als", "details", "n", "ds", "ins", "space", "ls", "ims", "args", "spec", "states", "f", "obj", "e", "sts"], "samples": ["exensions", "ssamples", "itsanguages", "exfaces", "exources", "isays", "insamples", "sourses", "ssizes", "insents", "Samps", "testsamples", "isamps", "Sannels", "exays", "nources", "nsamps", "namples", " sumps", "sensions", "nsents", "ssents", "isamples", "isannels", "sumps", "champs", "censions", "camples", "ssources", "tourses", "opensences", "itsamps", "says", "sents", "namps", "tamps", "tamples", "sfaces", "insamps", "ispaces", "exences", "sences", "spaces", " sizes", " sents", "samps", "itsources", "opensfaces", "Sizes", "Sents", "Sourses", "Spaces", " samps", "nanguages", "cays", "testsences", "ssamps", "isensions", "chumps", "opensamples", "insizes", "exanguages", "Sources", "sizes", "testsamps", "ssumps", "Sumps", "sources", " sourses", "Samples", "sannels", "testsfaces", "opensamps", "champles", "chources", "nsizes", "tumps", "examples", "itsamples", "camps", "sanguages", "examps", "nsamples"], "samples2": ["samplesTwo", "saves2", "Samples1", "Samps1", "sessions12", "Samps12", "samps102", "sviews256", "Samplest", "samps256", "savesTwo", "sessions1", "samplest", "Samples2", "sonents102", "Sampst", "samples1", "sessions256", "Samps102", "sviews1", "samps2", "sessions2", "Samps2", "sizes2", "SampsTwo", "sonentsTwo", "saves102", "sviews2", "soundst", "sviews12", "sampst", "sonents2", "SamplesTwo", "samples102", "saves1", "samplet", "samps12", "Samples102", "samples12", "Samples256", "sampsTwo", "samps1", "sizes1", "Samps256", "sonents1", "samples256", "Samples12"], "la": ["wa", "lis", "ma", "ka", "ta", "ml", "label", "na", "lc", "kl", "lo", "lang", "ls", "lab", "lp", "layer", "ea", "lt", "els", "sa", "lambda", "lag", "loop", "ld", "wl", "l", "elt", "da"], "cpe": ["cce", "cpy", "cse", "camke", "pple", " cce", "Cple", "acte", "campe", "pces", "cke", " cte", "pge", " cces", "ccce", "cces", "Cpe", "cple", "acope", " cse", "pcces", "ccoe", "coe", " cple", "acpy", "ccpe", "cample", "acke", "cte", "ccuke", " coe", "acpe", "pcpe", "Cope", "cope", "pope", " cuke", " cge", "mcpe", "ppy", "Cpy", "pse", "cuke", "acple", "camte", "pcse", "mcce", "mcoe", " cke", "cge", "mcuke", "ppe", "pcge"], "i": ["ei", "im", "c", "h", "ma", "gi", "zi", "ind", "t", "hi", "pi", "key", "ch", "I", "io", "in", "series", "x", "\u0438", "di", "q", "um", "mi", "er", "g", "xi", "index", "ri", "bi", "ki", "ti", "v", "iii", "ai", "m", "ia", "info", "l", "ci", "it", "u", "at", "ip", "li", "p", "ami", "dr", " I", "try", "y", "ii", "name", "init", "ij", "ini", "b", "oi", "qi", "si", "ie", "n", "multi", "me", "ui", "id", "ji", "phi", "ims", "ix", "status", "f", "ex", "iu", "e", "point"], "j": ["dj", "ja", "ev", "ij", "q", "b", "bj", "jo", "next", "it", "att", "jj", "c", "job", "J", "br", "kh", "h", "aj", "ijk", "p", "g", "n", "ind", "uj", "bo", "o", "jas", "Ja", "jc", "js", "ji", "ng", "oj", "v", "m", "ch", "y", "jump", "jp", "jit", "f", "obj", "jl", "e", "kj", "z", "fr", "x", "json", "l"], "chans": ["echanes", "chands", " chaus", "thanes", "achands", "chnanners", "cheans", "ichans", "achanes", "channers", "echones", "shans", "cpanks", "echins", "shands", "chaus", "cpans", "echands", " chats", "cpones", "chants", " chants", "chnats", "chnans", "ichanes", "chats", "chanks", "quanks", " chanes", "chanes", "ichants", "chnados", " chands", "chones", "thans", "echats", "cheados", "thands", "chins", " chanks", "tchanes", "ichaus", "chados", "tchants", " channers", "achants", "cheanners", "shanes", "achaus", "quones", "thados", "tchanks", "achans", "cheats", "cpins", "tchans", "quins", "echans", "echanks", "shados", "achats", "achados", "echants", " chados", "quans"], "tag": ["TAG", "par", "error", "feat", "match", "month", "mot", "task", "prefix", "term", "type", "field", "kind", "msg", "prop", "cmd", "stat", "mt", "var", "label", "pair", "key", "t", "nick", "col", "bit", "go", "word", "attribute", "debug", "pkg", "attr", "Tag", "style", "code", "token", "tags", "feature", "ack", "brand", "port", "reg", "comment", "date", "product", "rat", "cat", "bug", "mod", "ag", "hash", "format", "tail", "car", "name", "flag"], "start_ch": ["start___ch", "start2ach", "try_Ch", "start2chan", " start_col", "start2ch", "start___sh", "try_wh", "start_sh", " start_che", "Start_cell", "start_Ch", "Start_sh", "start_wh", " start_chan", "start_ach", "start___cell", " start_ach", "start___chan", " start_com", " start_con", "start_che", "start_cell", "end_Ch", "start_con", "Start_chan", "end_ch", "start_col", "end_chan", "try_ch", " start_cho", "start2col", "start_channel", " start_Ch", "end_channel", "Start_ch", "start_com", "start_cho", " start_channel", "start_chan", "try_cho"], "chan_map": ["chan_list", "channel_tag", "chanplMap", "channel_maps", "channel_Map", "channel_hash", "chan2list", "chan_Map", "chan2map", "channel2shape", "chan_maps", "chan_cap", "channel_map", "channel_cap", "chan_table", "chanMmask", "chan_hash", "chan2maps", "channel_manager", "channel2list", "chan_filter", "chanpllist", "chanMmatch", "channel_list", "chan2shape", "channel_filter", "chan_match", "channel_table", "channel_mask", "chan__maps", "channel2map", "chanMmap", "channel2maps", "chan_mask", "channel_shape", "chanplmap", "channel_match", "chan__list", "chanpltag", "chan_manager", "chan__shape", "chan__map", "chan_shape", "chan_tag"], "chan_el_counter": ["chan_id_table", "chan_el_count", "chan_id_count", "chan_el_table", "chan_id_nr", "chan_el_nr", "chan_id_counter"], "windows": ["boxes", "Window", "lists", "window", " queues", " wires", "wal", "wid", "irs", "wcs", "ints", "sys", "wx", "qs", "aps", "we", "frames", "ms", "details", "words", "pages", "rows", "workers", " wid", "win", "eds", "mas", "w", " managers", "ids", "blocks", "keys", "images", "Windows", "views", "vs", " hints", "wo", " widgets", "parts", "holes", "ks", "res", "aws", "ows", " wins"], "wi": ["ei", "feat", "wig", "wal", "live", "wid", "wat", "wx", " ni", "wiki", "wic", "wr", "xi", "WI", "wk", "hi", "Wi", "igi", "mu", "wit", "ye", "wei", "hei", "ours", "wo", "xp", "wen", "gra", "nw"], "ics": ["ic", "ico", "ris", "ists", "irs", "ns", "icons", "its", "wcs", "acs", "ikes", "ICS", "ats", "ints", "qs", "cs", "ik", "ms", "ts", "mic", "cus", "css", "ips", "ls", "icc", "xs", " ic", "nic", "stats", "pic", "bs", "xes", "mc", "cons", "fs", "ks", "ices", "IC", "icks"], "k": ["q", "km", "b", "c", "kt", "kid", "ka", "kind", "K", "ik", "ok", "mk", "g", "n", "kl", "key", "w", "unk", "an", "v", "ket", "m", "ch", " K", "ks", "kj", "tk"]}}
{"project": "FFmpeg", "commit_id": "6a6bc43f5f79587b8936334cc0b3a6616f4807ac", "target": 0, "func": "static int dxtory_decode_v2_420(AVCodecContext *avctx, AVFrame *pic,\n\n                                const uint8_t *src, int src_size)\n\n{\n\n    GetByteContext gb;\n\n    GetBitContext  gb2;\n\n    int nslices, slice, slice_height, ref_slice_height;\n\n    int cur_y, next_y;\n\n    uint32_t off, slice_size;\n\n    uint8_t *Y, *U, *V;\n\n    int ret;\n\n\n\n    bytestream2_init(&gb, src, src_size);\n\n    nslices = bytestream2_get_le16(&gb);\n\n    off = FFALIGN(nslices * 4 + 2, 16);\n\n    if (src_size < off) {\n\n        av_log(avctx, AV_LOG_ERROR, \"no slice data\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    if (!nslices || avctx->height % nslices) {\n\n        avpriv_request_sample(avctx, \"%d slices for %dx%d\", nslices,\n\n                              avctx->width, avctx->height);\n\n        return AVERROR_PATCHWELCOME;\n\n    }\n\n\n\n    ref_slice_height = avctx->height / nslices;\n\n    if ((avctx->width & 1) || (avctx->height & 1)) {\n\n        avpriv_request_sample(avctx, \"Frame dimensions %dx%d\",\n\n                              avctx->width, avctx->height);\n\n    }\n\n\n\n    avctx->pix_fmt = AV_PIX_FMT_YUV420P;\n\n    if ((ret = ff_get_buffer(avctx, pic, 0)) < 0)\n\n        return ret;\n\n\n\n    Y = pic->data[0];\n\n    U = pic->data[1];\n\n    V = pic->data[2];\n\n\n\n    cur_y  = 0;\n\n    next_y = ref_slice_height;\n\n    for (slice = 0; slice < nslices; slice++) {\n\n        slice_size   = bytestream2_get_le32(&gb);\n\n        slice_height = (next_y & ~1) - (cur_y & ~1);\n\n        if (slice_size > src_size - off) {\n\n            av_log(avctx, AV_LOG_ERROR,\n\n                   \"invalid slice size %\"PRIu32\" (only %\"PRIu32\" bytes left)\\n\",\n\n                   slice_size, src_size - off);\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n        if (slice_size <= 16) {\n\n            av_log(avctx, AV_LOG_ERROR, \"invalid slice size %\"PRIu32\"\\n\", slice_size);\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n\n\n        if (AV_RL32(src + off) != slice_size - 16) {\n\n            av_log(avctx, AV_LOG_ERROR,\n\n                   \"Slice sizes mismatch: got %\"PRIu32\" instead of %\"PRIu32\"\\n\",\n\n                   AV_RL32(src + off), slice_size - 16);\n\n        }\n\n        init_get_bits(&gb2, src + off + 16, (slice_size - 16) * 8);\n\n        dx2_decode_slice_420(&gb2, avctx->width, slice_height, Y, U, V,\n\n                             pic->linesize[0], pic->linesize[1],\n\n                             pic->linesize[2]);\n\n\n\n        Y += pic->linesize[0] *  slice_height;\n\n        U += pic->linesize[1] * (slice_height >> 1);\n\n        V += pic->linesize[2] * (slice_height >> 1);\n\n        off += slice_size;\n\n        cur_y   = next_y;\n\n        next_y += ref_slice_height;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 4306, "substitutes": {"avctx": ["AVtc", "AVctx", "ravpkg", "auxjac", "AVcp", " avcmp", "awtx", "ajcv", "awctx", "avcp", "averconf", "ajctx", "auxtx", "avefc", "avtc", "ravctx", "avcontext", " avcpu", "avjac", "avcv", "savcss", "avectl", "afcpu", "Avcontext", "avecp", "ravjac", "avecv", "avercc", "avcfg", "Avtx", "abconf", "devtx", "avkt", "afjac", "averctx", "avecc", "AVcmp", "avcmd", "ajctl", "afctx", "varcats", "savctx", "ajcontext", " avcp", "devcfg", "avecontext", "avectx", "avetc", "auxctx", "awcpu", "avercss", "avctl", "avcc", "avertx", "avconf", "avecmd", "auxcfg", "varcmd", "abctl", "avpkg", "avtx", "awcmp", " avkt", "avcpu", "avercp", "abcontext", "abcpu", " avcontext", "aftx", "avercontext", "avcss", "ajcc", "varctl", "devjac", " avtx", " avpkg", " avjac", "avertc", " avcfg", "ajcmd", " avctl", "averfc", " avcss", "avercmp", "afpkg", "ajcats", "avercpu", "ravcmd", "avecpu", "avercv", "abctx", "Avkt", "afcmp", "avecmp", "avercmd", "ajtx", "avfc", "ajfc", "avetx", "ajkt", "avecfg", "savcpu", " avcmd", "varctx", "ravcpu", "savcontext", "abcmp", "abtx", "ajcp", "Avctx", "avcmp", "ravcontext", "ajcfg", "afcfg", " avconf", "averkt", "avecats", "avekt", "afcontext", "devctx", "avcats"], "pic": ["ic", "sp", "gif", "gc", "feat", "Pic", "pc", "ctx", "Pict", "cam", "phot", "sys", "pit", "photo", "pict", "file", "fc", "px", "p", "ps", "pa", "pick", "picture", "piece", "mic", "fps", "fp", "phys", "pi", "peg", "syn", "py", "png", "pr", "style", "txt", "frame", "shot", "ac", "sci", "img", "parse", "kit", "doc", "jp", "np", "Picture", "fr", "photos", "image", "mp"], "src": ["init", "iv", "rs", "sp", "ser", "sr", "bg", "ctx", "cont", "sys", "sc", "raw", "fc", "inst", "input", "str", "rc", "ins", "proc", "sb", "png", "s", "txt", "sur", "sub", "bs", "serv", "scan", "ptr", "img", "sci", "tmp", "gin", "ur", "cur", "obj", "in", "source", "loc"], "src_size": ["source_size", "src_shape", "src_len", "src_SIZE", " src_ize", " src_Size", "rc_SIZE", "sys_SIZE", "source_name", "src32ize", "rc_shape", "sys_size", " src_len", "src32size", "rc_size", "src_Size", "src32Size", "sys_Size", "src_name", "src_ize", "source_len"], "gb": ["db", "gt", "yg", "uv", "gs", "buff", "gc", "xy", "uf", "gif", "gm", "eb", "bg", "ctx", "pc", "sys", " GB", " rgb", "eg", "tg", "g", "bd", "hub", "gd", "hog", "lib", "cb", " rg", "bt", "bb", "sv", "py", "attr", "sb", "rb", "bf", "args", "mb", "cfg", "bs", "nb", "fb", "Gb", "cv", "cd", "rg", "storage", "gin", "vt", " rc", "fi", "gu", "GB", "kb", "bm", "fg", "gpu"], "gb2": ["GB2", "GB1", "GB5", "cb1", "gb3", "gm3", "GB3", "cb2", "cb5", "gm1", "gb5", "gb1", "gm5", "cb3", "gm2"], "nslices": ["nsperseles", "nslicles", "nspreadies", "NSlimese", "nscallies", "nslicests", "nsple", "NSpersees", "snlicles", "NSlimales", "nslinments", "nsplese", "nslamles", " nslicales", "NSlicletes", "NSlices", "nscilces", "nslexies", "nslimese", "nsperseqs", "nspersements", "nsples", "nlices", "snlamests", "nperseqs", "nslenes", "nslenales", "nslibets", "nspreade", "NSpersee", " nslicces", "nslexes", "snlicests", " nscilces", "snluies", "nsclments", "nsitnesses", "nslicedes", "nsperseests", "NSlicese", "NSperseletes", "nscilies", "nspreadletes", "nscallces", "nslinqs", "nlicments", " nslicies", "nsperseales", "nslicmes", "nsitnessmes", "nssequletes", "nslibes", "outslicmes", "nsciices", "NSlice", "nscilales", "nscilences", "outslibences", " nslicices", "nsluies", "NSlicers", "nslamales", "snlamles", " nsletets", "nperseedes", "nsciles", "nsitnessences", "outslicets", "nslexces", "nsperseedes", "nslicices", "nscilets", "nscalles", "nslicales", " nslicets", " nsletales", "nspersee", "nslene", "outslicences", " nsletes", "nscilmes", "nscallales", "snlicales", "nslines", "snlue", "nslue", "nslexales", "nsseques", "nslicese", "NSperseers", "nsletets", "nslice", "npersees", "snlicies", "nslibmes", "nsperseers", " nsciles", "outslibes", "nslicences", "nslicletes", "snlices", "nsclqs", "nlicqs", "nslexests", "nslimies", "snlames", "NSlime", "nslicqs", "nsperseletes", "nsciets", "nscles", "nslicies", " nscilales", "nslexles", "snlamales", "nspersees", "nslicces", "snlicletes", "nsitnessets", "snlues", "snlice", "NSlimes", "nslues", "nslenese", "nspreades", "NSlicales", " nscilies", "nslimales", "nsciales", "nslimes", "nsluletes", "outslices", "nsletes", "nssequers", "nlicedes", "nsletales", "outslibmes", "snluletes", "nsseque", "nsplales", "nscilices", "nscies", "nslicers", "nslicments", "nslicets", "nslamests", "npersements", " nsletices", "nslinedes", "nslames", "nslime", "nslimers", "nscledes", "nsletices", "outslibets", "nslibences", "nslimletes"], "slice": ["single", "share", "depth", "sp", "Sl", "chain", "ice", "save", "star", "shift", "late", "perm", "i", "sort", "skip", "ie", "plot", "seed", "piece", "zero", "ind", "cut", "index", "pair", "label", "se", "split", "slave", "range", "sel", "scale", "pe", "limit", "mix", "dim", "slot", "angle", "sl", "clip", "spec", "sub", "volume", "pose", "sci", "batch", "axis", "tile", "sample", "ask", "face", "length", "lock", "series", "square", "second", "lower", "crop", "sequence"], "slice_height": ["sample_size", " slice_depth", "sample_height", "slice_depth", "sample_distance", "slice_distance", "slice_length", " slice_length", "sample_length"], "ref_slice_height": ["ref_slice2y", "ref_tile_height", "ref_tile2y", "ref_slice_window", "ref_tile2bottom", "ref_sample_width", "ref_slice_max", "ref_tile2height", "ref_tile2depth", "ref_slice2max", "ref_sample_window", "ref_sample_length", "ref_slice_size", "ref_slice2depth", "ref_slice_depth", "ref_tile_depth", "ref_sample_height", "ref_slice2size", "ref_sample_size", "ref_slice_width", "ref_tile_bottom", "ref_slice2bottom", "ref_slice2height", "ref_tile_y", "ref_sample_max", "ref_slice_y", "ref_slice_bottom", "ref_slice2window", "ref_slice_length"], "cur_y": ["cur____y", "curTimey", "cur_yy", "current_y", "Cur_y", " cur_yy", "cur_ym", "curTimeyy", "current_ym", "current_hot", "cur____yy", "Cur_hot", "cur_oy", "cur_x", "cur_ye", "current_ye", "cur____oy", "Cur_x", " cur_oy", "curTimeoy", "cur_hot"], "next_y": ["next_ny", "nextJny", "next_Y", "next___yt", "next_ey", "nextJyt", "nextJey", "next___ey", " next_Y", "next_yt", "next___y", "cur_ey", "next___ny", "nextJy", "cur_ny", " next_ny", " next_ey", " next_ym", "cur_yt", "next_ym"], "off": ["original", "open", "hand", "ff", "att", "it", "end", "shift", "Off", "offset", "det", "set", "pad", "buf", "ok", "at", "ext", "base", "addr", " on", "no", " Off", "OFF", "op", "on", "dev", "over", "aux", "o", "full", "ed", " pos", "from", "err", "old", "push", "after", "ref", "pos", "kw", "out", "start", " coff", "ow", "fun", "offs", "new", "now", "tmp", " OFF", "obj", "before", " offset", "ex", "size", "Offset", "pres", "j", "length", "of", "down", "def", "offer"], "slice_size": ["slice64size", "slice67rate", "slice64style", "sample_style", "ice_set", "sample_rate", "slice_length", "slice_set", "sample_SIZE", "ice_size", "slice5set", "slice5sum", "slice64height", "sample_height", "slice_rate", "slice1height", "slice1sum", "slice_SIZE", "slice_style", "slice5height", "slice67length", "slice5size", "ice_height", " slice_length", "slice_sum", "sample_length", "slice67SIZE", "slice1set", "sample_size", "ice_sum", "slice67size", "slice64SIZE", "slice1size"], "Y": ["OU", "CH", "YS", "X", "J", "T", "M", "YE", "A", "YP", "W", "TY", "F", "Z", "Q", "D", "N", "XY", "YC", "Py", "FY", "My", "R", "B", "I", "y", "SY", "Year", "YY", "P", "C", "S", "H", "E", "G", "MY"], "U": ["OU", "UID", "Up", "UT", "UU", "u", "Lu", "X", "UX", "T", "UL", "Ut", "UP", "US", "UI", "UC", "CU", "You", "F", "GU", "LU", "UV", "EU", "UN", "UE", "Us", "SU", "UR", "MU", "I", "UF", "UTF", "Tu", "P", "C", "S", "UD"], "V": ["VT", "Vector", "VA", "VER", "X", "VM", "T", "IV", "VR", "M", "CV", "VD", "VO", "F", "GV", "N", "UV", "VOL", "VL", "VC", "v", "VS", "TV", "Vol", "VI", "VG", "I", "B", "R", "Va", "VW", "VAL", "P", "C", "S", "VB", "H", "G", "AV"], "ret": ["gt", "result", "mem", "it", "Return", "back", "cont", "det", "nt", "ry", "progress", " Ret", "rets", "len", "val", "tr", "data", "t", "alt", "r", "err", "value", "ref", "rev", "rem", "out", "try", "v", "txt", "not", "rt", "reset", "final", "resp", "re", "print", "RET", "tf", "f", "Ret", "ft", "res", "def", "elt", "flag"]}}
{"project": "FFmpeg", "commit_id": "6ebc7240606e8f1fccd2edbe4ffac150053a16cc", "target": 0, "func": "static int read_sbr_grid(AACContext *ac, SpectralBandReplication *sbr,\n\n                         GetBitContext *gb, SBRData *ch_data)\n\n{\n\n    int i;\n\n    unsigned bs_pointer = 0;\n\n    // frameLengthFlag ? 15 : 16; 960 sample length frames unsupported; this value is numTimeSlots\n\n    int abs_bord_trail = 16;\n\n    int num_rel_lead, num_rel_trail;\n\n    unsigned bs_num_env_old = ch_data->bs_num_env;\n\n\n\n    ch_data->bs_freq_res[0] = ch_data->bs_freq_res[ch_data->bs_num_env];\n\n    ch_data->bs_amp_res = sbr->bs_amp_res_header;\n\n    ch_data->t_env_num_env_old = ch_data->t_env[bs_num_env_old];\n\n\n\n    switch (ch_data->bs_frame_class = get_bits(gb, 2)) {\n\n    case FIXFIX:\n\n        ch_data->bs_num_env                 = 1 << get_bits(gb, 2);\n\n        num_rel_lead                        = ch_data->bs_num_env - 1;\n\n        if (ch_data->bs_num_env == 1)\n\n            ch_data->bs_amp_res = 0;\n\n\n\n        if (ch_data->bs_num_env > 4) {\n\n            av_log(ac->avccontext, AV_LOG_ERROR,\n\n                   \"Invalid bitstream, too many SBR envelopes in FIXFIX type SBR frame: %d\\n\",\n\n                   ch_data->bs_num_env);\n\n            return -1;\n\n        }\n\n\n\n        ch_data->t_env[0]                   = 0;\n\n        ch_data->t_env[ch_data->bs_num_env] = abs_bord_trail;\n\n\n\n        abs_bord_trail = (abs_bord_trail + (ch_data->bs_num_env >> 1)) /\n\n                   ch_data->bs_num_env;\n\n        for (i = 0; i < num_rel_lead; i++)\n\n            ch_data->t_env[i + 1] = ch_data->t_env[i] + abs_bord_trail;\n\n\n\n        ch_data->bs_freq_res[1] = get_bits1(gb);\n\n        for (i = 1; i < ch_data->bs_num_env; i++)\n\n            ch_data->bs_freq_res[i + 1] = ch_data->bs_freq_res[1];\n\n        break;\n\n    case FIXVAR:\n\n        abs_bord_trail                     += get_bits(gb, 2);\n\n        num_rel_trail                       = get_bits(gb, 2);\n\n        ch_data->bs_num_env                 = num_rel_trail + 1;\n\n        ch_data->t_env[0]                   = 0;\n\n        ch_data->t_env[ch_data->bs_num_env] = abs_bord_trail;\n\n\n\n        for (i = 0; i < num_rel_trail; i++)\n\n            ch_data->t_env[ch_data->bs_num_env - 1 - i] =\n\n                ch_data->t_env[ch_data->bs_num_env - i] - 2 * get_bits(gb, 2) - 2;\n\n\n\n        bs_pointer = get_bits(gb, ceil_log2[ch_data->bs_num_env]);\n\n\n\n        for (i = 0; i < ch_data->bs_num_env; i++)\n\n            ch_data->bs_freq_res[ch_data->bs_num_env - i] = get_bits1(gb);\n\n        break;\n\n    case VARFIX:\n\n        ch_data->t_env[0]                   = get_bits(gb, 2);\n\n        num_rel_lead                        = get_bits(gb, 2);\n\n        ch_data->bs_num_env                 = num_rel_lead + 1;\n\n        ch_data->t_env[ch_data->bs_num_env] = abs_bord_trail;\n\n\n\n        for (i = 0; i < num_rel_lead; i++)\n\n            ch_data->t_env[i + 1] = ch_data->t_env[i] + 2 * get_bits(gb, 2) + 2;\n\n\n\n        bs_pointer = get_bits(gb, ceil_log2[ch_data->bs_num_env]);\n\n\n\n        get_bits1_vector(gb, ch_data->bs_freq_res + 1, ch_data->bs_num_env);\n\n        break;\n\n    case VARVAR:\n\n        ch_data->t_env[0]                   = get_bits(gb, 2);\n\n        abs_bord_trail                     += get_bits(gb, 2);\n\n        num_rel_lead                        = get_bits(gb, 2);\n\n        num_rel_trail                       = get_bits(gb, 2);\n\n        ch_data->bs_num_env                 = num_rel_lead + num_rel_trail + 1;\n\n        ch_data->t_env[ch_data->bs_num_env] = abs_bord_trail;\n\n\n\n        if (ch_data->bs_num_env > 5) {\n\n            av_log(ac->avccontext, AV_LOG_ERROR,\n\n                   \"Invalid bitstream, too many SBR envelopes in VARVAR type SBR frame: %d\\n\",\n\n                   ch_data->bs_num_env);\n\n            return -1;\n\n        }\n\n\n\n        for (i = 0; i < num_rel_lead; i++)\n\n            ch_data->t_env[i + 1] = ch_data->t_env[i] + 2 * get_bits(gb, 2) + 2;\n\n        for (i = 0; i < num_rel_trail; i++)\n\n            ch_data->t_env[ch_data->bs_num_env - 1 - i] =\n\n                ch_data->t_env[ch_data->bs_num_env - i] - 2 * get_bits(gb, 2) - 2;\n\n\n\n        bs_pointer = get_bits(gb, ceil_log2[ch_data->bs_num_env]);\n\n\n\n        get_bits1_vector(gb, ch_data->bs_freq_res + 1, ch_data->bs_num_env);\n\n        break;\n\n    }\n\n\n\n    if (bs_pointer > ch_data->bs_num_env + 1) {\n\n        av_log(ac->avccontext, AV_LOG_ERROR,\n\n               \"Invalid bitstream, bs_pointer points to a middle noise border outside the time borders table: %d\\n\",\n\n               bs_pointer);\n\n        return -1;\n\n    }\n\n\n\n    ch_data->bs_num_noise = (ch_data->bs_num_env > 1) + 1;\n\n\n\n    ch_data->t_q[0]                     = ch_data->t_env[0];\n\n    ch_data->t_q[ch_data->bs_num_noise] = ch_data->t_env[ch_data->bs_num_env];\n\n    if (ch_data->bs_num_noise > 1) {\n\n        unsigned int idx;\n\n        if (ch_data->bs_frame_class == FIXFIX) {\n\n            idx = ch_data->bs_num_env >> 1;\n\n        } else if (ch_data->bs_frame_class & 1) { // FIXVAR or VARVAR\n\n            idx = ch_data->bs_num_env - FFMAX(bs_pointer - 1, 1);\n\n        } else { // VARFIX\n\n            if (!bs_pointer)\n\n                idx = 1;\n\n            else if (bs_pointer == 1)\n\n                idx = ch_data->bs_num_env - 1;\n\n            else // bs_pointer > 1\n\n                idx = bs_pointer - 1;\n\n        }\n\n        ch_data->t_q[1] = ch_data->t_env[idx];\n\n    }\n\n\n\n    ch_data->e_a[0] = -(ch_data->e_a[1] != bs_num_env_old); // l_APrev\n\n    ch_data->e_a[1] = -1;\n\n    if ((ch_data->bs_frame_class & 1) && bs_pointer) { // FIXVAR or VARVAR and bs_pointer != 0\n\n        ch_data->e_a[1] = ch_data->bs_num_env + 1 - bs_pointer;\n\n    } else if ((ch_data->bs_frame_class == 2) && (bs_pointer > 1)) // VARFIX and bs_pointer > 1\n\n        ch_data->e_a[1] = bs_pointer - 1;\n\n\n\n    return 0;\n\n}\n", "idx": 4307, "substitutes": {"ac": ["ic", "et", "ct", "ab", "att", "c", "pc", "acs", "bc", "anc", "acer", "cs", "aic", "at", "fc", "ak", "ica", "mic", "aci", "ach", "cc", "Ac", "ap", "mac", "oc", "ad", "acc", "fac", "jac", "sac", "rac", "am", "pac", "mc", "apt", "ag", "iac", "ace", "cu", "acl", "AC", "tc", "act"], "sbr": ["ssBR", "sbc", "asspr", "sBR", "sshr", "jsBR", "asbr", "jsbre", "assBR", "aspr", "assbc", "sbre", " sbre", "assbr", "jshr", "shr", " spr", "ssbr", "jsbr", " sBR", "asBR", " shr", " sbc", "spr", "asbc", "ssbre"], "gb": ["db", "yg", "gh", "gs", "gc", "bytes", "gif", "bn", "sg", "csv", "xy", "gm", "eb", "pb", "bg", "bc", "eg", "tg", "gy", "g", "tm", "hub", "gram", "gd", "cb", "wb", "bb", "pg", "py", "sb", "rb", "gio", "args", "vg", "mb", "cfg", "ch", "nb", "rg", "fb", "Gb", "img", "storage", "gnu", "gu", "GB", "vm", "kb", "ha", "bm", "gg"], "ch_data": [" ch_table", "ch8device", "ch8data", "ech_Data", "ch_table", " chtresult", " chmdevice", "ch_device", "chtptdata", "ch___db", " ch_db", "chartptsession", "ch0DATA", "ch1da", "achtname", "chtptData", "chptdata", "changedentry", "chn_data", "ch2DATA", " ch_module", "ech_cache", "cheartydef", "ach_table", "chtname", "ech_dat", "ch8dev", "ach2defined", "ch___data", "cht_Data", "ch1name", "ch_block", "ach2data", "chtden", "cht_builder", "cholyinfo", "chn_window", "chartydat", "ech_ata", "ch2window", "ch_div", "ch2bin", "chptsession", "chartptinfo", "chdinfo", "ch1ata", " ch_results", "ch_entry", "cholydat", "ch2lan", "ch2data", "chartyinfo", "chptData", "chan_client", "cheartyinfo", "ch2den", "ch8connection", "chartyata", "ch_db", " chtdat", " ch_DATA", "cht_da", "ch_lan", "ach2lan", "ch1Data", "ach_name", "cholydata", "achtdata", "change_info", "chtwindow", "chtsession", "ach_info", "chptda", "ch_dat", "ech_data", "ach_data", "chmdata", " ch2DATA", "chtda", "chptdat", "chartydata", "ch_cache", "ch1client", "chtdata", "ach2table", "chtdat", "chptdiv", "chtresult", "ach_device", "chartptdata", "chptbuilder", "ch8ata", "form_data", "ch2device", "ech_connection", "chptclient", "che_def", "ech2Data", "chdentry", "changeddat", " ch2module", "ch2defined", "change_data", " chtresults", "ch_info", "ch_def", " chtwindow", "ch_results", "ch2cache", "ach_ata", "cht_data", "ch3dev", "chanptdata", "ech2dat", "chn_bin", "chMmodule", "che_data", " chmdat", "ch___dat", "chptconnection", "ch5dat", " chttable", " chtdata", "change_dat", " ch_result", "chanptdiv", "cht_client", "ch8cache", "chn_den", "ach2ata", "chan_data", "form_ata", "ch2module", " ch_device", "chtresults", "che_info", "ch1div", "ach_defined", "ech2data", "changedinfo", "ach_lan", "ch2table", "cholydb", "ch_da", "chptinfo", "ch3device", "ch_ata", "ch_result", "ch_client", "change_entry", "chtinfo", " ch_block", "cht_DATA", " ch_name", "chmdevice", " ch_ata", "chtptda", "ch1dat", "ch5ata", "chtptbuilder", "chn_cache", " ch_dat", "ch2da", "chartyname", "chn_dat", "chart_info", "achtata", " ch_window", " chtname", "ch___block", "cheartydat", "ch3data", "chartydef", "ch1data", "ch_den", "chtata", "changeddata", "ach_dat", " chtata", "chtclient", "form_device", "ch_defined", "chMdata", "ch_builder", " ch2data", "ch0da", "ch5defined", "chtdef", "chptname", "ch_dev", "chttable", "ach_dev", "ch_session", "ch_module", " chmdata", "chanptclient", "chddata", "chtDATA", "chart_session", "cheartydata", "che_dat", "ch_DATA", "ch2Data", "ch_bin", "chartytable", "ach_db", "ach2dat", "chart_data", "ch_connection", "ech_da", "ch0client", "ch0data", "chddat", "ch2dat", "ch_window", "chtentry", "chptcache", "ech2ata", "ch5data", "ch2ata", "ch_name", "chmdat", "ch_Data", "ech2da", "chMDATA", "chan_div", "chptata", "achtdat"], "i": ["ic", "ini", "ij", "q", " bi", " li", "ci", " multi", " ii", "ei", "it", "uri", " m", "im", "u", "cli", " x", " ni", " v", "oi", "gi", "mi", "qi", "er", "ip", "li", "g", "si", "ami", "zi", "ski", "xi", "ind", "index", " ti", "t", "bi", "pi", " e", "multi", "hi", "me", "ui", "ki", "ji", "span", " I", "phi", "ti", " pi", "ims", "ix", " j", "ai", "m", "status", " mi", "I", "PI", "batch", "parent", "y", "print", "\u0438", "us", "sim", "iu", "in", "point", "j", "di", "x", "ii"], "num_rel_lead": ["num_rel_Lead", "num_ref_fac", "num_rel__Lead", "num_ref_Lead", "num_reloothLead", "num_reloothfac", "num_rel__tail", "num_rel___lead", "num_rel___shift", "num_ref_tail", "num_rel__leader", "num_rel___Lead", "num_rel_leader", "num_ref_leader", "num_reloothlead", "num_rel___leader", "num_rel__lead", "num_rel_tail", "num_reloothleader", "num_rel__fac", "num_rel_shift", "num_ref_lead", "num_rel_fac"], "num_rel_trail": ["num_rel__profiling", "num_rel_traile", "num_rel__trailing", "num_rel__traill", "num_rel_trile", "num_rel_Traill", "num_rel_triling", "num_rel_traill", "num_rel_profiling", "num_rel_Trailing", "num_rel__profil", "num_rel_trailing", "num_rel_profil", "num_rel_tril", "num_rel_Traile", "num_rel_profile", "num_rel__profill", "num_rel_profill", "num_rel__profile", "num_rel_trill", "num_rel_Trail", "num_rel__traile", "num_rel__trail"]}}
{"project": "qemu", "commit_id": "45b339b18c660eb85af2ba25bfcaed5469660d77", "target": 0, "func": "static int uhci_complete_td(UHCIState *s, UHCI_TD *td, UHCIAsync *async, uint32_t *int_mask)\n\n{\n\n    int len = 0, max_len, err, ret;\n\n    uint8_t pid;\n\n\n\n    max_len = ((td->token >> 21) + 1) & 0x7ff;\n\n    pid = td->token & 0xff;\n\n\n\n    ret = async->packet.result;\n\n\n\n    if (td->ctrl & TD_CTRL_IOS)\n\n        td->ctrl &= ~TD_CTRL_ACTIVE;\n\n\n\n    if (ret < 0)\n\n        goto out;\n\n\n\n    len = async->packet.result;\n\n    td->ctrl = (td->ctrl & ~0x7ff) | ((len - 1) & 0x7ff);\n\n\n\n    /* The NAK bit may have been set by a previous frame, so clear it\n\n       here.  The docs are somewhat unclear, but win2k relies on this\n\n       behavior.  */\n\n    td->ctrl &= ~(TD_CTRL_ACTIVE | TD_CTRL_NAK);\n\n    if (td->ctrl & TD_CTRL_IOC)\n\n        *int_mask |= 0x01;\n\n\n\n    if (pid == USB_TOKEN_IN) {\n\n        if (len > max_len) {\n\n            ret = USB_RET_BABBLE;\n\n            goto out;\n\n        }\n\n\n\n        if ((td->ctrl & TD_CTRL_SPD) && len < max_len) {\n\n            *int_mask |= 0x02;\n\n            /* short packet: do not update QH */\n\n            trace_usb_uhci_packet_complete_shortxfer(async->queue->token,\n\n                                                    async->td);\n\n            return TD_RESULT_NEXT_QH;\n\n        }\n\n    }\n\n\n\n    /* success */\n\n    trace_usb_uhci_packet_complete_success(async->queue->token, async->td);\n\n    return TD_RESULT_COMPLETE;\n\n\n\nout:\n\n    /*\n\n     * We should not do any further processing on a queue with errors!\n\n     * This is esp. important for bulk endpoints with pipelining enabled\n\n     * (redirection to a real USB device), where we must cancel all the\n\n     * transfers after this one so that:\n\n     * 1) If they've completed already, they are not processed further\n\n     *    causing more stalls, originating from the same failed transfer\n\n     * 2) If still in flight, they are cancelled before the guest does\n\n     *    a clear stall, otherwise the guest and device can loose sync!\n\n     */\n\n    while (!QTAILQ_EMPTY(&async->queue->asyncs)) {\n\n        UHCIAsync *as = QTAILQ_FIRST(&async->queue->asyncs);\n\n        uhci_async_unlink(as);\n\n        uhci_async_cancel(as);\n\n    }\n\n\n\n    switch(ret) {\n\n    case USB_RET_STALL:\n\n        td->ctrl |= TD_CTRL_STALL;\n\n        td->ctrl &= ~TD_CTRL_ACTIVE;\n\n        s->status |= UHCI_STS_USBERR;\n\n        if (td->ctrl & TD_CTRL_IOC) {\n\n            *int_mask |= 0x01;\n\n        }\n\n        uhci_update_irq(s);\n\n        trace_usb_uhci_packet_complete_stall(async->queue->token, async->td);\n\n        return TD_RESULT_NEXT_QH;\n\n\n\n    case USB_RET_BABBLE:\n\n        td->ctrl |= TD_CTRL_BABBLE | TD_CTRL_STALL;\n\n        td->ctrl &= ~TD_CTRL_ACTIVE;\n\n        s->status |= UHCI_STS_USBERR;\n\n        if (td->ctrl & TD_CTRL_IOC) {\n\n            *int_mask |= 0x01;\n\n        }\n\n        uhci_update_irq(s);\n\n        /* frame interrupted */\n\n        trace_usb_uhci_packet_complete_babble(async->queue->token, async->td);\n\n        return TD_RESULT_STOP_FRAME;\n\n\n\n    case USB_RET_NAK:\n\n        td->ctrl |= TD_CTRL_NAK;\n\n        if (pid == USB_TOKEN_SETUP)\n\n            break;\n\n        return TD_RESULT_NEXT_QH;\n\n\n\n    case USB_RET_IOERROR:\n\n    case USB_RET_NODEV:\n\n    default:\n\n\tbreak;\n\n    }\n\n\n\n    /* Retry the TD if error count is not zero */\n\n\n\n    td->ctrl |= TD_CTRL_TIMEOUT;\n\n    err = (td->ctrl >> TD_CTRL_ERROR_SHIFT) & 3;\n\n    if (err != 0) {\n\n        err--;\n\n        if (err == 0) {\n\n            td->ctrl &= ~TD_CTRL_ACTIVE;\n\n            s->status |= UHCI_STS_USBERR;\n\n            if (td->ctrl & TD_CTRL_IOC)\n\n                *int_mask |= 0x01;\n\n            uhci_update_irq(s);\n\n            trace_usb_uhci_packet_complete_error(async->queue->token,\n\n                                                 async->td);\n\n        }\n\n    }\n\n    td->ctrl = (td->ctrl & ~(3 << TD_CTRL_ERROR_SHIFT)) |\n\n        (err << TD_CTRL_ERROR_SHIFT);\n\n    return TD_RESULT_NEXT_QH;\n\n}\n", "idx": 4315, "substitutes": {"s": ["rs", "gs", "ses", "sw", "ssl", "sg", "ns", "c", "h", "sys", "set", "self", "os", "p", "ps", "d", "stat", "n", "is", "ts", "ds", "t", "w", "sv", "ls", "sb", "v", "stats", "st", "ss", "bs", "states", "fs", "S", "sts"], "td": ["db", "gt", "cod", "ssl", "ctl", "dat", "att", "TD", "pb", "md", "pc", "def", "pad", "det", "pt", "nd", "tl", "nt", "cot", "elt", "ht", "d", "dt", "dl", "tg", "cmd", "tn", "dev", "ts", "sd", "ds", "ind", "bd", "tr", "tif", "dad", "t", "dh", "th", "edd", "tag", "ud", "dll", "txt", "ad", "dd", "lt", "dn", "tmp", "cd", "tf", "desc", "disc", "pd", "rd", "hd", "table", "ld", "tk", "typ", "tp", "fd", "tc", "od"], "async": [" asynchron", "jasynchron", "asyn", "Aspc", "ASsync", "Asynchronous", "jasynchronous", "asynchronous", "Asyn", "masync", "asterync", " asyn", "assynchronous", "Async", "jasync", "lassync", "lasyn", " assync", "AScore", "assyn", "massync", "sync", "assync", "ascore", "Asdule", "ASync", "aspc", "asspc", "syn", "Assync", " askie", " ascs", "ascs", "Ascs", "rasyn", "synchronous", "jaskie", "masynchronous", "ssync", "lasync", "maskie", "asynchron", " asynchronous", " asdule", "rasynchronous", "ASyn", "masdule", "asteryn", "astercs", "asterynchronous", "asssync", "rascore", "asdule", "masynchron", "Ascore", "askie", "raspc", "lasynchronous", "ASynchronous", "rasync"], "int_mask": ["Int_const", "alt_ma", "int_ma", "int_ask", "inter_Mask", "intityfilter", "int8Mask", "int_batch", "int_flag", "int__mask", "Int_filter", "int00mask", "int00const", "int00filter", "intitymask", "inter_flag", "Int_mask", "int8mask", "intityma", "int__Mask", "int_filter", "inter_mask", "alt_mask", "intitybatch", "alt_filter", "int_const", "int8flag", "int00ask", "int_Mask", "int__flag", "Int_ask", "alt_batch"], "max_len": ["max11lon", "max2en", "inv_lf", "inv_len", "main_en", "max2Len", " max_Len", "Max_Len", "max11ll", "max_length", " max_length", "Max_length", "main11en", " max_en", "Max_en", "main11lon", "Max_len", "max_lon", "max_Len", "main11ll", "max11len", "max_ll", "inv_length", "max2length", "max11en", "main_len", "main_lon", "inv_lon", "main_ll", "max_en", "max_lf", "max2len", "main11len"], "err": ["init", "rs", "error", "cert", "cmp", "msg", "er", "progress", "ind", "cb", "ner", "r", "str", "rc", "proc", "rev", "rr", "attr", "lp", "iter", "inner", "resp", "ch", "oe", "fr", "arr", "res", "elt"], "ret": ["gt", "result", "uf", "repl", "rot", "pret", "mem", "att", "reply", "cont", "rep", "nt", "prot", "dt", "mt", "rets", "len", "val", "del", "tr", "red", "alt", "sent", "t", "rc", "ref", "bool", "rev", "rem", "out", "code", "txt", "rt", "reset", "lt", "resp", "re", "fin", "status", "tmp", "lit", "tf", "RET", "cat", "Ret", "test", "ft", "tech", "ld", "ll", "nl", "res", "arr", "tail", "deg", "def", "rm", "elt", "flag"], "pid": ["thread", "sp", "mn", "po", "ping", "type", "pc", "ctx", "pan", "phy", "sys", "pt", "state", "vid", "pri", "os", "mid", "p", "pat", "pa", "base", "ps", "typ", "len", "ds", "uid", "pi", " pos", " fid", "pe", "id", "pos", "pkg", "proc", "pr", "phi", " pc", "bid", "token", "sid", "oid", "fin", "status", " tid", " sid", "port", "part", " PID", "iat", " pend", " p", "pin", "tp", "fd", "elt"], "as": ["was", "rs", "ass", "asp", "ar", "ars", "ab", "acs", "sam", "ma", "cs", "ias", "os", "mes", "pa", "ms", "is", "As", "or", "jas", "js", "asks", "ast", "an", "ap", "ras", "las", "sa", "ac", "aos", "bs", " es", "nas", "am", "pas", "AS", "us", "ask", "ais", "ase", "a", "oss"]}}
{"project": "qemu", "commit_id": "9d27abd94fe2c48281a77112d58422b392a80f7b", "target": 0, "func": "static void cpu_x86_dump_state(FILE *f)\n\n{\n\n    int eflags;\n\n    char cc_op_name[32];\n\n    eflags = cc_table[CC_OP].compute_all();\n\n    eflags |= (DF & DF_MASK);\n\n    if ((unsigned)env->cc_op < CC_OP_NB)\n\n        strcpy(cc_op_name, cc_op_str[env->cc_op]);\n\n    else\n\n        snprintf(cc_op_name, sizeof(cc_op_name), \"[%d]\", env->cc_op);\n\n    fprintf(f, \n\n            \"EAX=%08x EBX=%08X ECX=%08x EDX=%08x\\n\"\n\n            \"ESI=%08x EDI=%08X EBP=%08x ESP=%08x\\n\"\n\n            \"CCS=%08x CCD=%08x CCO=%-8s EFL=%c%c%c%c%c%c%c\\n\"\n\n            \"EIP=%08x\\n\",\n\n            env->regs[R_EAX], env->regs[R_EBX], env->regs[R_ECX], env->regs[R_EDX], \n\n            env->regs[R_ESI], env->regs[R_EDI], env->regs[R_EBP], env->regs[R_ESP], \n\n            env->cc_src, env->cc_dst, cc_op_name,\n\n            eflags & DF_MASK ? 'D' : '-',\n\n            eflags & CC_O ? 'O' : '-',\n\n            eflags & CC_S ? 'S' : '-',\n\n            eflags & CC_Z ? 'Z' : '-',\n\n            eflags & CC_A ? 'A' : '-',\n\n            eflags & CC_P ? 'P' : '-',\n\n            eflags & CC_C ? 'C' : '-',\n\n            env->eip);\n\n#if 1\n\n    fprintf(f, \"ST0=%f ST1=%f ST2=%f ST3=%f\\n\", \n\n            (double)ST0, (double)ST1, (double)ST(2), (double)ST(3));\n\n#endif\n\n}\n", "idx": 4337, "substitutes": {"f": ["cf", "q", "uf", "b", "ff", "fm", "c", "u", "h", "file", "fc", "p", "d", "g", "n", "F", "o", "fp", "t", "r", "w", "rf", "v", "df", "fa", "fn", "fb", "tf", "sf", "fi", "fs", "e", "fr", "z", "fd", "fw"], "eflags": ["efliaves", "efslats", "efliages", "efklatts", "eadlains", "eadlatches", "efflagged", "EFlods", "efmlinks", "efmlangs", "ethlenasks", "efflags", "efliaps", "eflsangs", "EFmags", "alflages", "embedleninks", "epslionds", "eflinks", "eflcods", "eflenatches", "epsliills", "eflsains", "efmlills", "eflangs", "efliags", "ebliaves", "efglasks", "erelsages", "efklags", "ethlasks", "epsliars", "eblsags", "eflsills", "eftlatts", "alflaps", "EFlatts", "eblaves", "efflaps", "eblatts", "eflaks", "efleninks", "eflenasks", "efliig", "reflags", "eflig", "eflagged", "alflags", "eflisugs", "eflonds", "efglugs", "efliagn", "embedlenems", "ethlugs", "efylagged", "efglags", "eflcatts", "embedlenangs", "eflatts", "eblagn", "eflnags", "eflages", "eflars", "efylaps", "efflugs", "efylages", "eflenems", "efrlaps", "eadlenugs", "eadlugs", "ethlenags", "eflsaps", "epslags", "efmlems", "eadlenags", "EFlages", "efrlugs", "eflatches", "embedlinks", "efllasks", "eflaps", "efmatts", "efliatts", "efklagn", "embedlags", "efliills", "EFmages", "erelaks", "ebliagn", "eflains", "eflsugs", "eflsaks", "efliars", "efllags", "eflenags", "efflages", "efklats", "erelages", "efslig", "eflisains", "eadlenatches", "eadlags", "reflig", "eflagn", "refklags", "efglills", "ethlenugs", "efmlars", "eflasks", "efllugs", "erelsaks", "efklig", "refklats", "eflats", "efrlags", "eflsags", "epslars", "ebliags", "ethlags", "efmods", "eflaves", "erelsills", "embedlems", "efglaks", "embedlenags", "eftlods", "eflcages", "epsliags", "efllains", "eblsugs", "efklaves", "alfylages", "eblugs", "efmlags", "eflionds", "epslills", "erelsags", "ethlains", "efklages", "efslages", "eflenains", "efrlages", "eflnaves", "eblages", "eflcags", "efslags", "EFmatts", "efylags", "eflisags", "eflnatts", "eflsems", "eblaps", "erelags", "eblsages", "eflisatches", "efmlonds", "EFlags", "eflsinks", "eflods", "ethlenains", "reflages", "efglages", "refklages", "eflems", "efglains", "efmages", "alfylaps", "eftlags", "alfylags", "eadlenains", "embedlangs", "eflugs", "reflats", "alflagged", "eblags", "eblsaps", "erelills", "ebliatts", "eflsatches", "refklig", "efliats", "eflills", "alfylagged", "eflsages", "eflenugs", "efmags", "eflenangs", "epslonds", "eflnagn", "EFmods", "eftlages", "efliagged"], "cc_op_name": ["cc_OP_str", "cc_oper_Name", "cc_op2name", "cc_op_desc", "cc_var2names", "cc_op_no", "cc_op___names", "cc_op_str", "cc_op2names", "cc_op_type", "cc_var_name", "cc_op__names", "cc_OP_name", "cc_op2type", "cc_op_string", "cc_OP_type", "cc_op_code", "cc_oper_str", "cc_OP_no", "cc_op_Name", "cc_var_type", "cc_op___no", "cc_op__type", "cc_op___name", "cc_op_names", "cc_op___Name", "cc_oper_name", "cc_var2type", "cc_op___str", "cc_var_names", "cc_op___type", "cc_var2name", "cc_op___desc", "cc_op__name"]}}
{"project": "FFmpeg", "commit_id": "612ecfbbbb3f4238d44cca5f250ffc6147d03ec2", "target": 0, "func": "static int gif_read_image(GifState *s)\n\n{\n\n    int left, top, width, height, bits_per_pixel, code_size, flags;\n\n    int is_interleaved, has_local_palette, y, pass, y1, linesize, n, i;\n\n    uint8_t *ptr, *spal, *palette, *ptr1;\n\n\n\n    left = bytestream_get_le16(&s->bytestream);\n\n    top = bytestream_get_le16(&s->bytestream);\n\n    width = bytestream_get_le16(&s->bytestream);\n\n    height = bytestream_get_le16(&s->bytestream);\n\n    flags = bytestream_get_byte(&s->bytestream);\n\n    is_interleaved = flags & 0x40;\n\n    has_local_palette = flags & 0x80;\n\n    bits_per_pixel = (flags & 0x07) + 1;\n\n\n\n    av_dlog(s->avctx, \"image x=%d y=%d w=%d h=%d\\n\", left, top, width, height);\n\n\n\n    if (has_local_palette) {\n\n        bytestream_get_buffer(&s->bytestream, s->local_palette, 3 * (1 << bits_per_pixel));\n\n        palette = s->local_palette;\n\n    } else {\n\n        palette = s->global_palette;\n\n        bits_per_pixel = s->bits_per_pixel;\n\n    }\n\n\n\n    /* verify that all the image is inside the screen dimensions */\n\n    if (left + width > s->screen_width ||\n\n        top + height > s->screen_height)\n\n        return AVERROR(EINVAL);\n\n\n\n    /* build the palette */\n\n    n = (1 << bits_per_pixel);\n\n    spal = palette;\n\n    for(i = 0; i < n; i++) {\n\n        s->image_palette[i] = (0xffu << 24) | AV_RB24(spal);\n\n        spal += 3;\n\n    }\n\n    for(; i < 256; i++)\n\n        s->image_palette[i] = (0xffu << 24);\n\n    /* handle transparency */\n\n    if (s->transparent_color_index >= 0)\n\n        s->image_palette[s->transparent_color_index] = 0;\n\n\n\n    /* now get the image data */\n\n    code_size = bytestream_get_byte(&s->bytestream);\n\n    ff_lzw_decode_init(s->lzw, code_size, s->bytestream,\n\n                       s->bytestream_end - s->bytestream, FF_LZW_GIF);\n\n\n\n    /* read all the image */\n\n    linesize = s->picture.linesize[0];\n\n    ptr1 = s->picture.data[0] + top * linesize + left;\n\n    ptr = ptr1;\n\n    pass = 0;\n\n    y1 = 0;\n\n    for (y = 0; y < height; y++) {\n\n        ff_lzw_decode(s->lzw, ptr, width);\n\n        if (is_interleaved) {\n\n            switch(pass) {\n\n            default:\n\n            case 0:\n\n            case 1:\n\n                y1 += 8;\n\n                ptr += linesize * 8;\n\n                if (y1 >= height) {\n\n                    y1 = pass ? 2 : 4;\n\n                    ptr = ptr1 + linesize * y1;\n\n                    pass++;\n\n                }\n\n                break;\n\n            case 2:\n\n                y1 += 4;\n\n                ptr += linesize * 4;\n\n                if (y1 >= height) {\n\n                    y1 = 1;\n\n                    ptr = ptr1 + linesize;\n\n                    pass++;\n\n                }\n\n                break;\n\n            case 3:\n\n                y1 += 2;\n\n                ptr += linesize * 2;\n\n                break;\n\n            }\n\n        } else {\n\n            ptr += linesize;\n\n        }\n\n    }\n\n    /* read the garbage data until end marker is found */\n\n    ff_lzw_decode_tail(s->lzw);\n\n    s->bytestream = ff_lzw_cur_ptr(s->lzw);\n\n    return 0;\n\n}\n", "idx": 4341, "substitutes": {"s": ["sw", "less", "tes", "conf", "h", "ps", "ports", "ts", "settings", "t", "js", "w", "sb", "ss", "changes", "sports", "params", "comments", "as", "rs", "ses", "ants", "os", "ms", "es", "stats", "m", "vs", "serv", "sis", "a", "aws", "l", "ops", "gs", "bis", "ns", "ats", "comm", "cs", "p", "is", "sv", "hs", "bs", "session", "parts", "fs", "S", "rates", "b", "its", "qs", "sys", "set", "als", "stat", "details", "ds", "ins", "ls", "ims", "sl", "status", "spec", "states", "obj", "ex", "sts"], "top": ["widget", "upper", "user", "target", "bot", "lat", "offset", "bottom", "pt", "client", "localhost", "my", "center", "best", "table", "lon", "typ", "op", "on", "tops", "t", "position", "to", "above", "clip", "part", "there", "TOP", "parent", "current", "Top", "size", "public", "html", "high", "tool", "origin", "x", "hop", "tp", "title", "lower"], "height": ["gh", "depth", "ty", "chain", "padding", "created", "Height", "window", "inches", "h", "radius", "bottom", "era", "density", "ht", "rank", "rows", "history", "range", "available", "headers", "style", "above", "host", "bits", "ch", "volume", "build", "version", "through", "capacity", "count", "sky", "he", "wh", "shape", "size", "hash", "length", "high", "html", "x", "ows", "hang", "resolution"], "bits_per_pixel": ["bits_per__component", "bits_PER_page", "bits_perippixel", "bits_peripblock", "bits_PER_px", "bits_last_pixel", "bits_Per_pixel", "bits_lastipbyte", "bits_per_Pixel", "bits_per__page", "bits_PER_component", "bits_per___byte", "bits_peripframe", "bits_perJpx", "bits_per___page", "bits_per_page", "bits_last_frame", "bits_per___pixel", "bits_perJpixel", "bits_per_byte", "bits_peripbyte", "bits_per_char", "bits_per_block", "bits_last_byte", "bits_per__byte", "bits_per_frame", "bits_Per_Pixel", "bits_Per_page", "bits_per_px", "bits_perJpage", "bits_last_block", "bits_PER_byte", "bits_per__Pixel", "bits_lastippixel", "bits_lastipblock", "bits_lastipframe", "bits_PER_pixel", "bits_PER_char", "bits_per_component", "bits_Per_byte", "bits_per___Pixel", "bits_per__pixel"], "code_size": ["code2Size", "image_no", "code_year", "code2size", "code5type", "image_Size", "image_size", "code5Size", "code_type", "image_type", "code2type", "code2no", "code5no", "code_no", "code5size", "image_year", "code_Size"], "flags": ["members", "rates", "fields", "styles", "weights", "times", "ants", "ats", "ags", "locks", "missions", "kind", "cs", "aps", "acts", "actions", "pins", "lines", "details", "words", "ports", "settings", "ts", "bugs", "products", "vals", "quality", "types", "options", "atts", "events", "comments", "grades", "planes", "units", "properties", "stats", "tags", "args", "keys", "bits", "status", "levels", "Flags", "states", "limits", "lag", "reports", "mask", "fs", "heads", "groups", "format", "features", "faces", "ops", "flag", "lists"], "is_interleaved": ["is_intlaved", "is_intlave", "is_interleave", "is_interlineaded", "is_interlaved", "is_interleaves", "is_interlaving", "is_interoleaving", "is_interpleaving", "is_interpleaves", "is_interlave", "is_intleaving", "is_intleave", "is_interlaves", "is_interladed", "is_intbleave", "is_interbleaves", "is_interoleaded", "is_intleaded", "is_intleaved", "is_interlineaved", "is_interbleaving", "is_intladed", "is_interoleave", "is_intlaving", "is_intbleaves", "is_interpleaved", "is_intbleaving", "is_intbleaved", "is_interpleave", "is_interlineaving", "is_interlineave", "is_interoleaved", "is_interleaving", "is_intleaves", "is_interbleave", "is_interbleaved", "is_interleaded"], "has_local_palette": ["has_local_alte", "has_local_alette", "has_local_Palette", "has_local_pixelettes", "has_local_pixelme", "has_local_pallete", "has_local_calme", "has_local_palme", "has_local_calette", "has_local_pixelte", "has_local_Palet", "has_local_alme", "has_local_palte", "has_local_alettes", "has_local_palet", "has_local_Pallete", "has_local_callete", "has_local_calet", "has_local_calettes", "has_local_pixelette", "has_local_Palettes", "has_local_palettes", "has_local_alet", "has_local_allete"], "y": ["xy", "b", "dy", "c", "h", "yi", "Y", "gy", "p", "ya", "t", "ny", "py", "yy", "ye", "scroll", "m", "ch", "yp", "ys", "ey", "e", "j", "z", "yo", "ym", "l"], "pass": ["read", "depth", "result", "channel", "Y", "p", "xx", "rows", "zero", "val", "row", "ep", "line", "scale", "pe", "r", "pos", "level", "k", "code", "dim", "ch", "ss", "f", "test", "z", "path"], "y1": ["Y2", "xy7", " y7", " y2", " y3", "y3", "Y7", "y2", "Y1", "xy3", "Y3", "y7", "xy2", "xy1"], "linesize": ["linesiz", "itemsz", "codesize", "codessize", "itemsize", "itemsiz", "codesz", "lssize", "lsz", "linesz", "itemssize", "lsiz", "linessize", "lsize", "codesiz"], "n": ["b", "mn", "ns", "c", "nt", "nn", "p", "d", "g", " N", "no", "nc", "len", "name", "network", "na", "index", "o", "t", "pi", "nu", "N", "w", "number", "r", "nm", "k", "cn", "num", "m", "nb", "sn", "nan", "np", "count", "size", "j", "nl", "ne", "names", "ni", "l"], "i": ["init", "this", "ic", "ini", "ij", "q", "ei", "chain", "ci", "b", "it", "c", "cli", "ma", "ter", "cgi", "oi", "gi", "mi", "qi", "ip", "li", "p", "si", "ami", "esi", "zi", "is", "ind", "xi", "index", "t", "ri", "pi", "bi", "multi", "me", "id", "ui", "ki", "slice", "phi", "ti", "iter", "v", "ims", "ix", "ai", "m", "status", "I", "batch", "print", "f", "us", "sim", "iu", "e", "in", "j", "di", "\u0438", "x", "ii", "l"], "ptr": ["iv", "sp", "buff", "copy", "mem", "pen", "offset", "pad", "pointers", "p", "addr", "rect", "ind", "row", "pointer", "tr", "err", "dr", "ref", "pos", "pipe", "inter", "pert", "alloc", "bl", "np", "length", "arr", "ro"], "spal": ["espel", "Spel", "ispal", "ospal", "espac", " spa", "psale", "spel", "SPac", "psal", "ospam", " spale", " spam", "Spale", " spall", "psel", " spac", "spam", " spar", "Spall", "espam", "espall", "Spar", "ispar", "spall", "ospar", "ispa", "Spa", "espal", "ispale", "spar", "spale", "psam", "ospall", "espale", "spac", "Spam", "Spal", "spa", "SPal", "SPall", "SPale"], "palette": ["stalme", "palme", "matlete", "matotype", "allete", "stallete", "matlette", "pallete", "pallette", "stalette", "chome", "matette", "fillete", "alettes", "salal", "callette", "Palotype", "plte", "pllete", "sallete", "alte", "choette", "stalal", "salme", "temette", "plettes", "Pallete", "choal", "temal", "alette", "sallette", "cholete", "Pallette", "palettes", "palotype", "filette", "filotype", "calette", "temlete", "calal", "temlette", "plette", " pallete", " palte", "callete", " palettes", "salette", "palal", "fillette", "palte", "Palette"], "ptr1": ["pad2", "pad1", "pointer3", "p3", "p0", "p2", "ptr3", "pad0", "p1", "pointer1", "pad3", "pointer2", "ptr2", "pointer0", "ptr0"]}}
{"project": "FFmpeg", "commit_id": "43a4cb070bf7588c53fd192e8fbc71a52fa14a4c", "target": 0, "func": "static int alac_encode_frame(AVCodecContext *avctx, uint8_t *frame,\n\n                             int buf_size, void *data)\n\n{\n\n    AlacEncodeContext *s = avctx->priv_data;\n\n    PutBitContext *pb = &s->pbctx;\n\n    int i, out_bytes, verbatim_flag = 0;\n\n\n\n    if (avctx->frame_size > DEFAULT_FRAME_SIZE) {\n\n        av_log(avctx, AV_LOG_ERROR, \"input frame size exceeded\\n\");\n\n        return -1;\n\n    }\n\n\n\n    if (buf_size < 2 * s->max_coded_frame_size) {\n\n        av_log(avctx, AV_LOG_ERROR, \"buffer size is too small\\n\");\n\n        return -1;\n\n    }\n\n\n\nverbatim:\n\n    init_put_bits(pb, frame, buf_size);\n\n\n\n    if (s->compression_level == 0 || verbatim_flag) {\n\n        // Verbatim mode\n\n        const int16_t *samples = data;\n\n        write_frame_header(s, 1);\n\n        for (i = 0; i < avctx->frame_size * avctx->channels; i++) {\n\n            put_sbits(pb, 16, *samples++);\n\n        }\n\n    } else {\n\n        init_sample_buffers(s, data);\n\n        write_frame_header(s, 0);\n\n        write_compressed_frame(s);\n\n    }\n\n\n\n    put_bits(pb, 3, 7);\n\n    flush_put_bits(pb);\n\n    out_bytes = put_bits_count(pb) >> 3;\n\n\n\n    if (out_bytes > s->max_coded_frame_size) {\n\n        /* frame too large. use verbatim mode */\n\n        if (verbatim_flag || s->compression_level == 0) {\n\n            /* still too large. must be an error. */\n\n            av_log(avctx, AV_LOG_ERROR, \"error encoding frame\\n\");\n\n            return -1;\n\n        }\n\n        verbatim_flag = 1;\n\n        goto verbatim;\n\n    }\n\n\n\n    return out_bytes;\n\n}\n", "idx": 4344, "substitutes": {"avctx": ["cvctx", "ajwcs", "afhistory", "wavjp", "ajcv", "ajctx", " avhistory", "avcontext", "avcv", "abcu", "abcfg", "ajjp", "Avcontext", "avwcs", "avecv", "avcfg", "Avtx", "avcu", "aukw", "averctx", "avejp", "ajcu", "afctx", " avjp", "aircu", "airhistory", "cvcontext", "avconn", "auctx", "avecontext", "avewcs", "auhistory", "avhistory", "avectx", "wavctx", "cvtx", "avctl", "wavcontext", "avertx", " avconn", "abctl", "avpkg", "avtx", "airkw", "abcontext", "avecu", " avcontext", "aftx", "avercontext", "avekw", " avtx", "Avconn", " avcfg", "averjp", " avctl", "wavtx", "avehistory", "afpkg", "avercv", "abctx", " avcu", "ajtx", "aucu", "avjp", "avetx", "averwcs", "cvctl", "abconn", "abtx", "Avctx", "averhistory", "ajcfg", "abpkg", "avepkg", "afcontext", "airctx", "avkw"], "frame": ["ence", "header", "package", "rame", "event", "feat", "chain", "window", "channel", "Frame", "fram", "framework", "type", "iframe", "state", "buffer", "fc", "flow", "base", " frames", "frames", "context", "ce", "range", "bit", "ime", "word", "style", "code", "video", "feature", "block", " sequence", "sample", " framed", "AME", "face", "point", "time", "length", "fr", "info", "in", "image", "sequence"], "buf_size": ["buf_length", "bufPshape", "uf_index", "poolingshape", "bufingbytes", "bufablesize", "bufbuflimit", "poolingsize", "bufableshape", "pool_shape", "bufPlevel", "uf_size", "pool_level", "bufinglevel", "buf_SIZE", "buf_shape", "pool_size", "uf_length", "bufPsize", "bufingshape", "bufingsize", "poolingbytes", "bufPbytes", " buf_limit", "bufablebytes", "buf_limit", "buf_bytes", "bufablelevel", "buf_index", "bufbufsize", " buf_loss", "uf_SIZE", "buf_loss", "bufbufloss", "buf_level", "poolinglevel", "pool_bytes"], "data": ["all", "bytes", "padding", "next", "dat", "window", "any", "values", "none", "buf", " Data", "buffer", "raw", "d", "p", "frames", "table", "missing", "n", " DATA", "ata", "o", "t", "r", "value", "Data", "to", "mu", "video", "args", "bits", "block", "load", "m", "new", "batch", "f", "DATA", "message", "sample", "size", "flags", "length", "res", "text", "a", "name", "image", "bin"], "s": ["as", "rs", "gs", "ses", "sp", "ssl", "b", "sw", "less", "ns", "c", "its", "ctx", "ats", "h", "aws", "sys", "set", "qs", "cs", "comm", "os", "p", "d", "als", "ms", "n", "ps", "is", "ts", "g", "ds", "t", "es", "js", "ins", "sv", "ls", "sb", "xs", "v", "ims", "iss", "stats", "args", "sl", "m", "sa", "hs", "spec", "ss", "bs", "sq", "parts", "fs", "e", "S", "sts", "z", "sis", "j", "a", "l"], "pb": ["gb", "uf", "sp", "b", "bj", "wp", "cp", "pc", "ctx", "pan", "pt", "buf", "px", "p", "ps", "pa", "mt", "bp", "vp", "cb", "pl", "wb", "fp", "lb", "pm", "ub", "pg", "pkg", "py", "ap", "sb", "lp", "rb", "bs", "tmp", "cv", "fb", "pool", "jp", "np", "tap", "dp", "pd", "obj", "vm", "pp", "PB", "td", "bm", "tk", "tp", "mp"], "i": ["init", "ic", "ini", " bi", "ci", " ii", "it", " m", "im", "c", "cli", " x", "gi", "mi", "qi", "ip", "li", "p", "si", "g", "zi", "xi", "ind", " ti", "t", "pi", "bi", "multi", "me", "ui", "hi", "ki", "span", " I", "phi", "ti", "iter", "ix", " j", "ai", "m", " mi", "I", "batch", "y", "\u0438", "sim", "gu", "iu", "in", "MI", "j", "x", "di", "ii"], "out_bytes": ["outMembytes", " out_cells", "out_pages", " out_bits", "out_bits", " out_lines", "out_pieces", "out___pieces", "out__Bytes", " out_parts", "out_errors", "OUT_bytes", "outMemlines", "out_tes", "out___tes", "out__parts", "out___lines", "OUT_lines", " out_errors", "out__bits", "out_parts", " out_Bytes", " out_tes", "out_Bytes", "outMemcells", " out_pages", "out__bytes", "out___bytes", "OUT_pieces", "OUT_tes", "out_lines", "outMemtes", "out_cells"], "samples": ["saces", "nizes", "ssamples", "exents", "ssources", "exources", "samps", "taces", "sources", "Samples", "naces", "Sizes", "sents", "namps", "Samps", "Sents", "tamps", "tamples", "examples", "namples", "ssamps", "Saces", "ssents", "examps", "tizes", "Sources", "sizes"]}}
{"project": "qemu", "commit_id": "2725aec70114cf1bee00443aeb47a305f9b0c665", "target": 1, "func": "static void i440fx_update_memory_mappings(PCII440FXState *d)\n\n{\n\n    int i, r;\n\n    uint32_t smram;\n\n    bool smram_enabled;\n\n\n\n    memory_region_transaction_begin();\n\n    update_pam(d, 0xf0000, 0x100000, (d->dev.config[I440FX_PAM] >> 4) & 3,\n\n               &d->pam_regions[0]);\n\n    for(i = 0; i < 12; i++) {\n\n        r = (d->dev.config[(i >> 1) + (I440FX_PAM + 1)] >> ((i & 1) * 4)) & 3;\n\n        update_pam(d, 0xc0000 + 0x4000 * i, 0xc0000 + 0x4000 * (i + 1), r,\n\n                   &d->pam_regions[i+1]);\n\n    }\n\n    smram = d->dev.config[I440FX_SMRAM];\n\n    smram_enabled = (d->smm_enabled && (smram & 0x08)) || (smram & 0x40);\n\n    memory_region_set_enabled(&d->smram_region, !smram_enabled);\n\n    memory_region_transaction_commit();\n\n}\n", "idx": 4360, "substitutes": {"d": ["db", "draw", "dc", "b", "dat", "c", "md", "dL", "du", "p", "dt", "dl", "n", "dict", "bd", "sd", "gd", "ds", "ind", "dev", "o", "data", "t", "D", "w", "dr", "dh", "debug", "dm", "dx", "send", "s", "out", "ad", "dd", "df", "m", "status", "st", "dn", "new", "f", "ord", "pd", "rd", "de", "l", "in", "ld", "j", "di", "x", "fd", "da", "od"], "i": ["init", "ic", "ij", "ini", "asi", "q", "ei", "ci", "uri", " ii", "it", "im", "u", "cli", "oi", "gi", "mi", "qi", "at", "ip", "RI", "li", "p", "si", "g", "ie", "zi", "ami", "is", "name", "iq", "xi", "ind", "index", "ri", "key", "pi", "bi", "multi", "me", "id", "ui", "to", "ki", " I", "phi", "ir", "ti", "abi", "v", "ix", "ai", "m", "status", "I", "batch", "print", "\u0438", "io", "sim", "ex", "in", "iu", "by", "info", "j", "di", "x", "ii", "l"], "r": ["rs", "vr", "q", "b", "ar", "sr", "c", "u", "h", "mr", "rn", "er", "p", "g", "n", "pair", "o", "t", "rw", "range", "w", "dr", "rc", "rr", "rf", "pr", "rb", "cr", "rar", "rt", "m", "re", "reg", "R", "rg", "ur", "rd", "e", "j", "res", "ro", "rm"], "smram": ["samam", " spgram", "mmgram", "smwater", "samram", "svam", "smam", "swgram", "svmm", "svram", " smmem", "smmem", "smcam", "mmrain", "samarm", "svarm", "smrain", "svgram", "samgram", "mmram", "swcam", " spram", "scam", "mmmm", " smcam", " smwater", " smgram", " spcam", "igmcam", "igmram", "srain", "swwater", "sgram", "igmgram", " smam", "smarm", "smmm", " smarm", "svrain", "swram", "smm", "smgram", "swater", "sram", " spmem", "igmmem"], "smram_enabled": ["smram_required", "smmm_online", "smram_position", "smgram_Enabled", "smramxEnabled", "smmem_enable", "smmem_required", "smram_Enabled", "smram_online", "smmm_position", "smram_enable", "smramxenabled", "smgram_encrypted", "smmm_enabled", "smramxposition", "smmem_online", "smramxonline", "smmem_enabled", "smgram_enabled", "smgram_enable", "smram_encrypted", "smmm_Enabled"]}}
{"project": "qemu", "commit_id": "e98768d43799cd3f00b358bfbe455fdae793d3e8", "target": 1, "func": "static int vmdk_open_vmdk4(BlockDriverState *bs,\n\n                           BlockDriverState *file,\n\n                           int flags)\n\n{\n\n    int ret;\n\n    uint32_t magic;\n\n    uint32_t l1_size, l1_entry_sectors;\n\n    VMDK4Header header;\n\n    VmdkExtent *extent;\n\n    int64_t l1_backup_offset = 0;\n\n\n\n    ret = bdrv_pread(file, sizeof(magic), &header, sizeof(header));\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n    if (header.capacity == 0) {\n\n        int64_t desc_offset = le64_to_cpu(header.desc_offset);\n\n        if (desc_offset) {\n\n            return vmdk_open_desc_file(bs, flags, desc_offset << 9);\n\n        }\n\n    }\n\n\n\n    if (le64_to_cpu(header.gd_offset) == VMDK4_GD_AT_END) {\n\n        /*\n\n         * The footer takes precedence over the header, so read it in. The\n\n         * footer starts at offset -1024 from the end: One sector for the\n\n         * footer, and another one for the end-of-stream marker.\n\n         */\n\n        struct {\n\n            struct {\n\n                uint64_t val;\n\n                uint32_t size;\n\n                uint32_t type;\n\n                uint8_t pad[512 - 16];\n\n            } QEMU_PACKED footer_marker;\n\n\n\n            uint32_t magic;\n\n            VMDK4Header header;\n\n            uint8_t pad[512 - 4 - sizeof(VMDK4Header)];\n\n\n\n            struct {\n\n                uint64_t val;\n\n                uint32_t size;\n\n                uint32_t type;\n\n                uint8_t pad[512 - 16];\n\n            } QEMU_PACKED eos_marker;\n\n        } QEMU_PACKED footer;\n\n\n\n        ret = bdrv_pread(file,\n\n            bs->file->total_sectors * 512 - 1536,\n\n            &footer, sizeof(footer));\n\n        if (ret < 0) {\n\n            return ret;\n\n        }\n\n\n\n        /* Some sanity checks for the footer */\n\n        if (be32_to_cpu(footer.magic) != VMDK4_MAGIC ||\n\n            le32_to_cpu(footer.footer_marker.size) != 0  ||\n\n            le32_to_cpu(footer.footer_marker.type) != MARKER_FOOTER ||\n\n            le64_to_cpu(footer.eos_marker.val) != 0  ||\n\n            le32_to_cpu(footer.eos_marker.size) != 0  ||\n\n            le32_to_cpu(footer.eos_marker.type) != MARKER_END_OF_STREAM)\n\n        {\n\n            return -EINVAL;\n\n        }\n\n\n\n        header = footer.header;\n\n    }\n\n\n\n    if (le32_to_cpu(header.version) >= 3) {\n\n        char buf[64];\n\n        snprintf(buf, sizeof(buf), \"VMDK version %d\",\n\n                 le32_to_cpu(header.version));\n\n        qerror_report(QERR_UNKNOWN_BLOCK_FORMAT_FEATURE,\n\n                bs->device_name, \"vmdk\", buf);\n\n        return -ENOTSUP;\n\n    }\n\n\n\n    l1_entry_sectors = le32_to_cpu(header.num_gtes_per_gte)\n\n                        * le64_to_cpu(header.granularity);\n\n    if (l1_entry_sectors == 0) {\n\n        return -EINVAL;\n\n    }\n\n    l1_size = (le64_to_cpu(header.capacity) + l1_entry_sectors - 1)\n\n                / l1_entry_sectors;\n\n    if (le32_to_cpu(header.flags) & VMDK4_FLAG_RGD) {\n\n        l1_backup_offset = le64_to_cpu(header.rgd_offset) << 9;\n\n    }\n\n    extent = vmdk_add_extent(bs, file, false,\n\n                          le64_to_cpu(header.capacity),\n\n                          le64_to_cpu(header.gd_offset) << 9,\n\n                          l1_backup_offset,\n\n                          l1_size,\n\n                          le32_to_cpu(header.num_gtes_per_gte),\n\n                          le64_to_cpu(header.granularity));\n\n    extent->compressed =\n\n        le16_to_cpu(header.compressAlgorithm) == VMDK4_COMPRESSION_DEFLATE;\n\n    extent->has_marker = le32_to_cpu(header.flags) & VMDK4_FLAG_MARKER;\n\n    extent->version = le32_to_cpu(header.version);\n\n    extent->has_zero_grain = le32_to_cpu(header.flags) & VMDK4_FLAG_ZERO_GRAIN;\n\n    ret = vmdk_init_tables(bs, extent);\n\n    if (ret) {\n\n        /* free extent allocated by vmdk_add_extent */\n\n        vmdk_free_last_extent(bs);\n\n    }\n\n    return ret;\n\n}\n", "idx": 4362, "substitutes": {"bs": ["rs", "gs", "bis", "b", "bn", "blog", "ns", "bos", "ib", "its", "bg", "bc", "sys", "cs", "os", "bh", "ps", "ms", "bp", "bd", "ts", "ds", "BS", "cb", "bt", "bi", "js", "bb", "ls", "sb", "bf", "iss", "bits", "vs", "bl", "fs", "ks", "kb", "bm", "bas", "obs", "lbs"], "file": ["db", "bytes", "filename", "chain", "channel", "offset", "model", "page", "store", "state", "lf", "files", "buffer", "os", "table", "base", "File", "vol", "domain", "document", "data", "fp", "queue", "line", "limit", "resource", "section", "fil", "out", "handle", "txt", "be", "port", "block", "stream", "dir", "le", "entry", "grid", "disk", "rule", "f", "fs", "fi", "io", "size", "fr", "lock", "format", "ile", "fd", "image", "path"], "flags": ["fields", "weights", "xf", "ants", " Flags", "ags", "locks", "kind", "cs", "lf", "files", "ensions", "cmd", "lines", "details", "settings", "ts", "fp", "vals", "func", "utils", "bool", "options", "comments", "Flag", "properties", "stats", "args", "bits", "fn", "FLAG", "Flags", "ptr", "cond", "lag", "mask", "fs", "heads", "size", "posts", "nl", "xxx", "features", "fd", "faces", "flag"], "ret": ["gt", "result", "pret", "mem", "att", "Return", "ber", "back", "cont", "ter", "det", "nt", "ry", "elt", "rier", "pat", "rect", "cmd", "mt", " Ret", " alt", "rets", "len", "details", "val", "tr", "usr", "alt", "t", "inter", "rem", "rest", "out", "try", "txt", "plain", "not", "complete", "rt", "reset", "final", "resp", "re", "reg", "report", "status", "lit", "print", "RET", "jump", "Ret", "ft", "net", "j", "ll", "res", "format", "def", "rm", "cert", "flag"], "magic": ["policy", "Magic", "method", "padding", "mag", "power", "prefix", "metadata", "type", "cookie", "offset", "field", "major", "kind", "special", "vector", "table", "base", "cmd", "zone", "domain", "parser", "data", "medium", "dr", "tag", "module", "style", "usage", "code", "slot", "meta", "command", "frame", "spec", "generic", "volume", "pic", "comment", "head", "brand", "version", "area", "handler", "mask", "serial", "spin", "size", "script", "hash", "format", "icon", "journal", "name", "image", "flag", "sequence"], "l1_size": ["l1_name", "l2_sum", "l1_sum", "l1xsize", "l1__size", "l2_name", "l1_Size", "l1__Size", "l2_Size", "l1xsum", "l1xSize", "l1xname", "l1__sum", "l2_size", "l1__name"], "l1_entry_sectors": ["l1_entry_severs", "l1_entry_pegments", "l1_entry_pecs", "l1_entry_spevers", "l1_entry_segments", "l1_entry_psegments", "l1_entry_pevers", "l1_entry_secs", "l1_entry_spegments", "l1_entry_specs", "l1_entry_pectors", "l1_entry_psectors", "l1_entry_spectors", "l1_entry_psecs", "l1_entry_psevers"], "header": ["policy", "tree", "event", "detail", "padding", "adder", "metadata", "window", "term", "type", "h", "HEAD", "offset", "field", "heading", "self", "buffer", "sort", "msg", "er", "prot", "vector", "table", "order", "body", "oder", "document", "index", "line", "data", "history", "key", "headers", "dr", "section", "tag", "commit", "layer", "iter", "summary", "meta", "status", "frame", "block", "writer", "head", "comment", "entry", "version", "ptr", "parent", "handler", "cache", "Header", "liner", "size", "hd", "drm", "column", "holder", "variable", "format", "ver", "journal", "title", "name", "flag"], "extent": ["content", "extant", "extency", "contant", "contency", "xtents", "xtant", "xtent", "indant", "indent", "contents", "indency", "xtency", "indents", "extents"], "pad": ["cod", "grad", "padding", "attach", "adder", "wait", "prefix", "end", "ped", "type", "paste", "pod", "offset", "ads", "help", "pat", "fix", "bind", "pick", "addr", "add", "pay", "prep", "quad", "scale", "push", "mac", "align", "ap", "ad", "cap", "wrap", "ptr", "batch", "frac", "amp", "blank", "dash", "patch", "Pad", "crop"], "QEMU_PACKED": ["QEMU_PACKed", "QEMU_PINKES", "QEMU_PackedLED", "QEMU_PALLLED", "QEMU_PACKITED", "QEMU_MACKed", "QEMU_PACKES", "QEMU_PAIXED", "QEMU_PAACKed", "QEMU_Packeded", "QEMU_PIXed", "QEMU_PAACKITED", "QEMU_MACKES", "QEMU_PALLITED", "QEMU_PIXITED", "QEMU_PASHed", "QEMU_PAACKES", "QEMU_MACKLED", "QEMU_PACKLED", "QEMU_PASHES", "QEMU_PASHED", "QEMU_PALLES", "QEMU_PINKed", "QEMU_PIXED", "QEMU_PAIXed", "QEMU_PALLED", "QEMU_PackedED", "QEMU_PAACKED", "QEMU_PAIXITED", "QEMU_PINKLED", "QEMU_PINKED", "QEMU_PAIXLED", "QEMU_PASHLED", "QEMU_PALLed", "QEMU_MACKED", "QEMU_PIXLED", "QEMU_PAACKLED", "QEMU_PackedES"]}}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "static void control_to_network(RDMAControlHeader *control)\n\n{\n\n    control->type = htonl(control->type);\n\n    control->len = htonl(control->len);\n\n    control->repeat = htonl(control->repeat);\n\n}\n", "idx": 4385, "substitutes": {"control": ["output", "content", "accept", "update", "form", "setup", "layout", "call", "ctl", "prefix", "ell", "null", "cont", "view", "rel", "edit", "management", "description", "compl", "client", "comm", "help", "trl", "cmd", "add", "settings", "rol", "follow", "Control", "input", "delete", "number", "connect", "rc", "send", "code", "handle", "component", "change", "critical", "scroll", "config", "driver", "command", "load", "controller", "close", "report", "build", "cond", "exec", "desc", "fail", "current", "cell", "obj", "unknown", "info", "check", "length", "hold", "roll", "ctrl", "create", "radio"]}}
{"project": "qemu", "commit_id": "95129d6fc9ead97155627a4ca0cfd37282883658", "target": 0, "func": "static bool use_multiport(VirtIOSerial *vser)\n\n{\n\n    VirtIODevice *vdev = VIRTIO_DEVICE(vser);\n\n    return virtio_has_feature(vdev, VIRTIO_CONSOLE_F_MULTIPORT);\n\n}\n", "idx": 4389, "substitutes": {"vser": ["vercer", "vtser", "vcther", "vctor", "vtther", "vther", " vsector", "vtsector", "vserv", "vertor", "vccer", "verser", "vtserv", "vsector", "vcserv", "vcsector", " vther", "vtor", " vtor", " vserv", "vcser", " vcer", "vcer"], "vdev": ["vev", "vdevice", "gdev", "dav", "vav", "gdevice", "vobj", "vserv", "fdev", "gserv", "dev", "vvar", "fobj", "tvvar", "fserv", " vserv", " vvar", "tvav", "tvev", "ddev", " vev", " vobj", "gobj", "fdevice", " vdevice", "dvar", "tvdev", " vav"]}}
{"project": "FFmpeg", "commit_id": "56ee3f9de7b9f6090d599a27d33a392890a2f7b8", "target": 0, "func": "static int poll_filter(OutputStream *ost)\n\n{\n\n    OutputFile    *of = output_files[ost->file_index];\n\n    AVFrame *filtered_frame = NULL;\n\n    int frame_size, ret;\n\n\n\n    if (!ost->filtered_frame && !(ost->filtered_frame = avcodec_alloc_frame())) {\n\n        return AVERROR(ENOMEM);\n\n    } else\n\n        avcodec_get_frame_defaults(ost->filtered_frame);\n\n    filtered_frame = ost->filtered_frame;\n\n\n\n    if (ost->enc->type == AVMEDIA_TYPE_AUDIO &&\n\n        !(ost->enc->capabilities & CODEC_CAP_VARIABLE_FRAME_SIZE))\n\n        ret = av_buffersink_get_samples(ost->filter->filter, filtered_frame,\n\n                                         ost->st->codec->frame_size);\n\n    else\n\n        ret = av_buffersink_get_frame(ost->filter->filter, filtered_frame);\n\n\n\n    if (ret < 0)\n\n        return ret;\n\n\n\n    if (filtered_frame->pts != AV_NOPTS_VALUE) {\n\n        filtered_frame->pts = av_rescale_q(filtered_frame->pts,\n\n                                           ost->filter->filter->inputs[0]->time_base,\n\n                                           ost->st->codec->time_base) -\n\n                              av_rescale_q(of->start_time,\n\n                                           AV_TIME_BASE_Q,\n\n                                           ost->st->codec->time_base);\n\n    }\n\n\n\n    switch (ost->filter->filter->inputs[0]->type) {\n\n    case AVMEDIA_TYPE_VIDEO:\n\n        if (!ost->frame_aspect_ratio)\n\n            ost->st->codec->sample_aspect_ratio = filtered_frame->sample_aspect_ratio;\n\n\n\n        do_video_out(of->ctx, ost, filtered_frame, &frame_size);\n\n        if (vstats_filename && frame_size)\n\n            do_video_stats(ost, frame_size);\n\n        break;\n\n    case AVMEDIA_TYPE_AUDIO:\n\n        do_audio_out(of->ctx, ost, filtered_frame);\n\n        break;\n\n    default:\n\n        // TODO support subtitle filters\n\n        av_assert0(0);\n\n    }\n\n\n\n    av_frame_unref(filtered_frame);\n\n\n\n    return 0;\n\n}\n", "idx": 4411, "substitutes": {"ost": ["must", "oster", "ether", "utt", "ob", "boost", "addr", " nost", "oad", "ast", "ud", "ird", "oc", "cern", "om", "art", "ict", "yt", "lost", "xp", "olog", "sta", "obs", "ust", "onet", "od", "post", "aud", "ty", "wow", "mem", "wp", "ox", "alist", "nt", "os", "odore", "oard", "oo", "ocr", "rob", "ocol", "old", "expr", "ow", "ot", "stream", "oe", "ops", "oss", "et", "ort", "areth", "ond", "osta", "ief", "wind", "usr", "and", "o", "rest", "org", "host", "lov", "oid", "rt", "st", "ord", "otype", "ld", "news", "your", "tt", "owl", "est", "sys", "ous", "\u00f3", "etc", "wn", "irst", "ott", "tto", "each", "OST", "rost", "embed", "asts", "oth", "ist", "obj", "hop", "pty", "oop", "arent"], "of": ["oft", "so", "oco", "et", "des", "sw", "bj", "eff", "root", "oa", "orf", "ol", "it", "less", "avored", "OO", "lf", "oof", "oi", "ok", "os", "oned", "osi", "boost", "ocket", "\u00f3", "on", "or", "Of", "eh", "o", "with", "zero", " af", " os", "uf", "from", "el", "oen", " OF", "to", "out", "ow", " od", "ot", " lov", "ef", "oid", "new", "om", "omp", "off", "wo", "by", "oe", "one", "OF"], "filtered_frame": ["filtered_step", "filteredtFrame", "filtered2message", "filtered_Frame", "filtered___point", "filannedJface", "filteredJrecord", "filteredmyfeature", "filteredbedinput", "filorted____fr", "filtered_record", "filtered___Frame", "filtered____word", "filoded7process", "filtering_block", "filted_fram", "fillectedmyface", "filanned_fram", "filorted_fr", "filorted____frame", "filered____component", "filteredJfram", "filered_frames", "filterededpoint", "filened_role", "filtered_input", "fillected_feature", "filtered__row", "filtered___word", "filorted____word", "filtered_window", "filtered23role", "filteringJframe", "filpped_channel", "filtered_from", "filtering_frame", "filteringJrow", "filendered_sample", "filtered___fr", "filtered____from", "filted_Frame", "filtered___channel", "filendered___sample", "filtered23frame", "filteredJframe", "fillected____channel", "filoded_frame", "filtered_state", "fillected_frame", "filtered____channel", "filtered_length", "filtered_block", "filterededframe", "filened_word", "filpped_frame", "filterededcomponent", "filered____frame", "filteringJsample", "filted___Frame", "filtered_file", "filted_record", "filtered_point", "filtered_image", "filtered_face", "filtered_message", "filtered23fram", "filteredJstate", "filtered___step", "filtering_component", "filted_frame", "filtered___component", "filtered_frames", "filtered23word", "filted_image", "filened23frame", "filtered_fr", "filtered___record", "filted_sample", "filtering_Frame", "filtered__step", "filteredbedblock", "filtering_row", "filannedJfram", "filoded_process", "filtered____window", "filteredtsample", "filtered__channel", "filtered__frames", "fillected____message", "fillected____frame", "filoded_zone", "filtered7zone", "filted_window", "filendered_point", "filted___image", "filened_frame", "filteredtrow", "filered____frames", "fillectedmychannel", "filtered____fr", "fillected_from", "filterededsample", "filendered_component", "fillectedmyframe", "fillected____from", "filtered23Frame", "fillected_face", "filered_frame", "filendered___component", "filtered___process", "filted_length", "filtered23record", "filendered___frame", "filteredJfeature", "filtered___fram", "filorted_frame", "filtered____file", "filtered2frame", "filened_row", "filtered__image", "filpped___image", "filteredmyface", "filteredJfrom", "filtering_frames", "filpped_image", "filtered__role", "filtered___image", "filtered_zone", "filtered_role", "filpped___channel", "filtered2from", "fillectedmyfeature", "filted___process", "filteredJface", "filendered___point", "filannedJstate", "filtered_channel", "filtering_window", "filtered23row", "filtered7frame", "filted___record", "filtered_fram", "filtered__file", "filted___fram", "fillected_channel", "filoded7zone", "filanned_frame", "filendered_frame", "filtered___row", "filteredtframe", "filteredbedframes", "filtered___sample", "filteredmychannel", "filtered____frame", "filtering_fram", "filtered_word", "filpped___frame", "filteredJrow", "filtered___input", "filened23row", "filtered_process", "filteredJchannel", "filtered____fram", "filtered____message", "filteredbedframe", "filteredJFrame", "filered_file", "filted___frame", "filteringJFrame", "filtered2channel", "filered_component", "filteredJsample", "filtering_sample", "filtered__word", "filened23word", "filtered___frame", "filtered____frames", "filteredmyframe", "filoded7frame", "filanned_face", "filannedJframe", "filened23role", "filtered__component", "filtering_input", "filtered__frame", "filpped___step", "filted___sample", "filtered____component", "filted_component", "filered____file", "filtered___block", "filtered7process", "filtered___frames", "filanned_state", "filorted_word", "filtered_feature", "filpped_step", "fillected_message", "filtered_component", "filtered_row", "filteredJmessage", "filted_process", "filtered_sample"], "frame_size": ["fram8member", "sample_offset", "frame64number", "Frame_SIZE", " frame_length", "sample_scale", "frame_offset", "fram8ize", "frame_loss", "fram8size", "frame_SIZE", "frame_length", "Frame_Size", "frame16SIZE", "sample_SIZE", "fram_loss", "frame_info", "Frame_info", "fram_member", "frame8loss", "frame_sn", "frame_ize", "frame64ize", "frame16storage", "Frame_number", "Frame_size", "frame16size", "frame_Size", "Frame_storage", "frame_storage", "frame64member", "frame_member", "fram_ize", "fram_size", "frame8member", "frame_scale", "sample_size", "frame16number", "frame8ize", "frame8size", "frame64size", "frame64info", "frame64Size", "fram8loss", " frame_sn", "frame_number", "frame64loss"], "ret": ["gt", "result", "alf", "pret", "ert", "mem", "att", "back", "cont", "mel", "ter", "sys", "buf", "nt", "ext", "cmd", "mt", " Ret", "rets", "len", "val", "tr", "usr", "alt", "t", "err", "value", "after", "ref", "rev", "rem", "out", "try", "rt", "fun", "lt", "reset", "re", "final", "reg", "ern", "resp", "tmp", "print", "RET", "jp", "jump", "tf", "Ret", "nz", "ft", "arg", "net", "ll", "nl", "res", "arr", "j", "deg", "def", "rm", "elt"]}}
{"project": "qemu", "commit_id": "ec05ec26f940564b1e07bf88857035ec27e21dd8", "target": 0, "func": "void *memory_region_get_ram_ptr(MemoryRegion *mr)\n\n{\n\n    if (mr->alias) {\n\n        return memory_region_get_ram_ptr(mr->alias) + mr->alias_offset;\n\n    }\n\n\n\n    assert(mr->terminates);\n\n\n\n    return qemu_get_ram_ptr(mr->ram_addr & TARGET_PAGE_MASK);\n\n}\n", "idx": 4440, "substitutes": {"mr": ["rs", "vr", "mn", "ln", "fm", "gm", "lr", "rpm", "kr", "md", "asm", "br", "wcs", "pc", "nr", "arry", "mk", "rn", "wm", "mt", "ml", "bp", "ms", "ocr", "wr", "usr", "lc", "r", "pm", "irm", "rr", "nm", "lp", "rar", "rl", "m", "shr", "MR", "hm", "drm", "ctr", "adr", "fr", "Mr", "rer", "hr", "rm"]}}
{"project": "FFmpeg", "commit_id": "36583d23bdbe31e8845d3ca9162bce33fef6e48c", "target": 0, "func": "void ff_af_queue_init(AVCodecContext *avctx, AudioFrameQueue *afq)\n\n{\n\n    afq->avctx             = avctx;\n\n    afq->next_pts          = AV_NOPTS_VALUE;\n\n    afq->remaining_delay   = avctx->delay;\n\n    afq->remaining_samples = avctx->delay;\n\n    afq->frame_queue       = NULL;\n\n}\n", "idx": 4479, "substitutes": {"avctx": ["AVctx", "abctx", "avpkg", "AVconn", "afctx", "Avpkg", "avtx", "AVobj", "avetx", "aptx", "avobj", "apkt", "avconn", "abcontext", " avcontext", "apconn", "aftx", "avecontext", "avcontext", "appkg", "afkt", "abtx", "afconn", "Avctx", " avtx", "afobj", " avpkg", "avectx", "wavctl", "wavctx", "Avcontext", " avctl", "wavtx", "wavpkg", "Avtx", "avctl", "apctx", "abpkg", "wavcontext", "avekt", "afcontext", "avkt", "afctl", "apcontext", "apobj", "AVcontext"], "afq": [" afqueue", "affquire", "abquest", "famquire", "iefq", "iefQ", "afquest", " afqs", "ifquit", "faquit", "ajch", "awce", "afck", "affdq", "ifque", "famdq", " afquit", "affqi", "awck", "aimQ", "aphch", "aimque", "aphqueue", "aimquit", "afqi", " afck", "afquit", "awqs", "ajqueue", "afQ", "ifq", "faquest", "affck", "ajq", "afce", "afquire", "afque", "abquit", "famqi", "awq", " afc", " afque", "iefquit", "afch", "abque", "fac", "famq", "ifquest", "faque", "aphc", "affqs", "iefquire", "affce", "iefque", " afce", " afquest", "ajque", " afch", "afdq", "afqueue", "aphque", "affq", "aimq", "abq", "faq", "afc", "aphquest", " afQ", "iefdq", "iefqi", "afqs", "aphq"]}}
{"project": "qemu", "commit_id": "de13d2161473d02ae97ec0f8e4503147554892dd", "target": 0, "func": "void kvm_s390_service_interrupt(S390CPU *cpu, uint32_t parm)\n\n{\n\n    kvm_s390_interrupt_internal(cpu, KVM_S390_INT_SERVICE, parm, 0 , 1);\n\n}\n", "idx": 4488, "substitutes": {"cpu": ["CPU", "pid", "thread", "gc", "node", "mem", "cum", "cp", "gp", "c", "pu", "pc", "met", "phy", " CPU", "clock", "p", "util", "chip", "nc", "hz", "xi", "process", "hw", "phys", "nu", "linux", "proc", "nic", "component", "ork", "processor", "uu", "core", "gnu", "vm", "cu", "gpu"], "parm": [" param", "tpay", "sparm", " pparam", "Pparam", "sparam", "tpdem", " parms", "tparm", "pdem", "Param", "tparp", "pay", "spparam", "pcay", "Parms", "parms", "pparam", "pcarm", "sparms", "parp", "pcarp", "param", "pcdem", "ppdem", "pparp", "ppay", "Parm", "pparm"]}}
{"project": "FFmpeg", "commit_id": "90540c2d5ace46a1e9789c75fde0b1f7dbb12a9b", "target": 1, "func": "static inline void RENAME(rgb24tobgr15)(const uint8_t *src, uint8_t *dst, int src_size)\n\n{\n\n    const uint8_t *s = src;\n\n    const uint8_t *end;\n\n    const uint8_t *mm_end;\n\n    uint16_t *d = (uint16_t *)dst;\n\n    end = s + src_size;\n\n    __asm__ volatile(PREFETCH\"    %0\"::\"m\"(*src):\"memory\");\n\n    __asm__ volatile(\n\n        \"movq          %0, %%mm7    \\n\\t\"\n\n        \"movq          %1, %%mm6    \\n\\t\"\n\n        ::\"m\"(red_15mask),\"m\"(green_15mask));\n\n    mm_end = end - 11;\n\n    while (s < mm_end) {\n\n        __asm__ volatile(\n\n            PREFETCH\"    32%1           \\n\\t\"\n\n            \"movd          %1, %%mm0    \\n\\t\"\n\n            \"movd         3%1, %%mm3    \\n\\t\"\n\n            \"punpckldq    6%1, %%mm0    \\n\\t\"\n\n            \"punpckldq    9%1, %%mm3    \\n\\t\"\n\n            \"movq       %%mm0, %%mm1    \\n\\t\"\n\n            \"movq       %%mm0, %%mm2    \\n\\t\"\n\n            \"movq       %%mm3, %%mm4    \\n\\t\"\n\n            \"movq       %%mm3, %%mm5    \\n\\t\"\n\n            \"psrlq         $3, %%mm0    \\n\\t\"\n\n            \"psrlq         $3, %%mm3    \\n\\t\"\n\n            \"pand          %2, %%mm0    \\n\\t\"\n\n            \"pand          %2, %%mm3    \\n\\t\"\n\n            \"psrlq         $6, %%mm1    \\n\\t\"\n\n            \"psrlq         $6, %%mm4    \\n\\t\"\n\n            \"pand       %%mm6, %%mm1    \\n\\t\"\n\n            \"pand       %%mm6, %%mm4    \\n\\t\"\n\n            \"psrlq         $9, %%mm2    \\n\\t\"\n\n            \"psrlq         $9, %%mm5    \\n\\t\"\n\n            \"pand       %%mm7, %%mm2    \\n\\t\"\n\n            \"pand       %%mm7, %%mm5    \\n\\t\"\n\n            \"por        %%mm1, %%mm0    \\n\\t\"\n\n            \"por        %%mm4, %%mm3    \\n\\t\"\n\n            \"por        %%mm2, %%mm0    \\n\\t\"\n\n            \"por        %%mm5, %%mm3    \\n\\t\"\n\n            \"psllq        $16, %%mm3    \\n\\t\"\n\n            \"por        %%mm3, %%mm0    \\n\\t\"\n\n            MOVNTQ\"     %%mm0, %0       \\n\\t\"\n\n            :\"=m\"(*d):\"m\"(*s),\"m\"(blue_15mask):\"memory\");\n\n        d += 4;\n\n        s += 12;\n\n    }\n\n    __asm__ volatile(SFENCE:::\"memory\");\n\n    __asm__ volatile(EMMS:::\"memory\");\n\n    while (s < end) {\n\n        const int b = *s++;\n\n        const int g = *s++;\n\n        const int r = *s++;\n\n        *d++ = (b>>3) | ((g&0xF8)<<2) | ((r&0xF8)<<7);\n\n    }\n\n}\n", "idx": 4519, "substitutes": {"src": ["iv", "rs", "loc", "b", "sr", "c", "h", "cont", "sc", "inst", "ind", "usr", "data", "input", "sel", "r", "rc", "ins", "sv", "sb", "start", "sh", "sur", "inner", "st", "sub", "ss", "sn", "bs", "cur", "dest", "in", "hl", "x", "source"], "dst": ["wput", "lsts", "wst", "lput", "wdest", "dbr", "ddest", "tdest", "dsts", " dsts", "lst", "tsts", "rbr", "ldest", "rst", " dbr", "dput", "wsts", "tst", " dput", " ddest", "tbr", "rdest", "rsts"], "src_size": [" src_Size", "src_offset", "src_Size", " src_number", " src_offset", "src_number"], "s": ["as", "rs", "sp", "gs", "sw", "b", "ns", "c", "its", "h", "ies", "ats", "i", "qs", "cs", "p", "ps", "ms", "g", "n", "als", "is", "ts", "rows", "ds", "sd", "si", "o", "t", "se", "es", "r", "js", "w", "ins", "sv", "ls", "sb", "v", "ims", "stats", "sl", "m", "st", "hs", "ss", "bs", "south", "ans", "f", "fs", "e", "S", "sts", "j", "x", "a", "l", "ows"], "end": [" End", "all", "gc", "ff", "est", "END", "h", "offset", "set", "nd", "last", "ext", "p", "ent", "mt", "ended", "t", "se", "ut", "stop", "w", "ender", "id", "rest", "ending", "start", "max", "en", "out", "v", "begin", "send", "ad", "m", "st", "close", "f", "dest", "size", "e", "length", "ment", "z", "End"], "mm_end": ["mid_ender", "mmm_start", "mm_e", " mm_start", "mm_ender", "mm_max", "mid_e", "mm_begin", " mm_ends", "mmm_max", "mm_ends", "mmm_begin", "mm_due", "mid_end", "mid_due", "mm_start", "mmm_end"], "d": ["db", "fd", "dc", "b", "dat", "c", "u", "h", "i", "p", "g", "dt", "n", "dict", "bd", "sd", "ds", "o", "data", "t", "r", "D", "w", "dh", "dm", "out", "v", "ad", "dd", "dos", "m", "a", "dn", "st", "y", "f", "dp", "de", "e", "j", "z", "di", "x", "l", "da"]}}
{"project": "qemu", "commit_id": "e61031cdd81826c433a8bbfa3aca2bae4ffaf845", "target": 1, "func": "static gboolean gd_motion_event(GtkWidget *widget, GdkEventMotion *motion,\n\n                                void *opaque)\n\n{\n\n    GtkDisplayState *s = opaque;\n\n    int x, y;\n\n    int mx, my;\n\n    int fbh, fbw;\n\n    int ww, wh;\n\n\n\n    fbw = surface_width(s->ds) * s->scale_x;\n\n    fbh = surface_height(s->ds) * s->scale_y;\n\n\n\n    gdk_drawable_get_size(gtk_widget_get_window(s->drawing_area), &ww, &wh);\n\n\n\n    mx = my = 0;\n\n    if (ww > fbw) {\n\n        mx = (ww - fbw) / 2;\n\n    }\n\n    if (wh > fbh) {\n\n        my = (wh - fbh) / 2;\n\n    }\n\n\n\n    x = (motion->x - mx) / s->scale_x;\n\n    y = (motion->y - my) / s->scale_y;\n\n\n\n    if (x < 0 || y < 0 ||\n\n        x >= surface_width(s->ds) ||\n\n        y >= surface_height(s->ds)) {\n\n        return TRUE;\n\n    }\n\n\n\n    if (qemu_input_is_absolute()) {\n\n        qemu_input_queue_abs(s->dcl.con, INPUT_AXIS_X, x,\n\n                             surface_width(s->ds));\n\n        qemu_input_queue_abs(s->dcl.con, INPUT_AXIS_Y, y,\n\n                             surface_height(s->ds));\n\n        qemu_input_event_sync();\n\n    } else if (s->last_x != -1 && s->last_y != -1 && gd_is_grab_active(s)) {\n\n        qemu_input_queue_rel(s->dcl.con, INPUT_AXIS_X, x - s->last_x);\n\n        qemu_input_queue_rel(s->dcl.con, INPUT_AXIS_Y, y - s->last_y);\n\n        qemu_input_event_sync();\n\n    }\n\n    s->last_x = x;\n\n    s->last_y = y;\n\n\n\n    if (!qemu_input_is_absolute() && gd_is_grab_active(s)) {\n\n        GdkScreen *screen = gtk_widget_get_screen(s->drawing_area);\n\n        int x = (int)motion->x_root;\n\n        int y = (int)motion->y_root;\n\n\n\n        /* In relative mode check to see if client pointer hit\n\n         * one of the screen edges, and if so move it back by\n\n         * 200 pixels. This is important because the pointer\n\n         * in the server doesn't correspond 1-for-1, and so\n\n         * may still be only half way across the screen. Without\n\n         * this warp, the server pointer would thus appear to hit\n\n         * an invisible wall */\n\n        if (x == 0) {\n\n            x += 200;\n\n        }\n\n        if (y == 0) {\n\n            y += 200;\n\n        }\n\n        if (x == (gdk_screen_get_width(screen) - 1)) {\n\n            x -= 200;\n\n        }\n\n        if (y == (gdk_screen_get_height(screen) - 1)) {\n\n            y -= 200;\n\n        }\n\n\n\n        if (x != (int)motion->x_root || y != (int)motion->y_root) {\n\n#if GTK_CHECK_VERSION(3, 0, 0)\n\n            GdkDevice *dev = gdk_event_get_device((GdkEvent *)motion);\n\n            gdk_device_warp(dev, screen, x, y);\n\n#else\n\n            GdkDisplay *display = gtk_widget_get_display(widget);\n\n            gdk_display_warp_pointer(display, screen, x, y);\n\n#endif\n\n            s->last_x = -1;\n\n            s->last_y = -1;\n\n            return FALSE;\n\n        }\n\n    }\n\n    return TRUE;\n\n}\n", "idx": 4521, "substitutes": {"widget": ["draw", "layout", "idget", "window", "wp", "wid", "ctx", "view", "box", "document", "ew", "win", "wt", "wk", "w", "game", "web", "board", "Widget", " widgets", "grid", " w", "gui", " window", "html", " win", "fw"], "motion": ["draw", "event", "spirit", "error", "sense", "mot", "otion", "direction", "move", "up", "phy", "mor", "flow", "Motion", "release", "movie", "upload", "mpeg", " Motion", "position", "params", "distance", "mode", "change", "video", "mass", "feature", "command", "m", "frame", "loss", "gravity", "request", "pose", "response", "version", "mega", "mission", "moving", "message", "activity", "mouse", "tor", "relation", "detail", "mage", "reference", "media", "image", "resolution", "machine"], "opaque": ["OPacity", "opposit", "oplay", "obacity", " opacity", "oposit", "oppaque", "ropent", "oppent", "Opacity", "opacity", "OPaque", "roposit", "Opaque", "Oposit", "oblay", "ropacity", "Opent", " oplay", "ropaque", "OPlay", "opent", "oppacity", "obaque"], "s": ["styles", "sw", "less", "conf", "c", "h", "terms", "d", "ps", "ports", "ts", "settings", "se", "t", "w", "js", "gets", "events", "sb", "ss", "south", "forms", "changes", "series", "params", "as", "rs", "service", "ses", "results", "sam", "sort", "os", "er", "g", "ms", "tests", "es", "plays", "ears", "an", "v", "stats", "bits", "m", "vs", "us", "sis", "aws", "a", "l", "ows", "gs", "ar", "ns", "ats", "ies", "comm", "cs", "uploads", "p", "aunts", "is", "sd", "r", "sv", "sm", "hs", "bs", "sq", "parts", "fs", "S", "b", "app", "its", "i", "sys", "qs", "als", "details", "n", "ds", "ins", "space", "ids", "ls", "ims", "ties", "sl", "views", "status", "spec", "browser", "states", "f", "search", "ex", "sts"], "x": ["xy", "ct", " xx", "xf", "h", "X", "ox", "lat", "i", "fx", "wx", "xt", "rx", "lex", "ux", "at", "xa", "px", "p", "lon", "ml", "xx", "zx", "on", "xi", "height", "xc", "w", "ax", "xxxx", "dx", "xs", "ix", "m", "xml", "tx", "hello", "yx", "xp", "ex", "xe", "time", "one", "z", "xxx", "a", "wd", "l"], "y": ["vy", "ty", "fy", "xy", "b", "cy", "dy", "wy", "h", "ies", "i", "sys", "yi", "Y", "ry", "ky", "gy", "hot", "sy", "ery", "uy", "lon", "icy", "aily", "on", "ay", "ya", "key", "t", "height", "ny", "ly", "py", "hy", "yy", "ye", "yn", "iy", "asy", "m", "ch", "yt", "sky", "ey", "ys", "by", "yo", "ym", "oy", "axy"], "mx": ["xy", "mn", "axy", "wy", "ym", "ox", "ma", "fx", "wx", "rx", "mi", "ux", "mr", "wm", "px", "xa", "ms", "ml", "xx", "zx", "hz", "xi", "mie", "xc", "ax", "dx", "xs", "ix", "mb", "m", "ai", "tx", "mm", "xes", "cox", "yx", "nz", "ey", "xp", "ex", "xe", "mouse", "gray", "obs", "mo", "mp"], "my": ["vy", "ty", "fy", "xy", "mn", "cy", "mem", "ity", "ies", "ox", "ma", "i", "MY", "ry", "mi", "mmm", "mk", "mis", "ky", "gy", "ami", "ms", "ery", "aily", "mic", "ny", "me", "py", "yy", "memory", "sym", "rey", "m", "ody", "My", "mine", "mm", "am", "yx", "sky", "ey", "ys", "by", "mys", "gray", "ni", "ym", "oy", "axy"], "fbh": ["ebhz", "wbw", "FBz", "bfz", "abbw", "ebw", "bmhr", "bmh", "bmx", "bhr", "rbgo", "bh", "facebookgo", "fwgo", "facebookz", "facebookw", "fbhr", "rbw", "fbb", "ebx", "wbz", "bfhz", "fbhz", "ebhr", "fbz", "abbhz", "fww", "fwh", "fwb", "bmw", "bw", "ebz", "wbh", "FBgo", "bfh", "ebh", "abbh", "facebookb", "fbgo", "FBh", "facebookh", "FBw", "abbz", "rbh", "fbx", "rbb", "bfw", "wbgo", "bx"], "fbw": ["bbwd", "fcwr", "wbw", "wbf", "bff", "fcw", "fbwd", "bfwm", "facebookwm", "fbmm", "tfw", "fch", "fbwr", "bfx", "lbmm", "tfW", "facebookw", "fcx", "FBmm", "wbwr", "fbf", "lbh", "facebookx", "facebookW", "bbw", "bfwr", "fbW", "wbh", "fbwm", "bfh", "wbwm", "facebookf", "lbw", "FBh", "facebookh", "bbh", "wbx", "FBw", "facebookmm", "lbW", "bbW", "tfwd", "fbx", "FBwd", "bfw", "FBW", "tfh"], "ww": ["www", " www", "wow", "sw", "lv", "dy", "wp", "wal", "wa", "wy", "ctx", "kk", "wat", "fx", "wx", "rx", "whe", "nn", "ht", "wm", "we", "eg", "wide", "week", "vp", "ew", "wb", "hw", "iw", "rw", "wk", "wn", "lb", "wt", "w", "pg", "kw", "org", "nox", "west", "WW", "wo", "ross", "hl", "wl", "wd", "hop", "work", "nw", "fw"], "wh": ["www", "ph", "cf", "gh", "how", "sw", "wp", "window", "WH", "wa", "wy", "white", "kr", "h", "kh", "wcs", "wx", "whe", "ht", "we", "wind", "zh", "wr", "hz", "tr", "hw", "iw", "rw", "wk", "height", "hi", "w", "tw", "th", "Wh", "kw", "thus", "sh", "ch", "hop", "sch", "hd", "hl", "html", "wd", "work", "haw", "nw", "fw"]}}
{"project": "FFmpeg", "commit_id": "b46a77f19ddc4b2b5fa3187835ceb602a5244e24", "target": 0, "func": "int ff_vdpau_common_init(AVCodecContext *avctx, VdpDecoderProfile profile,\n\n                         int level)\n\n{\n\n    VDPAUHWContext *hwctx = avctx->hwaccel_context;\n\n    VDPAUContext *vdctx = avctx->internal->hwaccel_priv_data;\n\n    VdpVideoSurfaceQueryCapabilities *surface_query_caps;\n\n    VdpDecoderQueryCapabilities *decoder_query_caps;\n\n    VdpDecoderCreate *create;\n\n    void *func;\n\n    VdpStatus status;\n\n    VdpBool supported;\n\n    uint32_t max_level, max_mb, max_width, max_height;\n\n    VdpChromaType type;\n\n    uint32_t width;\n\n    uint32_t height;\n\n\n\n    vdctx->width            = UINT32_MAX;\n\n    vdctx->height           = UINT32_MAX;\n\n\n\n    if (av_vdpau_get_surface_parameters(avctx, &type, &width, &height))\n\n        return AVERROR(ENOSYS);\n\n\n\n    if (hwctx) {\n\n        hwctx->reset            = 0;\n\n\n\n        if (hwctx->context.decoder != VDP_INVALID_HANDLE) {\n\n            vdctx->decoder = hwctx->context.decoder;\n\n            vdctx->render  = hwctx->context.render;\n\n            vdctx->device  = VDP_INVALID_HANDLE;\n\n            return 0; /* Decoder created by user */\n\n        }\n\n\n\n        vdctx->device           = hwctx->device;\n\n        vdctx->get_proc_address = hwctx->get_proc_address;\n\n\n\n        if (hwctx->flags & AV_HWACCEL_FLAG_IGNORE_LEVEL)\n\n            level = 0;\n\n\n\n        if (!(hwctx->flags & AV_HWACCEL_FLAG_ALLOW_HIGH_DEPTH) &&\n\n            type != VDP_CHROMA_TYPE_420)\n\n            return AVERROR(ENOSYS);\n\n    } else {\n\n        AVHWFramesContext *frames_ctx = NULL;\n\n        AVVDPAUDeviceContext *dev_ctx;\n\n\n\n        // We assume the hw_frames_ctx always survives until ff_vdpau_common_uninit\n\n        // is called. This holds true as the user is not allowed to touch\n\n        // hw_device_ctx, or hw_frames_ctx after get_format (and ff_get_format\n\n        // itself also uninits before unreffing hw_frames_ctx).\n\n        if (avctx->hw_frames_ctx) {\n\n            frames_ctx = (AVHWFramesContext*)avctx->hw_frames_ctx->data;\n\n        } else if (avctx->hw_device_ctx) {\n\n            int ret;\n\n\n\n            avctx->hw_frames_ctx = av_hwframe_ctx_alloc(avctx->hw_device_ctx);\n\n            if (!avctx->hw_frames_ctx)\n\n                return AVERROR(ENOMEM);\n\n\n\n            frames_ctx            = (AVHWFramesContext*)avctx->hw_frames_ctx->data;\n\n            frames_ctx->format    = AV_PIX_FMT_VDPAU;\n\n            frames_ctx->sw_format = avctx->sw_pix_fmt;\n\n            frames_ctx->width     = avctx->coded_width;\n\n            frames_ctx->height    = avctx->coded_height;\n\n\n\n            ret = av_hwframe_ctx_init(avctx->hw_frames_ctx);\n\n            if (ret < 0) {\n\n                av_buffer_unref(&avctx->hw_frames_ctx);\n\n                return ret;\n\n            }\n\n        }\n\n\n\n        if (!frames_ctx) {\n\n            av_log(avctx, AV_LOG_ERROR, \"A hardware frames context is \"\n\n                   \"required for VDPAU decoding.\\n\");\n\n            return AVERROR(EINVAL);\n\n        }\n\n\n\n        dev_ctx = frames_ctx->device_ctx->hwctx;\n\n\n\n        vdctx->device           = dev_ctx->device;\n\n        vdctx->get_proc_address = dev_ctx->get_proc_address;\n\n\n\n        if (avctx->hwaccel_flags & AV_HWACCEL_FLAG_IGNORE_LEVEL)\n\n            level = 0;\n\n    }\n\n\n\n    if (level < 0)\n\n        return AVERROR(ENOTSUP);\n\n\n\n    status = vdctx->get_proc_address(vdctx->device,\n\n                                     VDP_FUNC_ID_VIDEO_SURFACE_QUERY_CAPABILITIES,\n\n                                     &func);\n\n    if (status != VDP_STATUS_OK)\n\n        return vdpau_error(status);\n\n    else\n\n        surface_query_caps = func;\n\n\n\n    status = surface_query_caps(vdctx->device, type, &supported,\n\n                                &max_width, &max_height);\n\n    if (status != VDP_STATUS_OK)\n\n        return vdpau_error(status);\n\n    if (supported != VDP_TRUE ||\n\n        max_width < width || max_height < height)\n\n        return AVERROR(ENOTSUP);\n\n\n\n    status = vdctx->get_proc_address(vdctx->device,\n\n                                     VDP_FUNC_ID_DECODER_QUERY_CAPABILITIES,\n\n                                     &func);\n\n    if (status != VDP_STATUS_OK)\n\n        return vdpau_error(status);\n\n    else\n\n        decoder_query_caps = func;\n\n\n\n    status = decoder_query_caps(vdctx->device, profile, &supported, &max_level,\n\n                                &max_mb, &max_width, &max_height);\n\n#ifdef VDP_DECODER_PROFILE_H264_CONSTRAINED_BASELINE\n\n    if ((status != VDP_STATUS_OK || supported != VDP_TRUE) && profile == VDP_DECODER_PROFILE_H264_CONSTRAINED_BASELINE) {\n\n        profile = VDP_DECODER_PROFILE_H264_MAIN;\n\n        status = decoder_query_caps(vdctx->device, profile, &supported,\n\n                                    &max_level, &max_mb,\n\n                                    &max_width, &max_height);\n\n    }\n\n#endif\n\n    if (status != VDP_STATUS_OK)\n\n        return vdpau_error(status);\n\n\n\n    if (supported != VDP_TRUE || max_level < level ||\n\n        max_width < width || max_height < height)\n\n        return AVERROR(ENOTSUP);\n\n\n\n    status = vdctx->get_proc_address(vdctx->device, VDP_FUNC_ID_DECODER_CREATE,\n\n                                     &func);\n\n    if (status != VDP_STATUS_OK)\n\n        return vdpau_error(status);\n\n    else\n\n        create = func;\n\n\n\n    status = vdctx->get_proc_address(vdctx->device, VDP_FUNC_ID_DECODER_RENDER,\n\n                                     &func);\n\n    if (status != VDP_STATUS_OK)\n\n        return vdpau_error(status);\n\n    else\n\n        vdctx->render = func;\n\n\n\n    status = create(vdctx->device, profile, width, height, avctx->refs,\n\n                    &vdctx->decoder);\n\n    if (status == VDP_STATUS_OK) {\n\n        vdctx->width  = avctx->coded_width;\n\n        vdctx->height = avctx->coded_height;\n\n    }\n\n\n\n    return vdpau_error(status);\n\n}\n", "idx": 4524, "substitutes": {"avctx": ["avernp", "ajkl", "AVctx", "avercheck", " avcmp", "awtx", "awctx", "navcb", "amctx", "ajctx", "auxtx", "avetimeout", "auxpkg", "acttx", "avcontext", "avjac", "ajnp", "averctl", "evcontext", "hwcfg", "avcfg", "svcontext", "devtx", "awjac", "awconn", "afjac", "averctx", "avnp", "AVcmp", "auxval", "actctx", "AVcontext", "afctx", "svcmp", "devcontext", "amctl", "evcmp", "avconn", "amconn", "evctx", "navtx", "actval", "navkl", "navctx", "evtx", "afconn", "avectx", "auxctx", "avcheck", "ajcheck", "avertimeout", "avcb", "avctl", "avertx", "averval", "avtimeout", " avconn", "avpkg", "svctx", "avtx", "devcmp", "awcmp", "awcfg", " avkl", " avcontext", "aftx", "avecheck", " avtx", " avpkg", "hwtx", " avcfg", " avjac", "ajtimeout", " avctl", "avval", "auxconn", "ampkg", "svtx", "ajtx", "awcontext", "hwcontext", "auxctl", "AVtx", "avkl", "avenp", "avcmp", "ajcb", "actctl", "devctx", " avcb"], "profile": ["db", "Profile", " database", " descript", " usage", " prog", "prof", " definition", " profiling", " df", " db", " pro", " proto", " performance", " std", " family", " mode", " def", " file", " block", " descriptor", " prof", " Profile", " density", " depth", " dep", " profiles", "def"], "level": ["depth", "error", "scope", "state", "file", "link", "group", "location", "index", "stack", "vel", "scale", "pe", "vl", "limit", "err", "tag", "debug", "role", "style", "layer", "mode", "try", "priority", "levels", "lvl", "version", "local", "Level", "count", "message", "loop", "family", "length", "high", "interface", "l"], "hwctx": ["fwctx", "iwcmp", "hdcp", "hwdl", "httx", "hopctx", "hzcfg", "hawcontext", "htctx", "htcmd", "hdtxt", "himctx", "fwcmp", "iwctx", "hwcfg", "hawcrit", "iwcu", "ethercontext", "htcp", "hwtxt", "ethertx", "hwnp", "hzpkg", "hardtx", "etherctx", "iwdl", "etherdl", "htcontext", "hawcfg", "hzcontext", "hhtx", "hopcu", "htcfg", "iwpkg", "hzcrit", "fwtx", "hwcrit", "fwcontext", "hwcmd", "hhcmp", "hawtx", "hdcontext", "hdnp", "htcrit", "hopcmp", "hawctx", "hwcp", "iwkl", "hdtx", "hardtxt", "iwcontext", "himtx", "hwtx", "htkl", "hztx", "hardctx", "hddl", "htcmp", "hdcmp", "himcp", "hhctx", "hwkl", "iwnp", "hhcu", "hdpkg", "hwpkg", "htnp", "iwtxt", "himcmd", "hardpkg", "hwcontext", "hdcmd", "hwcu", "hoptx", "hawkl", "iwtx", "hwcmp", "hzctx", "hdctx"], "vdctx": ["hdcp", "nvcontext", "vdcu", "ndctx", "svcu", "vrctx", "vccontext", "ndtx", "xdjac", "svjac", "lvtx", "vdcmp", "lvcp", "svpkg", "xdtx", "svcontext", "hdjac", "visioncmp", "lvctx", "ndcrit", "visiontx", "vccu", "vdjac", "ddjac", "vdcp", "ddpkg", "vidcontext", "nvcu", "vidpy", "vidtmp", "vdtmp", "ndcmp", "vttmp", "ndcu", "vidcp", "nvcmp", "xdconn", "vdcontext", "vrcrit", "hdconn", "vtcontext", "vdpkg", "dbtx", "hdcontext", "svctx", "vrtx", "ddctx", "hdtmp", "vttx", "ndcontext", "hdtx", "dbconn", "dbjac", "nvtx", "visionctx", "vidtx", "udcp", "udtx", "vctx", "xdcmp", "lvcu", "vrcmp", "hdcmp", "svtx", "nvcp", "vtctx", "vdconn", "udctx", "visioncontext", "udpy", "hdcu", "vcctx", "xdcp", "xdpkg", "nvctx", "vdcrit", "dbctx", "vidctx", "xdcrit", "vdpy", "ddtx", "xdpy", "xdctx", "vdtx", "hdctx"], "surface_query_caps": ["surface_search_cap", "surface_search_abilities", "surface_query_cap", "surface_query_abilities", "surface_query_params", "surface_search_caps", "surface_search_params"], "decoder_query_caps": ["decoder_search_cap", "decoder_search_abilities", "decoder_query_cap", "decoder_query_abilities", "decoder_search_types", "decoder_search_caps", "decoder_query_types"], "create": ["update", "open", "read", "draw", "destroy", "creat", "setup", "attach", "created", "call", "activate", "save", "execute", "force", "add", "use", "process", "connect", "send", "code", "Create", "load", "clear", "close", "build", "make", "check", "name"], "func": ["cf", "cast", "function", "call", "ctx", "con", "fc", "actor", "util", "cmd", "unc", "cb", "callback", "cc", "rc", "proc", "code", "fac", "fun", "fn", "f", "conv", "family", "imp", "res", "tc", "act"], "status": [" success", "result", " fps", " performed", " progress", " prog", " exists", " stream", " stable", "state", " debug", "valid", "progress", " spec", " stat", " ok", " protocol", " speed", " severity", " performance", "Status", " mode", " description", "stream", " code", " statistic", " flag", "flag"], "supported": ["initialized", " unsupported", "created", "installed", "verified", "disabled", "enabled", "util", "approved", " connected", "loaded", "required", "platform", "lib", "locked", "used", "failed", "available", "support", "allowed", "handled", "mounted", "found", "conv", "connected", "Support", "Supported", "forced"], "max_level": ["max_vel", "ax_level", "max_levels", "ax_levels", "maxdvel", "maxdlevels", "ax_vel", "max_depth", "ax_depth", "maxddepth", "maxdlevel"], "max_mb": ["max_frame", "maxmlevel", "maxmthread", " max_thread", "max_thread", "maxmmb", "maxmframe", " max_frame"], "max_width": ["max_wid", " max_Width", " max_wid", "max_Width"], "max_height": ["max_mount", "max_Height", "max___depth", " max_mount", " max_depth", "max___height", "max___Height", " max_Height", "max___mount", "max_depth"], "type": ["TYPE", "method", "ty", "event", "error", "color", "view", "kind", "state", "file", " TYPE", "template", "what", "prop", "typ", "ype", "var", "index", "key", "t", "types", "pe", "tag", "module", "role", "options", "style", "command", "brand", "spec", "driver", "version", "Type", "message", "test", "family", "time", "size", "info", "length", "interface", "format", "tool", "class", "ver", "tp", "name", "tc"], "height": ["draw", "depth", "ty", "read", "padding", "grow", "power", "Height", "window", "h", "radius", "kind", "bottom", "density", "buffer", "arch", "ht", "rank", "chip", "data", "total", "history", "quality", "input", "scale", "device", "max", "host", "memory", "dim", "hei", "gravity", "command", "ch", "volume", "build", "ptr", "capacity", "address", "shape", "size", "family", "hash", "length", "hang", "resolution"], "frames_ctx": ["frames_tx", "frames___cmp", "faces_cc", "frames___urg", "faces_conn", "frames_cv", " frames_cv", "frames_conn", "frames___cv", "frames_cmp", "faces_ctx", "frames___cc", " frames_tx", "frames___conn", "frames_urg", "frames_cc", "faces_cmp", " frames_urg", "frames___tx", "frames___ctx"], "dev_ctx": ["ev_cmp", "ev_ctx", "dev_tx", "dev2pkg", "dev_pkg", "dev2tx", "ev_tx", "dev2ctx", "dev_cmp", "ev_pkg", "dev2cmp"], "ret": ["put", "result", "error", "deep", "active", "last", "valid", "prop", "val", "alt", " resp", "value", "rem", "layer", "final", "resp", "re", "cond", "RET", "Ret", "VAL", "mediate", "info", "class", "def", "flag"]}}
{"project": "FFmpeg", "commit_id": "f6774f905fb3cfdc319523ac640be30b14c1bc55", "target": 1, "func": "static int estimate_qp(MpegEncContext *s, int dry_run){\n\n    if (s->next_lambda){\n\n        s->current_picture_ptr->f.quality =\n\n        s->current_picture.f.quality = s->next_lambda;\n\n        if(!dry_run) s->next_lambda= 0;\n\n    } else if (!s->fixed_qscale) {\n\n        s->current_picture_ptr->f.quality =\n\n        s->current_picture.f.quality = ff_rate_estimate_qscale(s, dry_run);\n\n        if (s->current_picture.f.quality < 0)\n\n            return -1;\n\n    }\n\n\n\n    if(s->adaptive_quant){\n\n        switch(s->codec_id){\n\n        case AV_CODEC_ID_MPEG4:\n\n            if (CONFIG_MPEG4_ENCODER)\n\n                ff_clean_mpeg4_qscales(s);\n\n            break;\n\n        case AV_CODEC_ID_H263:\n\n        case AV_CODEC_ID_H263P:\n\n        case AV_CODEC_ID_FLV1:\n\n            if (CONFIG_H263_ENCODER)\n\n                ff_clean_h263_qscales(s);\n\n            break;\n\n        default:\n\n            ff_init_qscale_tab(s);\n\n        }\n\n\n\n        s->lambda= s->lambda_table[0];\n\n        //FIXME broken\n\n    }else\n\n        s->lambda = s->current_picture.f.quality;\n\n    update_qscale(s);\n\n    return 0;\n\n}\n", "idx": 4539, "substitutes": {"s": ["sw", "less", "c", "ers", "h", "terms", "ads", "ps", "ports", "ts", "eds", "se", "t", "js", "w", "gets", "events", "services", "xs", "sb", "ss", "south", "changes", "sports", "comments", "as", "bes", "rs", "ses", "os", "g", "ms", "tests", "ains", "sets", "es", "an", "v", "stats", "m", "vs", "aws", "a", "ops", "gs", "times", "ns", "ats", "ies", "ags", "cs", "comm", "p", "aunts", "is", "has", "r", "sv", "sm", "hs", "bs", "parts", "fs", "S", "b", "its", "acs", "sys", "qs", "set", "als", "n", "ds", "ins", "ls", "ess", "ims", "ties", "args", "views", "states", "f", "sts", "z", "mods"], "dry_run": ["dryNetrun", "drylyview", " dry_range", "dryNetmode", " dry_clean", " dry_view", "dryPostmode", " dry_running", "drylyRun", " dry_mode", "dry_range", "dry_Run", "dryoseRun", "dryNetclean", "dryoserange", "dryPostclean", "dry_clean", "dryOverremove", "dryoseview", "dryPostRun", "drylyrange", "dry_remove", " dry_remove", "dry_view", "dryOverRun", " dry_Run", "dryOverrun", "dry_mode", "drylyrun", "dryoserun", "dry_running", "dryNetRun", "dryOverrunning", "dryPostrun"]}}
{"project": "qemu", "commit_id": "bd79255d2571a3c68820117caf94ea9afe1d527e", "target": 0, "func": "static void spr_write_tbu (DisasContext *ctx, int sprn, int gprn)\n\n{\n\n    if (use_icount) {\n\n        gen_io_start();\n\n    }\n\n    gen_helper_store_tbu(cpu_env, cpu_gpr[gprn]);\n\n    if (use_icount) {\n\n        gen_io_end();\n\n        gen_stop_exception(ctx);\n\n    }\n\n}\n", "idx": 4540, "substitutes": {"ctx": ["ck", "cf", "cas", "ct", "cp", "conf", "c", "wcs", "cmp", "bc", "wx", "sys", "ok", " cx", "cm", "cmd", "co", "nc", "context", "cb", "hw", "history", "xc", "cc", "pkg", "kw", "req", "cfg", " context", "tx", "tmp", "ca", "jp", "mc", "obj", "qt", "Context", "cu", "conn", "CT", "tc", "act"], "sprn": [" prn", " prnm", "prN", "prn", "srn", "prnc", " prnc", "srnc", "sprnc", " prN", "prnm", "sprN", "srnm", "srN", "sprnm"], "gprn": ["gcrn", "gcrr", "bgkrn", "bgprn", "bgprr", "gsprnm", "bgkrnt", "gvrnm", "gcrno", "gprno", "gvrnt", "gprnb", "gkrn", "gpolr", "gkrr", "bgprnm", "bgkrnm", "gsprno", "gsprnb", "gprnm", " gcrn", " gcrnb", "gvrr", "gsprn", "gprnt", "gkrnt", "gkrnm", "gsprr", " gcrno", "gcrnb", " gprno", "gpoln", "gprr", "bgkrr", "gsprnt", "gpolnb", "gpolno", " gprr", "bgprnt", " gprnb", " gcrr", "gvrn"]}}
{"project": "qemu", "commit_id": "46746dbaa8c2c421b9bda78193caad57d7fb1136", "target": 0, "func": "static void vfio_intx_enable_kvm(VFIOPCIDevice *vdev)\n\n{\n\n#ifdef CONFIG_KVM\n\n    struct kvm_irqfd irqfd = {\n\n        .fd = event_notifier_get_fd(&vdev->intx.interrupt),\n\n        .gsi = vdev->intx.route.irq,\n\n        .flags = KVM_IRQFD_FLAG_RESAMPLE,\n\n    };\n\n    struct vfio_irq_set *irq_set;\n\n    int ret, argsz;\n\n    int32_t *pfd;\n\n\n\n    if (!VFIO_ALLOW_KVM_INTX || !kvm_irqfds_enabled() ||\n\n        vdev->intx.route.mode != PCI_INTX_ENABLED ||\n\n        !kvm_resamplefds_enabled()) {\n\n        return;\n\n    }\n\n\n\n    /* Get to a known interrupt state */\n\n    qemu_set_fd_handler(irqfd.fd, NULL, NULL, vdev);\n\n    vfio_mask_single_irqindex(&vdev->vbasedev, VFIO_PCI_INTX_IRQ_INDEX);\n\n    vdev->intx.pending = false;\n\n    pci_irq_deassert(&vdev->pdev);\n\n\n\n    /* Get an eventfd for resample/unmask */\n\n    if (event_notifier_init(&vdev->intx.unmask, 0)) {\n\n        error_report(\"vfio: Error: event_notifier_init failed eoi\");\n\n        goto fail;\n\n    }\n\n\n\n    /* KVM triggers it, VFIO listens for it */\n\n    irqfd.resamplefd = event_notifier_get_fd(&vdev->intx.unmask);\n\n\n\n    if (kvm_vm_ioctl(kvm_state, KVM_IRQFD, &irqfd)) {\n\n        error_report(\"vfio: Error: Failed to setup resample irqfd: %m\");\n\n        goto fail_irqfd;\n\n    }\n\n\n\n    argsz = sizeof(*irq_set) + sizeof(*pfd);\n\n\n\n    irq_set = g_malloc0(argsz);\n\n    irq_set->argsz = argsz;\n\n    irq_set->flags = VFIO_IRQ_SET_DATA_EVENTFD | VFIO_IRQ_SET_ACTION_UNMASK;\n\n    irq_set->index = VFIO_PCI_INTX_IRQ_INDEX;\n\n    irq_set->start = 0;\n\n    irq_set->count = 1;\n\n    pfd = (int32_t *)&irq_set->data;\n\n\n\n    *pfd = irqfd.resamplefd;\n\n\n\n    ret = ioctl(vdev->vbasedev.fd, VFIO_DEVICE_SET_IRQS, irq_set);\n\n    g_free(irq_set);\n\n    if (ret) {\n\n        error_report(\"vfio: Error: Failed to setup INTx unmask fd: %m\");\n\n        goto fail_vfio;\n\n    }\n\n\n\n    /* Let'em rip */\n\n    vfio_unmask_single_irqindex(&vdev->vbasedev, VFIO_PCI_INTX_IRQ_INDEX);\n\n\n\n    vdev->intx.kvm_accel = true;\n\n\n\n    trace_vfio_intx_enable_kvm(vdev->vbasedev.name);\n\n\n\n    return;\n\n\n\nfail_vfio:\n\n    irqfd.flags = KVM_IRQFD_FLAG_DEASSIGN;\n\n    kvm_vm_ioctl(kvm_state, KVM_IRQFD, &irqfd);\n\nfail_irqfd:\n\n    event_notifier_cleanup(&vdev->intx.unmask);\n\nfail:\n\n    qemu_set_fd_handler(irqfd.fd, vfio_intx_interrupt, NULL, vdev);\n\n    vfio_unmask_single_irqindex(&vdev->vbasedev, VFIO_PCI_INTX_IRQ_INDEX);\n\n#endif\n\n}\n", "idx": 4551, "substitutes": {"vdev": ["kenv", "kdevice", "vval", " vserial", "vcenv", "vhost", "uvhost", "fdev", "vcdev", " vval", "Vdb", "kval", "vcver", "tDev", "vDev", "versiondev", " vdb", "vclink", "vgo", "kserv", "kserial", " vserv", "fserial", "vcmem", "vcomment", "svdebug", "vconf", "uvenv", "kev", "vDEV", "hev", "vmem", "Vserial", "versiondb", "uvdev", "vserial", "Vconf", "kDEV", "klink", " vcam", "kgo", "vvar", " vgo", "Vdev", "kcam", "fserv", "tev", "vccomment", "hdev", "vdebug", "vev", "cvdev", "venv", "pserv", " vmem", "vcam", "vserv", "kvar", "hdevice", "vchost", "versionconf", " vhost", "Vlink", "vdriver", " vcomment", "pev", " vev", "Vmem", "uvlink", "versiondriver", "vcdebug", "kdev", "wdev", "pdev", " vconf", "Vval", "vlink", "vdevice", "vver", "cvdevice", " venv", " vconn", " vlink", "vcgo", "Vhost", " vver", "cvvar", "svdev", " vdebug", "penv", "tDEV", "kconn", "vcserv", "hDev", "vccam", "svcomment", "wev", "vconn", "Vdriver", "wdevice", "tdevice", "tdev", " vdriver", "fconn", "tvar", "wDev", "cvDEV", "svver", "vdb"], "irq_set": ["irq_source", "irqptSet", "irq_stat", "irQ_stat", "irch_Set", "irq_store", "irQ_SET", "irch_start", "irchptSet", "irq___base", "irqacsource", "irqrestree", "irq__set", "irq_init", "irQ_base", "irq_base", "irchptstart", "irchptSET", "irqresSET", "irch_SET", "irqacreset", "irqueueproinit", "irqresstate", "irqueue_set", "irdq_reset", "irqresst", "irqlogstat", "irqacset", "irq_entry", "irq2Set", "irq2set", "irqptstart", "irqproreset", "irq__mod", "irQ_entry", "irq8set", "irq_Set", "irquresmod", "irq8state", "irq__st", "irqlogentry", "irq_st", "irqresSet", "irq8SET", "irq___Set", "irq_mod", "irq___set", "irqlogset", "irquresset", "irQ_set", "irQ_state", "irqueueproreset", "irQ_Set", "irqueueproset", "irdq_source", "irqproinit", "irq__tree", "irQ_store", "irqptSET", "irdqacsource", "irq_SET", "irquresst", "irqu_tree", "irqu_st", "irq_reset", "irq_tree", "irqueue_init", "irch_set", "irdqacset", "irqresset", "irqproset", "irdq_set", "irq_start", "irqptset", "irqlogstore", "irq_state", "irqueue_reset", "irchptset", "irq2base", "irqu_set", "irqu_mod", "irqresmod", "irq8Set", "irdqacreset", "irqurestree"], "ret": ["success", " res", "call", "mem", "Val", " mem", "ry", "prop", "cmd", "val", "vals", " resp", "err", "rc", "ref", "sec", "final", "resp", "status", "lit", "RET", "Ret", " val", "class", "def", "flag"], "argsz": ["Argsze", "ArgsZ", "argszh", "agszi", "Argszi", "paramszek", "msiz", " argszi", "insz", " argsZ", "argszi", "idszi", " argsce", "agszo", "idsz", "argszo", "idszh", "argscz", "argsZ", "inszh", "msze", " argsiz", "argsce", "arszo", "idscz", "agsce", "agscz", "framesZ", " argsze", "arscz", "framesz", "arsz", "paramsiz", "agszh", "agsz", "insce", "frameszi", " argszo", "argsze", "arszi", "mszek", "inszi", " argszh", "argszek", "arszh", "framesze", "msz", "paramsz", "Argsz", " argszek", "argsiz", "paramsze"], "pfd": ["wFD", "pbfd", "pfx", " pdd", "Pdd", "pFD", "pbfp", "pdd", "PFD", "wdd", "Pfd", "wfx", "pbdata", "pdata", " pfx", " pfp", " pdata", "Pdata", " pFD", "pfp", "Pfx", "wfd", "Pfp", "pbFD"]}}
{"project": "qemu", "commit_id": "27a69bb088bee6d4efea254659422fb9c751b3c7", "target": 0, "func": "static inline void gen_evfsnabs(DisasContext *ctx)\n\n{\n\n    if (unlikely(!ctx->spe_enabled)) {\n\n        gen_exception(ctx, POWERPC_EXCP_APU);\n\n        return;\n\n    }\n\n#if defined(TARGET_PPC64)\n\n    tcg_gen_ori_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)], 0x8000000080000000LL);\n\n#else\n\n    tcg_gen_ori_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)], 0x80000000);\n\n    tcg_gen_ori_tl(cpu_gprh[rD(ctx->opcode)], cpu_gprh[rA(ctx->opcode)], 0x80000000);\n\n#endif\n\n}\n", "idx": 4555, "substitutes": {"ctx": ["ck", "cf", "loc", "ct", "ctl", "prefix", "gp", "cp", "c", "wcs", "kt", "cmp", "bc", "anc", "cl", "wx", "sc", "nt", "ann", "mk", "cmd", "co", "inst", "tm", "unc", "nc", "etc", "urg", "typ", "context", "cb", "std", "lc", "hw", "kl", "ind", "history", "aux", "xc", "cc", "crit", "pkg", "xs", "kw", "that", "txt", "req", "cfg", "jac", "resp", "alloc", "vc", "config", "tx", "tmp", "kg", "iat", "cv", "desc", "jp", "np", "pause", "cur", "obj", "xp", "qt", "kb", "ctr", "work", "conn", "today", "abc", "tc", "act"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint64_t imx_timerg_read(void *opaque, target_phys_addr_t offset,\n\n                                unsigned size)\n\n{\n\n    IMXTimerGState *s = (IMXTimerGState *)opaque;\n\n\n\n    DPRINTF(\"g-read(offset=%x)\", offset >> 2);\n\n    switch (offset >> 2) {\n\n    case 0: /* Control Register */\n\n        DPRINTF(\" cr = %x\\n\", s->cr);\n\n        return s->cr;\n\n\n\n    case 1: /* prescaler */\n\n        DPRINTF(\" pr = %x\\n\", s->pr);\n\n        return s->pr;\n\n\n\n    case 2: /* Status Register */\n\n        DPRINTF(\" sr = %x\\n\", s->sr);\n\n        return s->sr;\n\n\n\n    case 3: /* Interrupt Register */\n\n        DPRINTF(\" ir = %x\\n\", s->ir);\n\n        return s->ir;\n\n\n\n    case 4: /* Output Compare Register 1 */\n\n        DPRINTF(\" ocr1 = %x\\n\", s->ocr1);\n\n        return s->ocr1;\n\n\n\n\n\n    case 9: /* cnt */\n\n        imx_timerg_update_counts(s);\n\n        DPRINTF(\" cnt = %x\\n\", s->cnt);\n\n        return s->cnt;\n\n    }\n\n\n\n    IPRINTF(\"imx_timerg_read: Bad offset %x\\n\",\n\n            (int)offset >> 2);\n\n    return 0;\n\n}\n", "idx": 4556, "substitutes": {"opaque": ["paque", "boient", "oplque", " opade", "boque", "oppade", "OPface", "opque", "opface", "opaques", "oppaque", "pface", "pque", "paques", "boade", "opade", "OPaque", "OPaques", "opient", " opque", "oppient", "boaque", "oplface", "OPque", "oplaque", " opient", "oplaques", "oppque"], "offset": ["output", "sp", "error", "padding", "SIZE", "window", "end", "type", "kh", "operation", "shift", "pad", "set", "buffer", "amount", "base", "addr", "location", "len", "seek", "seed", "no", "row", "pointer", "index", "data", "bound", "o", "key", "from", "position", "slice", "ref", "pos", "attribute", "unk", "align", "start", "timeout", "usage", "slot", "oid", "reset", "scroll", "block", "alloc", "off", " offsets", "frequency", "area", "alias", "address", "count", "point", "Offset", "length", "origin"], "size": ["sp", "SIZE", "mem", "type", "h", "shift", "Size", "set", "amount", "body", "n", "len", "number", "IZE", "align", "start", "num", "command", "count", "address", "message", "ize", "e", "length", "z", "name"], "s": ["des", "ists", "sol", "ches", "ries", "h", "ps", "ports", "ts", "bugs", "settings", "ind", " slots", "eds", "ials", "js", "ands", "sb", "grades", "ss", "iffs", "ves", "j", "params", "alls", "as", "rs", "ses", " jumps", "ants", "sam", "os", "g", "ms", "ains", "Js", "vals", "es", "plays", "itions", "stats", "bits", "sis", "aws", "ops", "gs", "bis", "ssl", "olds", "ns", " values", "ies", "comm", "p", "is", "has", "izes", "sv", "sm", "hs", "bs", "y", "sq", "reports", "parts", "fs", "S", "rates", "sp", "b", "its", "sys", "qs", "aps", "als", "erences", "ds", "tains", "ins", "ls", "ess", "ims", "iss", "outs", "sl", "new", "spec", "ords", "sts", "ments", "ions"]}}
{"project": "qemu", "commit_id": "430b26a82da61876c4eaf559ae02332582968043", "target": 0, "func": "static int blkdebug_open(BlockDriverState *bs, QDict *options, int flags,\n\n                         Error **errp)\n\n{\n\n    BDRVBlkdebugState *s = bs->opaque;\n\n    QemuOpts *opts;\n\n    Error *local_err = NULL;\n\n    int ret;\n\n\n\n    opts = qemu_opts_create(&runtime_opts, NULL, 0, &error_abort);\n\n    qemu_opts_absorb_qdict(opts, options, &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        ret = -EINVAL;\n\n        goto out;\n\n    }\n\n\n\n    /* Read rules from config file or command line options */\n\n    s->config_file = g_strdup(qemu_opt_get(opts, \"config\"));\n\n    ret = read_config(s, s->config_file, options, errp);\n\n    if (ret) {\n\n        goto out;\n\n    }\n\n\n\n    /* Set initial state */\n\n    s->state = 1;\n\n\n\n    /* Open the image file */\n\n    bs->file = bdrv_open_child(qemu_opt_get(opts, \"x-image\"), options, \"image\",\n\n                               bs, &child_file, false, &local_err);\n\n    if (local_err) {\n\n        ret = -EINVAL;\n\n        error_propagate(errp, local_err);\n\n        goto out;\n\n    }\n\n\n\n    bs->supported_write_flags = BDRV_REQ_FUA &\n\n        bs->file->bs->supported_write_flags;\n\n    bs->supported_zero_flags = (BDRV_REQ_FUA | BDRV_REQ_MAY_UNMAP) &\n\n        bs->file->bs->supported_zero_flags;\n\n    ret = -EINVAL;\n\n\n\n    /* Set request alignment */\n\n    s->align = qemu_opt_get_size(opts, \"align\", 0);\n\n    if (s->align && (s->align >= INT_MAX || !is_power_of_2(s->align))) {\n\n        error_setg(errp, \"Cannot meet constraints with align %\" PRIu64,\n\n                   s->align);\n\n        goto out;\n\n    }\n\n\n\n    ret = 0;\n\nout:\n\n    if (ret < 0) {\n\n        g_free(s->config_file);\n\n    }\n\n    qemu_opts_del(opts);\n\n    return ret;\n\n}\n", "idx": 4563, "substitutes": {"bs": ["boxes", "bes", "rs", "bytes", "gs", "bis", "aks", "b", "bec", "ns", "ubs", "blog", "pb", "bos", "its", "ats", "acs", "ib", "bc", "cks", "locks", "qs", "aws", "abilities", "cs", "os", "bh", "bed", "ps", "als", "bp", "uts", "ports", "ts", "bles", "ds", "BS", "cb", "lets", "hz", "tops", "vals", "bu", "bi", "aus", "js", "ls", "sb", "bps", "ubis", "outs", "stats", "bits", "las", "vs", "hs", "aos", "ss", "bl", "fs", "obj", "ks", "bm", "obs", "res", "bas", "ops", "lbs"], "options": ["styles", "results", "weights", "times", "ption", "eps", "wcs", "comes", "its", "values", "objects", "terms", "os", "actions", "caps", "als", "ps", "p", "ms", "details", "ts", "settings", "uts", "option", "closure", "Options", "ptions", "vals", "errors", "es", "tops", "aches", "opt", "properties", "stats", "checks", "args", " Options", "IONS", "bits", "keys", "config", "ims", "parts", "fs", "currency", "some", "ex", "obj", "ices", "json", "params", "ops"], "flags": ["fields", "ns", "weight", "fee", " Flags", " fmt", "ags", "files", "cmd", "ts", "vals", " af", " fs", "Flag", "ents", "args", "bits", "FLAG", "Flags", "mask", "count", "fs", "res", "features", " flag", "flag"], "errp": ["ererpre", " errP", "iterper", " errps", "iterpa", "arrp", " errpre", "errpp", "iterpre", "orderp", "strpb", "errorpb", "errorv", "aerp", " errv", "iterP", "errps", " errpp", "aerv", "ererp", " errsp", " errpkg", "errpre", "errpy", "ererpa", "ererps", "errv", "errpa", "errpb", "orderpp", "errorP", "ererpp", "arrps", "orderps", "errorp", "rerper", "errper", "rerpa", "arrpa", "arrper", "errsp", "rerps", "ererP", "strp", "ordersp", "errorpy", "rerp", "errpkg", "erersp", "iterps", "errorpkg", "strP", "errP", "strpy", "iterp", "aerP", "aerpkg", " errpb", " errpa", " errpy"], "s": ["sw", "less", "c", "h", "self", "ps", "ts", "settings", "t", "utils", "js", "w", "gets", "sb", "services", "ss", "changes", "j", "sports", "params", "as", "rs", "so", "ses", "ubs", "sam", "https", "os", "g", "ms", "ains", "es", "v", "stats", "bits", "sa", "vs", "aws", "gs", "bis", "ssl", "ns", "ats", "ies", "cs", "comm", "p", "is", "has", "sv", "hs", "y", "sq", "fs", "S", "b", "its", "i", "set", "sys", "qs", "als", "details", "ds", "ins", "ls", "ims", "sl", "sn", "sts"], "opts": ["ioppt", "precs", "opTS", " opters", "poptes", "optts", "imts", "iopt", "opert", "opopt", "preters", "opensions", "optr", " opals", "optps", "oppts", "alensions", "operpt", "pregs", "alts", " copters", "copals", "iopts", "popts", "opth", "alters", "alcs", "oppTS", " copts", "copps", "ioprs", "poptx", " oppt", " oprs", "optx", "roptes", "opps", "roppt", "imters", "altr", "optters", "iopcs", "opcs", "copts", "roptx", "imth", "oppcs", "prets", " opps", "oprs", "optes", " copensions", "opgs", "oppt", "iopgs", "opals", "opters", "alrs", " optes", "ropters", "copopt", "optals", "impt", "iopters", "ropts", "opttr", " coptr", "prers", " opt", "opt", " opopt", "popters", "oppgs", "optensions", "optpt", "preTS", "optopt", "optth", "operrs", "iopTS", " optx", "ropth", "operts"], "local_err": ["error_priv", "locallycb", "local___bug", "local_eas", "localingattr", "locallyexp", "locallyerror", "internal_er", "localityeas", "totalityattr", "internal_error", "localityattr", "local_req", "localfulkr", "locjnorm", "loc_req", "total_init", "local_cb", "loc_out", "local_priv", "total_err", "local_arr", "loc_arr", "local_kr", "loc_eas", "locallypriv", "locfulerr", "local___norm", "totalityerr", "localityerr", "localityinit", "localjnorm", "error_err", "locfulkr", "loc_norm", "local_out", "local_state", "local_bug", "locfulbug", "localpystate", "local_attr", "total_attr", "localingexp", "locjerr", "local2req", "locjeas", "localingerr", "localpyerr", "localfulerr", "local_error", "local_exp", "error_error", "local_er", "local2err", " local_buf", "locjbug", "total_exp", "loc_err", "localpyerror", "localitynorm", "locallyattr", "localjerr", "localpyer", "locallyinit", "localinginit", "local_init", "localjbug", "local_norm", "local2out", "loc_bug", " local_er", "internal_err", "local___err", "loc_kr", "local2arr", "local_buf", "error_cb", "localityexp", "totalityexp", "localjeas", "localfulbug", "local___eas", "totalityinit", "internal_state", "locallyerr", "localitybug"], "ret": ["gc", "att", "Return", "det", "__", "url", "alt", "t", "iter", "reset", "pas", "jp", "j", "elt", "flag", "gt", "success", "ber", "ter", "nt", "dt", "g", " Ret", " alt", "over", "inter", "expr", "out", "lit", "cert", "it", "back", "ry", "at", "backed", "mt", "len", "val", "tr", "usr", "rev", "rem", "try", "rt", "re", "al", "ft", "sat", "net", "ll", "res", " RET", "deg", "result", "get", "cont", "rets", "failed", "ref", "bool", "opt", "fun", "status", "resp", "off", "print", "RET", "Ret", "nz", "arg", "got", "def"]}}
{"project": "qemu", "commit_id": "bc7c08a2c375acb7ae4d433054415588b176d34c", "target": 0, "func": "static void test_qemu_strtoull_full_negative(void)\n\n{\n\n    const char *str = \" \\t -321\";\n\n    uint64_t res = 999;\n\n    int err;\n\n\n\n    err = qemu_strtoull(str, NULL, 0, &res);\n\n\n\n    g_assert_cmpint(err, ==, 0);\n\n    g_assert_cmpint(res, ==, 18446744073709551295LLU);\n\n}\n", "idx": 4569, "substitutes": {"str": ["rs", "Str", "service", "sp", "b", "c", "gr", "br", "i", "buf", "cs", "sc", "buffer", "msg", "seq", "g", "n", "ocr", "tr", "t", "r", "list", "pr", "s", "out", "txt", "st", "obj", "fr", "ctr", "enc", "res", "text", "arr", "STR"], "err": [" terr", "ev", "rs", " gr", "error", " res", " ptr", "result", "Er", "lr", "fee", "kr", "gr", "br", "ox", "nr", "i", "sys", "elt", "exc", "er", "rn", "msg", "cmd", "urg", " error", "tr", " er", "usr", "errors", "r", "dr", "rc", "rr", "attr", "pr", " fr", "iter", "cr", "req", "resp", "ch", "der", " r", "cer", "diff", " rc", "obj", "oe", "ctr", "res", "Error", "arr", " dr", " cr"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static uint64_t exynos4210_fimd_read(void *opaque, target_phys_addr_t offset,\n\n                                  unsigned size)\n\n{\n\n    Exynos4210fimdState *s = (Exynos4210fimdState *)opaque;\n\n    int w, i;\n\n    uint32_t ret = 0;\n\n\n\n    DPRINT_L2(\"read offset 0x%08x\\n\", offset);\n\n\n\n    switch (offset) {\n\n    case FIMD_VIDCON0 ... FIMD_VIDCON3:\n\n        return s->vidcon[(offset - FIMD_VIDCON0) >> 2];\n\n    case FIMD_VIDTCON_START ... FIMD_VIDTCON_END:\n\n        return s->vidtcon[(offset - FIMD_VIDTCON_START) >> 2];\n\n    case FIMD_WINCON_START ... FIMD_WINCON_END:\n\n        return s->window[(offset - FIMD_WINCON_START) >> 2].wincon;\n\n    case FIMD_SHADOWCON:\n\n        return s->shadowcon;\n\n    case FIMD_WINCHMAP:\n\n        return s->winchmap;\n\n    case FIMD_VIDOSD_START ... FIMD_VIDOSD_END:\n\n        w = (offset - FIMD_VIDOSD_START) >> 4;\n\n        i = ((offset - FIMD_VIDOSD_START) & 0xF) >> 2;\n\n        switch (i) {\n\n        case 0:\n\n            ret = ((s->window[w].lefttop_x & FIMD_VIDOSD_COORD_MASK) <<\n\n            FIMD_VIDOSD_HOR_SHIFT) |\n\n            (s->window[w].lefttop_y & FIMD_VIDOSD_COORD_MASK);\n\n            break;\n\n        case 1:\n\n            ret = ((s->window[w].rightbot_x & FIMD_VIDOSD_COORD_MASK) <<\n\n                FIMD_VIDOSD_HOR_SHIFT) |\n\n                (s->window[w].rightbot_y & FIMD_VIDOSD_COORD_MASK);\n\n            break;\n\n        case 2:\n\n            if (w == 0) {\n\n                ret = s->window[w].osdsize;\n\n            } else {\n\n                ret = (pack_upper_4(s->window[w].alpha_val[0]) <<\n\n                    FIMD_VIDOSD_AEN0_SHIFT) |\n\n                    pack_upper_4(s->window[w].alpha_val[1]);\n\n            }\n\n            break;\n\n        case 3:\n\n            if (w != 1 && w != 2) {\n\n                DPRINT_ERROR(\"bad read offset 0x%08x\\n\", offset);\n\n                return 0xBAADBAAD;\n\n            }\n\n            ret = s->window[w].osdsize;\n\n            break;\n\n        }\n\n        return ret;\n\n    case FIMD_VIDWADD0_START ... FIMD_VIDWADD0_END:\n\n        w = (offset - FIMD_VIDWADD0_START) >> 3;\n\n        i = ((offset - FIMD_VIDWADD0_START) >> 2) & 1;\n\n        return s->window[w].buf_start[i];\n\n    case FIMD_VIDWADD1_START ... FIMD_VIDWADD1_END:\n\n        w = (offset - FIMD_VIDWADD1_START) >> 3;\n\n        i = ((offset - FIMD_VIDWADD1_START) >> 2) & 1;\n\n        return s->window[w].buf_end[i];\n\n    case FIMD_VIDWADD2_START ... FIMD_VIDWADD2_END:\n\n        w = (offset - FIMD_VIDWADD2_START) >> 2;\n\n        return s->window[w].virtpage_width | (s->window[w].virtpage_offsize <<\n\n            FIMD_VIDWADD2_OFFSIZE_SHIFT);\n\n    case FIMD_VIDINTCON0 ... FIMD_VIDINTCON1:\n\n        return s->vidintcon[(offset - FIMD_VIDINTCON0) >> 2];\n\n    case FIMD_WKEYCON_START ... FIMD_WKEYCON_END:\n\n        w = ((offset - FIMD_WKEYCON_START) >> 3) + 1;\n\n        i = ((offset - FIMD_WKEYCON_START) >> 2) & 1;\n\n        return s->window[w].keycon[i];\n\n    case FIMD_WKEYALPHA_START ... FIMD_WKEYALPHA_END:\n\n        w = ((offset - FIMD_WKEYALPHA_START) >> 2) + 1;\n\n        return s->window[w].keyalpha;\n\n    case FIMD_DITHMODE:\n\n        return s->dithmode;\n\n    case FIMD_WINMAP_START ... FIMD_WINMAP_END:\n\n        return s->window[(offset - FIMD_WINMAP_START) >> 2].winmap;\n\n    case FIMD_WPALCON_HIGH ... FIMD_WPALCON_LOW:\n\n        return s->wpalcon[(offset - FIMD_WPALCON_HIGH) >> 2];\n\n    case FIMD_TRIGCON:\n\n        return s->trigcon;\n\n    case FIMD_I80IFCON_START ... FIMD_I80IFCON_END:\n\n        return s->i80ifcon[(offset - FIMD_I80IFCON_START) >> 2];\n\n    case FIMD_COLORGAINCON:\n\n        return s->colorgaincon;\n\n    case FIMD_LDI_CMDCON0 ... FIMD_LDI_CMDCON1:\n\n        return s->ldi_cmdcon[(offset - FIMD_LDI_CMDCON0) >> 2];\n\n    case FIMD_SIFCCON0 ... FIMD_SIFCCON2:\n\n        i = (offset - FIMD_SIFCCON0) >> 2;\n\n        return s->sifccon[i];\n\n    case FIMD_HUECOEFCR_START ... FIMD_HUECOEFCR_END:\n\n        i = (offset - FIMD_HUECOEFCR_START) >> 2;\n\n        return s->huecoef_cr[i];\n\n    case FIMD_HUECOEFCB_START ... FIMD_HUECOEFCB_END:\n\n        i = (offset - FIMD_HUECOEFCB_START) >> 2;\n\n        return s->huecoef_cb[i];\n\n    case FIMD_HUEOFFSET:\n\n        return s->hueoffset;\n\n    case FIMD_VIDWALPHA_START ... FIMD_VIDWALPHA_END:\n\n        w = ((offset - FIMD_VIDWALPHA_START) >> 3);\n\n        i = ((offset - FIMD_VIDWALPHA_START) >> 2) & 1;\n\n        return s->window[w].alpha_val[i] &\n\n                (w == 0 ? 0xFFFFFF : FIMD_VIDALPHA_ALPHA_LOWER);\n\n    case FIMD_BLENDEQ_START ... FIMD_BLENDEQ_END:\n\n        return s->window[(offset - FIMD_BLENDEQ_START) >> 2].blendeq;\n\n    case FIMD_BLENDCON:\n\n        return s->blendcon;\n\n    case FIMD_WRTQOSCON_START ... FIMD_WRTQOSCON_END:\n\n        return s->window[(offset - FIMD_WRTQOSCON_START) >> 2].rtqoscon;\n\n    case FIMD_I80IFCMD_START ... FIMD_I80IFCMD_END:\n\n        return s->i80ifcmd[(offset - FIMD_I80IFCMD_START) >> 2];\n\n    case FIMD_VIDW0ADD0_B2 ... FIMD_VIDW4ADD0_B2:\n\n        if (offset & 0x0004) {\n\n            break;\n\n        }\n\n        return s->window[(offset - FIMD_VIDW0ADD0_B2) >> 3].buf_start[2];\n\n    case FIMD_SHD_ADD0_START ... FIMD_SHD_ADD0_END:\n\n        if (offset & 0x0004) {\n\n            break;\n\n        }\n\n        return s->window[(offset - FIMD_SHD_ADD0_START) >> 3].shadow_buf_start;\n\n    case FIMD_SHD_ADD1_START ... FIMD_SHD_ADD1_END:\n\n        if (offset & 0x0004) {\n\n            break;\n\n        }\n\n        return s->window[(offset - FIMD_SHD_ADD1_START) >> 3].shadow_buf_end;\n\n    case FIMD_SHD_ADD2_START ... FIMD_SHD_ADD2_END:\n\n        return s->window[(offset - FIMD_SHD_ADD2_START) >> 2].shadow_buf_size;\n\n    case FIMD_PAL_MEM_START ... FIMD_PAL_MEM_END:\n\n        w = (offset - FIMD_PAL_MEM_START) >> 10;\n\n        i = ((offset - FIMD_PAL_MEM_START) >> 2) & 0xFF;\n\n        return s->window[w].palette[i];\n\n    case FIMD_PALMEM_AL_START ... FIMD_PALMEM_AL_END:\n\n        /* Palette aliases for win 0,1 */\n\n        w = (offset - FIMD_PALMEM_AL_START) >> 10;\n\n        i = ((offset - FIMD_PALMEM_AL_START) >> 2) & 0xFF;\n\n        return s->window[w].palette[i];\n\n    }\n\n\n\n    DPRINT_ERROR(\"bad read offset 0x%08x\\n\", offset);\n\n    return 0xBAADBAAD;\n\n}\n", "idx": 4570, "substitutes": {"opaque": ["opos", "paque", " opca", "OPca", "oppca", "oplay", "oppaques", "opque", "play", "opaques", "oppaque", " opos", "OPatile", "opca", "pque", " opatile", "pos", "oppatile", "OPaque", "OPaques", " opaques", "OPos", " opque", "opatile", " oplay", "OPque", "OPlay"], "offset": ["layout", "empty", "operation", "addr", "pointer", "key", "trace", "pos", "attribute", "reset", "frequency", "message", "inet", "flag", "output", "encrypted", "kh", "pad", "adjusted", "os", "OFF", "zero", "index", "bound", "bit", "position", "inter", "start", "timeout", "command", "address", "into", "Offset", "length", "delay", "header", "error", "et", "kernel", "type", "shift", "mt", "line", "o", "style", "oid", "scroll", "alloc", "oint", "response", "object", "sp", "padding", "window", "set", "buffer", "amount", "location", "seek", "row", "data", "range", "from", "ref", "id", "slot", "now", "off", "area", "alias", "count", "point", "z", "onto", "offer"], "size": ["sp", "SIZE", "mem", "weight", "type", "h", "shift", "Size", "set", "n", "len", "seek", "name", "IZE", "style", "align", "start", "args", "count", "address", "message", "ize", "e", "length", "z", "l"], "s": ["ions", "ists", "less", "conf", "c", "ches", "ries", "ers", "ps", "ports", "ts", "eds", "t", "js", "ands", "ests", "gets", "events", "sb", "ss", "aces", "changes", "alls", "comments", "as", "bes", "rs", "ings", " jumps", "ses", "ants", "os", "g", "ms", "ains", "Js", "es", "itions", "v", "bits", "m", "vs", "uns", " ads", "sis", "aws", "ops", "gs", "bis", "ssl", "ns", "orders", "ats", "ies", "comm", "cs", "p", "is", "ed", "izes", "o", "ations", "sv", "hs", "bs", "y", "sq", "parts", "fs", "S", "rates", "its", "sys", "qs", "resses", "acts", "als", "erences", "n", "ds", "tains", "ins", "ls", "ents", "outs", "sl", "browser", "sts", "ing", "ments", " parts"], "w": ["widget", "all", "q", "sw", "b", "window", "wp", "end", "wid", "wa", "c", "h", "wx", "pt", "self", "ht", "raw", "d", "p", "g", "W", "n", "rew", "ew", "name", "xi", "row", "index", "wb", "hw", "iw", "wt", "wk", "t", "r", "rw", "o", "temp", "word", "tw", "k", "kw", "wall", "ow", "v", "start", "m", "win", "wi", "y", "f", "wh", "ex", "z", "x", "a", "l", "nw", "fw"], "i": ["ic", "ini", "ij", "ci", "b", "it", "u", "ib", "h", "mi", "ip", "li", "p", "si", "d", "n", "xi", "ind", "index", "o", "hi", "bi", "pi", "ui", "id", "phi", "ir", "ti", "v", "ix", "m", "I", "iat", "y", "f", "ia", "iu", "in", "e", "j", "di", "x", "ii", "l"]}}
{"project": "qemu", "commit_id": "e8ede0a8bb5298a6979bcf7ed84ef64a64a4e3fe", "target": 0, "func": "float64 HELPER(ucf64_absd)(float64 a)\n\n{\n\n    return float64_abs(a);\n\n}\n", "idx": 4571, "substitutes": {"a": ["as", "apa", "b", "oa", "c", "u", "ma", "i", "alpha", "aaa", "ta", "aa", "d", "A", "p", "g", "n", "ana", "ata", "ae", "na", "data", "o", "t", "r", "va", "w", "an", "s", "au", "acc", "v", "ea", "m", "sa", "ac", "la", "ca", "area", "ia", "z", "sta", "l", "da", "ba"]}}
{"project": "qemu", "commit_id": "32bafa8fdd098d52fbf1102d5a5e48d29398c0aa", "target": 0, "func": "static CharDriverState *qemu_chr_open_null(const char *id,\n\n                                           ChardevBackend *backend,\n\n                                           ChardevReturn *ret,\n\n                                           Error **errp)\n\n{\n\n    CharDriverState *chr;\n\n    ChardevCommon *common = backend->u.null;\n\n\n\n    chr = qemu_chr_alloc(common, errp);\n\n    if (!chr) {\n\n        return NULL;\n\n    }\n\n    chr->chr_write = null_chr_write;\n\n    chr->explicit_be_open = true;\n\n    return chr;\n\n}\n", "idx": 4607, "substitutes": {"id": ["init", "pid", "uri", "end", "wid", " rid", "kid", "mid", "ip", "base", "name", "aid", "uid", "key", "tag", "ref", "ids", "bid", "ad", "ID", "sid", "oid", "rid", "head", "ident", "bad", "Id", "fd"], "backend": ["stender", "backind", "Backengine", "Backnd", " backends", " backnd", "Backind", " backender", "stengine", " backind", "backnd", "Backends", "Backend", "stends", "Backender", "backengine", "backends", "backender", "stind", "stnd", " backengine", "stend"], "ret": ["et", "repl", "uf", "mem", "met", "det", "nt", "mt", "etc", "val", "aux", "std", "pet", "ref", "rev", "rem", "rest", "rt", "resp", "re", "reg", "lit", "RET", "Ret", "res", "rm", "unt"], "errp": [" errP", "errorpa", " errps", "Erpa", "erp", "errps", "ererp", " errm", "ErP", "erpo", "errr", "ererps", "ererpo", "errpa", "ererr", "errorP", "errorm", "erps", "err", "errorp", "Erp", "errP", " errr", "errpo", "Erm", "errm", " errpa", " errpo"], "chr": [" chrc", "chrator", "chnadr", "Chr", "schbr", " chrb", " chtr", "chrar", "clr", "Chdr", "chsr", "CHsr", "chrc", " chrat", "chnrat", "cherrc", "CHr", "Chbr", "cherar", "echr", "chadr", "chnrc", "chrat", " chdr", "Char", "chnrb", " chrator", "chnrator", "clrt", "cherrar", "chrt", "clrc", "chebr", "chert", "schr", " chbr", "Chrc", "chndr", "chnar", "chtr", " chrt", "chersr", "cherr", "Chrat", "cherdr", "chertr", "clbr", "chnr", "cherc", "CHtr", "schar", "echrator", "cheradr", "cher", "chdr", "schrc", "chbr", "CHdr", "chnrar", "cheadr", "echrb", " chsr", "chrb", "echar"], "common": ["specific", "low", "pro", "comm", "client", "primary", "recent", "custom", "util", " Common", "uch", "unique", "un", "general", "full", "san", "normal", "shared", "Common", "m", "generic", "basic", "current", "standard", "central", "known", "qualified", "public", "seen", "high", "global", "com", "non", "other", "onet"]}}
{"project": "qemu", "commit_id": "8ec14402029d783720f4312ed8a925548e1dad61", "target": 0, "func": "static int packet_enqueue(CompareState *s, int mode)\n\n{\n\n    ConnectionKey key;\n\n    Packet *pkt = NULL;\n\n    Connection *conn;\n\n\n\n    if (mode == PRIMARY_IN) {\n\n        pkt = packet_new(s->pri_rs.buf,\n\n                         s->pri_rs.packet_len,\n\n                         s->pri_rs.vnet_hdr_len);\n\n    } else {\n\n        pkt = packet_new(s->sec_rs.buf,\n\n                         s->sec_rs.packet_len,\n\n                         s->sec_rs.vnet_hdr_len);\n\n    }\n\n\n\n    if (parse_packet_early(pkt)) {\n\n        packet_destroy(pkt, NULL);\n\n        pkt = NULL;\n\n        return -1;\n\n    }\n\n    fill_connection_key(pkt, &key);\n\n\n\n    conn = connection_get(s->connection_track_table,\n\n                          &key,\n\n                          &s->conn_list);\n\n\n\n    if (!conn->processing) {\n\n        g_queue_push_tail(&s->conn_list, conn);\n\n        conn->processing = true;\n\n    }\n\n\n\n    if (mode == PRIMARY_IN) {\n\n        if (!colo_insert_packet(&conn->primary_list, pkt)) {\n\n            error_report(\"colo compare primary queue size too big,\"\n\n                         \"drop packet\");\n\n        }\n\n    } else {\n\n        if (!colo_insert_packet(&conn->secondary_list, pkt)) {\n\n            error_report(\"colo compare secondary queue size too big,\"\n\n                         \"drop packet\");\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 4609, "substitutes": {"s": ["as", "rs", "gs", "bis", "ses", "b", "less", "ns", "c", "its", "orders", "ats", "ies", "ags", "h", "qs", "sys", "set", "comm", "cs", "state", "os", "ps", "als", "aunts", "details", "p", "is", "ts", "ds", "r", "js", "ins", "sv", "ls", "events", "sb", "comments", "services", "v", "ties", "ims", "stats", "args", "m", "hs", "a", "vs", "ss", "bs", "south", "states", "serv", "parts", "fs", "ares", "S", "sts", "changes", "j", "sis", "sports", "aws", "mods", "ops"], "mode": ["mate", "method", "step", "type", "md", "direction", "pro", "dem", "Mode", "state", "tower", "stay", "my", "te", "mid", "med", "cmd", "mt", "ie", "tm", "settings", "position", "me", "module", "role", "dm", "style", "raid", "dim", "due", "command", "status", "m", " Mode", "mit", "MODE", "ance", "omp", "ze", "mm", "phrase", "area", "mod", "de", "nom", "format", "ase", "ace", "params", "def", "ode"], "key": ["Key", "node", "cp", "conf", "fee", " KEY", "ctx", "kt", "kk", "KEY", "kid", "set", "leader", "ek", "client", "msg", "mk", "ip", "pri", "link", "ke", "val", "context", "row", "pair", "wk", "temp", "col", "id", "tag", "pkg", "mac", "k", "kw", "code", "out", "token", "host", "sk", "keys", "ack", "tmp", "cond", "ca", "sum", "net", "by", "hash", "tk", "res", "name", "cert"], "pkt": [" pkg", "pkl", "perkt", "tpct", "packkt", "payett", "packct", "pingacket", "pet", "pingkg", "pingkt", "packgt", "pct", "pakt", " pmsg", "ppct", "paymsg", " pett", "ipet", "ppkg", "paykl", "ppacket", "phpacket", "ipnt", " pkl", "pqt", "payet", "ppnt", "ipkt", "paett", " pct", "wpkt", "paykg", "pernt", "pcmd", "phpqt", "paykt", "phpgt", "paacket", "Packet", "wpmsg", "pacmd", "paynt", "packacket", "pakg", "ppkt", "pkg", "phpkt", " pnt", "wpkl", "pett", "packqt", "tpet", "pmsg", "tpacket", "ppet", "ipacket", "ipct", "Pet", "pnt", "Pmsg", "tpkt", "pingcmd", "ipmsg", " pcmd", "wpacket", "paet", "packet", " pqt", "perkg", "ipkg", "payacket", "pgt", "peracket", " pgt", " pet", " packet", "Pkt"], "conn": ["att", "conf", "buf", "ann", "nn", "addr", "cb", "win", "t", "lang", "connect", "pg", "num", "ait", "txt", "ch", "pas", "jp", "pub", "cur", "connected", "j", "enc", "ne", "gt", " con", "mem", " mc", "nt", "rn", "g", "canon", "good", "ach", " ssh", "exec", "np", "conv", "ctr", "cert", "oss", "db", "ct", "ssl", "ns", "ctx", "comm", "p", "connection", "nc", "Conn", "pkg", "org", "rt", "cfg", "cell", "reg", "net", "auth", " win", "cp", "sys", "con", "client", "cmd", "n", "sync", "proc", "gate", " cc", "resp", "adj", "obj", "gen", "nw"]}}
{"project": "FFmpeg", "commit_id": "6c77805fc84a63b74e5025b4d7eeea24c8138cf3", "target": 0, "func": "enum CodecID av_codec_get_id(const AVCodecTag *tags[4], unsigned int tag)\n\n{\n\n    int i;\n\n    for(i=0; i<4 && tags[i]; i++){\n\n        enum CodecID id= codec_get_id(tags[i], tag);\n\n        if(id!=CODEC_ID_NONE) return id;\n\n    }\n\n    return CODEC_ID_NONE;\n\n}\n", "idx": 4610, "substitutes": {"tags": ["styles", "fields", "pieces", "weights", "relations", "times", "nets", "orders", "strings", "amps", "ats", "ags", "values", "Tags", "maps", "cats", "terms", "guards", "pins", "ps", "tests", "pages", "bugs", "products", "words", "ts", "workers", "sets", "uts", "cards", "lights", "atts", "tracks", "blocks", "phones", "ims", "images", "keys", "stats", "waves", "vs", "reports", "flags", "ugs", "links", "marks", "aws", "finals", "lists"], "tag": ["TAG", "event", "match", "feat", "node", "type", "category", "pack", "tar", "state", "at", "map", "var", "row", "pair", "key", "t", "bit", "byte", "id", "word", "unit", "ref", "attribute", "Tag", "out", "big", "ad", "oid", "block", "comment", "tmp", "version", "cat", "bug", "count", "ag", "sum", "format", "name", "image", "flag"], "i": ["init", "ic", "ini", "chain", " bi", " multi", "ci", "q", " ii", "uri", "it", " m", "im", "cli", "h", " ni", " v", "gi", "mi", "qi", "ip", "li", "g", "si", "zi", " init", "is", "xi", "ind", "index", " ti", "t", " err", "pi", "multi", "go", "bi", "hi", "id", "ui", "ki", "ji", "span", " I", "phi", "ti", " pi", "v", "ims", "ix", " it", " j", "ai", "m", " mi", "I", "y", "print", "\u0438", "f", "fi", "sim", "gu", "iu", "e", "in", "ex", "io", "j", "point", "z", "x", "di", "ii"]}}
{"project": "qemu", "commit_id": "27e0c9a1bbd166a67c16291016fba298a8e47140", "target": 0, "func": "static void ide_atapi_identify(IDEState *s)\n\n{\n\n    uint16_t *p;\n\n\n\n    if (s->identify_set) {\n\n\tmemcpy(s->io_buffer, s->identify_data, sizeof(s->identify_data));\n\n\treturn;\n\n    }\n\n\n\n    memset(s->io_buffer, 0, 512);\n\n    p = (uint16_t *)s->io_buffer;\n\n    /* Removable CDROM, 50us response, 12 byte packets */\n\n    put_le16(p + 0, (2 << 14) | (5 << 8) | (1 << 7) | (2 << 5) | (0 << 0));\n\n    padstr((char *)(p + 10), s->drive_serial_str, 20); /* serial number */\n\n    put_le16(p + 20, 3); /* buffer type */\n\n    put_le16(p + 21, 512); /* cache size in sectors */\n\n    put_le16(p + 22, 4); /* ecc bytes */\n\n    padstr((char *)(p + 23), s->version, 8); /* firmware version */\n\n    padstr((char *)(p + 27), \"QEMU DVD-ROM\", 40); /* model */\n\n    put_le16(p + 48, 1); /* dword I/O (XXX: should not be set on CDROM) */\n\n#ifdef USE_DMA_CDROM\n\n    put_le16(p + 49, 1 << 9 | 1 << 8); /* DMA and LBA supported */\n\n    put_le16(p + 53, 7); /* words 64-70, 54-58, 88 valid */\n\n    put_le16(p + 62, 7);  /* single word dma0-2 supported */\n\n    put_le16(p + 63, 7);  /* mdma0-2 supported */\n\n#else\n\n    put_le16(p + 49, 1 << 9); /* LBA supported, no DMA */\n\n    put_le16(p + 53, 3); /* words 64-70, 54-58 valid */\n\n    put_le16(p + 63, 0x103); /* DMA modes XXX: may be incorrect */\n\n#endif\n\n    put_le16(p + 64, 3); /* pio3-4 supported */\n\n    put_le16(p + 65, 0xb4); /* minimum DMA multiword tx cycle time */\n\n    put_le16(p + 66, 0xb4); /* recommended DMA multiword tx cycle time */\n\n    put_le16(p + 67, 0x12c); /* minimum PIO cycle time without flow control */\n\n    put_le16(p + 68, 0xb4); /* minimum PIO cycle time with IORDY flow control */\n\n\n\n    put_le16(p + 71, 30); /* in ns */\n\n    put_le16(p + 72, 30); /* in ns */\n\n\n\n    if (s->ncq_queues) {\n\n        put_le16(p + 75, s->ncq_queues - 1);\n\n        /* NCQ supported */\n\n        put_le16(p + 76, (1 << 8));\n\n    }\n\n\n\n    put_le16(p + 80, 0x1e); /* support up to ATA/ATAPI-4 */\n\n#ifdef USE_DMA_CDROM\n\n    put_le16(p + 88, 0x3f | (1 << 13)); /* udma5 set and supported */\n\n#endif\n\n    memcpy(s->identify_data, p, sizeof(s->identify_data));\n\n    s->identify_set = 1;\n\n}\n", "idx": 4611, "substitutes": {"s": ["rates", "as", "rs", "gs", "bis", "ses", "sw", "g", "less", "ns", "c", "its", "h", "ats", "ies", "i", "qs", "set", "sys", "cs", "comm", "os", "d", "ps", "details", "n", "ms", "is", "ts", "als", "ds", "settings", "t", "se", "es", "r", "js", "ins", "an", "sv", "ls", "sb", "ims", "stats", "sl", "spec", "hs", "vs", "ss", "bs", "south", "y", "sq", "parts", "fs", "ex", "S", "sts", "changes", "sports", "aws", "source"], "p": ["post", "pid", "peer", "result", "q", "sp", "b", "power", "ar", "wp", "cp", "ping", "pb", "c", "pc", "h", "br", "up", "i", "pro", "self", "at", "ip", "er", "ps", "pa", "g", "bp", "vp", "php", "op", "perm", "fp", "t", "pers", "pi", "pe", "err", "pm", "after", "pre", "pkg", "proc", "pg", "ap", "pr", "lp", "v", "port", "m", "new", "per", "local", "jp", "np", "f", "dp", "cache", "xp", "pp", "P", "point", "j", "x", "tp", "mp"]}}
{"project": "qemu", "commit_id": "b9bec74bcb16519a876ec21cd5277c526a9b512d", "target": 0, "func": "static int kvm_put_xsave(CPUState *env)\n\n{\n\n#ifdef KVM_CAP_XSAVE\n\n    int i, r;\n\n    struct kvm_xsave* xsave;\n\n    uint16_t cwd, swd, twd, fop;\n\n\n\n    if (!kvm_has_xsave())\n\n        return kvm_put_fpu(env);\n\n\n\n    xsave = qemu_memalign(4096, sizeof(struct kvm_xsave));\n\n    memset(xsave, 0, sizeof(struct kvm_xsave));\n\n    cwd = swd = twd = fop = 0;\n\n    swd = env->fpus & ~(7 << 11);\n\n    swd |= (env->fpstt & 7) << 11;\n\n    cwd = env->fpuc;\n\n    for (i = 0; i < 8; ++i)\n\n        twd |= (!env->fptags[i]) << i;\n\n    xsave->region[0] = (uint32_t)(swd << 16) + cwd;\n\n    xsave->region[1] = (uint32_t)(fop << 16) + twd;\n\n    memcpy(&xsave->region[XSAVE_ST_SPACE], env->fpregs,\n\n            sizeof env->fpregs);\n\n    memcpy(&xsave->region[XSAVE_XMM_SPACE], env->xmm_regs,\n\n            sizeof env->xmm_regs);\n\n    xsave->region[XSAVE_MXCSR] = env->mxcsr;\n\n    *(uint64_t *)&xsave->region[XSAVE_XSTATE_BV] = env->xstate_bv;\n\n    memcpy(&xsave->region[XSAVE_YMMH_SPACE], env->ymmh_regs,\n\n            sizeof env->ymmh_regs);\n\n    r = kvm_vcpu_ioctl(env, KVM_SET_XSAVE, xsave);\n\n    qemu_free(xsave);\n\n    return r;\n\n#else\n\n    return kvm_put_fpu(env);\n\n#endif\n\n}\n", "idx": 4615, "substitutes": {"env": ["draw", "them", "uv", "event", "esc", "conf", "h", "buf", "self", "addr", "vert", "ec", "enter", "dev", "cb", "environment", "gear", "query", "pg", "sb", "en", "ah", "req", "worker", "entry", "cur", "enc", "esm", "forge", "ve", "er", "context", "server", "va", "esp", "code", "v", "config", "vs", "desc", "info", "shell", "db", "ev", "export", "et", "end", "ctx", "assets", "era", "exc", "extra", "ent", "var", "viron", "hw", "org", "nv", "cv", "disk", "vm", "net", "rod", "window", "ov", "pb", "here", "eas", "erd", "te", "ext", "cmd", "inv", "vp", "ew", "eng", "proc", "gate", "ef", "her", "ptr", "doc", "ee", "manager", "vt", "obj", "qt", "e", "conn"], "i": ["ic", "ini", "q", "ei", "chain", "ci", "b", "it", "c", "u", "h", "gi", "mi", "qi", "ip", "li", "g", "si", "p", "ami", "zi", "ie", "n", "d", "ind", "xi", "o", "t", "ri", "pi", "multi", "bi", "w", "me", "id", "ui", "k", "phi", "ti", "s", "v", "ix", "port", "m", "ai", "I", "y", "\u0438", "mc", "f", "sim", "size", "info", "in", "iu", "e", "j", "di", "x", "ii", "l"], "r": ["rs", "result", "q", "b", "ar", "it", "sr", "c", "u", "h", "br", "ry", "mr", "rn", "er", "p", "g", "d", "n", "t", "w", "dr", "rc", "rr", "rf", "pr", "k", "rb", "ir", "cr", "v", "rar", "s", "rt", "m", "re", "R", "rg", "y", "f", "rd", "e", "res", "x", "l"], "xsave": ["xsav", "oxsav", "xxsend", "Xset", "xmldelete", "axclose", "ixexport", "lexnew", "lexdestroy", "xpsave", "rxsav", "xxsav", "ixave", "txsave", "oxsave", "ixnew", "axsave", "ixclose", "lexgoal", "rxuse", "txset", "xpave", "xgoal", "axgoal", "mximport", "exnew", "xpsubmit", "plexsave", "uxsee", "xxave", "dxsav", "ixsubmit", " xset", " xscale", "exexport", "Xsav", "rxdestroy", "ixscale", "xnew", "wxsave", "xpgoal", " xsav", "xpsend", "xstore", "txave", "txstore", "oxuse", "iximport", "xmlgoal", "ixsee", "dxclose", "xclose", "xmlgo", "mxsave", "xpsav", "xuse", "oxgo", "wxsav", "oxave", "oxdestroy", "lexsave", "axave", "axdelete", "plexsav", "Xnew", "xpnew", "wxstore", "plexdestroy", "xsubmit", "uxdestroy", "exscale", "oxstore", "exsave", "aximport", "xscale", "uxsubmit", " xsubmit", " xclose", "uxsav", "exclose", " xnew", "Xsave", "xexport", "ximport", "uxsave", "txsav", "exsav", "xmlexport", "lexsubmit", "xmlsave", "uxgoal", "oxgoal", "lexsav", "lexsee", "xsend", "xdelete", "rxsave", "mxave", "ixsave", "xxsave", "xsee", "dxsubmit", "plexuse", "xmlclose", "xmlnew", "mxclose", "ixsav", "xdestroy", "xave", "txnew", "xgo", " xsend", " xave", "ixdestroy", "wxave", "xset", "oxdelete", "axgo", "dxsave"], "cwd": ["cld", "fud", " cds", "cachewid", "cwa", " cov", "cachewd", "fld", "ccdir", "cdir", "ncad", "ncw", "tcwid", "tcwd", "cwid", "rcwd", " cud", "dcad", "dcwd", "cov", "fwd", " cwid", "dcds", "cad", "cud", " cw", "fdir", "cwl", "rcw", "ccwd", " cwa", "dcwa", "ncdir", "ncov", "ccld", "ncwa", "ncwd", "cw", "cachewl", " cdir", " cwl", "cachew", "cds", "tcw", " cad", "ncds", " cld", "ccud", "rcdir", "rcov", "tcwl"], "swd": ["swdl", "twm", "twfd", "awwd", "swt", "awp", "awl", "swm", "awD", "twdl", "swfd", "smwd", "smp", " swD", "swwd", "awdl", "wnd", "swp", "wnl", "awd", "awds", "ewds", " swds", "smd", "wnds", "awt", "wnfd", "swl", "swD", "awm", "twp", " swl", "smfd", "ewt", "swds", "twD", "wndl", "wnm", " swt", "ewD", "twds", "twl", "twwd", " swfd", "awfd", "ewd"], "twd": ["sdd", "twm", "tfd", "tfp", "twad", "whds", "sdds", "trp", "tfl", "swm", "tfds", " twad", "swp", "whd", " twl", "trds", "whw", "swad", "swl", "tww", "twp", "whl", "sww", " twds", "sdw", "sdl", "swds", " twm", "tfad", "trm", "trd", "twds", "twl", " twp"], "fop": [" fopl", "dhop", "wip", " fops", "flip", "dopp", "bfops", "fip", "wrop", "vhop", "fOP", "vOP", "vop", "vopl", " fopt", "flhop", "vopp", "fhop", "vip", "flop", "dopl", "bfhop", "flOP", "bfop", " fopp", "wOP", "vrop", "fops", "flopt", "frop", "wop", "fopp", "flrop", "fopt", "flops", "fopl", "bfopt", " fhop", "dop"]}}
{"project": "FFmpeg", "commit_id": "57d04d3f11290d1848efa3b47031762f936d4cb3", "target": 1, "func": "static inline void blockCopy(uint8_t dst[], int dstStride, uint8_t src[], int srcStride,\n\n\tint numLines, int levelFix)\n\n{\n\n\tint i;\n\n\tif(levelFix)\n\n\t{\n\n#ifdef HAVE_MMX\n\n\t\t\t\t\tasm volatile(\n\n\t\t\t\t\t\t\"movl %4, %%eax \\n\\t\"\n\n\t\t\t\t\t\t\"movl %%eax, temp0\\n\\t\"\n\n\t\t\t\t\t\t\"pushl %0 \\n\\t\"\n\n\t\t\t\t\t\t\"pushl %1 \\n\\t\"\n\n\t\t\t\t\t\t\"leal (%2,%2), %%eax\t\\n\\t\"\n\n\t\t\t\t\t\t\"leal (%3,%3), %%ebx\t\\n\\t\"\n\n\t\t\t\t\t\t\"movq packedYOffset, %%mm2\t\\n\\t\"\n\n\t\t\t\t\t\t\"movq packedYScale, %%mm3\t\\n\\t\"\n\n\t\t\t\t\t\t\"pxor %%mm4, %%mm4\t\\n\\t\"\n\n\n\n#define SCALED_CPY\t\t\t\t\t\\\n\n\t\t\t\t\t\t\"movq (%0), %%mm0\t\\n\\t\"\\\n\n\t\t\t\t\t\t\"movq (%0,%2), %%mm1\t\\n\\t\"\\\n\n\t\t\t\t\t\t\"psubusb %%mm2, %%mm0\t\\n\\t\"\\\n\n\t\t\t\t\t\t\"psubusb %%mm2, %%mm1\t\\n\\t\"\\\n\n\t\t\t\t\t\t\"movq %%mm0, %%mm5\t\\n\\t\"\\\n\n\t\t\t\t\t\t\"punpcklbw %%mm4, %%mm0 \\n\\t\"\\\n\n\t\t\t\t\t\t\"punpckhbw %%mm4, %%mm5 \\n\\t\"\\\n\n\t\t\t\t\t\t\"psllw $7, %%mm0\t\\n\\t\"\\\n\n\t\t\t\t\t\t\"psllw $7, %%mm5\t\\n\\t\"\\\n\n\t\t\t\t\t\t\"pmulhw %%mm3, %%mm0\t\\n\\t\"\\\n\n\t\t\t\t\t\t\"pmulhw %%mm3, %%mm5\t\\n\\t\"\\\n\n\t\t\t\t\t\t\"packuswb %%mm5, %%mm0\t\\n\\t\"\\\n\n\t\t\t\t\t\t\"movq %%mm0, (%1)\t\\n\\t\"\\\n\n\t\t\t\t\t\t\"movq %%mm1, %%mm5\t\\n\\t\"\\\n\n\t\t\t\t\t\t\"punpcklbw %%mm4, %%mm1 \\n\\t\"\\\n\n\t\t\t\t\t\t\"punpckhbw %%mm4, %%mm5 \\n\\t\"\\\n\n\t\t\t\t\t\t\"psllw $7, %%mm1\t\\n\\t\"\\\n\n\t\t\t\t\t\t\"psllw $7, %%mm5\t\\n\\t\"\\\n\n\t\t\t\t\t\t\"pmulhw %%mm3, %%mm1\t\\n\\t\"\\\n\n\t\t\t\t\t\t\"pmulhw %%mm3, %%mm5\t\\n\\t\"\\\n\n\t\t\t\t\t\t\"packuswb %%mm5, %%mm1\t\\n\\t\"\\\n\n\t\t\t\t\t\t\"movq %%mm1, (%1, %3)\t\\n\\t\"\\\n\n\n\n\t\t\t\t\t\t\"1:\t\t\t\\n\\t\"\n\nSCALED_CPY\n\n\t\t\t\t\t\t\"addl %%eax, %0\t\t\\n\\t\"\n\n\t\t\t\t\t\t\"addl %%ebx, %1\t\t\\n\\t\"\n\nSCALED_CPY\n\n\t\t\t\t\t\t\"addl %%eax, %0\t\t\\n\\t\"\n\n\t\t\t\t\t\t\"addl %%ebx, %1\t\t\\n\\t\"\n\n\t\t\t\t\t\t\"decl temp0\t\t\\n\\t\"\n\n\t\t\t\t\t\t\"jnz 1b\t\t\t\\n\\t\"\n\n\n\n\t\t\t\t\t\t\"popl %1 \\n\\t\"\n\n\t\t\t\t\t\t\"popl %0 \\n\\t\"\n\n\t\t\t\t\t\t: : \"r\" (src),\n\n\t\t\t\t\t\t\"r\" (dst),\n\n\t\t\t\t\t\t\"r\" (srcStride),\n\n\t\t\t\t\t\t\"r\" (dstStride),\n\n\t\t\t\t\t\t\"m\" (numLines>>2)\n\n\t\t\t\t\t\t: \"%eax\", \"%ebx\"\n\n\t\t\t\t\t);\n\n#else\n\n\t\t\t\tfor(i=0; i<numLines; i++)\n\n\t\t\t\t\tmemcpy(\t&(dst[dstStride*i]),\n\n\t\t\t\t\t\t&(src[srcStride*i]), BLOCK_SIZE);\n\n#endif\n\n\t}\n\n\telse\n\n\t{\n\n#ifdef HAVE_MMX\n\n\t\t\t\t\tasm volatile(\n\n\t\t\t\t\t\t\"movl %4, %%eax \\n\\t\"\n\n\t\t\t\t\t\t\"movl %%eax, temp0\\n\\t\"\n\n\t\t\t\t\t\t\"pushl %0 \\n\\t\"\n\n\t\t\t\t\t\t\"pushl %1 \\n\\t\"\n\n\t\t\t\t\t\t\"leal (%2,%2), %%eax\t\\n\\t\"\n\n\t\t\t\t\t\t\"leal (%3,%3), %%ebx\t\\n\\t\"\n\n\t\t\t\t\t\t\"movq packedYOffset, %%mm2\t\\n\\t\"\n\n\t\t\t\t\t\t\"movq packedYScale, %%mm3\t\\n\\t\"\n\n\n\n#define SIMPLE_CPY\t\t\t\t\t\\\n\n\t\t\t\t\t\t\"movq (%0), %%mm0\t\\n\\t\"\\\n\n\t\t\t\t\t\t\"movq (%0,%2), %%mm1\t\\n\\t\"\\\n\n\t\t\t\t\t\t\"movq %%mm0, (%1)\t\\n\\t\"\\\n\n\t\t\t\t\t\t\"movq %%mm1, (%1, %3)\t\\n\\t\"\\\n\n\n\n\t\t\t\t\t\t\"1:\t\t\t\\n\\t\"\n\nSIMPLE_CPY\n\n\t\t\t\t\t\t\"addl %%eax, %0\t\t\\n\\t\"\n\n\t\t\t\t\t\t\"addl %%ebx, %1\t\t\\n\\t\"\n\nSIMPLE_CPY\n\n\t\t\t\t\t\t\"addl %%eax, %0\t\t\\n\\t\"\n\n\t\t\t\t\t\t\"addl %%ebx, %1\t\t\\n\\t\"\n\n\t\t\t\t\t\t\"decl temp0\t\t\\n\\t\"\n\n\t\t\t\t\t\t\"jnz 1b\t\t\t\\n\\t\"\n\n\n\n\t\t\t\t\t\t\"popl %1 \\n\\t\"\n\n\t\t\t\t\t\t\"popl %0 \\n\\t\"\n\n\t\t\t\t\t\t: : \"r\" (src),\n\n\t\t\t\t\t\t\"r\" (dst),\n\n\t\t\t\t\t\t\"r\" (srcStride),\n\n\t\t\t\t\t\t\"r\" (dstStride),\n\n\t\t\t\t\t\t\"m\" (numLines>>2)\n\n\t\t\t\t\t\t: \"%eax\", \"%ebx\"\n\n\t\t\t\t\t);\n\n#else\n\n\t\t\t\tfor(i=0; i<numLines; i++)\n\n\t\t\t\t\tmemcpy(\t&(dst[dstStride*i]),\n\n\t\t\t\t\t\t&(src[srcStride*i]), BLOCK_SIZE);\n\n#endif\n\n\t}\n\n}\n", "idx": 4639, "substitutes": {"dst": ["Dsts", "dct", "Dct", "dest", "Dest", "dsts", "dsst", "dssts", " dest", "Dst", "dsct", " dct", "dsest", " dsts"], "dstStride": ["destRestride", "dstStrap", "destStr", "dstStrrap", "dstStrride", "dstRestride", "destRestr", "dstStr", "dstSlide", "destRestrap", "dstSlride", "destStride", "destStrap", "destStide", "dstStide", "dstRestrap", "dstRestr", "dstSlrap", "dstStrr", "destRestide", "dstRestide", "dstSlr"], "src": ["rs", "loc", "ser", "sr", "pack", "rel", "sys", "sc", "seq", "usr", "input", "str", "rc", "ins", "proc", "sb", "out", "sec", "stream", "sub", "st", "serv", "ources", "cur", "dest", "news", "mods", "source"], "srcStride": ["srcRestride", " srcRestridden", "srcSr", "srcSride", "srcRestridden", "srcStridden", "srcSridden", "srcRestr", " srcRestr", "srcDescide", " srcStide", "srcSide", " srcRestride", "srcStide", " srcRestide", " srcStridden", "srcStr", "srcDescride", "srcRestide", "srcDescridden", "srcDescr", " srcStr"], "numLines": ["numColines", "numLlines", "numLes", "numSine", " numLine", "numRines", "numSlines", "numCollines", " numLlines", " numRes", "numSines", "numColine", " numRine", " numRlines", "numSes", "numRlines", "numRine", "numColes", "numLine", " numRines", "numRes", " numLes"], "levelFix": ["LevelFix", "levelCheck", "levelsPos", "levelsFix", "levelsfix", "levelPos", " levelPos", "scaleChange", " levelfix", "LevelPos", " levelCheck", "levelChange", "levelfix", "LevelChange", "lvlChange", "LevelCheck", "Levelfix", "scaleFix", "levelsCheck", "lvlFix"], "i": [" bi", " li", " ii", " m", " v", "li", "p", "si", " si", "n", " ti", "pi", " e", " I", " pi", " j", "m", " mi", "I", " index", " k", " p", "e", "j", "di", "ii", "l", " l"]}}
{"project": "qemu", "commit_id": "ff5ce21e1b959206f257967d6de2efa6f4e3d188", "target": 1, "func": "build_tpm2(GArray *table_data, BIOSLinker *linker)\n\n{\n\n    Acpi20TPM2 *tpm2_ptr;\n\n\n\n    tpm2_ptr = acpi_data_push(table_data, sizeof *tpm2_ptr);\n\n\n\n    tpm2_ptr->platform_class = cpu_to_le16(TPM2_ACPI_CLASS_CLIENT);\n\n    tpm2_ptr->control_area_address = cpu_to_le64(0);\n\n    tpm2_ptr->start_method = cpu_to_le32(TPM2_START_METHOD_MMIO);\n\n\n\n    build_header(linker, table_data,\n\n                 (void *)tpm2_ptr, \"TPM2\", sizeof(*tpm2_ptr), 4, NULL, NULL);\n\n}\n", "idx": 4645, "substitutes": {"tpm2_ptr": ["tpm2_addr", "tpm3_Ptr", "tpm1_ptr", "tpm2_pointers", "tpm2___Ptr", "tpm12_ptr", "tpmto___Ptr", "tpm12_obj", "tpm2__ptr", "tpm02_obj", "tpm1_addr", "tpm2ptenv", "tpm2_req", "tpmto_ptr", "tpm2_th", "tpm1_obj", "tpm1_pointers", "tpm02_pointer", "tpm02_p", "tpm2__p", "tpm12_tch", "tpm2ptpointers", "tpm2___ptr", "tpmto_obj", "tpm2_obj", "tpm2_Ptr", "tpmto___obj", "tpm3_obj", "tpm2_pointer", "tpm2__req", "tpmto___ptr", "tpmto_Ptr", "tpm2__pointer", "tpm02_ptr", "tpm2___obj", "tpm2_ctr", "tpm3_ptr", "tpm2_tr", "tpm1_env", "tpm2_tch", "tpm2__obj", "tpm3_pointer", "tpm3_tr", "tpm1_req", "tpm12_req", "tpmto___ctr", "tpmto_ctr", "tpm2_p", "tpm2ptptr", "tpm2__tr", "tpm2_env", "tpm1_tr", "tpm2ptaddr", "tpm2___ctr"]}}
{"project": "FFmpeg", "commit_id": "ae93965359e71c1f88ba170f8efd6a198344c235", "target": 1, "func": "int ff_hevc_output_frame(HEVCContext *s, AVFrame *out, int flush)\n\n{\n\n    do {\n\n        int nb_output = 0;\n\n        int min_poc   = INT_MAX;\n\n        int i, min_idx, ret;\n\n\n\n        if (s->sh.no_output_of_prior_pics_flag == 1) {\n\n            for (i = 0; i < FF_ARRAY_ELEMS(s->DPB); i++) {\n\n                HEVCFrame *frame = &s->DPB[i];\n\n                if (!(frame->flags & HEVC_FRAME_FLAG_BUMPING) && frame->poc != s->poc &&\n\n                        frame->sequence == s->seq_output) {\n\n                    ff_hevc_unref_frame(s, frame, HEVC_FRAME_FLAG_OUTPUT);\n\n                }\n\n            }\n\n        }\n\n\n\n        for (i = 0; i < FF_ARRAY_ELEMS(s->DPB); i++) {\n\n            HEVCFrame *frame = &s->DPB[i];\n\n            if ((frame->flags & HEVC_FRAME_FLAG_OUTPUT) &&\n\n                frame->sequence == s->seq_output) {\n\n                nb_output++;\n\n                if (frame->poc < min_poc) {\n\n                    min_poc = frame->poc;\n\n                    min_idx = i;\n\n                }\n\n            }\n\n        }\n\n\n\n        /* wait for more frames before output */\n\n        if (!flush && s->seq_output == s->seq_decode && s->sps &&\n\n            nb_output <= s->sps->temporal_layer[s->sps->max_sub_layers - 1].num_reorder_pics)\n\n            return 0;\n\n\n\n        if (nb_output) {\n\n            HEVCFrame *frame = &s->DPB[min_idx];\n\n            AVFrame *dst = out;\n\n            AVFrame *src = frame->frame;\n\n            const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(src->format);\n\n            int pixel_shift = !!(desc->comp[0].depth_minus1 > 7);\n\n\n\n            ret = av_frame_ref(out, src);\n\n            if (frame->flags & HEVC_FRAME_FLAG_BUMPING)\n\n                ff_hevc_unref_frame(s, frame, HEVC_FRAME_FLAG_OUTPUT | HEVC_FRAME_FLAG_BUMPING);\n\n            else\n\n                ff_hevc_unref_frame(s, frame, HEVC_FRAME_FLAG_OUTPUT);\n\n            if (ret < 0)\n\n                return ret;\n\n\n\n            for (i = 0; i < 3; i++) {\n\n                int hshift = (i > 0) ? desc->log2_chroma_w : 0;\n\n                int vshift = (i > 0) ? desc->log2_chroma_h : 0;\n\n                int off = ((frame->window.left_offset >> hshift) << pixel_shift) +\n\n                          (frame->window.top_offset   >> vshift) * dst->linesize[i];\n\n                dst->data[i] += off;\n\n            }\n\n            av_log(s->avctx, AV_LOG_DEBUG,\n\n                   \"Output frame with POC %d.\\n\", frame->poc);\n\n            return 1;\n\n        }\n\n\n\n        if (s->seq_output != s->seq_decode)\n\n            s->seq_output = (s->seq_output + 1) & 0xff;\n\n        else\n\n            break;\n\n    } while (1);\n\n\n\n    return 0;\n\n}\n", "idx": 4668, "substitutes": {"s": ["sw", "less", "conf", "c", "h", "scope", "self", "ps", "ts", "settings", "t", "se", "w", "js", "events", "gets", "sb", "services", "ss", "south", "current", "in", "changes", "series", "comments", "source", "this", "as", "rs", "ses", "sam", "store", "sort", "https", "os", "g", "ms", "ains", "es", "an", "span", "v", "stats", "m", "sa", "sf", "a", "aws", "ops", "gs", "sg", "times", "ns", "ats", "cs", "comm", "ashes", "actions", "p", "is", "to", "sv", "hs", "bs", "sq", "session", "parts", "fs", "S", "snap", "b", "its", "sys", "qs", "set", "details", "n", "ds", "ins", "space", "ls", "ims", "sym", "sl", "spec", "states", "f", "sample", "obj", "e", "sts"], "out": ["output", "gt", "result", "b", "window", "ns", "c", "ctx", "sys", "buf", "set", "cs", "client", "file", "at", "os", "g", "table", "cmd", "screen", "Out", "n", "aux", "o", "t", "OUT", "err", "w", "js", "ref", "to", "list", "v", "ot", "outs", "new", "ch", "tmp", "y", "pool", "f", "obj", "conv", "io", "us", "in", "point", "res", "x"], "i": ["ei", " ii", "im", "ori", "h", "gi", "zi", "ind", "key", "hi", "pi", "iter", "I", "batch", "in", "j", "x", "\u0438", "di", "ic", "q", "instance", "mi", "my", "g", "xi", "index", "ri", "bi", "ki", "span", "ti", "v", "ai", "m", "remote", "info", "json", "ci", "it", "any", "ip", "li", "p", "is", "history", "record", "to", "try", "y", "fi", "ii", "init", "ini", "ij", "window", "cli", "oi", "client", "qi", "si", "n", "iq", "multi", "me", "id", "ui", "list", "ji", "phi", "ims", "ix", "f", "sim", "iu", "point"], "min_idx": ["min_Idindex", "min_endx", "min_idy", "min_bidx", "min_pidx", "min___idc", "min_bidindex", "min___indexp", "min___idy", "min___indexc", "min_fdxs", "min_fdl", "min_pidl", "min_Idl", "min_indexc", "min___idx", "min___indexy", "min_idc", "min_endy", "min_idix", "min_idp", "min_bidxc", "min_Idxc", "min_endxc", "min_Idx", "min_fdx", "min_endp", "min_Idp", "min_indexy", "min_indexx", "min_Idxs", "min___idp", "min_pidix", "min_endxs", "min_bidxs", "min___indexx", "min_idxc", "min_endindex", "min_indexp", "min_Idc", "min_idl", "min_Idy", "min_pidxs", "min_endc", "min_idindex", "min_idxs", "min_Idix", "min_fdix"], "ret": ["gt", "result", "mem", "it", "Return", "rel", "sys", "buf", "nt", "dt", "mt", "rets", "val", "tr", "full", "alt", "err", "ref", "bin", "txt", "rt", "reset", "status", "resp", "re", "tmp", "print", "RET", "Ret", "ft", "ll", "j", "res", "def", "rm", "elt"], "frame": ["draw", "chain", "function", "event", "step", "iframe", "state", "file", "flow", "link", "queue", "ce", "trace", "word", "module", "role", "reset", "request", " Frame", "foo", "owner", "message", "filter", "family", "face", "source", "ence", "feat", "next", "instance", "join", "page", "base", "zone", "process", "are", "position", "reason", "send", "code", "video", "command", "ze", "version", "remote", "fire", "one", "ace", "relation", "header", "cf", "channel", "Frame", "target", "type", "fe", "field", "force", "scene", "seq", "use", "line", "style", "close", "response", "session", "fr", "forced", "user", "cast", "rame", "form", "call", "window", "fram", "framework", "term", "set", "buffer", "we", "profile", "document", "row", "movie", "range", "slice", "ref", "list", "proc", "component", "feature", "block", "shot", "embed", "front", "show", "f", "point", "e", "interface", "format", "def", "image", "sequence"], "nb_output": ["nie____output", "nb_position", "nie____input", "nb_input", "nb___position", "nb_Output", "nb_written", "NB_output", "nb___Output", "nb____input", "nb_write", "NR_Output", "nb___exit", "NB_position", "bh_Output", "nie_written", "bh_exit", "nie_write", "nb___output", "bh_output", "nb____output", "nie_output", "bh_response", "NR_config", "NR_write", "nie_input", "NB_exit", "nb___write", "nb___config", "nb_config", "NB_Output", "nb____written", "nie____write", "NR_output", "nb_exit", "nb_response", "nb____write", "nie____written"], "dst": ["Dot", "tot", " dbr", "dbr", "ddest", "tdest", "dot", "Dbr", "tst", " dot", "tbr", " ddest", "Dst", "Ddest"], "src": ["init", "rs", "feat", "ser", "sr", "rel", "sys", "sc", "sup", "fc", "seq", "addr", "inst", "aux", "std", "usr", "sel", "str", "rc", "slice", "proc", "sb", "txt", "sec", "req", "sl", "rt", "rl", "config", "spec", "load", "st", "sub", "tmp", "ptr", "img", "sf", "sq", "supp", "dest", "conv", "obj", "in", "comp", "fr", "source", "stock", "loc"], "desc": ["Desc", "dc", "loc", "esc", "des", "feat", "dep", "cmp", "pro", "buf", "DES", "sc", "description", "d", "dict", "ec", "dev", "ds", "col", "dr", "rc", "ref", "asc", "txt", "dist", "sec", "req", "dir", "disc", "doc", "dest", "rec", "decl", "comp", "def", "vec"]}}
{"project": "FFmpeg", "commit_id": "4b9ac0b5f070f35eff671d83cee436db40631112", "target": 0, "func": "static int mpegaudio_parse(AVCodecParserContext *s1,\n\n                           AVCodecContext *avctx,\n\n                           uint8_t **poutbuf, int *poutbuf_size, \n\n                           const uint8_t *buf, int buf_size)\n\n{\n\n    MpegAudioParseContext *s = s1->priv_data;\n\n    int len, ret;\n\n    uint32_t header;\n\n    const uint8_t *buf_ptr;\n\n\n\n    *poutbuf = NULL;\n\n    *poutbuf_size = 0;\n\n    buf_ptr = buf;\n\n    while (buf_size > 0) {\n\n\tlen = s->inbuf_ptr - s->inbuf;\n\n\tif (s->frame_size == 0) {\n\n            /* special case for next header for first frame in free\n\n               format case (XXX: find a simpler method) */\n\n            if (s->free_format_next_header != 0) {\n\n                s->inbuf[0] = s->free_format_next_header >> 24;\n\n                s->inbuf[1] = s->free_format_next_header >> 16;\n\n                s->inbuf[2] = s->free_format_next_header >> 8;\n\n                s->inbuf[3] = s->free_format_next_header;\n\n                s->inbuf_ptr = s->inbuf + 4;\n\n                s->free_format_next_header = 0;\n\n                goto got_header;\n\n            }\n\n\t    /* no header seen : find one. We need at least MPA_HEADER_SIZE\n\n               bytes to parse it */\n\n\t    len = MPA_HEADER_SIZE - len;\n\n\t    if (len > buf_size)\n\n\t\tlen = buf_size;\n\n\t    if (len > 0) {\n\n\t\tmemcpy(s->inbuf_ptr, buf_ptr, len);\n\n\t\tbuf_ptr += len;\n\n\t\tbuf_size -= len;\n\n\t\ts->inbuf_ptr += len;\n\n\t    }\n\n\t    if ((s->inbuf_ptr - s->inbuf) >= MPA_HEADER_SIZE) {\n\n            got_header:\n\n\t\theader = (s->inbuf[0] << 24) | (s->inbuf[1] << 16) |\n\n\t\t    (s->inbuf[2] << 8) | s->inbuf[3];\n\n\n\n                ret = mpa_decode_header(avctx, header);\n\n                if (ret < 0) {\n\n\t\t    /* no sync found : move by one byte (inefficient, but simple!) */\n\n\t\t    memmove(s->inbuf, s->inbuf + 1, s->inbuf_ptr - s->inbuf - 1);\n\n\t\t    s->inbuf_ptr--;\n\n                    dprintf(\"skip %x\\n\", header);\n\n                    /* reset free format frame size to give a chance\n\n                       to get a new bitrate */\n\n                    s->free_format_frame_size = 0;\n\n\t\t} else {\n\n                    s->frame_size = ret;\n\n#if 0\n\n                    /* free format: prepare to compute frame size */\n\n\t\t    if (decode_header(s, header) == 1) {\n\n\t\t\ts->frame_size = -1;\n\n                    }\n\n#endif\n\n\t\t}\n\n\t    }\n\n        } else \n\n#if 0\n\n        if (s->frame_size == -1) {\n\n            /* free format : find next sync to compute frame size */\n\n\t    len = MPA_MAX_CODED_FRAME_SIZE - len;\n\n\t    if (len > buf_size)\n\n\t\tlen = buf_size;\n\n            if (len == 0) {\n\n\t\t/* frame too long: resync */\n\n                s->frame_size = 0;\n\n\t\tmemmove(s->inbuf, s->inbuf + 1, s->inbuf_ptr - s->inbuf - 1);\n\n\t\ts->inbuf_ptr--;\n\n            } else {\n\n                uint8_t *p, *pend;\n\n                uint32_t header1;\n\n                int padding;\n\n\n\n                memcpy(s->inbuf_ptr, buf_ptr, len);\n\n                /* check for header */\n\n                p = s->inbuf_ptr - 3;\n\n                pend = s->inbuf_ptr + len - 4;\n\n                while (p <= pend) {\n\n                    header = (p[0] << 24) | (p[1] << 16) |\n\n                        (p[2] << 8) | p[3];\n\n                    header1 = (s->inbuf[0] << 24) | (s->inbuf[1] << 16) |\n\n                        (s->inbuf[2] << 8) | s->inbuf[3];\n\n                    /* check with high probability that we have a\n\n                       valid header */\n\n                    if ((header & SAME_HEADER_MASK) ==\n\n                        (header1 & SAME_HEADER_MASK)) {\n\n                        /* header found: update pointers */\n\n                        len = (p + 4) - s->inbuf_ptr;\n\n                        buf_ptr += len;\n\n                        buf_size -= len;\n\n                        s->inbuf_ptr = p;\n\n                        /* compute frame size */\n\n                        s->free_format_next_header = header;\n\n                        s->free_format_frame_size = s->inbuf_ptr - s->inbuf;\n\n                        padding = (header1 >> 9) & 1;\n\n                        if (s->layer == 1)\n\n                            s->free_format_frame_size -= padding * 4;\n\n                        else\n\n                            s->free_format_frame_size -= padding;\n\n                        dprintf(\"free frame size=%d padding=%d\\n\", \n\n                                s->free_format_frame_size, padding);\n\n                        decode_header(s, header1);\n\n                        goto next_data;\n\n                    }\n\n                    p++;\n\n                }\n\n                /* not found: simply increase pointers */\n\n                buf_ptr += len;\n\n                s->inbuf_ptr += len;\n\n                buf_size -= len;\n\n            }\n\n\t} else \n\n#endif\n\n        if (len < s->frame_size) {\n\n            if (s->frame_size > MPA_MAX_CODED_FRAME_SIZE)\n\n                s->frame_size = MPA_MAX_CODED_FRAME_SIZE;\n\n\t    len = s->frame_size - len;\n\n\t    if (len > buf_size)\n\n\t\tlen = buf_size;\n\n\t    memcpy(s->inbuf_ptr, buf_ptr, len);\n\n\t    buf_ptr += len;\n\n\t    s->inbuf_ptr += len;\n\n\t    buf_size -= len;\n\n\t}\n\n        //    next_data:\n\n        if (s->frame_size > 0 && \n\n            (s->inbuf_ptr - s->inbuf) >= s->frame_size) {\n\n            *poutbuf = s->inbuf;\n\n            *poutbuf_size = s->inbuf_ptr - s->inbuf;\n\n\t    s->inbuf_ptr = s->inbuf;\n\n\t    s->frame_size = 0;\n\n\t    break;\n\n\t}\n\n    }\n\n    return buf_ptr - buf;\n\n}\n", "idx": 4681, "substitutes": {"s1": ["js1", "s0", "js2", "s3", "jsOne", " s5", " s0", "pOne", " sOne", "js0", "s5", "rs5", " s3", "p2", "rs3", "p1", "rs2", "s2", " s2", "sOne", "p0", "rs1"], "avctx": [" avconn", "averpkg", "avpkg", "evcfg", "avconn", "averconn", " avcontext", "evctx", "avercontext", "avcontext", "evconn", "wavconn", " avpkg", "wavcfg", "evcontext", "wavctx", " avcfg", "avcfg", "wavpkg", "wavcontext", "averctx"], "poutbuf": ["Pinbuf", "pinbuf", "poutbuffer", "Pincv", "pnvec", "Poutbuff", "poutbuff", "pncb", "prawbuffer", "prawcb", "pincv", "poutvec", "Pinbuffer", "pointcv", "Poutcb", "poutcb", "Poutvec", "pointbuf", "Poutcv", "pinbuffer", "pointbuff", "pnbuf", "Poutbuf", "prawvec", "pointbuffer", "pinbuff", "poutcv", "pincb", "pinvec", "Pinvec", "pnbuffer", "Poutbuffer", "prawbuf", "Pincb", "Pinbuff"], "poutbuf_size": ["poutbuffer_num", "poutbuf_SIZE", "poutbuf_Size", "poutbuffer_Size", "poutbuffer_size", "poutbuffer_start", "poutbuffer_SIZE", "poutbuf_num", "poutbuf_start"], "buf": ["bytes", "uf", "buff", "b", "ff", "SIZE", "BU", "end", "pb", "RAW", "Buffer", "buffer", "msg", "raw", "cmd", "cb", "data", "queue", "wb", "OUT", "ref", "bar", "Buff", "out", "bf", "bin", "block", "alloc", "foo", "tmp", "cv", "ptr", "xff", "BR", "np", "broad", "vec"], "buf_size": ["buf_c", "buff1start", " buffer_ize", "bufnstart", "buf_store", "buf1capacity", "buff1len", "buf1start", "buf_capacity", "buf_shape", "bufnsize", "cb_size", " buf_ize", "bufmodsent", "buf2Size", "buf_sent", "buf_start", " buffer_size", "cb_offset", "buf0store", "bufmodsize", "buf0shape", "buf_offset", "buff1capacity", "buf0length", "buf67index", "buf67size", " buffer_Size", " buf_length", "buf_Size", " buf_index", " buffer_len", "buf2ize", "buff_store", "buff_len", "buf67length", "buf1len", "buf2size", "buf_index", "buf67ize", "buf0size", "cb_sent", "bufmodoffset", "buf_length", "buf_len", "buff_start", "bufnlen", "buf1size", "buff1size", "bufncapacity", "buff_shape", "buf_ize", "bufmodc", "buff_capacity", "cb_c", "buff_length", "buf2len", "buff_size"], "s": ["sw", "less", "tes", "conf", "c", "http", "h", "ers", "state", "terms", "ps", "ts", "settings", "t", "se", "js", "gets", "sb", "ss", "south", "changes", "j", "sports", "comments", "scripts", "source", "as", "rs", "so", "ses", "sam", "store", "https", "os", "er", "g", "ms", "es", "simple", "stats", "bits", "m", "sa", "vs", "local", "aws", "a", "l", "ops", "gs", "bis", "ssl", "ns", "ats", "ies", "cs", "comm", "uploads", "aunts", "is", "sv", "sm", "rest", "hs", "bs", "y", "sq", "parts", "fs", "sql", "S", "b", "eps", "its", "acs", "i", "set", "qs", "sys", "als", "details", "n", "ds", "sync", "full", "ins", "space", "ls", "ess", "ims", "sl", "status", "spec", "browser", "states", "storage", "ex", "sts", "z"], "len": ["lv", "ln", "late", "h", "valid", "ler", "un", "kl", "t", "alt", "pos", "en", "lim", "iter", "fin", "size", "le", " l", "elt", "mem", "ell", " clen", " bl", "nt", "compl", "lon", " alt", "lib", "pl", "str", "el", "lp", "fn", "lit", "L", "comp", "length", "lic", "html", "nl", "l", "vec", "gl", "Len", "lf", "li", "vol", "ml", " el", "val", "del", "limit", "rev", "lt", "els", "la", "hl", "ld", "ll", "il", "cmp", "dl", "n", "fl", "lc", "err", "lan", "col", "ref", "ls", "fun", "sl", " le", "f", "z"], "ret": ["gt", "success", "result", "repl", "mem", "ber", "back", "cont", "det", "ter", "nt", "true", "ben", "valid", "ext", "rect", "mt", "rets", "val", "tr", "t", "alt", "ref", "rev", "rem", "out", "rt", "fin", "reset", "fun", "re", "lt", "status", "tf", "RET", "Ret", "ft", "ll", "nl", "res", "arr", "def", "elt"], "header": ["package", "result", "detail", "magic", "prefix", "window", "metadata", "lr", "type", "h", "HEAD", "offset", "tar", "description", "heading", "buffer", "msg", "er", "table", "dt", "cmd", "body", "timer", " HDR", "index", "data", "line", "t", "key", "headers", "err", "dr", "question", "tag", "section", "rr", "lp", "layer", "token", "txt", "frame", "part", "head", "comment", "response", "version", "Header", "message", "filter", "hash", "holder", "html", "format", "fr", "text", "tail", "title", "definition", "name", "flag"], "buf_ptr": ["buf_pos", "buffer_pointer", "uf_pointer", " buf_pointer", " buf_tr", "buf_pad", " buf_rel", "buffer_rep", " buf_pos", "buffer_ptr", "uf_addr", "buf_rel", "uf_ptr", " buf_pr", "buffer_tr", "uf_pad", "buf_addr", "buf_pointer", "buf_pr", "buf_rep", "buf_tr"], "inbuf_ptr": ["inbufibprime", "inbox__tr", "inbuf_tr", "inbuf_vr", "inbox_addr", "inbuf_desc", "inbuf__ptr", "inbox_pointer", "inbufibptr", "inbuffer_tr", "inbuf__addr", "inbuf_ref", "inbuf_Ptr", "inbr_addr", "inqueue_prime", "inbr_req", "inbuf_prime", "inbox_tr", "inbuf_ctr", "inbuffer_ptr", "inbuf__tr", "inqueue_pointer", "inbuf_pointer", "inbox__ptr", "inbuffer_Ptr", "inbufibaddr", "inbuf_req", "inqueue_addr", "inbox_ptr", "inbuffer_addr", "inbr_ptr", "inbuffer_ctr", "inbuf__pointer", "inbufibdesc", "inbuffer_ref", "inbox__addr", "inqueue_tr", "inqueue_desc", "inbox__pointer", "inbuf_addr", "inqueue_ptr", "inbuffer_vr", "inbr_tr", "inbuffer_pointer"]}}
{"project": "FFmpeg", "commit_id": "33d69a90085d30af8a292d9364b835a26565d6b9", "target": 0, "func": "JNIEnv *ff_jni_attach_env(int *attached, void *log_ctx)\n\n{\n\n    int ret = 0;\n\n    JNIEnv *env = NULL;\n\n\n\n    *attached = 0;\n\n\n\n    pthread_mutex_lock(&lock);\n\n    if (java_vm == NULL && (java_vm = av_jni_get_java_vm(log_ctx)) == NULL) {\n\n\n\n        av_log(log_ctx, AV_LOG_INFO, \"Retrieving current Java virtual machine using Android JniInvocation wrapper\\n\");\n\n        if (check_jni_invocation(log_ctx) == 0) {\n\n            if ((java_vm = get_java_vm(NULL, log_ctx)) != NULL ||\n\n                (java_vm = get_java_vm(\"libdvm.so\", log_ctx)) != NULL ||\n\n                (java_vm = get_java_vm(\"libart.so\", log_ctx)) != NULL) {\n\n                av_log(log_ctx, AV_LOG_INFO, \"Found Java virtual machine using Android JniInvocation wrapper\\n\");\n\n            }\n\n        }\n\n    }\n\n    pthread_mutex_unlock(&lock);\n\n\n\n    if (!java_vm) {\n\n        av_log(log_ctx, AV_LOG_ERROR, \"Could not retrieve a Java virtual machine\\n\");\n\n        return NULL;\n\n    }\n\n\n\n    ret = (*java_vm)->GetEnv(java_vm, (void **)&env, JNI_VERSION_1_6);\n\n    switch(ret) {\n\n    case JNI_EDETACHED:\n\n        if ((*java_vm)->AttachCurrentThread(java_vm, &env, NULL) != 0) {\n\n            av_log(log_ctx, AV_LOG_ERROR, \"Failed to attach the JNI environment to the current thread\\n\");\n\n            env = NULL;\n\n        } else {\n\n            *attached = 1;\n\n        }\n\n        break;\n\n    case JNI_OK:\n\n        break;\n\n    case JNI_EVERSION:\n\n        av_log(log_ctx, AV_LOG_ERROR, \"The specified JNI version is not supported\\n\");\n\n        break;\n\n    default:\n\n        av_log(log_ctx, AV_LOG_ERROR, \"Failed to get the JNI environment attached to this thread\");\n\n        break;\n\n    }\n\n\n\n    return env;\n\n}\n", "idx": 4685, "substitutes": {"attached": ["achanged", "Attachment", "attadded", "ATTachable", "readded", "ATTached", "ATTended", "ATTributed", "attenachable", "achributed", "attsachable", "reached", "attsadded", "attachment", "attributed", "attachable", "attsributed", "Attended", "attended", "reachable", "attsended", "achached", "attsanged", "Attached", "attenended", "Attachable", "attanged", "attsached", "attenached", "achachable", "achended", "reanged", "attenachment", "achadded", "ATTachment"], "log_ctx": ["logptloc", "log_scope", "logptbuf", "logzctx", " log_gz", "bugptcmp", "resource_cas", "logLoggz", "log_tx", "logxscope", "logtxtxt", "logttx", " log_tx", " log_kw", "log_buf", "loglytz", "logzcfg", "bugptkw", "log_cv", "Log_tz", "logtxtz", " log_txt", "logtcmp", "loggertz", "log_cas", "logxctx", "loglycas", " log_gc", "logpttx", "log_txt", "loglexrx", "logptctx", "logptkw", "log_kw", "log_conn", "log_gc", "resource_ctx", "log_tz", "logtxhandle", "Log_context", "loglexrect", "log_rx", " log_rect", "log_gz", "logtxconn", "bug_kw", "log_rec", "logzcmp", "loggercfg", "loggergc", " log_rx", "logptcv", "logLogtx", "log_obj", " log_crit", " log_obj", "Log_cfg", "logtxtx", " log_buf", "loglogtx", " log_prefix", "loglogcond", "loggermem", "logptmem", "logztz", "loglexobj", "logtxctx", "log_loc", "log_cfg", "logLogcv", "logtkw", " log_cond", "logtbuf", "logtcontext", "resource_conn", "log_mem", "logLogctx", "resourcelyctx", "log_cond", "loglyconn", "loggerrec", "logxcond", "log_handle", " log_handle", "logztx", "log_prefix", " log_rec", "loggercontext", "loggerkw", "loggerctx", "logzcontext", "logxtx", "loglexctx", "logptgc", "logtmem", " log_context", "bug_mem", "resourcelytz", "bug_cmp", "bug_ctx", " log_cv", "loggercmp", "logptcontext", "logzcrit", "log_context", "logtxcas", "resourcelycas", "log_rect", " log_loc", "log_cmp", "loglogscope", "bugptmem", "bugptctx", "logtrec", "resourcelyconn", "log_crit", "logtctx", "loglyctx", " log_cmp", "loglogctx", "logptgz", "resource_tz", "logtloc", "Log_ctx", "loggertx", " log_scope", "logptcmp"], "env": ["init", "this", "ev", "export", "result", "et", "instance", "window", "end", "ov", "dep", "ctx", "def", "here", "null", "eas", "conn", "buf", "ve", "buffer", "msg", "erd", "er", "ext", "ent", "addr", "cmd", "inv", "endif", "ec", "ew", "dev", "viron", "var", "cb", "environment", "eh", "vp", "context", "name", "server", "err", "gear", "proc", "attr", "nil", "kw", "en", "v", "ah", "txt", "ef", "nv", "eu", "new", "vs", "ret", "tmp", "cv", "ptr", "tx", "doc", "priv", "entry", "vt", "obj", "e", "oe", "enc", "elt"]}}
{"project": "qemu", "commit_id": "4652b8f3e1ec91bb9d6f00e40df7f96d1f1aafee", "target": 1, "func": "static int perform_cow(BlockDriverState *bs, QCowL2Meta *m)\n\n{\n\n    BDRVQcow2State *s = bs->opaque;\n\n    Qcow2COWRegion *start = &m->cow_start;\n\n    Qcow2COWRegion *end = &m->cow_end;\n\n    unsigned buffer_size;\n\n    unsigned data_bytes = end->offset - (start->offset + start->nb_bytes);\n\n    bool merge_reads;\n\n    uint8_t *start_buffer, *end_buffer;\n\n    QEMUIOVector qiov;\n\n    int ret;\n\n\n\n    assert(start->nb_bytes <= UINT_MAX - end->nb_bytes);\n\n    assert(start->nb_bytes + end->nb_bytes <= UINT_MAX - data_bytes);\n\n    assert(start->offset + start->nb_bytes <= end->offset);\n\n    assert(!m->data_qiov || m->data_qiov->size == data_bytes);\n\n\n\n    if (start->nb_bytes == 0 && end->nb_bytes == 0) {\n\n        return 0;\n\n    }\n\n\n\n    /* If we have to read both the start and end COW regions and the\n\n     * middle region is not too large then perform just one read\n\n     * operation */\n\n    merge_reads = start->nb_bytes && end->nb_bytes && data_bytes <= 16384;\n\n    if (merge_reads) {\n\n        buffer_size = start->nb_bytes + data_bytes + end->nb_bytes;\n\n    } else {\n\n        /* If we have to do two reads, add some padding in the middle\n\n         * if necessary to make sure that the end region is optimally\n\n         * aligned. */\n\n        size_t align = bdrv_opt_mem_align(bs);\n\n        assert(align > 0 && align <= UINT_MAX);\n\n        assert(QEMU_ALIGN_UP(start->nb_bytes, align) <=\n\n               UINT_MAX - end->nb_bytes);\n\n        buffer_size = QEMU_ALIGN_UP(start->nb_bytes, align) + end->nb_bytes;\n\n    }\n\n\n\n    /* Reserve a buffer large enough to store all the data that we're\n\n     * going to read */\n\n    start_buffer = qemu_try_blockalign(bs, buffer_size);\n\n    if (start_buffer == NULL) {\n\n        return -ENOMEM;\n\n    }\n\n    /* The part of the buffer where the end region is located */\n\n    end_buffer = start_buffer + buffer_size - end->nb_bytes;\n\n\n\n    qemu_iovec_init(&qiov, 2 + (m->data_qiov ? m->data_qiov->niov : 0));\n\n\n\n    qemu_co_mutex_unlock(&s->lock);\n\n    /* First we read the existing data from both COW regions. We\n\n     * either read the whole region in one go, or the start and end\n\n     * regions separately. */\n\n    if (merge_reads) {\n\n        qemu_iovec_add(&qiov, start_buffer, buffer_size);\n\n        ret = do_perform_cow_read(bs, m->offset, start->offset, &qiov);\n\n    } else {\n\n        qemu_iovec_add(&qiov, start_buffer, start->nb_bytes);\n\n        ret = do_perform_cow_read(bs, m->offset, start->offset, &qiov);\n\n        if (ret < 0) {\n\n            goto fail;\n\n        }\n\n\n\n        qemu_iovec_reset(&qiov);\n\n        qemu_iovec_add(&qiov, end_buffer, end->nb_bytes);\n\n        ret = do_perform_cow_read(bs, m->offset, end->offset, &qiov);\n\n    }\n\n    if (ret < 0) {\n\n        goto fail;\n\n    }\n\n\n\n    /* Encrypt the data if necessary before writing it */\n\n    if (bs->encrypted) {\n\n        if (!do_perform_cow_encrypt(bs, m->offset, start->offset,\n\n                                    start_buffer, start->nb_bytes) ||\n\n            !do_perform_cow_encrypt(bs, m->offset, end->offset,\n\n                                    end_buffer, end->nb_bytes)) {\n\n            ret = -EIO;\n\n            goto fail;\n\n        }\n\n    }\n\n\n\n    /* And now we can write everything. If we have the guest data we\n\n     * can write everything in one single operation */\n\n    if (m->data_qiov) {\n\n        qemu_iovec_reset(&qiov);\n\n        if (start->nb_bytes) {\n\n            qemu_iovec_add(&qiov, start_buffer, start->nb_bytes);\n\n        }\n\n        qemu_iovec_concat(&qiov, m->data_qiov, 0, data_bytes);\n\n        if (end->nb_bytes) {\n\n            qemu_iovec_add(&qiov, end_buffer, end->nb_bytes);\n\n        }\n\n        /* NOTE: we have a write_aio blkdebug event here followed by\n\n         * a cow_write one in do_perform_cow_write(), but there's only\n\n         * one single I/O operation */\n\n        BLKDBG_EVENT(bs->file, BLKDBG_WRITE_AIO);\n\n        ret = do_perform_cow_write(bs, m->alloc_offset, start->offset, &qiov);\n\n    } else {\n\n        /* If there's no guest data then write both COW regions separately */\n\n        qemu_iovec_reset(&qiov);\n\n        qemu_iovec_add(&qiov, start_buffer, start->nb_bytes);\n\n        ret = do_perform_cow_write(bs, m->alloc_offset, start->offset, &qiov);\n\n        if (ret < 0) {\n\n            goto fail;\n\n        }\n\n\n\n        qemu_iovec_reset(&qiov);\n\n        qemu_iovec_add(&qiov, end_buffer, end->nb_bytes);\n\n        ret = do_perform_cow_write(bs, m->alloc_offset, end->offset, &qiov);\n\n    }\n\n\n\nfail:\n\n    qemu_co_mutex_lock(&s->lock);\n\n\n\n    /*\n\n     * Before we update the L2 table to actually point to the new cluster, we\n\n     * need to be sure that the refcounts have been increased and COW was\n\n     * handled.\n\n     */\n\n    if (ret == 0) {\n\n        qcow2_cache_depends_on_flush(s->l2_table_cache);\n\n    }\n\n\n\n    qemu_vfree(start_buffer);\n\n    qemu_iovec_destroy(&qiov);\n\n    return ret;\n\n}\n", "idx": 4697, "substitutes": {"bs": ["boxes", "bes", "rs", "gb", "gs", "bis", "ses", "b", "ns", "ubs", "pb", "bos", "bg", "its", "bc", "sys", "cs", "bh", "ms", "bp", "bd", "ts", "bles", "ds", "BS", "cb", "es", "bi", "aus", "lb", "js", "bb", "ls", "sb", "bps", "ubis", "bits", "vs", "hs", "aos", "ss", "bl", "fs", "sts", "bm", "obs", "lbs"], "m": ["km", "b", "mn", "metadata", "gm", "conf", "managed", "c", "md", "met", "i", "mat", "M", "mi", "mr", "msg", "p", "d", "cm", "mt", "ms", "n", "tm", "perm", "r", "pm", "me", "module", "dm", "rem", "mac", "nm", "sm", "v", "man", "config", "om", "mm", "am", "y", "mc", "mod", "f", "hm", "sim", "vm", "e", "j", "bm", "esm", "l", "rm", "mp"], "s": ["rs", "gs", "sp", "ses", "b", "ns", "c", "i", "sys", "set", "state", "cs", "os", "ps", "p", "ms", "n", "is", "ts", "ds", "t", "js", "space", "sv", "ls", "sm", "sb", "v", "hs", "ss", "sn", "fs", "S", "sts", "j"], "start": ["draw", "open", "event", "step", "save", "pro", "state", "addr", "add", "ind", "key", "need", "pos", "iter", "art", "entry", "parent", "size", "in", "source", "this", "q", "root", "next", "middle", "store", "rank", "pre", "begin", "part", "before", "time", "info", "check", "trans", "error", "power", "it", "offset", "kind", "p", "started", "and", "stop", "rest", "style", "try", "st", "close", "y", "create", "name", "init", "all", "match", "app", "get", "set", "Start", "data", "first", "range", "from", "id", "space", "new", "starting", "sky", "ish", "e"], "end": ["open", "event", "run", "save", "nd", "last", "except", "order", "add", "ade", "vert", "ec", "dev", "or", "after", "en", "comment", "entry", "enc", "post", "eff", "ell", "up", "until", "endif", "good", "ended", "server", "append", "hend", "send", "max", "begin", "v", "rend", "env", "update", "export", "ort", "it", "END", "exc", "ent", "p", "ed", "enable", "and", "stop", "rest", "change", "final", "st", "close", "ord", "edge", "create", "all", "b", "app", "est", "set", "only", "ext", "east", "eng", "data", "each", "entity", "ending", "ad", "wrap", "ex", "e", "ment", "End"], "buffer_size": ["buffer_count", " buffer2storage", "Buffer_Size", " buffer_mode", "buffer2speed", " buffer_length", "buffer2size", " buffer_rate", "buffer_rate", "Buffer_count", " buffer_SIZE", "buffer_name", "buffer_mode", "device_SIZE", " buffer2speed", " buffer2size", "buffer_SIZE", "buffer2SIZE", "buffer_Size", "buffer2mode", " buffer_Size", "buffer_length", "buffer_speed", "buffer64Size", "buffer64size", " buffer2Size", "buffer64offset", "buffer_storage", "device_count", "buffer_offset", " buffer_name", " buffer2mode", "buffer64count", "buffer2count", "device_info", " buffer_storage", " buffer2SIZE", "buffer2Size", "buffer2info", "Buffer_size", "Buffer_offset", "device_size", "buffer_info", "buffer2storage", " buffer_speed"], "merge_reads": ["merfer_reads", "merge_checks", "merge___reads", "mergeingvalues", "merume_reads", "merumeingreads", "mergeoutlocks", "merge_locks", "merferlyreads", "mergeableloads", "merferlyrequisites", "merumeingwritten", "mergefulreads", "mergeablelocks", "merge_values", "mergeoutloads", "merge_read", "mergingableread", "mergingablelocks", "merger_read", "mergeingreads", "merge___requisites", "merge_requisites", "mergeablereads", "mergelyvalues", "merferlyvalues", "mergelyread", "mergelyrequisites", "merge___values", "mergeableread", "merume_values", "mergefulkeys", "merge___read", "merge_rows", "merger_keys", "merume_written", "mergingableloads", "merger_reads", "merfer_values", "merume_rows", "mergingablereads", "merging_loads", "merferlyread", "mergelyreads", "mergeingrows", "merger_checks", "merumeingvalues", "merge_keys", "merge_written", "mergeoutread", "merging_reads", "merfer_read", "merging_read", "mergeingwritten", "mergefulchecks", "mergeoutreads", "merging_locks", "merfer_requisites", "mergefulread", "merge_loads", "merumeingrows"], "start_buffer": ["stop_store", "startablebutton", " start_device", "start___base", "start_surface", "start___device", "start_base", " start_base", " start_surface", "startingbuffer", "startingbutton", "startingstore", "stop_device", "startablestore", " start_cache", "stop_button", "stop_buffer", "stopablestore", "start_button", "stopablebutton", " start_offset", "start_cache", "start_binary", "startabledevice", "startingdevice", "stopabledevice", "startablebuffer", "start_store", "stopablebuffer", "start___cache", " start_binary", "start_device", "start___buffer", "start_offset"], "end_buffer": ["end___Buffer", " end_buff", "end___buffer", "end_device", "end_Buffer", "end__cache", " end_Buffer", "end_buf", "end___buf", "end__Buffer", "end__buffer", "end__buf", "end_buff", " end_buf", " end_cache", "end___cache", " end_device", "end_cache"], "qiov": ["Qconv", " qiev", "quconv", "qconv", "qij", " qiop", "qiev", "Qiev", "qqiev", "quiev", "Qiop", "quiov", " qij", "quij", "qqiov", "qiop", "quiop", "Qiov", " qconv", "qqiop", "qqij"], "ret": ["result", "et", "Return", "rel", "ter", " alt", "val", "vals", "alt", " resp", "str", "rev", "rem", "out", "num", "final", "resp", "re", "status", "lit", "RET", "Ret", "net", "elt", "flag"]}}
{"project": "FFmpeg", "commit_id": "d1adad3cca407f493c3637e20ecd4f7124e69212", "target": 0, "func": "void sws_rgb2rgb_init(int flags)\n\n{\n\n#if HAVE_SSE2 || HAVE_MMX2 || HAVE_AMD3DNOW || HAVE_MMX\n\n    if (flags & SWS_CPU_CAPS_SSE2)\n\n        rgb2rgb_init_SSE2();\n\n    else if (flags & SWS_CPU_CAPS_MMX2)\n\n        rgb2rgb_init_MMX2();\n\n    else if (flags & SWS_CPU_CAPS_3DNOW)\n\n        rgb2rgb_init_3DNOW();\n\n    else if (flags & SWS_CPU_CAPS_MMX)\n\n        rgb2rgb_init_MMX();\n\n    else\n\n#endif /* HAVE_MMX2 || HAVE_AMD3DNOW || HAVE_MMX */\n\n        rgb2rgb_init_C();\n\n}\n", "idx": 4698, "substitutes": {"flags": ["members", "fields", "styles", "weights", "fts", " Flags", "laws", "wcs", "amps", "ags", "locks", "cs", "terms", "files", "aps", "goal", "actions", "pins", "ps", "cmd", "lines", "details", "frames", "words", "ports", "settings", "ts", "products", "bugs", "workers", "fps", "vals", "allows", "options", "atts", "comments", "planes", "grades", "ents", "properties", "tags", "bits", "FLAG", "Flags", "cond", "limits", "lag", "mask", "parts", "heads", "gnu", "posts", "packages", "features", "flag"]}}
{"project": "FFmpeg", "commit_id": "292850b634240045805e3c2001aed6f046034e93", "target": 0, "func": "static double tget_double(GetByteContext *gb, int le)\n\n{\n\n    av_alias64 i = { .u64 = le ? bytestream2_get_le64(gb) : bytestream2_get_be64(gb)};\n\n    return i.f64;\n\n}\n", "idx": 4718, "substitutes": {"gb": ["db", "gt", "yg", "gh", "gc", "gs", "sg", "gp", "gm", "eb", "pb", "bg", "bc", "gov", "cgi", " GB", "eg", "g", "tg", "hub", "gd", "cb", "bt", "bb", "pg", "sb", "rb", "bf", "vg", "dd", "mb", "cfg", "rg", "nb", "cv", "Gb", "gu", "GB", "kb", "gg"], "le": ["ige", "agle", "sle", "less", "ity", " angle", "ble", " alle", " ge", "ple", "ped", " ke", " ele", "yle", "Le", "ale", "ve", "ode", "te", "ele", " little", "ke", "les", "ce", " ce", "ole", "led", " ble", "el", "ile", " ty", " Le", " de", "be", " needle", "he", "ee", " ie", "de", "LE", " LE", "ne", "tle", " pe", "elt"]}}
{"project": "qemu", "commit_id": "9633fcc6a02f23e3ef00aa5fe3fe9c41f57c3456", "target": 1, "func": "static void init_proc_power5plus(CPUPPCState *env)\n\n{\n\n    gen_spr_ne_601(env);\n\n    gen_spr_7xx(env);\n\n    /* Time base */\n\n    gen_tbl(env);\n\n    /* Hardware implementation registers */\n\n    /* XXX : not implemented */\n\n    spr_register(env, SPR_HID0, \"HID0\",\n\n                 SPR_NOACCESS, SPR_NOACCESS,\n\n                 &spr_read_generic, &spr_write_clear,\n\n                 0x60000000);\n\n    /* XXX : not implemented */\n\n    spr_register(env, SPR_HID1, \"HID1\",\n\n                 SPR_NOACCESS, SPR_NOACCESS,\n\n                 &spr_read_generic, &spr_write_generic,\n\n                 0x00000000);\n\n    /* XXX : not implemented */\n\n    spr_register(env, SPR_750FX_HID2, \"HID2\",\n\n                 SPR_NOACCESS, SPR_NOACCESS,\n\n                 &spr_read_generic, &spr_write_generic,\n\n                 0x00000000);\n\n    /* XXX : not implemented */\n\n    spr_register(env, SPR_970_HID5, \"HID5\",\n\n                 SPR_NOACCESS, SPR_NOACCESS,\n\n                 &spr_read_generic, &spr_write_generic,\n\n                 POWERPC970_HID5_INIT);\n\n    /* XXX : not implemented */\n\n    spr_register(env, SPR_L2CR, \"L2CR\",\n\n                 SPR_NOACCESS, SPR_NOACCESS,\n\n                 &spr_read_generic, NULL,\n\n                 0x00000000);\n\n    /* Memory management */\n\n    /* XXX: not correct */\n\n    gen_low_BATs(env);\n\n    /* XXX : not implemented */\n\n    spr_register(env, SPR_MMUCFG, \"MMUCFG\",\n\n                 SPR_NOACCESS, SPR_NOACCESS,\n\n                 &spr_read_generic, SPR_NOACCESS,\n\n                 0x00000000); /* TOFIX */\n\n    /* XXX : not implemented */\n\n    spr_register(env, SPR_MMUCSR0, \"MMUCSR0\",\n\n                 SPR_NOACCESS, SPR_NOACCESS,\n\n                 &spr_read_generic, &spr_write_generic,\n\n                 0x00000000); /* TOFIX */\n\n    spr_register(env, SPR_HIOR, \"SPR_HIOR\",\n\n                 SPR_NOACCESS, SPR_NOACCESS,\n\n                 &spr_read_hior, &spr_write_hior,\n\n                 0x00000000);\n\n    spr_register(env, SPR_CTRL, \"SPR_CTRL\",\n\n                 SPR_NOACCESS, SPR_NOACCESS,\n\n                 &spr_read_generic, &spr_write_generic,\n\n                 0x00000000);\n\n    spr_register(env, SPR_UCTRL, \"SPR_UCTRL\",\n\n                 SPR_NOACCESS, SPR_NOACCESS,\n\n                 &spr_read_generic, &spr_write_generic,\n\n                 0x00000000);\n\n    spr_register(env, SPR_VRSAVE, \"SPR_VRSAVE\",\n\n                 &spr_read_generic, &spr_write_generic,\n\n                 &spr_read_generic, &spr_write_generic,\n\n                 0x00000000);\n\n#if !defined(CONFIG_USER_ONLY)\n\n    env->slb_nr = 64;\n\n#endif\n\n    init_excp_970(env);\n\n    env->dcache_line_size = 128;\n\n    env->icache_line_size = 128;\n\n    /* Allocate hardware IRQ controller */\n\n    ppc970_irq_init(env);\n\n    /* Can't find information on what this should be on reset.  This\n\n     * value is the one used by 74xx processors. */\n\n    vscr_init(env, 0x00010000);\n\n}\n", "idx": 4760, "substitutes": {"env": ["event", "esc", "conf", "site", "det", "addr", "dev", "enter", "ec", "cb", "environment", "w", "gear", "en", "txt", "req", "worker", "entry", "home", "cur", "esm", "ten", "vv", "stage", "ve", "er", "dt", "context", "server", "ut", "el", "esp", "code", "v", "vs", "desc", "tk", "shell", "db", "ev", "et", "end", "ctx", "gov", "dem", "era", "msg", "viron", "usr", "hw", "dh", "pkg", "eq", "org", "nv", "cv", "vm", "net", "hl", "act", "rod", "window", "here", "erd", "cmd", "inv", "ie", "vp", "ew", "eng", "ner", "emb", "vt", "obj", "e", "conn", "nw", "ect"]}}
{"project": "FFmpeg", "commit_id": "15d14ce47cb39b93a80a2c6b8396db81c16934e6", "target": 1, "func": "static int64_t get_bit_rate(AVCodecContext *ctx)\n\n{\n\n    int64_t bit_rate;\n\n    int bits_per_sample;\n\n\n\n    switch (ctx->codec_type) {\n\n    case AVMEDIA_TYPE_VIDEO:\n\n    case AVMEDIA_TYPE_DATA:\n\n    case AVMEDIA_TYPE_SUBTITLE:\n\n    case AVMEDIA_TYPE_ATTACHMENT:\n\n        bit_rate = ctx->bit_rate;\n\n        break;\n\n    case AVMEDIA_TYPE_AUDIO:\n\n        bits_per_sample = av_get_bits_per_sample(ctx->codec_id);\n\n        bit_rate = bits_per_sample ? ctx->sample_rate * ctx->channels * bits_per_sample : ctx->bit_rate;\n\n        break;\n\n    default:\n\n        bit_rate = 0;\n\n        break;\n\n    }\n\n    return bit_rate;\n\n}\n", "idx": 4761, "substitutes": {"ctx": ["ck", "cf", "ij", "loc", "gc", "dc", "ct", "ctl", "wp", "cp", "ns", "wcs", "pc", "kt", "cmp", "bc", "anc", "mom", "wx", "ka", "comm", "nt", "lex", "mk", "addr", "cmd", "dl", "inst", "etc", "tm", "ocr", "aux", "context", "hw", "kl", "aus", "cc", "js", "xc", "crit", "pkg", "unk", "proc", "xs", "kw", "animate", "that", "oc", "txt", "req", "cfg", "resp", "tx", "cv", "iat", "pause", "exec", "desc", "jp", "np", "mc", "kick", "obj", "xp", "iac", "kb", "kj", "news", "conn", "today", "abc", "tc", "act"], "bit_rate": ["bit_error", "bit8range", "bit_depth", "bitletrange", "bitmodrange", " bit_range", "bit_range", "bar_stream", "bar67frequency", "bit_stream", "bititudescale", "bit8width", "bit_change", "bit8rate", "bit67frequency", "byte_component", "bit67change", "bit_score", "bar_rate", " bit_scale", "bit_component", "bit5frequency", "bit_system", "bit_width", "bitituderate", " bit_rates", " bit_error", "bug_range", "byte_rate", "bitlyrate", "bitituderace", "bar67change", "bitlydevice", "bar67stream", "bit_length", "bitlyrange", "byte_speed", " bit_depth", "bit_frequency", "bit67stream", "bar67rate", "byte_range", "bitletrate", "bitlerate", "bit_device", "bitlerace", "bitmoddevice", " bit_race", "bitlerange", "bit_scale", " bit_device", "bug_rate", "bit5rate", "bit67rate", "bit_race", "bit8component", "bitlesystem", "byte_width", "bit_rates", "bitmodrate", "bar_change", "bitletwidth", "byte_score", "bititudedepth", "bitletcomponent", "bug_system", "bit5stream", "bug_race", "byte_length", "bit_speed", "bit5change", "bar_frequency"], "bits_per_sample": ["bits_for_component", "bits_per_space", "bits_to_sample", "bits_perPcomponent", "bits_for_scale", "bits_per_channel", "bits_perPample", "bits_per_scale", "bits_per_component", "bits_per_Sample", "bits_per_frame", "bits_for_space", "bits_to_ample", "bits_perPSample", "bits_per_ample", "bits_perPsample", "bits_to_component", "bits_for_sample", "bits_to_Sample", "bits_for_channel", "bits_for_frame", "bits_for_Sample"]}}
{"project": "FFmpeg", "commit_id": "7631f14bb35e8467d4ffaaa2b34e60614eb37c71", "target": 0, "func": "static int mkv_write_codecprivate(AVFormatContext *s, AVIOContext *pb,\n\n                                  AVCodecParameters *par,\n\n                                  int native_id, int qt_id)\n\n{\n\n    AVIOContext *dyn_cp;\n\n    uint8_t *codecpriv;\n\n    int ret, codecpriv_size;\n\n\n\n    ret = avio_open_dyn_buf(&dyn_cp);\n\n    if (ret < 0)\n\n        return ret;\n\n\n\n    if (native_id) {\n\n        ret = mkv_write_native_codecprivate(s, par, dyn_cp);\n\n    } else if (par->codec_type == AVMEDIA_TYPE_VIDEO) {\n\n        if (qt_id) {\n\n            if (!par->codec_tag)\n\n                par->codec_tag = ff_codec_get_tag(ff_codec_movvideo_tags,\n\n                                                    par->codec_id);\n\n            if (   ff_codec_get_id(ff_codec_movvideo_tags, par->codec_tag) == par->codec_id\n\n                && (!par->extradata_size || ff_codec_get_id(ff_codec_movvideo_tags, AV_RL32(par->extradata + 4)) != par->codec_id)\n\n            ) {\n\n                int i;\n\n                avio_wb32(dyn_cp, 0x5a + par->extradata_size);\n\n                avio_wl32(dyn_cp, par->codec_tag);\n\n                for(i = 0; i < 0x5a - 8; i++)\n\n                    avio_w8(dyn_cp, 0);\n\n            }\n\n            avio_write(dyn_cp, par->extradata, par->extradata_size);\n\n        } else {\n\n            if (!ff_codec_get_tag(ff_codec_bmp_tags, par->codec_id))\n\n                av_log(s, AV_LOG_WARNING, \"codec %s is not supported by this format\\n\",\n\n                       avcodec_get_name(par->codec_id));\n\n\n\n            if (!par->codec_tag)\n\n                par->codec_tag = ff_codec_get_tag(ff_codec_bmp_tags,\n\n                                                  par->codec_id);\n\n            if (!par->codec_tag && par->codec_id != AV_CODEC_ID_RAWVIDEO) {\n\n                av_log(s, AV_LOG_ERROR, \"No bmp codec tag found for codec %s\\n\",\n\n                       avcodec_get_name(par->codec_id));\n\n                ret = AVERROR(EINVAL);\n\n            }\n\n\n\n            ff_put_bmp_header(dyn_cp, par, ff_codec_bmp_tags, 0, 0);\n\n        }\n\n    } else if (par->codec_type == AVMEDIA_TYPE_AUDIO) {\n\n        unsigned int tag;\n\n        tag = ff_codec_get_tag(ff_codec_wav_tags, par->codec_id);\n\n        if (!tag) {\n\n            av_log(s, AV_LOG_ERROR, \"No wav codec tag found for codec %s\\n\",\n\n                   avcodec_get_name(par->codec_id));\n\n            ret = AVERROR(EINVAL);\n\n        }\n\n        if (!par->codec_tag)\n\n            par->codec_tag = tag;\n\n\n\n        ff_put_wav_header(s, dyn_cp, par, FF_PUT_WAV_HEADER_FORCE_WAVEFORMATEX);\n\n    }\n\n\n\n    codecpriv_size = avio_close_dyn_buf(dyn_cp, &codecpriv);\n\n    if (codecpriv_size)\n\n        put_ebml_binary(pb, MATROSKA_ID_CODECPRIVATE, codecpriv,\n\n                        codecpriv_size);\n\n    av_free(codecpriv);\n\n    return ret;\n\n}\n", "idx": 4762, "substitutes": {"s": ["as", "rs", "gs", "q", "sp", "ses", "sw", "sg", "ns", "c", "h", "ats", "set", "sys", "cs", "self", "sc", "os", "ps", "p", "ms", "ts", "ds", "t", "es", "r", "js", "w", "an", "pkg", "ls", "sv", "v", "m", "sa", "ss", "sq", "socket", "fs", "S", "sts", "x", "a"], "pb": ["sp", "uf", "gp", "cp", "pc", "ctx", "pro", "p", "pa", "vp", "cb", "pl", "fp", "prep", "ub", "pkg", "proc", "lp", "tmp", "cv", "pub", "jp", "np", "pd", "conv", "pp", "tk", "tp", "mp"], "par": ["ph", "peer", "sp", "repl", "app", "ar", "ars", "task", "cp", "conf", "att", "pc", "star", "rep", "tar", "rel", "pro", "ok", "pri", "arch", "prop", "p", "ps", "pa", "pat", "cmd", "pol", "dev", "arp", "var", "op", "ran", "pl", "perm", "kar", "prep", "pers", "Par", "crit", "pre", "pkg", "proc", "rem", "pr", "pard", "pal", "req", "resp", "part", "PAR", "per", "mm", "parse", "pass", "pas", "jp", "pub", "parent", "plan", "arg", "pp", "decl", "param", "pres", "params", "tp", "def", "mp"], "native_id": ["nativeityif", "native_if", "native_oid", "native_len", "nativeityid", "nativeitytag", "nativevisionid", "native_pic", "native___if", "nativevisionpic", "native___id", "nativeOpic", "nativeityids", "nn_len", "nativevisionlen", "native_tag", "parentityids", "nativeOoid", "parent_id", "nn_id", "nn_pic", "nativeOlen", "nativevisionoid", "nn_oid", "parentityid", "parentitytag", "parentityif", "parent_if", "native___tag", "parent_tag", "nativeOid", "native___ids", "native_ids", "parent_ids"], "qt_id": ["qq_id", "qt_Id", "qtmykey", "qt_key", "qt___id", "quant_key", "qtmymi", "qt___mid", "quant_id", "qtmymid", "qt___key", "quant_mi", "qq_status", "qtokeid", "qq_side", "qq_Id", "qt_status", "quant_mid", "qtmyid", "qt_mi", "qtokeside", "qt___mi", "qt_mid", "qtokeId", "qt_side", "qtokestatus"], "dyn_cp": ["din_cs", "dynptfp", "dyn_cmp", "dyn___bp", "dyn5cpp", "dyn_bp", "dyn_CP", "dynJcas", "dyn_conn", "dyn___conn", "dyn_buf", "dYN_conn", "dynJbuf", "dyn_ctx", "dawn_caps", "dyn___cmp", "dYN_buf", "dynptwp", "dyn_jp", "dynptcp", "dyn5cmp", "dync_fp", "dynJcaps", "dynJcp", "dyn___cb", "dynJconn", "dyn___buf", "dyn_tp", "dawn_cp", "dyn_fp", "dyn___cpp", "din_fp", "dyn___cv", "dyn_cas", "dYN_cp", "dyn___fp", "dYN_tp", "din_cp", "dynptgc", "dyn_wp", "dynJCP", "dync_gc", "dyn___CP", "dyn___ctx", "dyn_cpp", "din_cv", "dyn_gc", "dync_wp", "dYN___tp", "dyn___tp", "dYN___bp", "dyn5ctx", "dyn_cv", "dyn_cs", "dYN___CP", "dYN_CP", "dyn5cp", "dyn_caps", "dYN___cp", "dyn_cb", "dyn___cs", "dynJjp", "dyn___cp", "dawn_cas", "dync_cp", "dawn_jp", "dYN_bp"], "codecpriv": ["codocprivate", "odecPriv", "codcriv", "codcprivate", "odcpriv", "codecriv", "odcprivate", "codcpriv", "codecPriv", "codencpriv", "odcriv", "codecprivate", "odecriv", "codencPriv", "codencriv", "odecpriv", "odecprivate", "codocPriv", "codcPriv", "codocriv", "codocpriv", "codencprivate", "odcPriv"], "ret": ["gt", "result", "gc", "mem", "att", "Return", "ber", "get", "mel", "ter", "xt", "nt", "ry", "__", "secondary", "cmd", " Ret", "mt", "rets", "len", "val", "tr", "t", "alt", "err", "value", "limit", "ref", "inter", "rev", "rem", "try", "rt", "fun", "mb", "resp", "re", "reset", "status", "RET", "Ret", "ft", "arg", "ll", " RET", "res", "arr", "deg", "def", "rm", "elt", "flag"], "codecpriv_size": ["codecprivxSize", "codecprivate_Size", "codecprivxlen", "codecprivate_len", "codecprivxsize", "codecprivate_size", "codecpriv_Size", "codecprivxlength", "codecpriv_length", "codecprivate_length", "codecpriv_len"], "i": ["ic", "q", "ci", "b", " ii", "it", " m", "im", "c", "u", "cli", "h", "oi", "gi", "mi", "qi", "li", "p", "si", "zi", "n", "is", "xi", "ind", "o", "t", "hi", "pi", "multi", "ui", "phi", "ti", "iter", "ims", "ix", " j", "ai", "m", "I", "y", "\u0438", "us", "io", "sim", "iu", "in", "e", "j", "x", "di", "ii", "l"]}}
{"project": "FFmpeg", "commit_id": "c23acbaed40101c677dfcfbbfe0d2c230a8e8f44", "target": 1, "func": "void ff_vp3_idct_dc_add_c(uint8_t *dest/*align 8*/, int line_size, const DCTELEM *block/*align 16*/){\n\n    int i, dc = (block[0] + 15) >> 5;\n\n    const uint8_t *cm = ff_cropTbl + MAX_NEG_CROP + dc;\n\n\n\n    for(i = 0; i < 8; i++){\n\n        dest[0] = cm[dest[0]];\n\n        dest[1] = cm[dest[1]];\n\n        dest[2] = cm[dest[2]];\n\n        dest[3] = cm[dest[3]];\n\n        dest[4] = cm[dest[4]];\n\n        dest[5] = cm[dest[5]];\n\n        dest[6] = cm[dest[6]];\n\n        dest[7] = cm[dest[7]];\n\n        dest += line_size;\n\n    }\n\n}\n", "idx": 4766, "substitutes": {"dest": ["them", "dc", "chain", "dat", "way", "save", "rel", "buf", "see", "d", "display", "addr", "dev", "ports", "alt", "comb", "iter", "transform", "comment", "tmp", "gest", "sum", "size", "origin", "coord", "di", "params", "loc", "source", "output", "success", "mem", "sort", "good", "server", "resource", "pipe", "reason", "master", "start", "out", "max", "v", "dim", "port", "scan", "local", "axis", "desc", "decl", "comp", "check", "trans", "copy", "src", "it", "end", "target", "dep", "shift", "msg", "del", "tr", "usr", "delete", "route", "rest", "host", "orig", "st", "ident", "nom", "all", "result", "sp", "match", "cp", "est", "cont", "table", "selected", "temp", "slice", "list", "opt", "Dest", "gate", "dist", "status", "spec", "ptr", "reverse", "search", "global", "transfer"], "line_size": ["line_pos", "Line_space", " line_SIZE", "line_Size", "Line_size", "line_start", "line_SIZE", " line_start", "line_space", "Line_pos", " line_Size"], "block": ["chain", "event", "copy", "conf", "type", "null", "pack", "cl", "field", "box", "set", "buffer", "map", "link", "row", "label", "line", "byte", "word", "ref", "list", "proc", "cell", "load", "config", "pixel", "scan", "rule", "bl", "point", "check", "lock", "Block", "image", "source", "bin"], "i": ["ic", "ini", "asi", "q", " bi", "ci", " ii", "it", "im", "c", " v", " ni", "gi", "mi", "qi", "ip", "li", "p", "si", "g", " n", "zi", "n", "ie", "xi", "ind", "index", " ti", "t", "pi", " err", "bi", "multi", "me", "ui", "ki", "phi", "ti", " pi", "iter", "v", "ims", "ix", " j", "ai", "m", "status", "I", "batch", "print", "ish", "sim", " k", "iu", "ex", "j", "x", "di", "ii"], "cm": ["cf", "dc", "form", "gc", "csv", "km", "ct", "mn", "ci", "fm", "cy", "um", "cp", "conf", "gm", "c", "iam", "asm", "gr", "cont", "mom", "CM", "comm", "mr", "arm", "wm", "fc", "med", "mt", "ms", "cut", "rum", "lc", "cc", "pm", "sem", "nm", "cn", "cr", "fine", "mb", "m", "cv", "mm", "disc", "cd", "ca", "mc", "mod", "hm", "vm", "ctr", "bm", "com", "ctrl", "ace", "rom", "ym", "rm", "tc", "mp"]}}
{"project": "qemu", "commit_id": "a01aedc8d32e6f5b08a4041b62be3c5fab7a3382", "target": 1, "func": "void object_property_add_bool(Object *obj, const char *name,\n\n                              bool (*get)(Object *, Error **),\n\n                              void (*set)(Object *, bool, Error **),\n\n                              Error **errp)\n\n{\n\n    BoolProperty *prop = g_malloc0(sizeof(*prop));\n\n\n\n    prop->get = get;\n\n    prop->set = set;\n\n\n\n    object_property_add(obj, name, \"bool\",\n\n                        get ? property_get_bool : NULL,\n\n                        set ? property_set_bool : NULL,\n\n                        property_release_bool,\n\n                        prop, errp);\n\n}\n", "idx": 4768, "substitutes": {"obj": ["ck", "this", "xy", "bj", " ob", "ctx", "objects", "sys", "pt", "nt", "ob", "self", "os", "bh", "ht", "rect", "inst", "og", "o", "hw", "phys", "js", "out", "oj", "org", "rb", "txt", "ot", "object", "Obj", "tmp", "y", "np", "ex", "j", "obs", "onet", "elt", "act"], "name": ["b", "prefix", "ns", "named", "term", "type", "ma", "p", "g", "base", "order", "ame", "n", "no", "len", "var", "property", "label", "key", "t", "str", "w", "id", "word", "attr", "nm", "normal", "v", "common", "m", "NAME", "part", "local", "f", "ex", "names", "title", "Name", "path"], "get": ["draw", "read", "export", "put", "et", "call", "pull", "it", "access", "end", "find", " Get", "gener", "msg", "force", "g", "p", "util", "cmd", "Get", "ge", "del", "full", "query", "let", "getting", "list", "pre", "gets", "entity", "handle", "select", "generic", "GET", "like", "secure", "build", "eval", "ret", "exec", "print", "show", "give", "maybe", "gen", "info", "check", "create", "got", "le"], "set": ["update", "open", "put", "et", "it", "end", "save", "place", "move", "edit", "apply", "store", "sys", "given", "force", "p", "ets", "add", "n", "use", "settings", "Set", "del", "ge", "sets", "full", "range", "value", "delete", "hide", "let", "list", "send", "en", "change", "handle", "reset", "sl", "ch", "sub", "clear", "st", "secure", "disable", "local", "parse", "make", "mod", "test", "ex", "gen", "hash", "write", "create", "SET", "ver"], "errp": [" erps", " errP", " erp", "errorpa", " errps", "erp", "erpr", "errps", "errr", " ErrP", "errpa", "errorP", " err", "erps", "err", "errorp", " erpr", " errpr", " Errp", " Errpa", "errP", " errpa", " errr", "errpo", "errorpo", " Errpo", " errpo", "errpr"], "prop": ["ph", "pid", "xy", "feat", "att", "po", "cp", "conf", "term", "pb", "ctx", "rep", "pro", "rel", "pt", "buf", "nt", "prot", "msg", "mk", "map", "p", "ps", "cmd", "plot", "pred", "op", "val", "property", "pl", " Prop", "key", "col", "pos", "bar", "proc", "list", "attr", "opt", "pr", "pkg", "kw", "acc", "fac", "properties", "cap", "orig", "cfg", "ch", "spec", "per", "tmp", "ptr", "lit", "priv", "jp", "rop", "pub", "mod", "supp", "fo", "bug", "info", " props", "comp", "j", "arr", "def", "Prop"]}}
{"project": "FFmpeg", "commit_id": "13705b69ebe9e375fdb52469760a0fbb5f593cc1", "target": 1, "func": "static inline int mirror(int v, int m){\n\n    if     (v<0) return -v;\n\n    else if(v>m) return 2*m-v;\n\n    else         return v;\n\n}\n", "idx": 4769, "substitutes": {"v": ["iv", "ev", "vv", "uv", "q", "b", "lv", "um", "im", "c", "u", "h", "av", "vi", "i", "vector", "ve", "mi", "d", "g", "p", "n", "vert", "vp", "val", "tv", "t", "pi", "va", "value", "sv", "qv", "k", "nv", "V", "vc", "vs", "version", "cv", "f", "vt", "conv", "wire", "vm", "j", "x", "ver", "l"], "m": ["q", "b", "mn", "gm", "c", "md", "h", "ma", "i", "M", "mi", "mr", "mk", "g", "p", "cm", "d", "mt", "tm", "n", "ms", "perm", "t", "r", "pm", "mu", "dm", "sm", "k", "mm", "mc", "f", "vm", "j", "bm", "esm", "l", "mp"]}}
{"project": "qemu", "commit_id": "cd7fdfe59f4f965665dcd9868fe3764f5256d6aa", "target": 1, "func": "void virtio_blk_data_plane_stop(VirtIOBlockDataPlane *s)\n\n{\n\n    if (!s->started) {\n\n        return;\n\n    }\n\n    s->started = false;\n\n    trace_virtio_blk_data_plane_stop(s);\n\n\n\n    /* Stop thread or cancel pending thread creation BH */\n\n    if (s->start_bh) {\n\n        qemu_bh_delete(s->start_bh);\n\n        s->start_bh = NULL;\n\n    } else {\n\n        event_poll_notify(&s->event_poll);\n\n        qemu_thread_join(&s->thread);\n\n    }\n\n\n\n    ioq_cleanup(&s->ioqueue);\n\n\n\n    s->vdev->binding->set_host_notifier(s->vdev->binding_opaque, 0, false);\n\n\n\n    event_poll_cleanup(&s->event_poll);\n\n\n\n    /* Clean up guest notifier (irq) */\n\n    s->vdev->binding->set_guest_notifiers(s->vdev->binding_opaque, 1, false);\n\n\n\n    vring_teardown(&s->vring);\n\n}\n", "idx": 4770, "substitutes": {"s": ["sw", "less", "sol", "h", "ps", "ports", "ts", "se", "t", "pers", "js", "w", "gets", "sb", "services", "ss", "changes", "sports", "comments", "params", "source", "rs", "ses", "results", "store", "my", "os", "g", "ms", "ains", "es", "an", "v", "stats", "m", "vs", "serv", "sis", "aws", "l", "ops", "gs", "ssl", "ns", "ats", "ies", "comm", "cs", "still", "p", "is", "r", "sv", "sm", "hs", "bs", "y", "sq", "parts", "fs", "S", "ssh", "b", "eps", "its", "i", "sys", "set", "qs", "als", "details", "n", "ds", "ins", "syn", "ls", "ims", "ties", "args", "sl", "spec", "states", "sts"]}}
{"project": "FFmpeg", "commit_id": "ddef3d902f0e4cbd6be6b3e5df7ec158ce51488b", "target": 1, "func": "static int mov_write_tkhd_tag(AVIOContext *pb, MOVMuxContext *mov,\n\n                              MOVTrack *track, AVStream *st)\n\n{\n\n    int64_t duration = av_rescale_rnd(track->track_duration, MOV_TIMESCALE,\n\n                                      track->timescale, AV_ROUND_UP);\n\n    int version = duration < INT32_MAX ? 0 : 1;\n\n    int flags   = MOV_TKHD_FLAG_IN_MOVIE;\n\n    int rotation = 0;\n\n    int group   = 0;\n\n\n\n    uint32_t *display_matrix = NULL;\n\n    int      display_matrix_size, i;\n\n\n\n    if (st) {\n\n        if (mov->per_stream_grouping)\n\n            group = st->index;\n\n        else\n\n            group = st->codecpar->codec_type;\n\n\n\n        display_matrix = (uint32_t*)av_stream_get_side_data(st, AV_PKT_DATA_DISPLAYMATRIX,\n\n                                                            &display_matrix_size);\n\n        if (display_matrix && display_matrix_size < 9 * sizeof(*display_matrix))\n\n            display_matrix = NULL;\n\n    }\n\n\n\n    if (track->flags & MOV_TRACK_ENABLED)\n\n        flags |= MOV_TKHD_FLAG_ENABLED;\n\n\n\n    if (track->mode == MODE_ISM)\n\n        version = 1;\n\n\n\n    (version == 1) ? avio_wb32(pb, 104) : avio_wb32(pb, 92); /* size */\n\n    ffio_wfourcc(pb, \"tkhd\");\n\n    avio_w8(pb, version);\n\n    avio_wb24(pb, flags);\n\n    if (version == 1) {\n\n        avio_wb64(pb, track->time);\n\n        avio_wb64(pb, track->time);\n\n    } else {\n\n        avio_wb32(pb, track->time); /* creation time */\n\n        avio_wb32(pb, track->time); /* modification time */\n\n    }\n\n    avio_wb32(pb, track->track_id); /* track-id */\n\n    avio_wb32(pb, 0); /* reserved */\n\n    if (!track->entry && mov->mode == MODE_ISM)\n\n        (version == 1) ? avio_wb64(pb, UINT64_C(0xffffffffffffffff)) : avio_wb32(pb, 0xffffffff);\n\n    else if (!track->entry)\n\n        (version == 1) ? avio_wb64(pb, 0) : avio_wb32(pb, 0);\n\n    else\n\n        (version == 1) ? avio_wb64(pb, duration) : avio_wb32(pb, duration);\n\n\n\n    avio_wb32(pb, 0); /* reserved */\n\n    avio_wb32(pb, 0); /* reserved */\n\n    avio_wb16(pb, 0); /* layer */\n\n    avio_wb16(pb, group); /* alternate group) */\n\n    /* Volume, only for audio */\n\n    if (track->par->codec_type == AVMEDIA_TYPE_AUDIO)\n\n        avio_wb16(pb, 0x0100);\n\n    else\n\n        avio_wb16(pb, 0);\n\n    avio_wb16(pb, 0); /* reserved */\n\n\n\n    /* Matrix structure */\n\n\n    if (st && st->metadata) {\n\n        AVDictionaryEntry *rot = av_dict_get(st->metadata, \"rotate\", NULL, 0);\n\n        rotation = (rot && rot->value) ? atoi(rot->value) : 0;\n\n    }\n\n\n    if (display_matrix) {\n\n        for (i = 0; i < 9; i++)\n\n            avio_wb32(pb, display_matrix[i]);\n\n\n    } else if (rotation == 90) {\n\n        write_matrix(pb,  0,  1, -1,  0, track->par->height, 0);\n\n    } else if (rotation == 180) {\n\n        write_matrix(pb, -1,  0,  0, -1, track->par->width, track->par->height);\n\n    } else if (rotation == 270) {\n\n        write_matrix(pb,  0, -1,  1,  0, 0, track->par->width);\n\n\n    } else {\n\n        write_matrix(pb,  1,  0,  0,  1, 0, 0);\n\n    }\n\n    /* Track width and height, for visual only */\n\n    if (st && (track->par->codec_type == AVMEDIA_TYPE_VIDEO ||\n\n               track->par->codec_type == AVMEDIA_TYPE_SUBTITLE)) {\n\n        int64_t track_width_1616;\n\n        if (track->mode == MODE_MOV) {\n\n            track_width_1616 = track->par->width * 0x10000ULL;\n\n        } else {\n\n            track_width_1616 = av_rescale(st->sample_aspect_ratio.num,\n\n                                                  track->par->width * 0x10000LL,\n\n                                                  st->sample_aspect_ratio.den);\n\n            if (!track_width_1616 ||\n\n                track->height != track->par->height ||\n\n                track_width_1616 > UINT32_MAX)\n\n                track_width_1616 = track->par->width * 0x10000ULL;\n\n        }\n\n        if (track_width_1616 > UINT32_MAX) {\n\n            av_log(mov->fc, AV_LOG_WARNING, \"track width is too large\\n\");\n\n            track_width_1616 = 0;\n\n        }\n\n        avio_wb32(pb, track_width_1616);\n\n        if (track->height > 0xFFFF) {\n\n            av_log(mov->fc, AV_LOG_WARNING, \"track height is too large\\n\");\n\n            avio_wb32(pb, 0);\n\n        } else\n\n            avio_wb32(pb, track->height * 0x10000U);\n\n    } else {\n\n        avio_wb32(pb, 0);\n\n        avio_wb32(pb, 0);\n\n    }\n\n    return 0x5c;\n\n}", "idx": 4781, "substitutes": {"pb": ["stab", "peer", "uf", "sp", "gc", "pel", "bj", "wp", "cp", "conf", "rpm", "pc", "ctx", "bc", "pro", "buf", "pt", "px", "p", "bp", "orp", "vp", "typ", "cb", "erb", "fp", "wb", "func", "aus", "lb", "cc", "pm", "ub", "bb", "pg", "pkg", "proc", "pr", "sb", "lp", "rb", "bps", "emb", "resp", "tab", "bs", "nb", "tmp", "cv", "tx", "fb", "pool", "jp", "np", "amp", "dp", "PB", "pp", "patch", "tk", "tp", "tc", "mp"], "mov": ["smav", "mOV", "Mov", "smOV", "cmov", "movi", "move", "cmOV", "mutote", "smote", "mote", "smovi", "mav", " mav", " move", "Mav", "Move", " mOV", " movi", "mutove", "cmote", "smove", "MOV", "mutOV", "cmovi", "mutov", "cmove", "cmav", "smov"], "track": ["train", "vr", "form", "match", "setup", "task", "src", "metadata", "run", "move", "met", "find", "pt", "store", "set", "runtime", "sort", "skip", "trak", "stat", "add", "seek", "tm", "rank", "round", "mt", "sync", "tr", "row", "review", "t", "history", "follow", "r", "trace", "dr", "rack", "record", "tag", "tracking", "rr", "stall", "claim", "transform", "Track", "rt", "ack", "stream", "tab", "comment", "tmp", "report", "batch", "tf", "kick", "session", "search", "trip", "time", "check", "info", "roll", "tp", "rm", "disable"], "st": ["so", "sp", "sw", "ct", "src", "sth", "step", "stage", "ctx", "cont", "pt", "nd", "sc", "store", "state", "nt", "inst", "mt", "stat", "std", "tr", "irst", "se", "t", "stack", "r", "stop", "str", "th", "mont", "sv", "sm", "rest", "start", "station", "rt", "sl", "stream", "sn", "tmp", "stable", "ist", "ST", "cur", "ste", "td", "sts", "sta", "ost", "St"], "display_matrix": ["display_formatric", "display_managerication", "display_manrie", "display_formatix", "display_atrix", "display_managerMatrix", "display_mrices", "display_formatMatrix", "display_nonrie", "display_mrix", "display_managerrices", "display_dimrix", "display_manMatrix", "display_dimMatrix", "display_mitric", "display_formattx", "display_atrie", "display_nonrix", "display_manrices", "display_metrix", "display_mitrices", "display_mMatrix", "display_mattx", "display_matix", "display_matrie", "display_matrices", "display_formatication", "display_formatrix", "display_nonrices", "display_metrices", "display_matication", "display_manrix", "display_metric", "display_atix", "display_managerrix", "display_mitix", "display_dimrices", "display_mettx", "display_atMatrix", "display_matMatrix", "display_atication", "display_formatrices", "display_atric", "display_mittx", "display_atrices", "display_matric", "display_mitrix"], "display_matrix_size": ["display_matrices_sum", "display_matrix_Size", "display_matrices_data", "display_matrix_sum", "display_matrices_size", "display_matrix_data", "display_matrices_set", "display_matrices_SIZE", "display_matrix_SIZE", "display_matrices_Size", "display_matrix_len", "display_matrix_set", "display_matrices_len"], "i": ["c", "ip", "p", "si", "d", "g", "n", "ind", "index", "t", "pi", "slice", "id", "k", "s", "v", "ix", "port", "m", "I", "f", "in", "j", "z", "di", "x", "ii"]}}
{"project": "FFmpeg", "commit_id": "4189fe11ffcbdcd311eb9a3437586a94492c4cde", "target": 1, "func": "static int vobsub_read_seek(AVFormatContext *s, int stream_index,\n\n                            int64_t min_ts, int64_t ts, int64_t max_ts, int flags)\n\n{\n\n    MpegDemuxContext *vobsub = s->priv_data;\n\n\n\n    /* Rescale requested timestamps based on the first stream (timebase is the\n\n     * same for all subtitles stream within a .idx/.sub). Rescaling is done just\n\n     * like in avformat_seek_file(). */\n\n    if (stream_index == -1 && s->nb_streams != 1) {\n\n        int i, ret = 0;\n\n        AVRational time_base = s->streams[0]->time_base;\n\n        ts = av_rescale_q(ts, AV_TIME_BASE_Q, time_base);\n\n        min_ts = av_rescale_rnd(min_ts, time_base.den,\n\n                                time_base.num * (int64_t)AV_TIME_BASE,\n\n                                AV_ROUND_UP   | AV_ROUND_PASS_MINMAX);\n\n        max_ts = av_rescale_rnd(max_ts, time_base.den,\n\n                                time_base.num * (int64_t)AV_TIME_BASE,\n\n                                AV_ROUND_DOWN | AV_ROUND_PASS_MINMAX);\n\n        for (i = 0; i < s->nb_streams; i++) {\n\n            int r = ff_subtitles_queue_seek(&vobsub->q[i], s, stream_index,\n\n                                            min_ts, ts, max_ts, flags);\n\n            if (r < 0)\n\n                ret = r;\n\n        }\n\n        return ret;\n\n    }\n\n\n\n\n\n    return ff_subtitles_queue_seek(&vobsub->q[stream_index], s, stream_index,\n\n                                   min_ts, ts, max_ts, flags);\n\n}", "idx": 4798, "substitutes": {"s": ["as", "rs", "gs", "b", "less", "ns", "c", "its", "eps", "ats", "acs", "h", "sys", "qs", "cs", "comm", "sc", "self", "https", "os", "ps", "p", "ms", "als", "n", "g", "is", "ds", "t", "es", "w", "js", "ins", "sv", "ls", "sb", "scl", "v", "m", "spec", "hs", "a", "ss", "bs", "sq", "fs", "ex", "S", "sts", "sports", "aws"], "stream_index": ["streamIdinstance", "file_ind", "video_Index", "stream_weight", "streamIdIndex", "streamingindex", "streamitymix", "streamationlist", "fileingconnection", "videoitymix", " stream_request", "stream_Index", "streamityIndex", "line_weight", "stream_loop", "streamityindex", "streamationIndex", "streamingdistance", "stream_ind", "lineIdIndex", "stream_list", "video_chain", "video_index", " stream_ind", " stream_loop", "streamNameinstance", "stream___connection", " stream_list", "file_index", "stream_request", "streamIdweight", "video_mix", "line_Index", "streamitychain", "stream_distance", "videoitychain", "stream_instance", " stream_id", "stream_id", "streamingind", "stream8mix", "file_distance", "streamNameweight", "streamationind", "line_instance", "stream8loop", "stream___distance", "lineIdinstance", "streamNameIndex", "videoityIndex", "streamationrequest", "lineIdweight", "stream_mix", "stream8index", "stream8Index", "stream8chain", "videoityindex", "streamationid", "fileingindex", "stream___ind", "file_connection", "stream___index", "line_index", "streamNameindex", "lineIdindex", "stream_chain", "streamIdindex", "fileingdistance", "fileingind", " stream_Index", "streamationloop", "streamationindex", "stream_connection", "streamingconnection", "stream8request"], "min_ts": [" min_ms", "min_fs", "min_posts", "mintids", "minlyts", "emin_ts", "minPmt", "min_ls", "min___posts", "min_ms", "minlyls", "minEts", "minute_td", "minimfs", "minEtd", "minimds", "min_ds", "minuteEmt", "minEmt", "minute_tes", "minlyats", "midlymt", "mid_mt", "mid_ids", "mid_ats", "minlymt", "midlyids", "minuteEtd", "mintats", "eminlytimes", "eminlyts", " min_posts", "midlyats", "eminlyats", "mid_ts", "minPts", "min_times", "minlyids", "minimts", "min_mt", "min_ats", "minPats", "minute_ts", "emin_ls", "minptts", "min_td", "minlytimes", "mintts", "minptms", "emin_times", " min_mt", "min___ms", "min_ids", "min___ts", "eminlyls", "minptmt", "min_tes", "minptposts", " min_ds", "minute_mt", "min___mt", "mintmt", "minEtes", "emin_ats", "minuteEts", "minPids", "minuteEtes", " min_fs", "midlyts", "minimposts"], "ts": ["rs", "gs", "points", "times", "tes", "ns", "ics", "fts", "its", "amps", "ats", "tp", "ints", "qs", "pt", "cs", "Ts", "aps", "TS", "ps", "ets", "als", "ms", "mt", "tm", "rets", "ports", "uts", "ds", "tim", "inters", "t", "wt", "aints", "vals", "tips", "js", "ens", "ins", "atts", "ls", "xs", "ents", "ims", "tz", "outs", "stats", "txt", "lt", "vs", "bs", "tx", "fs", "ems", "posts", "td", "sts", "stones", "mods", "tt", "elt"], "max_ts": ["max_ets", "max12mt", "max8ts", "total_times", " max_tes", "max_mt", "max8amps", "max2times", "max_amps", "max_t", "min_cs", "prime_ts", "max__times", "max_ls", "prime_amps", "max_ps", "max8sts", "max2t", "max_times", "max2ds", "max_sts", "total_tz", "prime_sts", " max_t", "total_ls", "total_ts", " max_ps", "max_tes", "max12tes", "prime_ets", "max_ds", "max__ds", "max_cs", "max12ts", "max8ets", "max_tz", " max_mt", "max2ts", "min_t", "max__t", "min_tes", " max_ds", " max_times", "max__ts", "max12ps"], "flags": ["members", "cf", "fields", "alf", "weights", "xf", "fee", " Flags", "wcs", "amps", " fmt", "ags", "ats", "locks", "fits", "files", "acts", "ensions", "pins", "ps", "cmd", "ms", "details", "uts", "fps", " options", "func", "types", "aints", "options", "atts", "orts", "comments", "Flag", "tags", "args", "bits", "FLAG", "Flags", "cond", "lag", "fs", "heads", "posts", "doms", "nl", "features", " flag", "faces", "flag"], "vobsub": [" vobdata", "vobrec", "vobbyrec", "vobssub", "vobbysub", "avobweb", "veembsel", "vembsub", "vobbot", "voybatch", "avobrc", "veobsel", "vorgjob", " vobbdata", "veobsub", "vobjob", "vembsel", "veobbatch", "veembjob", "vembjob", "voyrc", "vobsweb", "vobsdata", "vobweb", " vobub", "avoyweb", "vorgsel", " vobbsub", "avoyrec", "vobbub", "voysub", "veembbatch", "vobsbot", "vobbbot", "vobbsub", "vobsrec", " vobbub", "avobsub", "vobbyweb", " vobbot", "vobub", "vorgsub", "avoyrc", "voyrec", "voberbot", "voyweb", "vobsrc", "vobbdata", "veembsub", "vobrc", "vorgbatch", "vobdata", "voysel", " vobbbot", "avoysub", "voberub", "vobbyrc", "vobsel", "vembbatch", "veobjob", "vobersub", "voberdata", "voyjob", "avobrec", "vobbatch"], "i": ["ic", "ini", "ij", "q", "ei", "chain", "ci", "uri", "it", "jj", "im", "c", "cli", "oi", "gi", "mi", "qi", "ip", "li", "p", "si", "zi", "n", "is", "iq", "ind", "xi", "index", "t", "hi", "pi", "multi", "r", "bi", "ri", "me", "id", "ui", "ki", "ji", "k", "phi", "ir", "iter", "ti", "v", "ix", "ai", "m", "I", "batch", "y", "\u0438", "sim", "gu", "info", "e", "in", "iu", "j", "x", "di", "ii", "l"]}}
{"project": "FFmpeg", "commit_id": "c177f2ec4a21d62fdefd925ad69c24a2f9dad303", "target": 0, "func": "static av_cold int aac_encode_init(AVCodecContext *avctx)\n\n{\n\n    AACContext *s = avctx->priv_data;\n\n    int ret = AVERROR(EINVAL);\n\n    AACENC_InfoStruct info = { 0 };\n\n    CHANNEL_MODE mode;\n\n    AACENC_ERROR err;\n\n    int aot = FF_PROFILE_AAC_LOW + 1;\n\n    int sce = 0, cpe = 0;\n\n\n\n    if ((err = aacEncOpen(&s->handle, 0, avctx->channels)) != AACENC_OK) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Unable to open the encoder: %s\\n\",\n\n               aac_get_error(err));\n\n        goto error;\n\n    }\n\n\n\n    if (avctx->profile != FF_PROFILE_UNKNOWN)\n\n        aot = avctx->profile + 1;\n\n\n\n    if ((err = aacEncoder_SetParam(s->handle, AACENC_AOT, aot)) != AACENC_OK) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Unable to set the AOT %d: %s\\n\",\n\n               aot, aac_get_error(err));\n\n        goto error;\n\n    }\n\n\n\n    if (aot == FF_PROFILE_AAC_ELD + 1 && s->eld_sbr) {\n\n        if ((err = aacEncoder_SetParam(s->handle, AACENC_SBR_MODE,\n\n                                       1)) != AACENC_OK) {\n\n            av_log(avctx, AV_LOG_ERROR, \"Unable to enable SBR for ELD: %s\\n\",\n\n                   aac_get_error(err));\n\n            goto error;\n\n        }\n\n    }\n\n\n\n    if ((err = aacEncoder_SetParam(s->handle, AACENC_SAMPLERATE,\n\n                                   avctx->sample_rate)) != AACENC_OK) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Unable to set the sample rate %d: %s\\n\",\n\n               avctx->sample_rate, aac_get_error(err));\n\n        goto error;\n\n    }\n\n\n\n    switch (avctx->channels) {\n\n    case 1: mode = MODE_1;       sce = 1; cpe = 0; break;\n\n    case 2: mode = MODE_2;       sce = 0; cpe = 1; break;\n\n    case 3: mode = MODE_1_2;     sce = 1; cpe = 1; break;\n\n    case 4: mode = MODE_1_2_1;   sce = 2; cpe = 1; break;\n\n    case 5: mode = MODE_1_2_2;   sce = 1; cpe = 2; break;\n\n    case 6: mode = MODE_1_2_2_1; sce = 2; cpe = 2; break;\n\n    default:\n\n        av_log(avctx, AV_LOG_ERROR,\n\n               \"Unsupported number of channels %d\\n\", avctx->channels);\n\n        goto error;\n\n    }\n\n\n\n    if ((err = aacEncoder_SetParam(s->handle, AACENC_CHANNELMODE,\n\n                                   mode)) != AACENC_OK) {\n\n        av_log(avctx, AV_LOG_ERROR,\n\n               \"Unable to set channel mode %d: %s\\n\", mode, aac_get_error(err));\n\n        goto error;\n\n    }\n\n\n\n    if ((err = aacEncoder_SetParam(s->handle, AACENC_CHANNELORDER,\n\n                                   1)) != AACENC_OK) {\n\n        av_log(avctx, AV_LOG_ERROR,\n\n               \"Unable to set wav channel order %d: %s\\n\",\n\n               mode, aac_get_error(err));\n\n        goto error;\n\n    }\n\n\n\n    if (avctx->flags & CODEC_FLAG_QSCALE || s->vbr) {\n\n        int mode = s->vbr ? s->vbr : avctx->global_quality;\n\n        if (mode <  1 || mode > 5) {\n\n            av_log(avctx, AV_LOG_WARNING,\n\n                   \"VBR quality %d out of range, should be 1-5\\n\", mode);\n\n            mode = av_clip(mode, 1, 5);\n\n        }\n\n        av_log(avctx, AV_LOG_WARNING,\n\n               \"Note, the VBR setting is unsupported and only works with \"\n\n               \"some parameter combinations\\n\");\n\n        if ((err = aacEncoder_SetParam(s->handle, AACENC_BITRATEMODE,\n\n                                       mode)) != AACENC_OK) {\n\n            av_log(avctx, AV_LOG_ERROR, \"Unable to set the VBR bitrate mode %d: %s\\n\",\n\n                   mode, aac_get_error(err));\n\n            goto error;\n\n        }\n\n    } else {\n\n        if (avctx->bit_rate <= 0) {\n\n            if (avctx->profile == FF_PROFILE_AAC_HE_V2) {\n\n                sce = 1;\n\n                cpe = 0;\n\n            }\n\n            avctx->bit_rate = (96*sce + 128*cpe) * avctx->sample_rate / 44;\n\n            if (avctx->profile == FF_PROFILE_AAC_HE ||\n\n                avctx->profile == FF_PROFILE_AAC_HE_V2 ||\n\n                s->eld_sbr)\n\n                avctx->bit_rate /= 2;\n\n        }\n\n        if ((err = aacEncoder_SetParam(s->handle, AACENC_BITRATE,\n\n                                       avctx->bit_rate)) != AACENC_OK) {\n\n            av_log(avctx, AV_LOG_ERROR, \"Unable to set the bitrate %d: %s\\n\",\n\n                   avctx->bit_rate, aac_get_error(err));\n\n            goto error;\n\n        }\n\n    }\n\n\n\n    /* Choose bitstream format - if global header is requested, use\n\n     * raw access units, otherwise use ADTS. */\n\n    if ((err = aacEncoder_SetParam(s->handle, AACENC_TRANSMUX,\n\n                                   avctx->flags & CODEC_FLAG_GLOBAL_HEADER ? 0 : s->latm ? 10 : 2)) != AACENC_OK) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Unable to set the transmux format: %s\\n\",\n\n               aac_get_error(err));\n\n        goto error;\n\n    }\n\n\n\n    if (s->latm && s->header_period) {\n\n        if ((err = aacEncoder_SetParam(s->handle, AACENC_HEADER_PERIOD,\n\n                                       s->header_period)) != AACENC_OK) {\n\n             av_log(avctx, AV_LOG_ERROR, \"Unable to set header period: %s\\n\",\n\n                    aac_get_error(err));\n\n             goto error;\n\n        }\n\n    }\n\n\n\n    /* If no signaling mode is chosen, use explicit hierarchical signaling\n\n     * if using mp4 mode (raw access units, with global header) and\n\n     * implicit signaling if using ADTS. */\n\n    if (s->signaling < 0)\n\n        s->signaling = avctx->flags & CODEC_FLAG_GLOBAL_HEADER ? 2 : 0;\n\n\n\n    if ((err = aacEncoder_SetParam(s->handle, AACENC_SIGNALING_MODE,\n\n                                   s->signaling)) != AACENC_OK) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Unable to set signaling mode %d: %s\\n\",\n\n               s->signaling, aac_get_error(err));\n\n        goto error;\n\n    }\n\n\n\n    if ((err = aacEncoder_SetParam(s->handle, AACENC_AFTERBURNER,\n\n                                   s->afterburner)) != AACENC_OK) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Unable to set afterburner to %d: %s\\n\",\n\n               s->afterburner, aac_get_error(err));\n\n        goto error;\n\n    }\n\n\n\n    if (avctx->cutoff > 0) {\n\n        if (avctx->cutoff < (avctx->sample_rate + 255) >> 8) {\n\n            av_log(avctx, AV_LOG_ERROR, \"cutoff valid range is %d-20000\\n\",\n\n                   (avctx->sample_rate + 255) >> 8);\n\n            goto error;\n\n        }\n\n        if ((err = aacEncoder_SetParam(s->handle, AACENC_BANDWIDTH,\n\n                                       avctx->cutoff)) != AACENC_OK) {\n\n            av_log(avctx, AV_LOG_ERROR, \"Unable to set the encoder bandwidth to %d: %s\\n\",\n\n                   avctx->cutoff, aac_get_error(err));\n\n            goto error;\n\n        }\n\n    }\n\n\n\n    if ((err = aacEncEncode(s->handle, NULL, NULL, NULL, NULL)) != AACENC_OK) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Unable to initialize the encoder: %s\\n\",\n\n               aac_get_error(err));\n\n        return AVERROR(EINVAL);\n\n    }\n\n\n\n    if ((err = aacEncInfo(s->handle, &info)) != AACENC_OK) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Unable to get encoder info: %s\\n\",\n\n               aac_get_error(err));\n\n        goto error;\n\n    }\n\n\n\n#if FF_API_OLD_ENCODE_AUDIO\n\n    avctx->coded_frame = avcodec_alloc_frame();\n\n    if (!avctx->coded_frame) {\n\n        ret = AVERROR(ENOMEM);\n\n        goto error;\n\n    }\n\n#endif\n\n    avctx->frame_size = info.frameLength;\n\n    avctx->delay      = info.encoderDelay;\n\n    ff_af_queue_init(avctx, &s->afq);\n\n\n\n    if (avctx->flags & CODEC_FLAG_GLOBAL_HEADER) {\n\n        avctx->extradata_size = info.confSize;\n\n        avctx->extradata      = av_mallocz(avctx->extradata_size +\n\n                                           FF_INPUT_BUFFER_PADDING_SIZE);\n\n        if (!avctx->extradata) {\n\n            ret = AVERROR(ENOMEM);\n\n            goto error;\n\n        }\n\n\n\n        memcpy(avctx->extradata, info.confBuf, info.confSize);\n\n    }\n\n    return 0;\n\nerror:\n\n    aac_encode_close(avctx);\n\n    return ret;\n\n}\n", "idx": 4800, "substitutes": {"avctx": ["avsc", "ajsetup", "cvctx", "avegc", "AVctx", "avheight", "ravjp", " avcmp", "avtmp", "vrctx", "averconf", "ajctx", " avhistory", "avertmp", "ravcu", "ravctx", "avcontext", "AVsc", "avcv", "ajjp", "ajpy", "avecv", "avcu", "avkt", "iverparent", "averpy", "averctx", "avnp", "AVcmp", "AVcontext", "ajcu", "averpkg", "navdt", " avjp", "avercookie", "ajsys", "ravdict", "vrpkg", "ivercontext", "aveconf", "cvcontext", "avdt", "ajcontext", "iverpy", "vrcv", "avecontext", "avcookie", "varcookie", "navctx", "avparams", "avhistory", "avectx", "wavctx", "cvtx", "ravconf", "avgc", "avconf", " avkw", "ravparams", "cvkw", " avcookie", "navhistory", "avca", "avpkg", "varcontext", " avheight", "averparent", "wavnp", "avesys", "ravcv", "aveca", "iverheight", "ravca", "avtx", "avparent", " avkt", "avergc", "ajparent", "ravheight", " avcontext", "wavgc", "avercu", "avercontext", "aversc", " avdict", "avekw", " avtx", "iverctx", "averjp", "ajhistory", "wavtx", " avtmp", "avsetup", "avehistory", "avercmp", "ajparams", "ivertx", "avsys", "avercv", " avsys", "avdict", "iverdict", "averparams", "avjp", "avetx", "ajkt", "varctx", "aversetup", "avedt", "vartmp", "avenp", "vrgc", "averhistory", "iversetup", " avsc", "ivergc", "avcmp", "ravcontext", "avekt", "avepkg", "averca", "ajdt", "navsys", "ivernp", "avkw", "avpy"], "s": ["rs", "gs", "ses", "ns", "c", "its", "ctx", "ats", "h", "sam", "ies", "sys", "qs", "set", "cs", "sc", "self", "os", "p", "d", "ms", "ps", "is", "ts", "ds", "t", "es", "js", "w", "ins", "sv", "ls", "sm", "sb", "scl", "v", "stats", "sa", "hs", "vs", "ss", "bs", "y", "sq", "fs", "ys", "S", "sts", "j", "sports", "a", "source"], "mode": ["policy", "mate", "error", "power", "metadata", "channel", " scheme", "type", "stage", "direction", "cmp", "scope", "multiple", "kind", "Mode", "state", "only", "toggle", "mid", "purpose", "cmd", "use", "option", "key", "multi", "scale", "position", "me", "module", "proc", "role", "theme", "device", "style", "master", "code", "dim", "command", "status", "m", "config", "spec", "MODE", "pose", "version", "mm", "mask", "mod", "message", "loop", "operator", "phase", "nom", "format", "door", "params", "menu", "name", "sequence"], "err": [" res", "conf", "c", "kr", "late", "gr", "aaa", "die", "ler", "dev", "or", "t", "js", "iter", "cr", "txt", "req", "ch", "later", "test", "Error", "elt", "lr", "ger", "nr", "rn", "er", "norm", "dt", "notice", "good", "out", "report", "cer", "rer", "ev", "error", "it", "cor", "msg", "mr", "timer", "ez", "tr", "usr", "r", "dr", "rev", "rr", "attr", "try", "cfg", "fr", "res", "ver", " terr", "all", "result", "Er", "fee", "here", " msg", "eas", "sys", "erd", "cmd", " error", "ner", "resp", "off", "gz", "obj", "e", "z", "arr", "warn"]}}
{"project": "FFmpeg", "commit_id": "24947d4988012f1f0fd467c83418615adc11c3e8", "target": 1, "func": "static int vorbis_floor1_decode(vorbis_context *vc,\n\n                                vorbis_floor_data *vfu, float *vec)\n\n{\n\n    vorbis_floor1 *vf = &vfu->t1;\n\n    GetBitContext *gb = &vc->gb;\n\n    uint16_t range_v[4] = { 256, 128, 86, 64 };\n\n    unsigned range = range_v[vf->multiplier - 1];\n\n    uint16_t floor1_Y[258];\n\n    uint16_t floor1_Y_final[258];\n\n    int floor1_flag[258];\n\n    unsigned class, cdim, cbits, csub, cval, offset, i, j;\n\n    int book, adx, ady, dy, off, predicted, err;\n\n\n\n\n\n    if (!get_bits1(gb)) // silence\n\n        return 1;\n\n\n\n// Read values (or differences) for the floor's points\n\n\n\n    floor1_Y[0] = get_bits(gb, ilog(range - 1));\n\n    floor1_Y[1] = get_bits(gb, ilog(range - 1));\n\n\n\n    av_dlog(NULL, \"floor 0 Y %d floor 1 Y %d \\n\", floor1_Y[0], floor1_Y[1]);\n\n\n\n    offset = 2;\n\n    for (i = 0; i < vf->partitions; ++i) {\n\n        class = vf->partition_class[i];\n\n        cdim   = vf->class_dimensions[class];\n\n        cbits  = vf->class_subclasses[class];\n\n        csub = (1 << cbits) - 1;\n\n        cval = 0;\n\n\n\n        av_dlog(NULL, \"Cbits %u\\n\", cbits);\n\n\n\n        if (cbits) // this reads all subclasses for this partition's class\n\n            cval = get_vlc2(gb, vc->codebooks[vf->class_masterbook[class]].vlc.table,\n\n                            vc->codebooks[vf->class_masterbook[class]].nb_bits, 3);\n\n\n\n        for (j = 0; j < cdim; ++j) {\n\n            book = vf->subclass_books[class][cval & csub];\n\n\n\n            av_dlog(NULL, \"book %d Cbits %u cval %u  bits:%d\\n\",\n\n                    book, cbits, cval, get_bits_count(gb));\n\n\n\n            cval = cval >> cbits;\n\n            if (book > -1) {\n\n                floor1_Y[offset+j] = get_vlc2(gb, vc->codebooks[book].vlc.table,\n\n                vc->codebooks[book].nb_bits, 3);\n\n            } else {\n\n                floor1_Y[offset+j] = 0;\n\n            }\n\n\n\n            av_dlog(NULL, \" floor(%d) = %d \\n\",\n\n                    vf->list[offset+j].x, floor1_Y[offset+j]);\n\n        }\n\n        offset+=cdim;\n\n    }\n\n\n\n// Amplitude calculation from the differences\n\n\n\n    floor1_flag[0] = 1;\n\n    floor1_flag[1] = 1;\n\n    floor1_Y_final[0] = floor1_Y[0];\n\n    floor1_Y_final[1] = floor1_Y[1];\n\n\n\n    for (i = 2; i < vf->x_list_dim; ++i) {\n\n        unsigned val, highroom, lowroom, room, high_neigh_offs, low_neigh_offs;\n\n\n\n        low_neigh_offs  = vf->list[i].low;\n\n        high_neigh_offs = vf->list[i].high;\n\n        dy  = floor1_Y_final[high_neigh_offs] - floor1_Y_final[low_neigh_offs];  // render_point begin\n\n        adx = vf->list[high_neigh_offs].x - vf->list[low_neigh_offs].x;\n\n        ady = FFABS(dy);\n\n        err = ady * (vf->list[i].x - vf->list[low_neigh_offs].x);\n\n        off = err / adx;\n\n        if (dy < 0) {\n\n            predicted = floor1_Y_final[low_neigh_offs] - off;\n\n        } else {\n\n            predicted = floor1_Y_final[low_neigh_offs] + off;\n\n        } // render_point end\n\n\n\n        val = floor1_Y[i];\n\n        highroom = range-predicted;\n\n        lowroom  = predicted;\n\n        if (highroom < lowroom) {\n\n            room = highroom * 2;\n\n        } else {\n\n            room = lowroom * 2;   // SPEC mispelling\n\n        }\n\n        if (val) {\n\n            floor1_flag[low_neigh_offs]  = 1;\n\n            floor1_flag[high_neigh_offs] = 1;\n\n            floor1_flag[i]               = 1;\n\n            if (val >= room) {\n\n                if (highroom > lowroom) {\n\n                    floor1_Y_final[i] = val - lowroom + predicted;\n\n                } else {\n\n                    floor1_Y_final[i] = predicted - val + highroom - 1;\n\n                }\n\n            } else {\n\n                if (val & 1) {\n\n                    floor1_Y_final[i] = predicted - (val + 1) / 2;\n\n                } else {\n\n                    floor1_Y_final[i] = predicted + val / 2;\n\n                }\n\n            }\n\n        } else {\n\n            floor1_flag[i]    = 0;\n\n            floor1_Y_final[i] = predicted;\n\n        }\n\n\n\n        av_dlog(NULL, \" Decoded floor(%d) = %u / val %u\\n\",\n\n                vf->list[i].x, floor1_Y_final[i], val);\n\n    }\n\n\n\n// Curve synth - connect the calculated dots and convert from dB scale FIXME optimize ?\n\n\n\n    ff_vorbis_floor1_render_list(vf->list, vf->x_list_dim, floor1_Y_final, floor1_flag, vf->multiplier, vec, vf->list[1].x);\n\n\n\n    av_dlog(NULL, \" Floor decoded\\n\");\n\n\n\n    return 0;\n\n}\n", "idx": 4801, "substitutes": {"vc": ["iv", "gt", "vv", "vy", "vr", "uv", "csv", "ic", "lv", "voc", "c", "wcs", "pc", "ctx", "av", "ib", "bc", "vi", "cow", "fc", "ht", "inv", "vp", "vin", "cb", "tv", "lc", "GV", "xc", "vl", "cc", "sv", "veh", "v", "VC", "vo", "nv", "vd", "vg", "vs", "serv", "cv", "vt", "conv", "vm", "cu", "vet", "fw"], "vfu": ["mrf", "svau", "svFu", "vcau", " vau", "mfu", " vpu", " vrf", "vFu", "svbo", "vrf", "vpu", "mbo", "svpu", " vFu", "vau", " vbo", "svfu", "vbo", "svrf", "vcpu", "mFu", "vcfu"], "vec": ["iv", "ev", "cod", "uv", "xy", "ff", "cam", "buf", "vid", "vector", "ve", "fc", "ec", "len", "tv", "sel", "ref", "pos", "sv", "v", "nv", "cv", "ver", "def"], "vf": [" vfc", "devff", "vcbf", "ovf", "svc", " vF", "vfal", "ovfs", " vfx", "cvfac", "vcfa", " vfs", "versionfal", "Vfc", "svfal", "avc", "vfc", "cfs", "vrfc", "ovfd", "svcf", "versionfs", "vfo", "vcfunc", "invlf", "vrc", "avf", "devf", "vtf", "verfc", "vrfac", "vtlf", "vfd", "svfl", "vrff", "svfd", " vfal", " vfl", "avcf", "vcff", "vfs", "ovfc", "svfc", "verfo", "versionfc", "versionf", " vff", "cf", "vfx", "vtfa", "vfac", " vfo", "cvf", "vcf", "vff", "svf", "avbf", "Vbf", "devfc", " vfd", "vlf", "invfunc", "avfx", "vfa", "cvff", "cfc", "vrF", "vF", "verbf", "svfa", "vfl", "invf", "vcfac", "vtfunc", "cvfunc", "vfunc", "vrf", "invfa", "vbf", "Vfo", "verf", "avfa", "devF", "vclf", " vbf", "svfs", "vrfunc", "vcfx", "cfl", "avfu", "vcfu", "vrfa", "vrcf", "Vf"], "gb": ["db", "gt", "yg", "uv", "gc", "gs", "gif", "b", "bn", "bytes", "xy", "csv", "gp", "gm", "eb", "pb", "asm", "bg", "ctx", "binary", "eg", "g", "tg", "rect", "hub", "gd", "cb", "bt", "wb", "range", "lb", "bb", "linux", "pg", "sb", "rb", "bf", "ubis", "ruby", "vg", "bits", "cfg", "mb", "rl", "nb", "rg", "fb", "cv", "Gb", "storage", "img", "gz", "vt", "gam", "gnu", "io", "GB", "vm", "kb", "html", "bm", "gg", "hog", "gpu"], "range_v": [" range_m", "Range_v", "range_c", "range_cv", " range_c", "Range_cv", "Range_c", "range_h", "Range_m", "range_m", " range_h"], "floor1_Y": ["floor6_X", "floor1Xy", "floorOne_y", "floor1_D", "floor1_X", "floor6_N", "floor1_N", "floor11_X", "floor1___Y", "floor1XYY", "floorOne_Y", "floor1XX", "floor1_YY", "floor1XY", "floor1___YY", "floor11_Y", "floor0_y", "floor1___y", "floor1_MY", "floor11_S", "floor1___D", "floor1_S", "floorOne_X", "floor6_MY", "floor1_y", "floorOne_YY", "floor0_YY", "floor6_Y", "floor0_Y"], "floor1_Y_final": ["floor1_y_last", "floor1_Y_unsigned", "floor1_Y2last", "floor1_Y2unsigned", "floor1_Y2final", "floor1_y_Final", "floor1_y_final", "floor1_y_unsigned", "floor1_Y_Final", "floor1_Y_last", "floor1_Y2Final"], "floor1_flag": ["floor2_flags", "floor1Tflag", "floor1_offset", "floor1_x", "floor1_flags", "floor2_flag", "floor1Toffset", "floor2_x", "floor1Tx", "floor2_offset", "floor1Tflags"], "class": ["user", "ic", "chain", "classes", "Class", "b", "c", "type", "CLASS", "pack", "cl", "classified", "box", "binary", "kind", "state", "cs", "sc", "file", "scope", "con", "fc", "prop", "base", "table", "vol", "link", "lib", "course", "label", "index", "lc", "line", "cc", "id", "list", "module", "style", "lab", "code", "status", "cell", "spec", "lass", " Class", "cd", "count", "test", "ex", "size", "l", "interface", "bus", "title", "name"], "cdim": ["codims", "cedim", "czim", "cdimm", "codim", "cediv", "condim", "cdiv", "cedimm", "cdir", "cdip", " cdiv", "ddims", "ddir", " cdip", "czom", "cdims", "cedip", " cdiam", "condip", "ddimen", " cdimen", " cdims", "cdimen", "condiv", " cdimm", "czip", " cdom", "ddiam", "codir", "ddim", " cdir", "cdom", "ddom", "condimm", "ddip", "czimen", "codiam", "cdiam"], "cbits": ["lbytes", "cuints", "cumbits", "acbit", " cits", "acbs", "acflags", "pbs", "cnets", " cnets", "cints", "cbps", "cbit", "cbytes", " cvals", "cunets", "Cbits", "covals", "cbis", " cobs", "cuflags", " cints", "cvkeys", "lbits", " cflags", "cumbps", "cbugs", "cobugs", "coints", "cybis", " cbanks", " cbps", "cubits", "cobs", "pbis", " cbytes", "acbits", "acits", "cybits", " cbugs", " cbis", "cobps", "Cvals", "cokeys", " ckeys", "cvbps", "pbits", "coits", "cybs", "cvals", "cvbits", "pbanks", "cits", "ckeys", "lbs", "cubugs", "cvits", "cumvals", "cumobs", "coobs", "acnets", "acvals", " cbs", "rcobs", "rcbytes", "cuits", " cbit", "cbanks", "lobs", "Cbs", "cukeys", "rcbits", "Cbit", "cybanks", "rcbs", "cflags", "cobits", "cbs"], "csub": ["ckssub", "ksub", "rsub", "codesub", "cksubs", "csUB", "codesum", "rsubs", "cksug", "csum", "cusum", "dsum", "cksub", "dsub", "cusubs", "ksubs", "cksum", "kssub", "csssub", "dsug", "cussub", "csug", "rssub", "rsum", "csubs", "cssub", "cksUB", "cssubs", "dsubs", "ksUB", "cusub", "codessub", "codesubs", "cssUB", "codesug"], "cval": ["lcall", "lcVal", "lcval", "dval", "vval", "xcserv", "Cdata", "cserv", "lcserv", "vvol", "cdef", "Cval", "tval", "cvalue", "Cvalue", "dcvalid", "cbin", "rcdef", "rserv", "ctest", "cvalid", " cdef", " ctest", "acvalue", " cvals", "tserv", " cvol", "dvalue", "rval", " cvalue", " cserv", "CVal", "cabel", "cptest", " cvalid", "cdata", "rcVal", "lcvol", "cpval", "cpVal", "dcval", "dcabel", "nserv", "dcserv", "dserv", "rctest", " cVal", "xcval", "nbin", "cpdef", "xceval", "lcVAL", " cabel", "ceval", "xcvalue", "nval", " call", "cvals", "rcval", "rvals", "nvals", "lcvalue", "call", "vVAL", " cbin", "vall", "acval", "lcabel", "cvol", "cVAL", " ceval", "rbin", "tvalue", " cVAL", "acVal", "acdata", "cVal", "lcvalid", " cdata", "deval", "tVal"], "offset": ["error", "next", "prefix", "end", "type", "shift", "pad", "set", "buffer", "base", "table", "order", "location", "seek", "seed", "ind", "row", "index", "o", "pointer", "range", "bound", "trace", "position", "slice", "id", "pos", "attribute", "timeout", "start", "slot", "ix", "scroll", "batch", "axis", "address", "count", "size", "point", "Offset", "lock", "length", "origin"], "i": ["ic", "ij", "ini", "ci", "b", "it", "im", "c", "h", "gi", "mi", "at", "ip", "li", "p", "si", "ie", "zi", "n", "is", "name", "xi", "ind", "index", "o", "ri", "pi", "bi", "r", "multi", "me", "id", "k", "phi", "ti", "v", "ix", "ai", "m", "I", "y", "through", "ish", "\u0438", "f", "us", "io", "ex", "iu", "in", "e", "by", "info", "lock", "x", "a", "di", "ii", "l"], "j": ["dj", "ja", "ij", "q", "b", "bj", "jo", "it", "jj", "bot", "c", "job", "h", "J", "aj", "er", "g", "p", "d", "n", "uj", "index", "o", "jas", "jc", "js", "ji", "k", "oj", "try", "v", "m", "jack", "y", "jump", "jp", "jl", "us", "kj", "z", "fr", "json", "other", "x", "l"], "book": ["counter", "package", "read", "b", "quant", "ab", "thing", "chapter", "back", "pack", "bc", "box", "bank", "cmp", "buf", "base", "card", "bind", "buy", "table", "lib", "var", "bo", "label", "cb", "bu", "BOOK", "led", " bookmark", "record", "unit", "books", "cell", "block", "uc", "reader", "volume", "item", "home", "alias", "area", "count", "black", "test", "obj", "journal", "family", "Book", "check", "hold", "bus", "car", "bin"], "adx": ["adxi", "aidxi", "adox", " adxi", "madox", "aidox", "madrx", "adrx", "aidrx", "madxi", "madx", " adrx", " adox", "aidx"], "ady": ["eddy", "along", "fy", "nr", "wx", "arm", "addy", "oly", "my", "aa", "aj", "uy", "ads", "aily", "ya", "ay", "ax", "adv", "kay", "rr", "ada", "asy", "ac", "adapt", "ey", "yan", "adr", "az", "mx"], "dy": ["deb", "dj", "ty", "xy", "wy", "phy", "dem", "die", "dt", "dl", "yd", "ded", "ds", "ay", "py", "dx", "dll", "yy", "dim", "iy", "dd", "dq", "dn", "dir", "y", "ey", "did", "oy"], "off": ["ff", "ov", "prof", "ox", "det", "buf", "ok", "oo", "dev", "op", "on", "bo", "o", "height", "opp", "pos", "attr", "offs", "loss", "wo", "obj", "fo", "oe", "of", "def"], "predicted": ["repliction", "indiction", "predicated", "preduced", "indicated", "replicted", "redicted", "induced", "replicated", "rediction", "reduced", "repluced", "prediction", "indicted", "redicated"], "err": ["ev", "train", "result", "error", "lr", "br", "buf", "msg", "er", "progress", "norm", "order", "score", "ner", "str", "rc", "rev", "rr", "attr", "iter", "cr", "ptr", "rate", "obj", "arr", "res", "elt"]}}
{"project": "qemu", "commit_id": "b3f7f0c5e6449be7275f1762bccbfa2177395a3b", "target": 1, "func": "static void colo_process_checkpoint(MigrationState *s)\n{\n    QIOChannelBuffer *bioc;\n    QEMUFile *fb = NULL;\n    int64_t current_time, checkpoint_time = qemu_clock_get_ms(QEMU_CLOCK_HOST);\n    Error *local_err = NULL;\n    int ret;\n    failover_init_state();\n    s->rp_state.from_dst_file = qemu_file_get_return_path(s->to_dst_file);\n    if (!s->rp_state.from_dst_file) {\n        error_report(\"Open QEMUFile from_dst_file failed\");\n    /*\n     * Wait for Secondary finish loading VM states and enter COLO\n     * restore.\n     */\n    colo_receive_check_message(s->rp_state.from_dst_file,\n                       COLO_MESSAGE_CHECKPOINT_READY, &local_err);\n    if (local_err) {\n    bioc = qio_channel_buffer_new(COLO_BUFFER_BASE_SIZE);\n    fb = qemu_fopen_channel_output(QIO_CHANNEL(bioc));\n    object_unref(OBJECT(bioc));\n    qemu_mutex_lock_iothread();\n    vm_start();\n    qemu_mutex_unlock_iothread();\n    trace_colo_vm_state_change(\"stop\", \"run\");\n    while (s->state == MIGRATION_STATUS_COLO) {\n        current_time = qemu_clock_get_ms(QEMU_CLOCK_HOST);\n        if (current_time - checkpoint_time <\n            s->parameters.x_checkpoint_delay) {\n            int64_t delay_ms;\n            delay_ms = s->parameters.x_checkpoint_delay -\n                       (current_time - checkpoint_time);\n            g_usleep(delay_ms * 1000);\n        ret = colo_do_checkpoint_transaction(s, bioc, fb);\n        if (ret < 0) {\n        checkpoint_time = qemu_clock_get_ms(QEMU_CLOCK_HOST);\nout:\n    /* Throw the unreported error message after exited from loop */\n    if (local_err) {\n        error_report_err(local_err);\n    if (fb) {\n        qemu_fclose(fb);\n    if (s->rp_state.from_dst_file) {\n        qemu_fclose(s->rp_state.from_dst_file);", "idx": 4815, "substitutes": {"s": ["rs", "gs", "ses", "sw", "results", "less", "ns", "its", "ats", "ies", "h", "steps", "sys", "qs", "state", "cs", "comm", "self", "https", "os", "ps", "p", "ms", "details", "n", "als", "is", "ts", "has", "ds", "settings", "t", "es", "r", "js", "ins", "sv", "ls", "events", "services", "v", "ims", "stats", "args", "m", "spec", "hs", "vs", "ss", "bs", "south", "states", "sq", "parts", "fs", "e", "S", "sts", "changes", "series", "sis", "source", "sports", "aws", "l", "ops"], "bioc": ["boob", "yiok", "niob", "biosc", " bioko", "jiok", "biob", "jioko", " biroc", "piob", "gios", "pioc", "jiog", "kiosc", "yiosc", "boroc", "biocation", "kioc", " biob", "biok", "kiocation", "jiosc", "boos", "jioc", "yioc", "giob", "biocy", "fiob", "hiog", "biOC", "bioko", "yiocation", "niOC", "hiou", "hioko", "jiocy", "jiov", "kiok", "booc", "jiocation", " biOC", "bios", " biou", " biov", "nioc", "fiov", "fiOC", "pios", "hioc", "biov", " biog", "biou", " biocy", "boocy", "jiroc", "niov", "fioc", "boov", "giov", "biroc", "jiou", "gioc", "biog", "piov"], "fb": ["deb", "db", "gb", "raf", "uf", "buff", "stab", "xf", "fm", "ff", "usb", "eb", "pb", "bg", "buf", "FB", "ob", "fc", "bp", "cb", "erb", "bt", "fp", "wb", "lb", "bb", "rf", "sb", "rb", "bf", "mb", "fab", "bridge", "fn", "xb", "nb", "abb", "tf", "fi", "facebook", "hd", "fg", "fd", "fw"], "current_time": ["currentingruntime", "currentjlevel", "critical_hour", "given_request", "currentvallevel", "criticalTimeruntime", "capacity_etime", "givenvaltime", "currentTimespeed", "currentjtime", "currentTimehour", "criticalTimename", "Current_time", "currentingname", "current12level", "capacitytimetime", "given_level", "current_runtime", "currentinghour", "critical_runtime", "current_request", "currentjmoney", "currentvalrequest", "currentTimeetime", "currentjrequest", "current_speed", "capacitytimeetime", "capacitytimespeed", "critical_name", "current_level", "currentpytimeout", "current_money", "current12money", "current12request", "current_timeout", "currenttimetime", "current_hour", "current_Time", "currenttimeetime", "currentingtime", "given_money", "currentpytime", "currentpyTime", "currenttimespeed", "givenvallevel", "criticalTimehour", "Current_timeout", "currentvaltime", "current_etime", "given_time", "currentTimename", "givenvalmoney", "currentTimetime", "currentvalmoney", "currentTimeruntime", "capacity_speed", "current_name", "criticalTimetime", "Current_Time", "critical_time", "capacity_time", "givenvalrequest", "current12time"], "local_err": [" local_msg", "managed_arr", "local___Er", "managed_cfg", "internal___arr", "localeder", "internal___r", "local_Er", "localaxyr", "local_arr", "locallyelt", "local_cfg", "managedlyerr", "localedattr", "local_elt", "local_r", "single_err", "managedlycfg", "internal_r", "local_br", "local_attr", "local___cfg", "localednotice", "localedmsg", "localederr", "locallycfg", "internal___br", " local_timer", "localaxyarr", "local___r", "local_error", " local_error", "managed_err", "local_er", "managedlyelt", "localedtimer", " local_buf", "managedlyarr", "singlelynotice", "local_msg", "singlelyerr", "local___br", "single_Er", "single_notice", "locallyattr", "localedEr", "internal_arr", "locallyarr", "local___notice", "single_attr", "localaxyerr", " local_er", "internal_err", "local___err", "locallynotice", "singlelyEr", "locallyEr", "managed_elt", "internal___err", "local_buf", "local___arr", "local_timer", "internal_br", "local___attr", "singlelyattr", "locallyerr", "local_notice", "localaxybr", "local___elt"], "ret": ["gt", "result", "git", "ber", "reply", "job", "back", "cont", "sys", "nt", "ext", " Ret", "mt", "rets", "len", "val", "usr", "tr", "mail", "alt", "t", "r", "err", "ref", "inter", "rem", "out", "iter", "args", "rt", "reset", "status", "resp", "re", "lt", "tf", "RET", "jump", "Ret", "ft", "arg", "net", "ll", "nl", "res", " RET", "deg", "def", "rm", "elt", "flag"], "delay_ms": ["delay00mb", "dl_fs", "late00ms", "skip_ls", "late_ds", "delay00mas", "delay3mas", "late_min", "delay_ls", "delay00ts", "delaylyds", "delaylyms", "delay3min", "dl_ts", "late_ms", "delaylymas", "delay_mo", "delay_ts", "delay_mas", "late00ds", "skip_mo", "delay00ms", "late_mas", "skip_ms", "delay00ds", "delay_min", "skip_mm", "delay_mb", "late00min", "delay_fs", "delay00min", "delay3ds", "delaylymin", "delay00fs", "dl_mb", "late00mas", "delay_mm", "delay_ds", "dl_ms", "delay3ms"]}}
{"project": "qemu", "commit_id": "c97294ec1b9e36887e119589d456557d72ab37b5", "target": 0, "func": "static void pc_init1(QEMUMachineInitArgs *args,\n\n                     int pci_enabled,\n\n                     int kvmclock_enabled)\n\n{\n\n    MemoryRegion *system_memory = get_system_memory();\n\n    MemoryRegion *system_io = get_system_io();\n\n    int i;\n\n    ram_addr_t below_4g_mem_size, above_4g_mem_size;\n\n    PCIBus *pci_bus;\n\n    ISABus *isa_bus;\n\n    PCII440FXState *i440fx_state;\n\n    int piix3_devfn = -1;\n\n    qemu_irq *cpu_irq;\n\n    qemu_irq *gsi;\n\n    qemu_irq *i8259;\n\n    qemu_irq *smi_irq;\n\n    GSIState *gsi_state;\n\n    DriveInfo *hd[MAX_IDE_BUS * MAX_IDE_DEVS];\n\n    BusState *idebus[MAX_IDE_BUS];\n\n    ISADevice *rtc_state;\n\n    ISADevice *floppy;\n\n    MemoryRegion *ram_memory;\n\n    MemoryRegion *pci_memory;\n\n    MemoryRegion *rom_memory;\n\n    DeviceState *icc_bridge;\n\n    FWCfgState *fw_cfg = NULL;\n\n    PcGuestInfo *guest_info;\n\n\n\n    if (xen_enabled() && xen_hvm_init(&ram_memory) != 0) {\n\n        fprintf(stderr, \"xen hardware virtual machine initialisation failed\\n\");\n\n        exit(1);\n\n    }\n\n\n\n    icc_bridge = qdev_create(NULL, TYPE_ICC_BRIDGE);\n\n    object_property_add_child(qdev_get_machine(), \"icc-bridge\",\n\n                              OBJECT(icc_bridge), NULL);\n\n\n\n    pc_cpus_init(args->cpu_model, icc_bridge);\n\n\n\n    if (kvm_enabled() && kvmclock_enabled) {\n\n        kvmclock_create();\n\n    }\n\n\n\n    /* Check whether RAM fits below 4G (leaving 1/2 GByte for IO memory).\n\n     * If it doesn't, we need to split it in chunks below and above 4G.\n\n     * In any case, try to make sure that guest addresses aligned at\n\n     * 1G boundaries get mapped to host addresses aligned at 1G boundaries.\n\n     * For old machine types, use whatever split we used historically to avoid\n\n     * breaking migration.\n\n     */\n\n    if (args->ram_size >= 0xe0000000) {\n\n        ram_addr_t lowmem = gigabyte_align ? 0xc0000000 : 0xe0000000;\n\n        above_4g_mem_size = args->ram_size - lowmem;\n\n        below_4g_mem_size = lowmem;\n\n    } else {\n\n        above_4g_mem_size = 0;\n\n        below_4g_mem_size = args->ram_size;\n\n    }\n\n\n\n    if (pci_enabled) {\n\n        pci_memory = g_new(MemoryRegion, 1);\n\n        memory_region_init(pci_memory, NULL, \"pci\", UINT64_MAX);\n\n        rom_memory = pci_memory;\n\n    } else {\n\n        pci_memory = NULL;\n\n        rom_memory = system_memory;\n\n    }\n\n\n\n    guest_info = pc_guest_info_init(below_4g_mem_size, above_4g_mem_size);\n\n\n\n    guest_info->has_acpi_build = has_acpi_build;\n\n\n\n    guest_info->has_pci_info = has_pci_info;\n\n    guest_info->isapc_ram_fw = !pci_enabled;\n\n\n\n    if (smbios_defaults) {\n\n        /* These values are guest ABI, do not change */\n\n        smbios_set_defaults(\"QEMU\", \"Standard PC (i440FX + PIIX, 1996)\",\n\n                            args->machine->name);\n\n    }\n\n\n\n    /* allocate ram and load rom/bios */\n\n    if (!xen_enabled()) {\n\n        fw_cfg = pc_memory_init(system_memory,\n\n                       args->kernel_filename, args->kernel_cmdline,\n\n                       args->initrd_filename,\n\n                       below_4g_mem_size, above_4g_mem_size,\n\n                       rom_memory, &ram_memory, guest_info);\n\n    }\n\n\n\n    gsi_state = g_malloc0(sizeof(*gsi_state));\n\n    if (kvm_irqchip_in_kernel()) {\n\n        kvm_pc_setup_irq_routing(pci_enabled);\n\n        gsi = qemu_allocate_irqs(kvm_pc_gsi_handler, gsi_state,\n\n                                 GSI_NUM_PINS);\n\n    } else {\n\n        gsi = qemu_allocate_irqs(gsi_handler, gsi_state, GSI_NUM_PINS);\n\n    }\n\n\n\n    if (pci_enabled) {\n\n        pci_bus = i440fx_init(&i440fx_state, &piix3_devfn, &isa_bus, gsi,\n\n                              system_memory, system_io, args->ram_size,\n\n                              below_4g_mem_size,\n\n                              above_4g_mem_size,\n\n                              pci_memory, ram_memory);\n\n    } else {\n\n        pci_bus = NULL;\n\n        i440fx_state = NULL;\n\n        isa_bus = isa_bus_new(NULL, system_io);\n\n        no_hpet = 1;\n\n    }\n\n    isa_bus_irqs(isa_bus, gsi);\n\n\n\n    if (kvm_irqchip_in_kernel()) {\n\n        i8259 = kvm_i8259_init(isa_bus);\n\n    } else if (xen_enabled()) {\n\n        i8259 = xen_interrupt_controller_init();\n\n    } else {\n\n        cpu_irq = pc_allocate_cpu_irq();\n\n        i8259 = i8259_init(isa_bus, cpu_irq[0]);\n\n    }\n\n\n\n    for (i = 0; i < ISA_NUM_IRQS; i++) {\n\n        gsi_state->i8259_irq[i] = i8259[i];\n\n    }\n\n    if (pci_enabled) {\n\n        ioapic_init_gsi(gsi_state, \"i440fx\");\n\n    }\n\n    qdev_init_nofail(icc_bridge);\n\n\n\n    pc_register_ferr_irq(gsi[13]);\n\n\n\n    pc_vga_init(isa_bus, pci_enabled ? pci_bus : NULL);\n\n\n\n    /* init basic PC hardware */\n\n    pc_basic_device_init(isa_bus, gsi, &rtc_state, &floppy, xen_enabled(),\n\n        0x4);\n\n\n\n    pc_nic_init(isa_bus, pci_bus);\n\n\n\n    ide_drive_get(hd, MAX_IDE_BUS);\n\n    if (pci_enabled) {\n\n        PCIDevice *dev;\n\n        if (xen_enabled()) {\n\n            dev = pci_piix3_xen_ide_init(pci_bus, hd, piix3_devfn + 1);\n\n        } else {\n\n            dev = pci_piix3_ide_init(pci_bus, hd, piix3_devfn + 1);\n\n        }\n\n        idebus[0] = qdev_get_child_bus(&dev->qdev, \"ide.0\");\n\n        idebus[1] = qdev_get_child_bus(&dev->qdev, \"ide.1\");\n\n    } else {\n\n        for(i = 0; i < MAX_IDE_BUS; i++) {\n\n            ISADevice *dev;\n\n            char busname[] = \"ide.0\";\n\n            dev = isa_ide_init(isa_bus, ide_iobase[i], ide_iobase2[i],\n\n                               ide_irq[i],\n\n                               hd[MAX_IDE_DEVS * i], hd[MAX_IDE_DEVS * i + 1]);\n\n            /*\n\n             * The ide bus name is ide.0 for the first bus and ide.1 for the\n\n             * second one.\n\n             */\n\n            busname[4] = '0' + i;\n\n            idebus[i] = qdev_get_child_bus(DEVICE(dev), busname);\n\n        }\n\n    }\n\n\n\n    pc_cmos_init(below_4g_mem_size, above_4g_mem_size, args->boot_order,\n\n                 floppy, idebus[0], idebus[1], rtc_state);\n\n\n\n    if (pci_enabled && usb_enabled(false)) {\n\n        pci_create_simple(pci_bus, piix3_devfn + 2, \"piix3-usb-uhci\");\n\n    }\n\n\n\n    if (pci_enabled && acpi_enabled) {\n\n        I2CBus *smbus;\n\n\n\n        smi_irq = qemu_allocate_irqs(pc_acpi_smi_interrupt, first_cpu, 1);\n\n        /* TODO: Populate SPD eeprom data.  */\n\n        smbus = piix4_pm_init(pci_bus, piix3_devfn + 3, 0xb100,\n\n                              gsi[9], *smi_irq,\n\n                              kvm_enabled(), fw_cfg);\n\n        smbus_eeprom_init(smbus, 8, NULL, 0);\n\n    }\n\n\n\n    if (pci_enabled) {\n\n        pc_pci_device_init(pci_bus);\n\n    }\n\n}\n", "idx": 4835, "substitutes": {"args": ["aw", "fields", "gs", "points", "results", "ars", "ants", "ns", "orders", "eps", "amps", "values", "locks", "aws", "objects", "apps", "qs", "sys", "terms", "self", "aps", "actions", "caps", "ians", "artifacts", "ms", "tests", "cmd", "yes", "ts", "settings", "aux", "arms", "range", "aus", "GV", "js", "atts", "ids", "options", "Args", "units", "ims", "ras", "users", "images", "bits", "checks", "ams", "config", "cfg", "GS", "limits", "parts", "obj", "arg", "flags", "changes", "links", "arr", "params"], "pci_enabled": ["pico_Enabled", "pico_required", "pci_enable", "pico_enable", "pci__enabled", "pci_required", "pico_enabled", "pci__enable", "pci8enabled", "pci__Enabled", "pci8required", "pci_Enabled", "pci8enable", "pci__required", "pci8Enabled"], "kvmclock_enabled": ["kvmclocklyprovided", "kvmlock_enabled", "kvmlock_supported", "kvmclock_provided", "kvmclocklyenabled", "kvmclock_supported", "kvmclock2enabled", "kvmclock_Enabled", "kvmclock2Enabled", "kvmclock2enable", "kvmlock_enable", "kvmclocklyenable", "kvmlock_Enabled", "kvmclock_enable", "kvmclock2provided", "kvmclocklyEnabled"], "system_memory": ["system__system", "system__library", "ram_system", "system7storage", "ram_storage", "system7library", "system_storage", "system_library", "system_system", "system7system", "system__memory", "system__storage", "system7memory", "ram_library"], "system_io": ["sys_ios", "system___ios", "system___io", "systemityio", "system___error", "systemityerror", "system_ios", "sys_library", "systemityios", "system_library", "system_error", "sys_io", "systemitylibrary", "system___library", "sys_error"], "i": ["ei", "ci", "b", "im", "h", "ip", "li", "p", "si", "n", "ati", "xi", "t", "bi", "pi", " I", "phi", " j", "m", "I", "ia", "io", "e", "j", "di", "a", "ii", "l"], "below_4g_mem_size": ["below_4g_mem_len", "below_4g_mem_space", "below_4g_mem_name", "below_4g_mem_Size"], "above_4g_mem_size": ["above_4g_mem_SIZE", "above_4g_Mem_SIZE", "above_4g_ram_size", "above_4g_mem_sum", "above_4g_mem_Size", "above_4g_Mem_Size", "above_4g_ram_SIZE", "above_4g_ram_sum", "above_4g_Mem_size"], "pci_bus": ["pci0bus", "pci1boot", "pci1disk", "pci_dev", "pca_bus", "pci1dev", "pci1bus", "pci0dev", "pci_boot", "pca_dev", "pci_disk", "pca_boot", "pca_disk", "pci0disk", "pci0boot"], "isa_bus": ["isa_boot", "isaambook", "isa_machine", "isaamboot", "ista_boot", "isaammachine", "isaambus", "ista_machine", "ista_bus", "ista_book", "isa_book"], "i440fx_state": ["i440fax_start", "i440fxptstate", "i440fx_resource", "i440fx2start", "i440fx2state", "i440fx_status", "i440fx2status", "i440fax_state", "i440fxptresource", "i440faxptresource", "i440faxptstart", "i440fx_start", "i440fax_resource", "i440fxptstart", "i440fxptstatus", "i440faxptstatus", "i440faxptstate", "i440fx2resource", "i440fax_status"], "cpu_irq": ["cpu__irqs", "cpu_ibrques", "cpu_irqs", "cpu__irq", "cpu__mirq", "cpu_pirq", "cpu_pirques", "cpu_mirQ", "cpu_mirqs", "cpu__irques", "cpu_ibrqs", "cpu__irQ", "cpu_pirqs", "cpu_irques", "cpu_ibrQ", "cpu__mirqs", "cpu_mirq", "cpu_ibrq", "cpu__mirQ", "cpu_mirques", "cpu__mirques", "cpu_irQ", "cpu_pirQ"], "gsi": ["Gsm", "mgdi", "mgsm", "gsa", "gsm", " gdi", "mgsi", "Gsa", "Gsi", " gsa", "gdi", "mgsa", "Gdi", " gsm"], "i8259": ["i5285", "i9266", "I8285", "i80191", "i5191", "i8285", "I8259", "I8191", "i80285", "I9285", "i9285", "i5259", "I9266", "i9259", "i9191", "i8191", "i80266", "i5266", "I9191", "i8266", "I9259", "i80259", "I8266"], "smi_irq": ["smi_irQ", "smi__irqs", "smi__pirQ", "smi__irq", "smi_mirQ", "smi_pirq", "smi_pirqs", "smi__irQ", "smi__pirqs", "smi__pirq", "smi_mirq", "smi_IRq", "smi_irqs", "smi_IRQ", "smi_IRqs", "smi_mirqs", "smi_pirQ"], "gsi_state": ["gsi__state", "gami_info", "gsi__config", "gsi_status", "gsi_info", "gsi__info", "gami_status", "gsi__status", "gami_config", "gami_state", "gsi_config"], "hd": ["h", "dylib", "ht", "dl", "ded", "bd", "ds", "hz", "hw", "hi", "HD", "dh", "dr", "him", "rh", "dm", "vd", "rt", "dd", "hs", "dn", "cd", "he", "hid", "ha", "ld", "ssh", "haw", "hp"], "MAX_IDE_BUS": ["MAX_IDE__PATH", "MAX_IDES__BO", "MAX_IDEIPPATH", "MAX_IDE__BUS", "MAX_IDEIPBO", "MAX_IDE_IN", "MAX_IDEIPBUS", "MAX_IDE__BO", "MAX_IDE_US", "MAX_DE_US", "MAX_IDE_BO", "MAX_DE_BUS", "MAX_IDES_BO", "MAX_DE_PATH", "MAX_IDES__BUS", "MAX_IDES__PATH", "MAX_IDES_PATH", "MAX_IDES_BUS", "MAX_IDE__IN", "MAX_IDE__US", "MAX_DE_IN", "MAX_IDE_PATH"], "MAX_IDE_DEVS": ["MAX_IDE_DVs", "MAX_IDE_DRVS", "MAX_IDE_DFS", "MAX_IDE_DAPS", "MAX_IDE_DRVs", "MAX_IDE_DPS", "MAX_IDE_DRPS", "MAX_IDE_DAVs", "MAX_IDE2DEFS", "MAX_IDE2DPS", "MAX_IDE2DFS", "MAX_IDE_DAVS", "MAX_IDE2DEVs", "MAX_IDE2DVs", "MAX_IDE2DEVS", "MAX_IDE_DEVs", "MAX_IDE_DAFS", "MAX_IDE_DEPS", "MAX_IDE_DEFS", "MAX_IDE_DVS", "MAX_IDE_DRFS", "MAX_IDE2DVS", "MAX_IDE2DEPS"], "idebus": ["idestate", "itedev", "ridedev", "itebal", "linebus", "idebal", "linedev", "itebus", "ridestate", "ridebus", "linebal", "itestate", "idedev", "linestate", "ridebal"], "rtc_state": ["rtc__port", "rtf_status", "rtf_state", "rtf_states", "rtc__state", "rtc_states", "rtc__states", "rtc__status", "rtc_port", "rtf_port", "rtc_status"], "floppy": ["sloop", "FLoop", "ploop", "slogo", "plppy", "slppy", "flogo", "FLogo", "FLoppy", "ploppy", "floop", "sloppy", "plogo", "flppy", "FLppy"], "ram_memory": ["mem_hash", "rammmhash", "ram67memory", "system_metadata", "ram67directory", "ram67storage", "ram_storage", "rammmmemory", "ram_mem", "mem_directory", "rammmdirectory", "ram67hash", "ram_hash", "system_storage", "ram_metadata", "mem_storage", "rammmstorage", "system_mem", "mem_memory", "ram_directory"], "pci_memory": ["pci___mem", "pcu_message", "pci___ram", "pci___message", "pci_ram", "pci___memory", "pcu_ram", "pcu_memory", "pci_message", "pcu_mem", "pci_mem"], "rom_memory": ["romacymemory", "romaxymem", "rom_mem", "romacymem", "romaxymemory", "romacymachine", "romaxymargin", "romacymargin", "rom_margin", "ram_mem", "ram_machine", "ram_margin", "romaxymachine", "rom_machine"], "icc_bridge": ["ico_master", "uci___forge", "fc_bridge", "ico_device", "iccacbind", "fc___device", "uci___plugin", "uci_bridge", "icc_device", "icc67device", "icc___bridge", "icoptbind", "icc67bridge", "icc___ridge", "fc___dev", "ico_bind", "fc___bridge", "icc___dev", "icc_dev", "icc_ridge", "iccptbridge", "fc_dev", "icoptmaster", "iccacbridge", "ic_dev", "uci___bridge", "uci_forge", "icc67dev", "uci_plugin", "icc_forge", "iccptdevice", "fc___link", "ic_ridge", "uci_ridge", "icc___link", "ic_link", "icc___plugin", "iccptmaster", "iccacdevice", "icc_link", "icc67link", "iccptbind", "icc_plugin", "fc_link", "icc_bind", "ico_bridge", "icoptbridge", "iccacmaster", "fc_device", "icc_master", "icoptdevice", "uci___ridge", "icc___device", "ic_bridge", "icc___forge"], "fw_cfg": ["fc_conf", "fc_config", "fw_config", "fw_fg", "fw_conf", "fc_cfg", "fw2conf", "fw2cfg", "fw2config", "fc_fg", "fw2fg"], "guest_info": ["guestmyfo", "guest_error", "guestmyerror", "guestmydict", "guest2fo", "guet2info", "guet_dict", "guestmyinfo", "guet_info", "guet_error", "guest2error", "guestuserinfo", "guet2fo", "guest_fo", "guest_dict", "guest2info", "guest2dict", "guet2dict", "guestusererror", "guestuserfo", "guet_fo", "guet2error", "guestuserdict"]}}
{"project": "qemu", "commit_id": "4bb3893908385836410346725dd9e584dcd24836", "target": 0, "func": "uint32_t wm8750_adc_dat(void *opaque)\n\n{\n\n    WM8750State *s = (WM8750State *) opaque;\n\n    uint32_t *data;\n\n\n\n    if (s->idx_in >= sizeof(s->data_in))\n\n        wm8750_in_load(s);\n\n\n\n    data = (uint32_t *) &s->data_in[s->idx_in];\n\n    s->req_in -= 4;\n\n    s->idx_in += 4;\n\n    return *data;\n\n}\n", "idx": 4842, "substitutes": {"opaque": ["obaques", "paque", "iopaques", "boacity", "obque", "ogque", "opque", "ocacity", "opaques", "ioposit", "oposit", "patile", "paques", "ogaques", "iopque", "opacity", "boaques", "pacity", "ocaque", "opatile", "boaque", "ocaques", "ogaque", "ogosit", "ocatile", "iopaque", "obosit", "boatile", "obaque"], "s": ["rs", "service", "so", "sp", "gs", "ses", "ssl", "b", "sw", "less", "bis", "g", "ns", "conf", "h", "i", "qs", "store", "sys", "comm", "self", "state", "scope", "os", "ps", "als", "ms", "stat", "p", "details", "is", "ts", "n", "ds", "sync", "t", "se", "es", "js", "syn", "space", "sv", "ls", "sm", "sb", "soc", "ess", "stats", "sl", "sa", "hs", "spec", "st", "bs", "ss", "y", "sq", "fs", "ex", "S", "sts", "j", "sis", "source", "z", "aws", "l", "ops"], "data": ["output", "content", "aw", "result", "bytes", "empty", "dat", "window", "step", "join", "rel", "only", "buffer", "valid", "raw", "map", "d", "p", "n", " DATA", "rew", "ata", "o", "t", "r", "Data", "str", "value", "to", "mu", "out", "v", "m", "block", "response", "batch", "f", "DATA", "message", "format", "text", "a", "relation"]}}
{"project": "qemu", "commit_id": "09e68369a88d7de0f988972bf28eec1b80cc47f9", "target": 0, "func": "static QmpInputVisitor *to_qiv(Visitor *v)\n\n{\n\n    return container_of(v, QmpInputVisitor, visitor);\n\n}\n", "idx": 4849, "substitutes": {"v": ["vv", "ev", "uv", "vr", "q", "b", "c", "u", "h", "av", "gov", "vi", "i", "p", "g", "n", "vp", "tv", "o", "t", "w", "sv", "qv", "m", "V", "vc", "vis", "vs", "y", "f", "vt", "vm", "e", "j", "x", "l"]}}
{"project": "FFmpeg", "commit_id": "11de006babf735aafa3462d43dd2c02bb6ac6e2f", "target": 0, "func": "static int v4l2_read_packet(AVFormatContext *s1, AVPacket *pkt)\n\n{\n\n#if FF_API_CODED_FRAME\n\nFF_DISABLE_DEPRECATION_WARNINGS\n\n    struct video_data *s = s1->priv_data;\n\n    AVFrame *frame = s1->streams[0]->codec->coded_frame;\n\nFF_ENABLE_DEPRECATION_WARNINGS\n\n#endif\n\n    int res;\n\n\n\n    av_init_packet(pkt);\n\n    if ((res = mmap_read_frame(s1, pkt)) < 0) {\n\n        return res;\n\n    }\n\n\n\n#if FF_API_CODED_FRAME\n\nFF_DISABLE_DEPRECATION_WARNINGS\n\n    if (frame && s->interlaced) {\n\n        frame->interlaced_frame = 1;\n\n        frame->top_field_first = s->top_field_first;\n\n    }\n\nFF_ENABLE_DEPRECATION_WARNINGS\n\n#endif\n\n\n\n    return pkt->size;\n\n}\n", "idx": 4873, "substitutes": {"s1": [" s7", "ws1", "nsone", "sts1", "ns2", "s3", "cone", "ws2", "wsone", "ss7", "tsOne", "ss1", "sone", "ts3", "s10", "c1", " s10", " sOne", "ss2", "sts10", "sts2", " sone", " s3", "ps1", "ss10", "ws6", "ps2", "ns1", "psOne", "s2", "c2", "ts1", "ts2", " s6", " s2", "sOne", "s6", "ps3", "sts7", "s7", "ns6"], "pkt": [" pkg", "packk", "cpqt", "opacket", "tpacket", "wpkg", "wpkt", "wpq", "Pet", "pq", "Puf", "packkt", "opkt", " puf", "packuf", "tpkt", "cpkt", "Packet", "opq", "wpacket", "packacket", "puf", "Pqt", "pet", "packet", "pkg", " pqt", "cpacket", " pq", " pk", "pk", "cpet", "opkg", "tpk", "tpet", "pqt", " pet", " packet", "Pkt"], "s": ["rs", "gs", "des", "sw", "b", "less", "ns", "c", "ats", "h", "sys", "qs", "comm", "cs", "os", "p", "ps", "ms", "g", "d", "ts", "ds", "t", "r", "js", "w", "ins", "space", "sv", "ls", "services", "v", "stats", "args", "bits", "m", "ss", "bs", "sq", "f", "parts", "fs", "S", "z", "aws"], "frame": ["init", "header", "draw", "cf", "rame", "cast", "q", "error", "feat", "next", "window", "channel", "Frame", "fram", "type", "iframe", "ox", "none", "set", "state", "self", "file", "valid", "os", "scene", "force", "profile", "flow", "zone", "frames", "picture", "use", "data", "t", "line", "w", "position", "role", "style", "send", "normal", "code", "component", "video", "feature", "reset", "m", "block", "response", "fire", "f", "message", "face", "point", "e", "info", "fr", "render", "ace", "format", "def", "image", "sequence"], "res": ["resources", "rs", "result", "des", "results", "ress", "ber", "gr", " Res", "os", "ps", "ms", "details", " RES", "ts", "val", "Res", "red", "vals", "pers", "err", "str", "js", "rev", "rem", "rest", "out", "ras", "RES", "reset", "resh", "resp", "re", "respons", "ret", "ptr", "pas", "cons", "VAL", "size", "pres", "RS", "resolution"], "interlaced": ["interslaced", "interslagged", "Interlaced", "interleaces", "Interleated", "interplaces", "interslated", "interleagged", "Interleaces", "interplated", "Interlagged", "Interleagged", "Interlaces", "interlaces", "interleated", "interplaced", "Interleaced", "Interlated", "interplagged", "interleaced", "interlated", "interlagged", "interslaces"]}}
{"project": "qemu", "commit_id": "efec3dd631d94160288392721a5f9c39e50fb2bc", "target": 1, "func": "static void bonito_pcihost_class_init(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n    SysBusDeviceClass *k = SYS_BUS_DEVICE_CLASS(klass);\n\n\n\n    k->init = bonito_pcihost_initfn;\n\n    dc->no_user = 1;\n\n}\n", "idx": 4874, "substitutes": {"klass": ["ikclass", "ekclass", "Klasses", " klasses", "eklasses", "Kclass", "ekls", "ikls", "kwl", " kwl", " kls", "kickls", "Klass", "kicklass", "Kls", "eklass", "klasses", "iklasses", "kicklasses", "iklass", "kls", "kickwl", " kclass", "Kwl", "kclass"], "data": ["dat", " dat", "type", "c", "def", " Data", "raw", "d", " sd", " DATA", "ata", "o", "key", "func", "Data", "rc", "mu", " d", "m", "DATA", "rec", "res", "json", "di", "name", "da", "bin"], "dc": ["ck", "db", "gc", "cp", "pb", "c", "pc", "ctx", "bc", "mk", "fc", "DC", " DC", "d", "cm", "deck", "nc", "ec", "lc", "cc", "dm", "cr", "oc", "ac", "dk", "cd", "ca", "cca", "disc", "mc", "dp", "nz", "iac", "ga", "di", "tc", "da"], "k": ["ck", "q", "km", "c", "kr", "kt", "kh", "kk", "ku", "i", "ka", "K", "ik", "ek", "ok", "mk", "p", "g", "ak", "n", "ke", "kan", "kar", "key", "wk", "ki", "kw", "kn", "sk", "dk", "ko", "kit", "aka", "ks", "kj", "j", "tk"]}}
{"project": "FFmpeg", "commit_id": "955aec3c7c7be39b659197e1ec379a09f2b7c41c", "target": 0, "func": "static int mp3_parse_vbr_tags(AVFormatContext *s, AVStream *st, int64_t base)\n\n{\n\n    uint32_t v, spf;\n\n    MPADecodeHeader c;\n\n    int vbrtag_size = 0;\n\n    MP3DecContext *mp3 = s->priv_data;\n\n\n\n    ffio_init_checksum(s->pb, ff_crcA001_update, 0);\n\n\n\n    v = avio_rb32(s->pb);\n\n    if(ff_mpa_check_header(v) < 0)\n\n      return -1;\n\n\n\n    if (avpriv_mpegaudio_decode_header(&c, v) == 0)\n\n        vbrtag_size = c.frame_size;\n\n    if(c.layer != 3)\n\n        return -1;\n\n\n\n    spf = c.lsf ? 576 : 1152; /* Samples per frame, layer 3 */\n\n\n\n    mp3->frames = 0;\n\n    mp3->size   = 0;\n\n\n\n    mp3_parse_info_tag(s, st, &c, spf);\n\n    mp3_parse_vbri_tag(s, st, base);\n\n\n\n    if (!mp3->frames && !mp3->size)\n\n        return -1;\n\n\n\n    /* Skip the vbr tag frame */\n\n    avio_seek(s->pb, base + vbrtag_size, SEEK_SET);\n\n\n\n    if (mp3->frames)\n\n        st->duration = av_rescale_q(mp3->frames, (AVRational){spf, c.sample_rate},\n\n                                    st->time_base);\n\n    if (mp3->size && mp3->frames && !mp3->is_cbr)\n\n        st->codec->bit_rate = av_rescale(mp3->size, 8 * c.sample_rate, mp3->frames * (int64_t)spf);\n\n\n\n    return 0;\n\n}\n", "idx": 4879, "substitutes": {"s": ["rs", "gs", "sp", "b", "ns", "its", "ctx", "h", "ats", "aws", "i", "sys", "qs", "cs", "sc", "os", "ps", "p", "ms", "g", "n", "is", "ts", "ds", "t", "se", "es", "r", "w", "js", "ins", "space", "sv", "ls", "sb", "ims", "stats", "sl", "hs", "vs", "ss", "bs", "south", "sq", "fs", "us", "S", "sts", "z", "sports", "a"], "st": ["so", "sp", "et", "sw", "ct", "b", "ust", "it", "src", "end", "est", "step", "sth", "ctx", "h", "stage", "set", "pt", "nd", "sc", "nt", "inst", "mt", "stat", "ts", "std", "usr", "se", "t", "ut", "r", "stop", "str", "th", "ast", "sv", "rest", "start", "stream", "ss", "stable", "ist", "tmp", "storage", "ST", "ste", "sts", "fr", "sta", "ost", "St", "tt"], "base": ["db", "sp", "b", "end", " Base", " bas", "h", "offset", "i", "set", "based", " max", "buffer", "ta", " bases", "p", "pa", "bp", "zero", "bound", "se", " start", "scale", "Base", "server", "w", "r", "id", "bi", "ui", "pe", "start", "out", "bf", "max", "m", " from", " b", " BASE", "f", "size", " k", "e", "kb", "bas", "ase", "x", "a", "origin", "l"], "v": ["iv", "vv", "vr", "uv", "ev", "q", "b", "lv", " tv", "ov", "u", " va", "av", "h", " x", "vi", "i", "ve", "buffer", " vm", " ov", "p", "g", "vp", "var", "tv", " h", "t", " value", "r", "value", "w", "sv", "qv", " var", " V", " sv", "nv", " f", "m", "vs", " av", "V", "vc", "cv", "version", "f", "vt", "conv", "wire", " val", "vm", "j", "x", "ver", " env", "l", " vs"], "spf": ["spz", " sph", "spv", "espl", "spfc", "lph", "aspm", "spfr", "aspv", "psv", "aspfc", "esph", "lpz", "spl", "psf", "bspf", "spel", "ppz", " spz", "lpfc", "Sph", "ppc", "psef", "psel", "Spl", "lpf", "spfs", " spm", "bsph", "Spv", " spfc", " spv", "bspfc", "espv", "spef", "aspf", "psm", "lpc", "sph", " spfx", " spfr", " spc", "spev", "spc", "lpfs", "ppf", "spefx", "psfc", "espf", "ppfr", " spl", "lpfr", " spfs", "bspfs", "spfx", "psev", "spm", "psefx", "Spf"], "c": ["cf", "cod", "dc", "gc", "ct", "b", "ci", "cp", "conf", " C", "ctx", "h", "wcs", "cmp", "cont", "cl", "bc", "pc", "anc", "con", "cs", "sc", "fc", "p", "cm", "co", "d", "etc", "ec", "cb", "lc", "ce", "t", "r", "cc", "xc", "rc", "kw", "cr", "m", "config", "ac", "vc", "cv", "ca", "cd", "cache", "mc", "f", "cur", "C", "l", "enc", "com", "cu", "comments", "abc", "tc"], "mp3": [" mptx", "MP1", "av4", "av03", "MPthree", "proc3", "MP6", "mt03", "pp7", "mph3", "cmp03", "mphant", "img3", " mp1", "proc23", "mphment", " mplet", " mp5", "omp1", "mk3", "pp2", "cmp3", "img43", "mpeg2", "cmpant", " mpdef", "mpeg5", "mp4", "omp03", "procthree", "m3", "mx03", "mpThree", "mp33", "cmp2", " mp03", " mpThree", "mp2", "avack", "emp03", "mpthree", "amp3", "mpth", "mph03", "omp3", "emp2", "pp6", "mxment", "av3", "mpment", "amplet", "m5", " mp6", " mp2", "avlet", "mpeg3", "mpack", "MP23", "cp7", "m2", " mpth", "cp3", "cmpment", "cp2", "ampThree", "mp1", "omp33", "mpeg6", " mpack", "mt2", "mptx", "mx3", "omp2", "emp3", "mpeg03", "mpdef", "m4", "mt4", "mk6", "cp6", "amp4", "mp03", "MPry", "cmptx", "mpegth", " mp4", "mp43", " mp7", "mtx", "mp6", "mk43", "imgdef", "cmp6", "mp5", "pp3", "cmp33", " mp43", "MP3", "mxant", "emp33", "avth", "mry", "mpry", "MP2", "omp5", "mpegack", "mp23", "omp23", "m03", "mt3", "img6", "cmp4", "mplet", "mkdef", "avThree", "MP03", "ompthree", "mpant", "MP5", "proc03", " mpry", "cmp5", "mp7"]}}
{"project": "qemu", "commit_id": "ad523590f62cf5d44e97388de370d27b95b25aff", "target": 0, "func": "void memory_region_iommu_replay_all(MemoryRegion *mr)\n\n{\n\n    IOMMUNotifier *notifier;\n\n\n\n    IOMMU_NOTIFIER_FOREACH(notifier, mr) {\n\n        memory_region_iommu_replay(mr, notifier, false);\n\n    }\n\n}\n", "idx": 4892, "substitutes": {"mr": ["rs", "vr", "rer", "mn", "gm", "lr", "rpm", "sr", "kr", "br", "ire", "mk", "rn", "wm", "cm", "mt", "ml", "tm", "ms", "tr", "r", "dr", "irm", "rr", "rb", "rar", "memory", "rt", "rl", "m", "shr", "rg", "mm", "MR", "mc", "hm", "drm", "adr", "bm", "Mr", "mx", "hr", "rm", "mp"], "notifier": [" NOTer", "NOTifier", " NOTifer", " noter", " notifer", " notifiable", " NOTifiable", "Notify", "notger", "notizer", "noter", "NOTer", " notger", "neifier", "Notifier", "neger", "notify", "NOTify", "notifer", "NOTizer", "neify", "NOTifer", "neifer", "noifier", " NOTifier", " notify", "noify", "notifiable", "noifer", "noizer", "Notifer", " notizer", "NOTifiable", "Notger"]}}
{"project": "qemu", "commit_id": "dc638fadb54c911019227ae37656560c49a209b9", "target": 0, "func": "static int usb_uhci_piix3_initfn(PCIDevice *dev)\n\n{\n\n    UHCIState *s = DO_UPCAST(UHCIState, dev, dev);\n\n    uint8_t *pci_conf = s->dev.config;\n\n\n\n    pci_config_set_vendor_id(pci_conf, PCI_VENDOR_ID_INTEL);\n\n    pci_config_set_device_id(pci_conf, PCI_DEVICE_ID_INTEL_82371SB_2);\n\n    return usb_uhci_common_initfn(s);\n\n}\n", "idx": 4893, "substitutes": {"dev": ["db", "ev", "des", "mem", "devices", "usb", "conf", "att", "av", "cam", "pad", "DEV", "dem", "buf", "pro", "sys", "nt", "ve", "raw", "d", "p", "cmd", "sd", "data", "hw", "w", "go", "adv", "proc", "debug", "device", "out", "v", "vo", "Device", "dd", "ch", "block", "spec", "serv", "remote", "desc", "priv", "serial", "obj", "test", "de", "info", "dis", "ver", "Dev", "conn", "def", "develop"], "s": ["rs", "ses", "b", "ns", "conf", "sol", "c", "h", "i", "sys", "state", "cs", "self", "comm", "sc", "p", "ps", "n", "is", "ts", "ds", "sync", "t", "es", "js", "w", "syn", "sv", "ls", "v", "sh", "sl", "m", "sa", "bs", "ss", "south", "su", "sq", "f", "fs", "S", "sts", "sis", "a"], "pci_conf": ["pdi_con", "pci__cfg", "pdi_cfg", "pci_config", "puci_req", "pdi_dict", "puci_cfg", "pci__acc", "pci_dict", "puci_config", "pcierconf", "puci_conf", "pci__conf", "pdi_acc", "pciercon", "pcierdict", "pdi_config", "pci_acc", "pci_con", "pcierconfig", "pdi_conf", "pci_req", "pci__config", "pci_cfg"]}}
{"project": "FFmpeg", "commit_id": "842b6c14bcfc1c5da1a2d288fd65386eb8c158ad", "target": 0, "func": "static void mpegts_write_pmt(AVFormatContext *s, MpegTSService *service)\n\n{\n\n    MpegTSWrite *ts = s->priv_data;\n\n    uint8_t data[1012], *q, *desc_length_ptr, *program_info_length_ptr;\n\n    int val, stream_type, i;\n\n\n\n    q = data;\n\n    put16(&q, 0xe000 | service->pcr_pid);\n\n\n\n    program_info_length_ptr = q;\n\n    q += 2; /* patched after */\n\n\n\n    /* put program info here */\n\n\n\n    val = 0xf000 | (q - program_info_length_ptr - 2);\n\n    program_info_length_ptr[0] = val >> 8;\n\n    program_info_length_ptr[1] = val;\n\n\n\n    for(i = 0; i < s->nb_streams; i++) {\n\n        AVStream *st = s->streams[i];\n\n        MpegTSWriteStream *ts_st = st->priv_data;\n\n        AVDictionaryEntry *lang = av_dict_get(st->metadata, \"language\", NULL,0);\n\n        switch(st->codec->codec_id) {\n\n        case AV_CODEC_ID_MPEG1VIDEO:\n\n        case AV_CODEC_ID_MPEG2VIDEO:\n\n            stream_type = STREAM_TYPE_VIDEO_MPEG2;\n\n            break;\n\n        case AV_CODEC_ID_MPEG4:\n\n            stream_type = STREAM_TYPE_VIDEO_MPEG4;\n\n            break;\n\n        case AV_CODEC_ID_H264:\n\n            stream_type = STREAM_TYPE_VIDEO_H264;\n\n            break;\n\n        case AV_CODEC_ID_CAVS:\n\n            stream_type = STREAM_TYPE_VIDEO_CAVS;\n\n            break;\n\n        case AV_CODEC_ID_DIRAC:\n\n            stream_type = STREAM_TYPE_VIDEO_DIRAC;\n\n            break;\n\n        case AV_CODEC_ID_MP2:\n\n        case AV_CODEC_ID_MP3:\n\n            stream_type = STREAM_TYPE_AUDIO_MPEG1;\n\n            break;\n\n        case AV_CODEC_ID_AAC:\n\n            stream_type = (ts->flags & MPEGTS_FLAG_AAC_LATM) ? STREAM_TYPE_AUDIO_AAC_LATM : STREAM_TYPE_AUDIO_AAC;\n\n            break;\n\n        case AV_CODEC_ID_AAC_LATM:\n\n            stream_type = STREAM_TYPE_AUDIO_AAC_LATM;\n\n            break;\n\n        case AV_CODEC_ID_AC3:\n\n            stream_type = STREAM_TYPE_AUDIO_AC3;\n\n            break;\n\n        default:\n\n            stream_type = STREAM_TYPE_PRIVATE_DATA;\n\n            break;\n\n        }\n\n        *q++ = stream_type;\n\n        put16(&q, 0xe000 | ts_st->pid);\n\n        desc_length_ptr = q;\n\n        q += 2; /* patched after */\n\n\n\n        /* write optional descriptors here */\n\n        switch(st->codec->codec_type) {\n\n        case AVMEDIA_TYPE_AUDIO:\n\n            if(st->codec->codec_id==AV_CODEC_ID_EAC3){\n\n                *q++=0x7a; // EAC3 descriptor see A038 DVB SI\n\n                *q++=1; // 1 byte, all flags sets to 0\n\n                *q++=0; // omit all fields...\n\n            }\n\n            if(st->codec->codec_id==AV_CODEC_ID_S302M){\n\n                *q++ = 0x05; /* MPEG-2 registration descriptor*/\n\n                *q++ = 4;\n\n                *q++ = 'B';\n\n                *q++ = 'S';\n\n                *q++ = 'S';\n\n                *q++ = 'D';\n\n            }\n\n\n\n            if (lang) {\n\n                char *p;\n\n                char *next = lang->value;\n\n                uint8_t *len_ptr;\n\n\n\n                *q++ = 0x0a; /* ISO 639 language descriptor */\n\n                len_ptr = q++;\n\n                *len_ptr = 0;\n\n\n\n                for (p = lang->value; next && *len_ptr < 255 / 4 * 4; p = next + 1) {\n\n                    next = strchr(p, ',');\n\n                    if (strlen(p) != 3 && (!next || next != p + 3))\n\n                        continue; /* not a 3-letter code */\n\n\n\n                    *q++ = *p++;\n\n                    *q++ = *p++;\n\n                    *q++ = *p++;\n\n\n\n                if (st->disposition & AV_DISPOSITION_CLEAN_EFFECTS)\n\n                    *q++ = 0x01;\n\n                else if (st->disposition & AV_DISPOSITION_HEARING_IMPAIRED)\n\n                    *q++ = 0x02;\n\n                else if (st->disposition & AV_DISPOSITION_VISUAL_IMPAIRED)\n\n                    *q++ = 0x03;\n\n                else\n\n                    *q++ = 0; /* undefined type */\n\n\n\n                    *len_ptr += 4;\n\n                }\n\n\n\n                if (*len_ptr == 0)\n\n                    q -= 2; /* no language codes were written */\n\n            }\n\n            break;\n\n        case AVMEDIA_TYPE_SUBTITLE:\n\n            {\n\n                const char default_language[] = \"und\";\n\n                const char *language = lang && strlen(lang->value) >= 3 ? lang->value : default_language;\n\n\n\n                if (st->codec->codec_id == AV_CODEC_ID_DVB_SUBTITLE) {\n\n                    uint8_t *len_ptr;\n\n                    int extradata_copied = 0;\n\n\n\n                    *q++ = 0x59; /* subtitling_descriptor */\n\n                    len_ptr = q++;\n\n\n\n                    while (strlen(language) >= 3 && (sizeof(data) - (q - data)) >= 8) { /* 8 bytes per DVB subtitle substream data */\n\n                        *q++ = *language++;\n\n                        *q++ = *language++;\n\n                        *q++ = *language++;\n\n                        /* Skip comma */\n\n                        if (*language != '\\0')\n\n                            language++;\n\n\n\n                        if (st->codec->extradata_size - extradata_copied >= 5) {\n\n                            *q++ = st->codec->extradata[extradata_copied + 4]; /* subtitling_type */\n\n                            memcpy(q, st->codec->extradata + extradata_copied, 4); /* composition_page_id and ancillary_page_id */\n\n                            extradata_copied += 5;\n\n                            q += 4;\n\n                        } else {\n\n                            /* subtitling_type:\n\n                             * 0x10 - normal with no monitor aspect ratio criticality\n\n                             * 0x20 - for the hard of hearing with no monitor aspect ratio criticality */\n\n                            *q++ = (st->disposition & AV_DISPOSITION_HEARING_IMPAIRED) ? 0x20 : 0x10;\n\n                            if ((st->codec->extradata_size == 4) && (extradata_copied == 0)) {\n\n                                /* support of old 4-byte extradata format */\n\n                                memcpy(q, st->codec->extradata, 4); /* composition_page_id and ancillary_page_id */\n\n                                extradata_copied += 4;\n\n                                q += 4;\n\n                            } else {\n\n                                put16(&q, 1); /* composition_page_id */\n\n                                put16(&q, 1); /* ancillary_page_id */\n\n                            }\n\n                        }\n\n                    }\n\n\n\n                    *len_ptr = q - len_ptr - 1;\n\n                } else if (st->codec->codec_id == AV_CODEC_ID_DVB_TELETEXT) {\n\n                    uint8_t *len_ptr = NULL;\n\n                    int extradata_copied = 0;\n\n\n\n                    /* The descriptor tag. teletext_descriptor */\n\n                    *q++ = 0x56;\n\n                    len_ptr = q++;\n\n\n\n                    while (strlen(language) >= 3) {\n\n                        *q++ = *language++;\n\n                        *q++ = *language++;\n\n                        *q++ = *language++;\n\n                        /* Skip comma */\n\n                        if (*language != '\\0')\n\n                            language++;\n\n\n\n                        if (st->codec->extradata_size - 1 > extradata_copied) {\n\n                            memcpy(q, st->codec->extradata + extradata_copied, 2);\n\n                            extradata_copied += 2;\n\n                            q += 2;\n\n                        } else {\n\n                            /* The Teletext descriptor:\n\n                             * teletext_type: This 5-bit field indicates the type of Teletext page indicated. (0x01 Initial Teletext page)\n\n                             * teletext_magazine_number: This is a 3-bit field which identifies the magazine number.\n\n                             * teletext_page_number: This is an 8-bit field giving two 4-bit hex digits identifying the page number. */\n\n                            *q++ = 0x08;\n\n                            *q++ = 0x00;\n\n                        }\n\n                    }\n\n\n\n                    *len_ptr = q - len_ptr - 1;\n\n                 }\n\n            }\n\n            break;\n\n        case AVMEDIA_TYPE_VIDEO:\n\n            if (stream_type == STREAM_TYPE_VIDEO_DIRAC) {\n\n                *q++ = 0x05; /*MPEG-2 registration descriptor*/\n\n                *q++ = 4;\n\n                *q++ = 'd';\n\n                *q++ = 'r';\n\n                *q++ = 'a';\n\n                *q++ = 'c';\n\n            }\n\n            break;\n\n        case AVMEDIA_TYPE_DATA:\n\n            if (st->codec->codec_id == AV_CODEC_ID_SMPTE_KLV) {\n\n                *q++ = 0x05; /* MPEG-2 registration descriptor */\n\n                *q++ = 4;\n\n                *q++ = 'K';\n\n                *q++ = 'L';\n\n                *q++ = 'V';\n\n                *q++ = 'A';\n\n            }\n\n            break;\n\n        }\n\n\n\n        val = 0xf000 | (q - desc_length_ptr - 2);\n\n        desc_length_ptr[0] = val >> 8;\n\n        desc_length_ptr[1] = val;\n\n    }\n\n    mpegts_write_section1(&service->pmt, PMT_TID, service->sid, ts->tables_version, 0, 0,\n\n                          data, q - data);\n\n}\n", "idx": 4896, "substitutes": {"s": ["rs", "gs", "b", "less", "ns", "conf", "c", "ats", "sys", "cs", "comm", "os", "ps", "ms", "g", "n", "ds", "t", "se", "js", "ins", "sv", "ls", "services", "v", "ims", "stats", "sl", "m", "spec", "hs", "ss", "serv", "sq", "fs", "in", "S", "sts", "series", "source", "sports", "aws", "ops"], "service": ["sp", "event", "ice", "task", "c", "ctx", "set", "store", "state", "Service", "file", "is", "context", "process", "t", "se", "server", "support", "js", "sv", "services", "start", "v", "command", "m", "status", "vc", "serv", "storage", "y", "handler", "sky", "address", "session", "info", "spe", "library", "source"], "ts": ["rs", "tes", "ns", "ics", "its", "ats", "pt", "cs", "Ts", "nt", "aps", "terms", "ta", "TS", "ps", "als", "ms", "mt", "tn", "uts", "ds", "ops", "t", "wt", "js", "ls", "stats", "vs", "hs", "ss", "bs", "tx", "td", "sts", "tt", "tc"], "data": ["bytes", "window", "values", "buf", " Data", "ATA", "buffer", "d", "n", " DATA", "len", "name", "ata", "zero", "vals", "key", "t", "Data", "str", "value", "w", "code", "v", "final", "stream", "block", "DATA", "length", "arr", "x", "a", "def", "xff"], "q": ["qual", "b", "quant", "it", "quote", "c", "u", "qs", "buf", "pt", "qi", "seq", "g", "d", "iq", "queue", "t", "quality", "Q", "w", "query", "pkg", "qv", "ue", "k", "qa", "eq", "v", "req", "qq", "qu", "dq", "m", "ch", "quit", "cv", "aq", "sq", "f", "qt", "pp", "length", "z", "j", "x", "l"], "desc_length_ptr": ["desc_length_tr", "desc_size_tr", "desc_size_ptr", "desc_size_len", "desc_length_len", "desc_size_length", "desc_length_length"], "program_info_length_ptr": ["program_info_length_tr", "program_info_length2req", "program_info_Length_addr", "program_info_length_req", "program_info_length2addr", "program_info_length_length", "program_info_len_desc", "program_info_Length_ptr", "program_info_len_ptr", "program_info_len_req", "program_info_Length_pointers", "program_info_len_length", "program_info_length_addr", "program_info_length_pointers", "program_info_Length_req", "program_info_Length_length", "program_info_len_obj", "program_info_length_obj", "program_info_len_tr", "program_info_len_offset", "program_info_length_desc", "program_info_length_offset", "program_info_length2pointers", "program_info_len_addr", "program_info_length2ptr"], "val": [" delta", "b", "it", "mem", "u", "ctx", "Val", " v", "pt", " valid", "buf", "alpha", "valid", "seq", " al", "vol", "len", " el", " value", "vals", " interval", "ival", "t", "value", "sel", "bal", "bit", "ref", "pr", "lev", "au", "max", "v", "num", "pal", "aval", " aval", "ch", "al", "ret", "tx", "eval", "Value", "AL", "vt", "VAL", " len", "z", " eval", "x", "res", "l", "elt"], "stream_type": ["wrapper_template", "streamityTYPE", "streamingtype", "streamitystyle", " stream_TYPE", "streamlistTYPE", "wrappererstyle", "stream_category", "stream_ype", "wrapper_type", "stream_module", "sampleityname", "stream_policy", "streamlistcategory", "streamingpolicy", "stream_info", "iterator_module", "iterator_type", "wrapperertemplate", "track_style", "trackitynumber", "streamlistype", "streamitystatus", "streamityname", "stream_status", " stream_ty", "sampleityid", "streamingmodule", "streamlype", "streamertype", "sampleitytype", " stream_name", "iteratoringmodule", "wrapper_policy", "streamertemplate", "streamerstyle", "streamlytype", "streamlnumber", "streamityinfo", "stream_id", "sample_info", "track_number", "streamableid", "streamlyowner", "streamlycategory", "streamltype", "streamlisttype", "stream_style", " stream_owner", "stream_owner", "sampleityinfo", "iterator_id", "streamlstyle", "streamityspec", "streamablemodule", "streamingid", "ream_type", "streamabletype", "ream_spec", "stream_template", "streamingcategory", "sample_name", "wrapper_style", "stream_TYPE", "streamingstyle", " stream_category", "sample_id", "streamerpolicy", "stream_number", "iteratoringtype", "streamablecategory", "ream_status", "sample_type", "trackitystyle", "wrappererpolicy", "streamableowner", "streamityid", "iteratoringcategory", "stream_ty", "iterator_category", "trackitytype", "streamlcategory", "stream_name", "stream_spec", "ream_TYPE", "track_type", "wrapperertype", " stream_ype", "streamablename", "streamitynumber", "iteratoringid", "streamlyname", "streamitytype", "streamlTYPE", "streamingtemplate"], "i": ["ic", "ini", "ij", "ei", "ci", "b", "it", "c", "u", "cli", "oi", "gi", "mi", "qi", "ip", "li", "si", "g", "zi", "ind", "xi", "index", "t", "hi", "pi", "bi", "multi", "ri", "me", "id", "ui", "ki", "ji", "k", "phi", "ti", "v", "ix", "ai", "m", "I", "batch", "y", "\u0438", "sim", "iu", "e", "info", "in", "j", "x", "di", "ii", "l"], "st": ["so", "sp", "sw", "ct", "it", "src", "est", "step", "stage", "set", "nd", "pt", "sc", "nt", "std", "tr", "irst", "bt", "t", "se", "stop", "str", "th", "sv", "sm", "rest", "start", "station", "v", "sh", "sl", "rt", "stream", "ss", "sn", "stable", "ist", "ST", "ste", "td", "sts", "sta", "ost", "St", "tt"], "ts_st": ["js_ST", "js_sc", "ts_ST", "ts__ste", "js_st", "ts_sc", "js__sc", "js__ST", "ts_ste", "ts__st", "ts__ST", "js__st", "ts__sc", "js_ste", "js__ste"], "lang": ["cod", "trans", "ang", "ec", "lib", "ind", "lc", "line", "kl", "pos", "ng", "angs", "keys", "meta", "sl", "lvl", "translation", "desc", "bl", "obj", "l", "hl", "kb", "enc", "nl", "mo", "def", "loc"]}}
{"project": "qemu", "commit_id": "a7812ae412311d7d47f8aa85656faadac9d64b56", "target": 0, "func": "static unsigned int dec_addi_r(DisasContext *dc)\n\n{\n\n\tTCGv t0;\n\n\tDIS(fprintf (logfile, \"addi.%c $r%u, $r%u\\n\",\n\n\t\t    memsize_char(memsize_zz(dc)), dc->op2, dc->op1));\n\n\tcris_cc_mask(dc, 0);\n\n\tt0 = tcg_temp_new(TCG_TYPE_TL);\n\n\ttcg_gen_shl_tl(t0, cpu_R[dc->op2], tcg_const_tl(dc->zzsize));\n\n\ttcg_gen_add_tl(cpu_R[dc->op1], cpu_R[dc->op1], t0);\n\n\ttcg_temp_free(t0);\n\n\treturn 2;\n\n}\n", "idx": 4899, "substitutes": {"dc": ["db", "draw", "design", "loc", "ctl", "dat", "fee", "c", "wcs", "pc", "bc", "cont", "sys", " mc", "cs", "sc", "fc", "DC", "du", "d", "cm", "dt", "dl", "nc", "ec", "ds", "lc", "cc", "dr", "rc", "dm", "kw", "oc", "dim", "dd", "df", "ac", "vc", "dir", "mm", "disc", "cd", "cca", "desc", "doc", "mc", "dp", "ca", "currency", "de", "cat", "ga", "coord", "di", "cu", "def", "inc", "tc", "da"], "t0": ["tfrom", " t1", "T1", "tc1", "T180", " t3", "tcear", " tZero", "Targ", "TZero", "tnarg", "c1", "t180", "cZero", "tZero", "tc0", "Tear", "tear", "targ", "Tfrom", "c0", "t1", " tear", "p2", "p1", "T3", "tempfrom", " t180", "T2", "tn0", "t3", "c180", "T0", "p3", "tc2", "p0", "tn1", "t2", " tfrom", "temp1", "temp0", " t2", " targ"]}}
{"project": "qemu", "commit_id": "42a268c241183877192c376d03bd9b6d527407c7", "target": 0, "func": "static void gen_trap (DisasContext *ctx, uint32_t opc,\n\n                      int rs, int rt, int16_t imm)\n\n{\n\n    int cond;\n\n    TCGv t0 = tcg_temp_new();\n\n    TCGv t1 = tcg_temp_new();\n\n\n\n    cond = 0;\n\n    /* Load needed operands */\n\n    switch (opc) {\n\n    case OPC_TEQ:\n\n    case OPC_TGE:\n\n    case OPC_TGEU:\n\n    case OPC_TLT:\n\n    case OPC_TLTU:\n\n    case OPC_TNE:\n\n        /* Compare two registers */\n\n        if (rs != rt) {\n\n            gen_load_gpr(t0, rs);\n\n            gen_load_gpr(t1, rt);\n\n            cond = 1;\n\n        }\n\n        break;\n\n    case OPC_TEQI:\n\n    case OPC_TGEI:\n\n    case OPC_TGEIU:\n\n    case OPC_TLTI:\n\n    case OPC_TLTIU:\n\n    case OPC_TNEI:\n\n        /* Compare register to immediate */\n\n        if (rs != 0 || imm != 0) {\n\n            gen_load_gpr(t0, rs);\n\n            tcg_gen_movi_tl(t1, (int32_t)imm);\n\n            cond = 1;\n\n        }\n\n        break;\n\n    }\n\n    if (cond == 0) {\n\n        switch (opc) {\n\n        case OPC_TEQ:   /* rs == rs */\n\n        case OPC_TEQI:  /* r0 == 0  */\n\n        case OPC_TGE:   /* rs >= rs */\n\n        case OPC_TGEI:  /* r0 >= 0  */\n\n        case OPC_TGEU:  /* rs >= rs unsigned */\n\n        case OPC_TGEIU: /* r0 >= 0  unsigned */\n\n            /* Always trap */\n\n            generate_exception(ctx, EXCP_TRAP);\n\n            break;\n\n        case OPC_TLT:   /* rs < rs           */\n\n        case OPC_TLTI:  /* r0 < 0            */\n\n        case OPC_TLTU:  /* rs < rs unsigned  */\n\n        case OPC_TLTIU: /* r0 < 0  unsigned  */\n\n        case OPC_TNE:   /* rs != rs          */\n\n        case OPC_TNEI:  /* r0 != 0           */\n\n            /* Never trap: treat as NOP. */\n\n            break;\n\n        }\n\n    } else {\n\n        int l1 = gen_new_label();\n\n\n\n        switch (opc) {\n\n        case OPC_TEQ:\n\n        case OPC_TEQI:\n\n            tcg_gen_brcond_tl(TCG_COND_NE, t0, t1, l1);\n\n            break;\n\n        case OPC_TGE:\n\n        case OPC_TGEI:\n\n            tcg_gen_brcond_tl(TCG_COND_LT, t0, t1, l1);\n\n            break;\n\n        case OPC_TGEU:\n\n        case OPC_TGEIU:\n\n            tcg_gen_brcond_tl(TCG_COND_LTU, t0, t1, l1);\n\n            break;\n\n        case OPC_TLT:\n\n        case OPC_TLTI:\n\n            tcg_gen_brcond_tl(TCG_COND_GE, t0, t1, l1);\n\n            break;\n\n        case OPC_TLTU:\n\n        case OPC_TLTIU:\n\n            tcg_gen_brcond_tl(TCG_COND_GEU, t0, t1, l1);\n\n            break;\n\n        case OPC_TNE:\n\n        case OPC_TNEI:\n\n            tcg_gen_brcond_tl(TCG_COND_EQ, t0, t1, l1);\n\n            break;\n\n        }\n\n        generate_exception(ctx, EXCP_TRAP);\n\n        gen_set_label(l1);\n\n    }\n\n    tcg_temp_free(t0);\n\n    tcg_temp_free(t1);\n\n}\n", "idx": 4924, "substitutes": {"ctx": ["ck", "cf", "setup", "ci", "ct", "cas", "cp", "conf", "c", "cmp", "wx", "sc", "fc", " cx", "cm", "cmd", "tm", "nc", "context", "hw", "cci", "xc", "cc", "pkg", "kw", "cfg", " context", "tx", "cv", "iat", "ca", "KC", "jp", "mc", "obj", "Context", "ctr", "conn", "tc", "act"], "opc": ["oppcn", "optcp", "operc", " copci", "ropcr", "iopc", "opercn", "opC", "opci", "hopc", "oppct", " opci", " ipc", " opC", "optc", "opcu", "iopct", "optcr", "opcc", " ipct", "Opcp", "Opci", " ipC", "Opcu", "opct", "hopcount", "opcp", "ropcp", "opcount", "iopcn", "opercc", "opcr", "iopcc", " opct", " copC", "hopcr", "oppcc", " copc", "opcn", "hopci", "hopcu", "hopcp", "operct", "ropcount", "oppc", "ropc", "optcount", " copct", "Opc", "optcu", " ipci", "optci"], "rs": ["rates", "as", "repl", "ris", "ars", "times", "ns", "rpm", "amps", "ats", "pps", "sys", "cs", "rx", "rans", "mr", "acts", "aps", "ps", "arts", "ms", "mt", "ts", "rows", "ds", "fps", "rob", "r", "rss", "rc", "ins", "ls", "rr", "acks", "xs", "s", "ras", "ims", "rl", "re", "vs", "reg", "ptr", "RS", "rd", "fs", "ems", "ires", "ks", "Rs", "res", "rings", "mods", "rm"], "rt": ["gt", "vr", "rot", "grad", "rpm", " addr", "pt", "rx", "nt", "TX", "mr", "rn", "addr", "rect", "mt", "tm", "RT", "rows", "t", "rw", "wt", "r", "rc", "irm", "rr", "attr", "rf", "xs", "rb", "iter", " mt", "mitt", "lt", "rl", "rm", "rid", "reg", "rin", "tmp", "rat", "ptr", "rd", "RM", "fr", "res", "x", "irt", "tt", "act", " ret"], "imm": ["orm", "um", "fm", "att", "gm", " im", "im", "mun", "rpm", "asm", "cmp", "em", "mat", "Imm", "mi", "mt", "mut", "tm", "perm", "alt", "emp", "lamm", "pm", "irm", "amm", "attr", "sm", "rr", "lim", "utm", "ims", "mitt", "dim", "m", "reg", "mm", " imp", "susp", "sim", "vm", "imp", "snap", "bm", "esm", "rm"], "cond": ["post", " ind", "cf", "thread", "form", " Cond", "chain", " cont", "ct", "ci", "rupt", " con", "cert", "call", "conf", "ond", "def", "cmp", "cont", "bc", "day", "state", "con", "compl", " conditional", " condition", "cmd", "pred", "circ", "ind", "red", "bound", "cc", "connect", "bool", "pos", "crit", "reason", "pre", "sec", "not", "req", "fun", "dd", "resp", "success", "close", "fail", "count", "mod", "comp", "check", "lock", " count", "respond", "ld", "Cond", "hold", "fd", "condition"]}}
{"project": "qemu", "commit_id": "a89f364ae8740dfc31b321eed9ee454e996dc3c1", "target": 0, "func": "static uint64_t pxa2xx_gpio_read(void *opaque, hwaddr offset,\n\n                                 unsigned size)\n\n{\n\n    PXA2xxGPIOInfo *s = (PXA2xxGPIOInfo *) opaque;\n\n    uint32_t ret;\n\n    int bank;\n\n    if (offset >= 0x200)\n\n        return 0;\n\n\n\n    bank = pxa2xx_gpio_regs[offset].bank;\n\n    switch (pxa2xx_gpio_regs[offset].reg) {\n\n    case GPDR:\t\t/* GPIO Pin-Direction registers */\n\n        return s->dir[bank];\n\n\n\n    case GPSR:\t\t/* GPIO Pin-Output Set registers */\n\n        qemu_log_mask(LOG_GUEST_ERROR,\n\n                      \"pxa2xx GPIO: read from write only register GPSR\\n\");\n\n        return 0;\n\n\n\n    case GPCR:\t\t/* GPIO Pin-Output Clear registers */\n\n        qemu_log_mask(LOG_GUEST_ERROR,\n\n                      \"pxa2xx GPIO: read from write only register GPCR\\n\");\n\n        return 0;\n\n\n\n    case GRER:\t\t/* GPIO Rising-Edge Detect Enable registers */\n\n        return s->rising[bank];\n\n\n\n    case GFER:\t\t/* GPIO Falling-Edge Detect Enable registers */\n\n        return s->falling[bank];\n\n\n\n    case GAFR_L:\t/* GPIO Alternate Function registers */\n\n        return s->gafr[bank * 2];\n\n\n\n    case GAFR_U:\t/* GPIO Alternate Function registers */\n\n        return s->gafr[bank * 2 + 1];\n\n\n\n    case GPLR:\t\t/* GPIO Pin-Level registers */\n\n        ret = (s->olevel[bank] & s->dir[bank]) |\n\n                (s->ilevel[bank] & ~s->dir[bank]);\n\n        qemu_irq_raise(s->read_notify);\n\n        return ret;\n\n\n\n    case GEDR:\t\t/* GPIO Edge Detect Status registers */\n\n        return s->status[bank];\n\n\n\n    default:\n\n        hw_error(\"%s: Bad offset \" REG_FMT \"\\n\", __FUNCTION__, offset);\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 4961, "substitutes": {"opaque": [" opois", "oplois", "oposition", "Opaques", "oplay", "omposition", "opaques", "OPatile", " opatile", "Oplay", "OPaque", "OPaques", " opaques", "ompaque", "Opaque", "opois", " oposition", "opatile", "oplosition", " oplay", "OPlay", "Opatile", "oplaque", "ompois"], "offset": ["buf", "file", "addr", "pointer", "key", "t", "pos", "attribute", "reset", "offs", "frequency", "entry", "batch", "origin", "inet", "path", "flag", "encrypted", "job", "kh", "pad", "ta", "OFF", "index", "bound", "position", "start", "code", "timeout", "port", "address", "Offset", "length", "et", "error", "prefix", "end", "type", "shift", "template", "mt", "len", "o", "r", "usage", "oid", "scroll", "name", "sp", "padding", "ff", "window", "set", "client", "buffer", "location", "seek", "data", "range", "from", "err", "slice", "id", "ref", "slot", "now", "off", "area", "alias", "count", "f", "point", "e", "offer"], "size": ["read", "SIZE", "mem", "window", "c", "type", "shift", "Size", "set", "buf", "buffer", "body", "n", "len", "data", "send", "start", "code", "area", "count", "message", "ize", "e", "length", "z", "format", "name"], "s": ["des", "sw", "ists", "less", "ches", "c", "ries", "ers", "h", "ps", "d", "ports", "ts", "settings", "eds", "t", "js", "ests", "ands", "w", "gets", "sb", "ances", "ities", "ss", "ves", "changes", "alls", "as", "rs", "ses", "ings", "ants", "ubs", "ees", "sam", "os", "g", "ms", "ains", "ores", "es", "mods", "itions", "v", "stats", "sis", "aws", "a", "gs", "bis", "ns", "orders", "ats", "ies", "comm", "p", "is", "ed", "izes", "r", "ations", "sv", "hs", "bs", "sq", "parts", "fs", "S", "rates", "b", "its", "i", "sys", "qs", "aps", "resses", "als", "erences", "ds", "ins", "ls", "ims", "outs", "sn", "states", "ums", "ords", "ments", "sts", "ing", "ions"], "ret": ["gt", "read", "ral", "result", "uf", "gc", "pret", "ert", "mem", "Return", "back", "det", "set", "nt", "g", "rets", "val", "tr", "red", "alt", "t", "value", "rem", "out", "txt", "v", "rt", "reset", "lt", "resp", "re", "status", "new", "final", "print", "RET", "pas", "jp", "f", "Ret", "ft", "arg", "ll", "res", "def", "rm", "elt", "flag"], "bank": ["bag", "tree", "chain", "model", "file", "order", "dev", "lang", "tag", "sb", "device", "book", "bridge", "comment", "batch", "family", "bin", "anch", "service", "root", "binding", "base", "rank", "ame", "brain", "ay", "go", "board", "farm", "country", "rb", "port", "volume", "scan", "jack", "pool", "black", "bm", "db", "prefix", "cash", "type", "bg", "field", "kind", "stay", "ANK", "card", "banks", "bo", " banking", "k", "plant", "cell", "disk", "gem", " branch", "Bank", "ank", "library", "ver", "bus", "agency", "b", "bn", "node", "pb", "iban", "buffer", "table", "ban", " banks", "group", "account", "parser", "bb", " Bank", "bird", "bid", "token", "leaf", "brand", "block", "browser", "rule", "bang", "alias", "shop"]}}
{"project": "FFmpeg", "commit_id": "8eb76217d0137b7adad438f6c923310fbc1fc4c1", "target": 1, "func": "static int ipvideo_decode_block_opcode_0xD(IpvideoContext *s, AVFrame *frame)\n{\n    int y;\n    unsigned char P[2];\n    /* 4-color block encoding: each 4x4 block is a different color */\n    for (y = 0; y < 8; y++) {\n        if (!(y & 3)) {\n            P[0] = bytestream2_get_byte(&s->stream_ptr);\n            P[1] = bytestream2_get_byte(&s->stream_ptr);\n        memset(s->pixel_ptr,     P[0], 4);\n        memset(s->pixel_ptr + 4, P[1], 4);\n        s->pixel_ptr += s->stride;\n    /* report success */\n    return 0;", "idx": 4995, "substitutes": {"s": ["sw", "less", "conf", "c", "http", "save", "h", "state", "self", "d", "ps", "ts", "settings", "t", "se", "js", "w", "query", "sb", "ss", "this", "rs", "q", "asm", "https", "os", "g", "ms", "ains", "es", "resource", "an", "v", "stats", "m", "vs", "aws", "a", "l", "gs", "ns", "cs", "comm", "p", "is", "sv", "webkit", "sq", "session", "fs", "S", "res", "sp", "b", "i", "sys", "qs", "set", "details", "n", "ds", "space", "ls", "ess", "ims", "status", "spec", "f", "e", "sts", "z"], "frame": ["rame", " command", "Frame", "iframe", " stream", " input", " response", " video", " frames", "frames", " message", " t", "movie", " sample", " image", " screen", " f", "block", " Frame", " block", " sequence", " chunk", "f", " pixel", " fram", " event", " window", "image"], "y": ["hey", "ty", " dy", "xy", "cy", "dy", " busy", "any", " Yi", "ym", "wy", "c", "ies", "i", "yi", "Y", "my", " ye", "uy", "gy", "p", "sy", " try", "hot", "icy", "aily", " yo", "ay", "ya", "t", "key", "height", "ny", " i", "col", "ly", " ly", " ty", "py", "ady", "yy", "ye", "yu", "yr", "iy", " j", "yet", "scroll", " ya", " py", "yt", " Ny", " my", "yl", "sky", "ys", "ey", "sim", "j", "x", " Y", "ley", "oy", "axy"], "P": ["AMP", "This", "MP", "PT", "PM", "NP", "CP", "J", "X", "PS", "Patch", "T", "Y", "M", "K", "p", "A", "YP", "New", "F", "PK", "Ps", "PA", "State", "BP", "Array", "Q", "JP", "Other", "N", "SP", "LP", "Compare", "CA", "PR", "PD", "GP", "PUT", "PIN", "Part", "PP", "Path", "Message", "V", "PI", "R", "FP", "Type", "PE", "PO", "L", "Query", "Pay", "C", "S", "DP", "Progress", "H", "TP", "Pad", "G", "AP", "IP"]}}
{"project": "qemu", "commit_id": "1964a397063967acc5ce71a2a24ed26e74824ee1", "target": 0, "func": "static int64_t migration_set_rate_limit(void *opaque, int64_t new_rate)\n\n{\n\n    MigrationState *s = opaque;\n\n    if (qemu_file_get_error(s->file)) {\n\n        goto out;\n\n    }\n\n\n\n    s->xfer_limit = new_rate;\n\n\n\nout:\n\n    return s->xfer_limit;\n\n}\n", "idx": 5035, "substitutes": {"opaque": ["ipaques", "iopaques", "iopacity", " Opush", " Opaque", "oplosit", "ipaque", "opaques", "oposit", "OPatile", "ipacity", "ipatile", "opacity", "OPaque", "popacity", "popaque", "iopatile", "popaques", "opatile", "iopaque", "popatile", "oplatile", "OPosit", "oplaque", "OPush", "oplush", " Opatile", " Oposit", "opush"], "new_rate": ["new_currency", "new_rates", "newlyrate", "new_Rate", " new_fee", " new_currency", "new_rat", " new_width", "newvalcurrency", "newlywidth", "newvalrate", "newPrat", "newPrate", "newPrates", " new_Rate", "newlyrates", "newlyrat", "newvalfee", " new_rat", " new_rates", "new_width", "new_fee", "newPwidth", "newvalRate"], "s": ["rates", "rs", "Ws", "gs", "ses", "ssl", "b", "less", "ns", "sol", "c", "its", "ches", "ats", "ies", "h", "qs", "sys", "cs", "g", "p", "als", "ps", "n", "is", "ts", "ds", "o", "eds", "t", "se", "pers", "r", "js", "ins", "sv", "ls", "sb", "services", "ess", "stats", "outs", "sl", "m", "hs", "ss", "bs", "serv", "states", "sq", "session", "parts", "ares", "S", "sts", "changes", "j", "sis", "a"]}}
{"project": "FFmpeg", "commit_id": "aefdb735c3df9480c1ca9bcf4a3835bd66271bd1", "target": 0, "func": "static void reverse_matrixing(float *su1, float *su2, int *prev_code,\n\n                              int *curr_code)\n\n{\n\n    int i, nsample, band;\n\n    float mc1_l, mc1_r, mc2_l, mc2_r;\n\n\n\n    for (i = 0, band = 0; band < 4 * 256; band += 256, i++) {\n\n        int s1 = prev_code[i];\n\n        int s2 = curr_code[i];\n\n        nsample = 0;\n\n\n\n        if (s1 != s2) {\n\n            /* Selector value changed, interpolation needed. */\n\n            mc1_l = matrix_coeffs[s1 * 2    ];\n\n            mc1_r = matrix_coeffs[s1 * 2 + 1];\n\n            mc2_l = matrix_coeffs[s2 * 2    ];\n\n            mc2_r = matrix_coeffs[s2 * 2 + 1];\n\n\n\n            /* Interpolation is done over the first eight samples. */\n\n            for (; nsample < 8; nsample++) {\n\n                float c1 = su1[band + nsample];\n\n                float c2 = su2[band + nsample];\n\n                c2 = c1 * INTERPOLATE(mc1_l, mc2_l, nsample) +\n\n                     c2 * INTERPOLATE(mc1_r, mc2_r, nsample);\n\n                su1[band + nsample] = c2;\n\n                su2[band + nsample] = c1 * 2.0 - c2;\n\n            }\n\n        }\n\n\n\n        /* Apply the matrix without interpolation. */\n\n        switch (s2) {\n\n        case 0:     /* M/S decoding */\n\n            for (; nsample < 256; nsample++) {\n\n                float c1 = su1[band + nsample];\n\n                float c2 = su2[band + nsample];\n\n                su1[band + nsample] =  c2       * 2.0;\n\n                su2[band + nsample] = (c1 - c2) * 2.0;\n\n            }\n\n            break;\n\n        case 1:\n\n            for (; nsample < 256; nsample++) {\n\n                float c1 = su1[band + nsample];\n\n                float c2 = su2[band + nsample];\n\n                su1[band + nsample] = (c1 + c2) *  2.0;\n\n                su2[band + nsample] =  c2       * -2.0;\n\n            }\n\n            break;\n\n        case 2:\n\n        case 3:\n\n            for (; nsample < 256; nsample++) {\n\n                float c1 = su1[band + nsample];\n\n                float c2 = su2[band + nsample];\n\n                su1[band + nsample] = c1 + c2;\n\n                su2[band + nsample] = c1 - c2;\n\n            }\n\n            break;\n\n        default:\n\n            assert(0);\n\n        }\n\n    }\n\n}\n", "idx": 5044, "substitutes": {"su1": ["sn2", "Su3", " su3", "su3", "tu1", "su101", "uu64", "des9", "san2", "u2", "su9", "SU64", "sudo1", "uu2", "ru0", "SU1", "bu001", "sn001", "ru2", "uu71", "pu1", "SU0", "Su1", "sn1", "SU71", "SU2", " su71", "sn30", "des0", "du1", "duOne", "tu001", "bu2", "u71", "ru9", "tu30", "ru64", "u101", "des2", "su001", "SU101", "des1", "du2", " suOne", "du0", "bu1", "tu0", "sudo001", "san71", " su001", "suOne", "bu30", "SUOne", "san1", "ru71", "su30", "uu1", "u1", "tu2", "sudo2", "pu71", "su0", "pu3", "su64", "Su71", "func", "_", "Su0", "san101", "su71", "pu0", "tu9", " su0", "ru1", "def"], "su2": ["Su2", "cuTwo", "Su1", "su22", " su22", "rutwo", "sn1", "des02", "tu2", " sutwo", "sn2", " su3", "Su3", "tu4", " su02", "so1", "su3", "tu1", "su4", "tu5", "cu02", "des3", "ru02", "desTwo", "uuTwo", "tu0", "du1", "tutwo", "su0", "cu3", "uu0", "su9", "dutwo", "so2", "Su0", "tu02", "uu2", "duTwo", "du5", "sn3", "su02", "Su4", "su5", "cu2", "tu9", "ru2", "tuTwo", " su4", "Su22", "so22", "uu9", " suTwo", "du9", "so0", "des2", " su0", "ru1", "suTwo", "Sutwo", "uu5", "sutwo", "sntwo", "du02", "du2", "du0"], "prev_code": ["prev_data", "Previous_code", "prev_buffer", "Previous___cell", "prev_cell", "Previous_cell", "prevliccode", "prev___buffer", "pre_image", "prevliccell", "prev_image", "prevlicbuffer", "Previous___case", "prevencebuffer", "prev_case", "pre_codes", "prev___cell", "prev_codes", "Previous_case", "Previous_buffer", "prev___case", "prevliccase", "pre_code", "prevencecode", "pre_data", "Previous___code", "prev___code", "prevencecell", "Previous___buffer", "prevencecase"], "curr_code": ["curr_ode", "currb_Code", "currb_code", "currCode", "currCcode", "curr_error", "currb_error", "currb_codes", "currCcodes", "currCCode", "curr_Code", "currb_ode", "curr_codes"], "i": ["ic", "ij", "ini", "chain", " bi", "ci", "b", " ii", "it", "window", "im", "client", "gi", "mi", "ip", "p", "n", "is", "xi", "ind", "index", "o", "t", "ri", "pi", "bi", "r", "go", "multi", "me", "id", "slice", "inter", "mount", "phi", "ti", "s", "v", "sym", "ix", " j", "ai", "m", "art", "I", "batch", "y", "\u0438", "io", "point", "j", "x", "di", "ii", "l"], "nsample": ["nschange", "nisimble", "ssample", "NSamp", "namesam", "nasemark", "keysenge", "nsamp", "ainsample", "unsumo", "nsaple", "connsample", "bsamp", "namesimer", "inssample", "namesmem", "NSsample", "xsamp", "xssample", "unsimer", "xspling", "mnsample", "msample", " nsam", "namespace", "connample", "onsample", "netscale", "atsam", "nsimer", "ansample", "nasimble", "mnample", "NSaple", "NSrace", "insam", "csamine", "conngrade", "netssample", "mnaple", "netsshot", "connickle", "nosamp", "insimer", "anscale", "mnoom", "nscale", "unsample", "nasshot", "ainssample", "nsirm", "enspace", "nisimer", "insamp", "NSample", "NScale", "namesim", "sam", "nsoom", "bssample", "ainsam", "namesamp", "nssample", "onsemon", "nsickle", "mnirm", " nsrace", "xsemon", "noscale", "namescale", "onsirm", "nissample", "mnchange", "xsample", "atsickle", "stscale", "nspling", "nsshot", "xsirm", "onsimer", "keyssample", "atssample", "insgrade", "ensample", "atsim", "namesamine", "nassample", "conncale", "nisemark", "conssample", "consample", "csimer", "anssample", "onsgrade", "onsam", "namespling", "nameschange", "nasample", "nsimble", "namesickle", "atspling", "xsoom", "nsumo", "ansenge", "ansimer", "xsaple", "namesrace", "atsimer", "consamp", "insample", "namesample", "atswarm", " nssample", "NSwarm", "nspace", "atscale", "nossample", "nmem", "sshot", "nasimer", "NSoom", "mnam", "bsam", " nscale", "onspling", "atsamp", "onsamp", "keyscale", "nisample", "mssample", "namesumo", "ainsim", "ansshot", "nsemon", "NSam", "onsshot", "netsample", "stsample", "namesenge", "nsmem", "connam", "ncale", "nam", "nsemark", "xsickle", "onsimble", "csample", "keysample", "atschange", "msmem", "scale", "nsrace", "unssample", "nswarm", "msam", "nisamine", "nsim", "stsshot", "space", "namesshot", "nsenge", "onssample", "nample", "mnimer", "mnumo", "namessample", "nsamine", "nickle", "nsgrade", "onsemark", "atsample", "nosample", "conspling", "bsample", "cssample", "ensam", " nswarm", "nsam", "sample", "mnemon", "enssample", "stssample"], "band": ["chain", "function", "stand", "d", "display", "Band", "plot", "bright", "light", "hub", "ind", "key", "word", "tag", "device", "layer", " Band", "bridge", "art", "period", "frequency", "batch", "io", "filter", "j", "work", "broad", "bin", "plane", "bard", "weight", "job", "stage", "amber", "brid", "plug", "index", "bound", "bit", "board", "port", "stream", "command", "load", "part", "nb", "jack", "power", "channel", "back", "field", "day", "kind", "plugin", "iband", "bo", "gain", "dB", "style", "dd", "st", "disk", "boot", "library", "statement", "b", "window", "binary", "bind", "group", "range", "burst", "slice", "border", "bid", "handle", "component", "man", "brand", "block", "tab", "lag", "handler"], "mc1_l": ["mc1pyll", "mc1_c", "mcOne_l", "mc1__ll", "mc1pyl", "mc1pyc", "mc101_c", "mc101_l", "mc1mml", "mc1__c", "mc1mmc", "mcOne__lin", "mc12c", "mc1_li", "mc1__lin", "mc1pylin", "mc1mmkl", "mcOne__l", "mc101mm1", "mcOne_li", "mc1mm1", "mc101mmc", "mc1_1", "mcOne_le", "mc1__l", "mc1_ll", "mcOne_ll", "mc101_1", "mcOne__ll", "mc101mmkl", "mc101mml", "mc101_kl", "mc12l", "mcOne_c", "mc1_kl", "mcOne__c", "mc12lin", "mc12ll", "mcOne_r", "mc1_lin", "mc1_le", "mcOne_lin"], "mc1_r": ["mcOne__b", "mcOne_l", "mc51_rr", "mc1_b", "mc1_right", "mc1__p", "mc1__or", "mc1mmer", "mc51_r", "mc51_er", "mc1_n", "mc1__n", "mcOne_r", "mc1__l", "mc51_right", "mc1_or", "mc1__b", "mc1_er", "mcOne_b", "mcOne__r", "mc1mmrr", "mcOne__p", "mcOne__or", "mcOne_n", "mcOne_er", "mc1__er", "mc1_p", "mc1_rr", "mcOne_or", "mc1mmright", "mcOne_p", "mc1__r", "mc1mmr"], "mc2_l": ["mc7_l", "mc2_e", "mc12_m", "mc2pyb", "mc96_e", "mc96_la", "mc2pylc", "mc2_b", "mc2_la", "mc2_ls", "mc2_lc", "mc7_lr", "mc2_lr", "mc22ls", "mc2_m", "mc22l", "mc2_le", "mc2pylr", "mc96_l", "mc12_l", "mc22le", "mc7_lc", "mc2pyl", "mc7_b", "mc12_ls", "mc22m", "mc12_le", "mc96_lc"], "mc2_r": ["mc2_g", "mcball_p", "mcball_rc", "mc2_p", "mc42_pair", "mc2___right", "mc42_right", "mcball___p", "mc2___pair", "mcball_rr", "mc5_rc", "mc42_r", "mcball___rc", "mc2___rc", "mcball_r", "mcball___r", "mc42_g", "mc42___g", "mc2___r", "mc2_rc", "mc42___r", "mc5_l", "mc2_right", "mc5_r", "mc5_p", "mc2___p", "mc2___g", "mc2___rr", "mc2_pair", "mc2_rr", "mcball___rr", "mc42___pair", "mc42___right"]}}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "static void scsi_disk_reset(DeviceState *dev)\n\n{\n\n    SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev.qdev, dev);\n\n    uint64_t nb_sectors;\n\n\n\n    scsi_device_purge_requests(&s->qdev, SENSE_CODE(RESET));\n\n\n\n    bdrv_get_geometry(s->qdev.conf.bs, &nb_sectors);\n\n    nb_sectors /= s->qdev.blocksize / 512;\n\n    if (nb_sectors) {\n\n        nb_sectors--;\n\n    }\n\n    s->qdev.max_lba = nb_sectors;\n\n    /* reset tray statuses */\n\n    s->tray_locked = 0;\n\n    s->tray_open = 0;\n\n}\n", "idx": 5054, "substitutes": {"dev": ["ev", "des", "mem", "cam", "pad", "DEV", "dem", "pro", "buf", "nt", "ve", "raw", "cmd", "sd", "ds", "hw", "go", "proc", "device", "out", "ad", "Device", "dd", "spec", "serv", "ptr", "priv", "test", "obj", "de", "info", "ver", "Dev", "conn", "def"], "s": ["rs", "gs", "ses", "des", "b", "sw", "ns", "sol", "eps", "ats", "ies", "sam", "qs", "state", "cs", "self", "comm", "ps", "g", "ms", "p", "is", "ts", "ds", "sync", "es", "se", "js", "ins", "ears", "sv", "ls", "sb", "ims", "stats", "sl", "m", "spec", "hs", "vs", "st", "ss", "bs", "states", "serv", "y", "sq", "fs", "obj", "S", "sts", "j", "sis", "aws", "ops"], "nb_sectors": ["nb_necs", "nb_peers", "nb_sercs", "nb_telements", "nb_searers", "nb_gellers", "nb_speers", "nb_serctions", "nb_lellers", "nb_vectors", "nb_seers", "nb_sellers", "nb_pellers", "nb_selements", "nb_segments", "nb_nellers", "nb_serors", "nb_nectors", "nb_sedarers", "nb_spegments", "nb_spections", "nb_speors", "nb_veholders", "nb_tectors", "nb_sedllers", "nb_peors", "nb_geholders", "nb_negments", "nb_teors", "nb_specs", "nb_secs", "nb_neers", "nb_pelements", "nb_tecs", "nb_lelements", "nb_vellers", "nb_gectors", "nb_spectors", "nb_sedlements", "nb_velements", "nb_sections", "nb_pectors", "nb_speholders", "nb_geors", "nb_lectors", "nb_pecs", "nb_pegments", "nb_sedctors", "nb_vearers", "nb_learers", "nb_seholders", "nb_nections", "nb_nelements", "nb_spellers", "nb_seors", "nb_serctors", "nb_neors", "nb_vecs", "nb_veors"]}}
{"project": "FFmpeg", "commit_id": "eedd9148733ff4467c62092ad1c1a26d6125b249", "target": 1, "func": "static int read_part_of_packet(AVFormatContext *s, int64_t *pts,\n\n                               int *len, int *strid, int read_packet) {\n\n    AVIOContext *pb = s->pb;\n\n    PVAContext *pvactx = s->priv_data;\n\n    int syncword, streamid, reserved, flags, length, pts_flag;\n\n    int64_t pva_pts = AV_NOPTS_VALUE, startpos;\n\n    int ret;\n\n\n\nrecover:\n\n    startpos = avio_tell(pb);\n\n\n\n    syncword = avio_rb16(pb);\n\n    streamid = avio_r8(pb);\n\n    avio_r8(pb);               /* counter not used */\n\n    reserved = avio_r8(pb);\n\n    flags    = avio_r8(pb);\n\n    length   = avio_rb16(pb);\n\n\n\n    pts_flag = flags & 0x10;\n\n\n\n    if (syncword != PVA_MAGIC) {\n\n        pva_log(s, AV_LOG_ERROR, \"invalid syncword\\n\");\n\n        return AVERROR(EIO);\n\n    }\n\n    if (streamid != PVA_VIDEO_PAYLOAD && streamid != PVA_AUDIO_PAYLOAD) {\n\n        pva_log(s, AV_LOG_ERROR, \"invalid streamid\\n\");\n\n        return AVERROR(EIO);\n\n    }\n\n    if (reserved != 0x55) {\n\n        pva_log(s, AV_LOG_WARNING, \"expected reserved byte to be 0x55\\n\");\n\n    }\n\n    if (length > PVA_MAX_PAYLOAD_LENGTH) {\n\n        pva_log(s, AV_LOG_ERROR, \"invalid payload length %u\\n\", length);\n\n        return AVERROR(EIO);\n\n    }\n\n\n\n    if (streamid == PVA_VIDEO_PAYLOAD && pts_flag) {\n\n        pva_pts = avio_rb32(pb);\n\n        length -= 4;\n\n    } else if (streamid == PVA_AUDIO_PAYLOAD) {\n\n        /* PVA Audio Packets either start with a signaled PES packet or\n\n         * are a continuation of the previous PES packet. New PES packets\n\n         * always start at the beginning of a PVA Packet, never somewhere in\n\n         * the middle. */\n\n        if (!pvactx->continue_pes) {\n\n            int pes_signal, pes_header_data_length, pes_packet_length,\n\n                pes_flags;\n\n            unsigned char pes_header_data[256];\n\n\n\n            pes_signal             = avio_rb24(pb);\n\n            avio_r8(pb);\n\n            pes_packet_length      = avio_rb16(pb);\n\n            pes_flags              = avio_rb16(pb);\n\n            pes_header_data_length = avio_r8(pb);\n\n\n\n            if (pes_signal != 1 || pes_header_data_length == 0) {\n\n                pva_log(s, AV_LOG_WARNING, \"expected non empty signaled PES packet, \"\n\n                                          \"trying to recover\\n\");\n\n                avio_skip(pb, length - 9);\n\n                if (!read_packet)\n\n                    return AVERROR(EIO);\n\n                goto recover;\n\n            }\n\n\n\n            ret = avio_read(pb, pes_header_data, pes_header_data_length);\n\n            if (ret != pes_header_data_length)\n\n                return ret < 0 ? ret : AVERROR_INVALIDDATA;\n\n            length -= 9 + pes_header_data_length;\n\n\n\n            pes_packet_length -= 3 + pes_header_data_length;\n\n\n\n            pvactx->continue_pes = pes_packet_length;\n\n\n\n            if (pes_flags & 0x80 && (pes_header_data[0] & 0xf0) == 0x20)\n\n                pva_pts = ff_parse_pes_pts(pes_header_data);\n\n        }\n\n\n\n        pvactx->continue_pes -= length;\n\n\n\n        if (pvactx->continue_pes < 0) {\n\n            pva_log(s, AV_LOG_WARNING, \"audio data corruption\\n\");\n\n            pvactx->continue_pes = 0;\n\n        }\n\n    }\n\n\n\n    if (pva_pts != AV_NOPTS_VALUE)\n\n        av_add_index_entry(s->streams[streamid-1], startpos, pva_pts, 0, 0, AVINDEX_KEYFRAME);\n\n\n\n    *pts   = pva_pts;\n\n    *len   = length;\n\n    *strid = streamid;\n\n    return 0;\n\n}\n", "idx": 5060, "substitutes": {"s": ["as", "rs", "gs", "ses", "sp", "b", "sw", "sg", "ar", "ns", "conf", "c", "its", "ats", "sys", "set", "qs", "cs", "sc", "os", "p", "ps", "g", "ms", "n", "is", "ts", "ds", "t", "es", "js", "w", "ins", "sv", "ls", "sm", "sb", "scl", "v", "stats", "m", "a", "hs", "bs", "ss", "south", "sq", "fs", "us", "e", "S", "sts", "z", "x", "aws", "l"], "pts": ["ptt", "portts", "pkgs", "portt", "portsets", "ports", "ptts", "cmdt", "cmdts", "ptsets", "pkgsets", "pkgt", "cmds", "cmdsets", "pkgts"], "len": ["bytes", "ln", "mem", "Len", "offset", "lf", "elt", "seq", "dl", "ml", "val", "lan", "lang", "el", "pos", "ls", "lp", "en", "fin", "load", "size", "ld", "ll", "nl", "l", "loc"], "strid": ["strname", "stringid", "streamId", " stride", "stringId", "stride", "stringname", "streamname", "stringide", " strname", "streamide", "strId", " strId"], "read_packet": ["readtoctets", "read_octet", "readtoctET", "read_preset", "read_presets", "read_ppacket", "readtoctacket", "read_ppet", "readtpackets", "readtpackET", "read_presET", "read_ppET", "readtoctet", "read_presacket", "read_packacket", "read_ppets", "read_packET", "read_octacket", "read_packets", "readtpackacket", "readtpacket", "read_octets", "read_octET"], "pb": ["db", "pid", "peer", "gb", "uf", "sp", "stab", "b", "bj", "um", "wp", "cp", "eb", "rpm", "asm", "pc", "ctx", "ping", "sam", "bank", "sys", "pt", "buf", "prot", "buffer", "msg", "p", "tg", "pa", "mt", "bp", "tm", "typ", "vp", "ts", "cb", "pl", "wb", "fp", "erb", "func", "lb", "pm", "bb", "pg", "pkg", "proc", "py", "sb", "lp", "rb", "emb", "tab", "bs", "tx", "cv", "fb", "tmp", "pool", "jp", "np", "amp", "pd", "conv", "dp", "vm", "PB", "pp", "td", "tk", "tp", "tc", "mp"], "pvactx": ["puvacttx", "pvactX", "pvictxp", "pvacttx", "pvpactx", "pvctex", "pvectx", "pvectex", "puvactx", "pvctxx", "pvictx", "pvpactX", "puvctX", "pvctX", "pvicttx", "pvpectex", "puvcttx", "pvpectx", "puvctxp", "puvctx", "puvactX", "pvctxX", "pvcttx", "pvectX", "pvictX", "pvactex", "pvctxtx", "pvctx", "pvctxp", "pvctxex", "pvpecttx", "pvpactex", "puvactxp", "pvactxp", "pvpectX", "pvecttx", "pvpacttx"], "syncword": ["synno", "synword", "scanterm", "synwords", " syncno", "polltag", "locktext", "syncterm", " synctext", "synterm", " syncbyte", "yncterm", "syncno", "synctype", "synctag", "yncbyte", "locktype", "lockword", "polltype", "scanWord", "synWord", "polltext", "syncWord", "scanwords", "syncwords", "yncword", "yncwords", " syncwords", " synctag", "locktag", "syncbyte", "synbyte", "yncno", "scanword", "pollword", "yncWord", "synctext", " synctype"], "streamid": ["channelId", "formID", "streamoid", "streamId", "StreamId", "reamID", "poolId", "channelID", " streamId", " streamident", "streamtype", "pooliden", "userid", "streaminfo", "steamId", "hostid", "reamident", " streamlike", "reamid", "specID", "hostident", "StreamID", "hostide", "poolid", " streamtype", "streammid", "streamID", "streamlike", "streamide", "Streamoid", "steamID", "Streamtype", " streamID", "hostifier", "usertype", " streammid", "streamiden", " streamoid", "Streamid", "specid", "poolinfo", "channelid", " streamifier", "steamlike", " streamide", "streamifier", "reammid", "userId", "formId", "formlike", "reamiden", "reamifier", "specoid", "channelmid", "userID", " streamiden", "reamId", "reaminfo", "formid", "streamident", "steamid", " streaminfo", "reamide"], "reserved": ["reolved", "responserved", "reervation", "verserved", "Resumed", "Resolved", "responsolved", "stickerved", "resumed", "RESumed", "responservation", "preserved", "responsumed", "presserved", "reservation", "REServation", "REServed", "presolved", "Reservation", "verservation", "Reserved", "stickumed", "presumed", "resolved", "versserved", "reerved", "resserved", "versolved", "stickervation", "stickolved", "preservation", "RESolved"], "flags": ["rates", "fields", "bytes", "relations", "weights", "ants", "items", "abilities", "ags", "ints", "locks", "missions", "acts", "actions", "ps", "frames", "tests", "words", "ports", "ts", "settings", "fps", "vals", "types", "utils", "options", "atts", "orts", "blocks", "grades", "planes", "properties", "stats", "tags", "args", "bits", "vs", "Flags", "limits", "mask", "heads", "features", "faces", "ops", "flag"], "length": ["bytes", "form", "error", "padding", "pieces", "end", "type", "h", "join", "offset", "pad", "buffer", "amount", "duration", "lib", "php", "name", "data", "total", "full", "range", "quality", "height", "maximum", "limit", "position", "Length", "word", "options", "always", "ENGTH", "angle", "ength", "load", "volume", "expected", "capacity", "count", "f", "message", "loop", "shape", "L", "size", "time", "pp", "performance", "other", "l", "sequence"], "pts_flag": ["ptts_mask", "pts1only", "pts_field", "ptts_field", "ptts_limit", "pts_tag", "ptps_flag", "pts1flag", "pts_mask", "pts1tag", "ptps_tag", "ptps_flags", "pts1flags", "ptts_flags", "pts_flags", "pts_limit", "pts_only", "ptts_flag", "ptps_only"], "startpos": ["endcol", "endPos", "startingposition", "endPOS", "endval", "startval", " startposition", "startingpos", "startPos", "stoppos", "endposition", "startPOS", "startingval", " startcol", "startingPos", " startPos", "endpos", "stopPos", "startposition", " startPOS", "stopPOS", " startval", "startcol", "stopcol"], "ret": ["rs", "result", "mem", "rel", "ry", "prop", "progress", "details", "rets", "fit", "val", "alt", " resp", "vals", "ref", "rev", "rem", "reset", "fin", "resp", "re", "lit", "RET", "Ret", "VAL", "res"], "pes_signal": ["pes_SIGNalog", "pes_packar", "pes_seal", "pes_conset", "pes_packals", "pes_discet", "pes_sear", "pes_seals", "pes_packal", "pes_SIGNar", "pes_signet", "pes_consaler", "pes_SIGNet", "pes_signar", "pes_signalog", "pes_discaler", "pes_consal", "pes_signals", "pes_discal", "pes_signaler", "pes_SIGNal", "pes_SIGNals", "pes_packaler", "pes_SIGNaler", "pes_sealer", "pes_discalog", "pes_consalog"], "pes_header_data_length": ["pes_header_data_long", "pes_header_data_size", "pes_header_block_size", "pes_header_block_long", "pes_header_block_len", "pes_header_block_length", "pes_header_data_len"], "pes_packet_length": ["pes_packet_data", "pes_packet_size", "pes_packacket_length", "pes_packet_p", "pes_packets_p", "pes_packet_len", "pes_packacket_size", "pes_packacket_len", "pes_packet__", "pes_packets__", "pes_packacket_data"], "pes_flags": ["pes___options", "pes___flag", "pes_flag", "pes_features", "pe_options", "pes_options", "pe_flags", "pes___flags", "pes___features", "pe_features", "pe_flag"], "pes_header_data": ["pes_Header_block", "pes_Header_DATA", "pes_header_block", "pes_Header_data", "pes_Header_table", "pes_header_DATA", "pes_header_table"]}}
{"project": "FFmpeg", "commit_id": "60f10e0ad37418cc697765d85b0bc22db70f726a", "target": 1, "func": "static void pred8x8_top_dc_rv40_c(uint8_t *src, int stride){\n\n    int i;\n\n    int dc0;\n\n\n\n    dc0=0;\n\n    for(i=0;i<8; i++)\n\n        dc0+= src[i-stride];\n\n    dc0= 0x01010101*((dc0 + 4)>>3);\n\n\n\n    for(i=0; i<8; i++){\n\n        ((uint32_t*)(src+i*stride))[0]=\n\n        ((uint32_t*)(src+i*stride))[1]= dc0;\n\n    }\n\n}\n", "idx": 5071, "substitutes": {"src": ["iv", "rs", "RC", "ser", "sr", "http", "bc", "sys", "sc", "sup", "bh", "inst", "impl", "zh", "input", "cc", "rc", "bb", "ins", "pkg", "sb", "rb", "txt", "sl", "sur", "rl", "rt", "req", "load", "st", "inner", "usc", "now", "sn", "img", "ptr", "tmp", "supp", "sq", "jp", "cur", "dest", "obj", "in", "hl", "ipl", "ctr", "source"], "stride": ["specride", "specider", " strice", "divide", "divimate", "brice", "strimate", "STRade", "strice", "STRine", "stockride", "constride", "constide", "divride", "constade", "specide", " strider", "constider", "strider", " strade", "stockider", "divider", "stockimate", "brider", "stockide", "brride", "STRider", "STRice", "strine", "strride", "STRride", "STRimate", "bride", "specine", "strade", "STRide", "divine", " strride"], "i": ["asi", "chain", "ei", " ii", "im", "ik", "gi", "zi", "ind", " ti", "hi", "pi", "key", "iter", "I", "loop", "io", "in", "j", "series", "x", "\u0438", "di", "this", "ic", "q", "mi", "my", "g", "xi", "index", "ri", "bi", "go", "ogi", "ki", "ti", "ai", "m", "PI", "remote", "info", "json", "ci", "it", "at", "ip", "li", "p", "is", "o", "dr", "to", " I", "try", "iy", "y", "ii", "init", "ini", "ij", " bi", "uri", "cli", "oi", "qi", "si", "multi", "err", "me", "ui", "id", "ji", "phi", "ims", "ix", "print", "sim", "ex", "iu", "point"], "dc0": [" dc5", "DC1", "pc1", "tcZero", "DCVal", "dc7", "dc1", "pc5", "di00", "DC8", "fc1", "dcVal", "dc5", "fc02", "dc02", "arcVal", " dc90", " dc02", "lc12", "dc8", "ccaZero", "fc0", "disc0", "DC2", "arc1", "dc12", "dcno", "tc0", "arc0", "pc02", " dc2", "dc2", "disc00", " dc7", "ccano", "dc90", "dcSystem", "DC7", "tc90", "cca90", "dc00", "dcZero", " dcZero", " dc12", "fcVal", "di12", "disc2", " dc00", "fc5", "DCSystem", "fc8", "DC0", "DC00", "lc0", "tcno", "lc00", "disc1", " dc1", " dcSystem", "cca0", " dcno", "pc0", "arc8", "disc7", "discSystem", "di0"]}}
{"project": "qemu", "commit_id": "955cc8c9541779e09895a9c5ccbf8ace15d884f5", "target": 0, "func": "static int virtio_ccw_set_vqs(SubchDev *sch, uint64_t addr, uint32_t align,\n\n                              uint16_t index, uint16_t num)\n\n{\n\n    VirtIODevice *vdev = virtio_ccw_get_vdev(sch);\n\n\n\n    if (index >= VIRTIO_PCI_QUEUE_MAX) {\n\n        return -EINVAL;\n\n    }\n\n\n\n    /* Current code in virtio.c relies on 4K alignment. */\n\n    if (addr && (align != 4096)) {\n\n        return -EINVAL;\n\n    }\n\n\n\n    if (!vdev) {\n\n        return -EINVAL;\n\n    }\n\n\n\n    virtio_queue_set_addr(vdev, index, addr);\n\n    if (!addr) {\n\n        virtio_queue_set_vector(vdev, index, 0);\n\n    } else {\n\n        /* Fail if we don't have a big enough queue. */\n\n        /* TODO: Add interface to handle vring.num changing */\n\n        if (virtio_queue_get_num(vdev, index) > num) {\n\n            return -EINVAL;\n\n        }\n\n        virtio_queue_set_vector(vdev, index, index);\n\n    }\n\n    /* tell notify handler in case of config change */\n\n    vdev->config_vector = VIRTIO_PCI_QUEUE_MAX;\n\n    return 0;\n\n}\n", "idx": 5093, "substitutes": {"sch": ["ph", "yz", "gh", "sp", "ssl", "sw", "sg", "chn", "kr", "kh", "sc", "https", "mk", "sd", "wk", "ach", "th", "chid", "sche", "hed", "Sch", "rh", "soc", "sm", "org", "sk", "sh", "ch", "hs", "ich", "orsche", "isc", "ih", "isch", "shop", "ssh", "tk"], "addr": ["init", "ssl", "prefix", "src", "conf", "ctx", "shift", "cmp", "pad", "set", "offset", "sys", "ok", "msg", "help", "ip", "map", "cmd", "add", "oad", "len", "url", "cb", "alt", "phys", "ref", "pos", "pkg", "attr", "gate", "ad", "host", "ix", "rt", "aff", "ack", "alloc", "ac", "ptr", "alias", "address", "ord", "np", "obj", "eth", "hash", "lock", "nl", "arr", "ace", "coord", "res", "conn", "x", "loc", "act"], "align": ["rot", "sw", "ctl", "conf", "weight", "pack", "cmp", "shift", "offset", "rel", "map", "rank", "cmd", "len", "val", "pay", "label", "rol", "hal", "coll", "mix", "dim", "angle", "sign", "aff", "config", "block", "aligned", "adj", "al", "scan", "alias", "address", "diff", "ign", "shape", "hash", "lock", "tool", "coord", "work", "loc", "xff"], "index": ["init", "thread", "open", "success", "sp", "instance", "node", "end", "type", "ctx", "offset", "i", "set", "find", "active", "vector", "ok", "valid", "order", "add", "rank", "round", "n", "len", "seek", "seed", "val", "ind", "row", "zero", "insert", "key", "height", "number", "position", "connect", "id", "pos", "ref", "each", "slice", "attr", "level", "start", "max", "ion", "gate", "slot", "timeout", "ix", "iter", "config", "block", "Index", "axis", "alias", "address", "diff", "loop", "size", "info", "hash", "length", "x", "loc"], "num": ["all", "Num", "mult", "um", "node", "mem", "mn", "end", "ctx", "cmp", "offset", "con", "mon", "valid", "add", "n", "no", "len", "on", "un", "phys", "number", "pos", "nm", "max", "en", "dim", "out", "NUM", "new", "nb", "count", "np", "sum", "size", "net", "nom", "x", "name"], "vdev": ["vval", "evdev", "wserv", " vval", "vvdev", " vstick", "evend", "nvdevice", " vserv", "ndev", "vvserv", "vmem", "verdata", " vend", "vdata", "uvdev", "verdevice", " vdata", "envdebug", "evserv", "nvdev", "uvtest", "nserv", " vdevice", "varscan", "envde", "vdebug", "vardev", "vev", "vswitch", "vvev", "verdev", "nvstick", " vmem", "uvblock", "vserv", "vend", "evdevice", "vtest", "uvscan", "vstick", "nvdata", "uvend", "ddevice", " vscan", "uvstick", "vde", "nev", "nval", " vswitch", "verev", "envdev", " vev", "wend", "wdev", "varblock", "vartest", "uvdebug", "vdevice", "wdata", "ddata", " vdebug", " vtest", "uvmem", "vscan", "wev", "vblock", "nvmem", "wdevice", "uvde", " vblock", "ddev", "nvswitch", "dswitch", "vvval", "nvdebug", "envend", " vde"]}}
{"project": "qemu", "commit_id": "e3f5ec2b5e92706e3b807059f79b1fb5d936e567", "target": 0, "func": "static void rtl8139_receive(void *opaque, const uint8_t *buf, size_t size)\n\n{\n\n    rtl8139_do_receive(opaque, buf, size, 1);\n\n}\n", "idx": 5099, "substitutes": {"opaque": [" oposter", "paque", " opade", "boacity", "boque", "oposter", "opque", "poster", " opacity", "opaques", "booster", "indque", "pque", "indaque", "paques", "indacity", "opade", "opacity", " opaques", "boaques", " opque", "indade", "boaque", "boade"], "buf": ["bag", "bytes", "uf", "buff", " buff", "b", "mem", "window", "pb", "br", "bc", "box", "Buffer", "uffer", "ann", "buffer", "raw", "map", "p", " avail", "queue", "data", "bound", " vec", "bb", "vec", "bar", "Buff", "rb", "v", "cap", "block", "tab", " buffer", "cv", "batch", "doc", "aka", "bin"], "size": ["form", "empty", "SIZE", " resize", " sizes", "fee", "type", "Size", "offset", "set", "see", "g", "body", "n", "len", " Size", "sent", "t", "space", "send", "code", " notice", "small", "sn", "count", "message", "shape", "sum", "ize", "e", "length", " count", "news", "name"]}}
{"project": "qemu", "commit_id": "4fa4ce7107c6ec432f185307158c5df91ce54308", "target": 0, "func": "static int local_chown(FsContext *fs_ctx, V9fsPath *fs_path, FsCred *credp)\n\n{\n\n    char buffer[PATH_MAX];\n\n    char *path = fs_path->data;\n\n\n\n    if ((credp->fc_uid == -1 && credp->fc_gid == -1) ||\n\n        (fs_ctx->export_flags & V9FS_SM_PASSTHROUGH) ||\n\n        (fs_ctx->export_flags & V9FS_SM_NONE)) {\n\n        return lchown(rpath(fs_ctx, path, buffer),\n\n                      credp->fc_uid, credp->fc_gid);\n\n    } else if (fs_ctx->export_flags & V9FS_SM_MAPPED) {\n\n        return local_set_xattr(rpath(fs_ctx, path, buffer), credp);\n\n    } else if (fs_ctx->export_flags & V9FS_SM_MAPPED_FILE) {\n\n        return local_set_mapped_file_attr(fs_ctx, path, credp);\n\n    }\n\n    return -1;\n\n}\n", "idx": 5102, "substitutes": {"fs_ctx": ["httpptsrc", "fs_cv", "fskcur", "fs5tx", "fsacsetup", "httpptctx", "http_ctx", "fsptcontext", "irs5tx", "fs___cv", "fs_cur", "fsdbjp", "fskco", "irs_cont", "fts_cfg", "httpptcontext", "irs_hw", "fs_cp", "ns_tx", "fs___cmp", "fsptcont", "http_voc", "cs_jp", "fsaccontext", "fs2hw", "fs___ctx", "fs_cmp", "fts_ctx", "fs_setup", "fsptvoc", "cs_obj", "cs_cfg", "ns_context", "fs5cont", "irs_tx", "ns_cv", "http_context", "fsptsrc", "fs_hw", "fs_obj", "fs_cont", "fskctx", "fsptctx", "fsdbcfg", "fspthw", "fspttx", "fs___voc", "fts_client", "fsdbcur", "fs_tx", "irs5ctx", "fsdbcp", " fs_cur", "ns_ctx", "fs5hw", "fs_voc", "httpptvoc", "fsdbclient", " fs_jp", "irs5hw", "fs5ctx", "fs2ctx", "fskjp", "ns_setup", "fs___context", "fs2cont", "irs_ctx", "fs_jp", "fs___src", "cs_ctx", "irs5cont", "fts_cp", "ns_conn", "http_src", "fsdbco", "fs_client", "fs_cfg", "ns_co", "fs_conn", "fs_context", "fsdbctx", " fs_co", "fsacctx", "ns_cmp", "fs_co", "fs2tx", "fsacconn", "fs_src"], "fs_path": ["cs_device", "fsacpath", "cs_crit", "fsaccontext", "cs_context", "cs_self", "cs_path", "fs5crit", "fs5path", "cs_ctx", "fs_device", "fs_context", "fs_crit", "fs5self", "fsacctx", "fsacdevice", "fs_self", "fs5ctx"], "credp": ["ciedpolicy", " credphp", " ciedp", " Credlp", "ccledlp", " Criedpi", "cclednp", "ccedP", "credpr", "ccedop", "ancriedv", "ccedpi", "ecredp", "credpolicy", "callcedp", "codedp", "credP", "cedp", "criedpr", "cpredpp", "credpp", "credpi", "cashedp", " cashedp", " Criedlp", "credvp", "credi", "credpt", "ecredinfo", "ciedpy", "cppedpt", "chedinfo", " ciedpolicy", "crednp", " ciedphp", " credpolicy", "cppedp", " Criednp", " Credp", "cursorp", "ecredvp", "cashedpkg", "cpredpt", "ccedp", "crodinfo", " credop", " cashedop", "callredp", "chedvp", "ecrodinfo", "ccledp", "crede", "cede", "codedP", "chedp", "cledpy", "credphp", "criedpress", " ciedpy", "ucpredpi", "cashedop", " Crednp", "ciedphp", "crodvp", "ancriedpr", " credpkg", "callcedP", "callredP", "cursorop", "codedop", "callredop", "ancredp", " cashedi", "codedlp", "cedlp", "ancredv", "credinfo", "ancriedp", "ancredpress", "ucredpp", "ccedpr", "credpkg", "chede", "ccedphp", "callredlp", "callcedlp", "cledpolicy", "cashedi", "ucredp", "cursorpkg", "ccledpi", "credop", "callcedop", "credv", " Credpi", "criedp", "ccedpress", "crode", "ancriedpress", "ucpredp", "ucpredpp", "ccedpolicy", "cedvp", "cppedpp", " credpy", " cashedpkg", "ecrodp", "criedpi", "csedp", "cpredp", "credlp", "cedP", " Criedp", "criedlp", "cppedpi", "csedpp", "ccedlp", "cedop", "crodp", "ccedi", "ccedpkg", "cedinfo", "criedv", "cledphp", "csedpt", "cpredpi", "ecrode", "ciedp", "ucredpt", "csedpi", "ancredpr", "ecrede", " credi", "ccedpy", "ecrodvp", "cursori", "cledp", "criednp", "ucpredpt", "ccednp", "credpress", "ccedv", "credpy", "ucredpi"], "buffer": ["package", "result", "uf", "buff", "b", "mem", "window", "channel", "pb", "c", "bank", "binary", "pad", "page", "buf", "Buffer", "template", "raw", "extra", "base", "flow", "row", "pointer", "data", "queue", "stack", "available", "append", "trace", "limit", "byte", "bar", "Buff", "password", " Buffer", "iter", "v", "command", "block", "bridge", "comment", "phrase", "fb", "batch", "cache", "f", "message", "que", "length", "text", "flag"], "path": ["package", "loc", "form", "chain", "b", "root", "PATH", "node", "binding", "prefix", "cp", "end", "ctx", "file", "template", "ip", "raw", "prop", "p", "cmd", "link", "url", "context", "pointer", "data", "full", "key", "index", "temp", "history", "trace", "value", "th", "str", "ref", "w", "pkg", "route", "transform", "Path", "port", "stream", "dir", "entry", "pattern", "ath", "current", "test", "length", "patch", "text", "name", "image"]}}
{"project": "qemu", "commit_id": "ff9d38963e55598b40237735426225c35de6c7e5", "target": 0, "func": "static void qdict_crumple_test_recursive(void)\n\n{\n\n    QDict *src, *dst, *rule, *vnc, *acl, *listen;\n\n    QObject *child, *res;\n\n    QList *rules;\n\n\n\n    src = qdict_new();\n\n    qdict_put(src, \"vnc.listen.addr\", qstring_from_str(\"127.0.0.1\"));\n\n    qdict_put(src, \"vnc.listen.port\", qstring_from_str(\"5901\"));\n\n    qdict_put(src, \"vnc.acl.rules.0.match\", qstring_from_str(\"fred\"));\n\n    qdict_put(src, \"vnc.acl.rules.0.policy\", qstring_from_str(\"allow\"));\n\n    qdict_put(src, \"vnc.acl.rules.1.match\", qstring_from_str(\"bob\"));\n\n    qdict_put(src, \"vnc.acl.rules.1.policy\", qstring_from_str(\"deny\"));\n\n    qdict_put(src, \"vnc.acl.default\", qstring_from_str(\"deny\"));\n\n    qdict_put(src, \"vnc.acl..name\", qstring_from_str(\"acl0\"));\n\n    qdict_put(src, \"vnc.acl.rule..name\", qstring_from_str(\"acl0\"));\n\n\n\n    res = qdict_crumple(src, &error_abort);\n\n\n\n    g_assert_cmpint(qobject_type(res), ==, QTYPE_QDICT);\n\n\n\n    dst = qobject_to_qdict(res);\n\n\n\n    g_assert_cmpint(qdict_size(dst), ==, 1);\n\n\n\n    child = qdict_get(dst, \"vnc\");\n\n    g_assert_cmpint(qobject_type(child), ==, QTYPE_QDICT);\n\n    vnc = qobject_to_qdict(child);\n\n\n\n    child = qdict_get(vnc, \"listen\");\n\n    g_assert_cmpint(qobject_type(child), ==, QTYPE_QDICT);\n\n    listen = qobject_to_qdict(child);\n\n    g_assert_cmpstr(\"127.0.0.1\", ==, qdict_get_str(listen, \"addr\"));\n\n    g_assert_cmpstr(\"5901\", ==, qdict_get_str(listen, \"port\"));\n\n\n\n    child = qdict_get(vnc, \"acl\");\n\n    g_assert_cmpint(qobject_type(child), ==, QTYPE_QDICT);\n\n    acl = qobject_to_qdict(child);\n\n\n\n    child = qdict_get(acl, \"rules\");\n\n    g_assert_cmpint(qobject_type(child), ==, QTYPE_QLIST);\n\n    rules = qobject_to_qlist(child);\n\n    g_assert_cmpint(qlist_size(rules), ==, 2);\n\n\n\n    rule = qobject_to_qdict(qlist_pop(rules));\n\n    g_assert_cmpint(qdict_size(rule), ==, 2);\n\n    g_assert_cmpstr(\"fred\", ==, qdict_get_str(rule, \"match\"));\n\n    g_assert_cmpstr(\"allow\", ==, qdict_get_str(rule, \"policy\"));\n\n    QDECREF(rule);\n\n\n\n    rule = qobject_to_qdict(qlist_pop(rules));\n\n    g_assert_cmpint(qdict_size(rule), ==, 2);\n\n    g_assert_cmpstr(\"bob\", ==, qdict_get_str(rule, \"match\"));\n\n    g_assert_cmpstr(\"deny\", ==, qdict_get_str(rule, \"policy\"));\n\n    QDECREF(rule);\n\n\n\n    /* With recursive crumpling, we should see all names unescaped */\n\n    g_assert_cmpstr(\"acl0\", ==, qdict_get_str(vnc, \"acl.name\"));\n\n    child = qdict_get(vnc, \"acl\");\n\n    g_assert_cmpint(qobject_type(child), ==, QTYPE_QDICT);\n\n    acl = qdict_get_qdict(vnc, \"acl\");\n\n    g_assert_cmpstr(\"acl0\", ==, qdict_get_str(acl, \"rule.name\"));\n\n\n\n    QDECREF(src);\n\n    QDECREF(dst);\n\n}\n", "idx": 5104, "substitutes": {"src": ["iv", "SOURCE", "sw", "rel", "sc", "addr", "inst", "impl", "ind", "cb", "fp", "js", "java", "sb", "txt", "secure", "cur", "dest", "scripts", "loc", "source", "rs", "setup", "lr", "rect", "sel", "str", "nil", "rb", "scan", "supp", "comp", "ctr", "trans", "gs", "ssl", "copy", "sr", "buster", "zh", "dict", "std", "usr", "rol", "rc", "Source", "sur", "rt", "ripp", "st", "bs", "usc", "sq", "hl", "grow", "ser", "its", "lat", "cont", "sys", "stat", "sync", "construct", "input", "ins", "syn", "proc", "scl", "dist", "sl", "rl", "new", "resh", "sn", "ptr", "ipl", "sts"], "dst": ["disST", "dsnd", "dnt", " dlt", "dsc", "wst", "dslt", "sdlt", "dST", "wnd", "dsnt", "dsth", "ddest", "sdst", "sdnt", " dST", "dsts", "wth", "dev", "sdsts", "dsst", " dnd", " dnt", " dsts", "disdest", "Dv", "dssc", " dsc", "Dsts", "disst", "dost", "dlt", " dth", "Dst", "deost", "dests", "Ddest", "dnd", " dv", "dv", "Dost", "dest", "dissts", " dost", "dth", " ddest", "dssts", "wsc", "DST"], "rule": ["policy", "event", "node", "ule", "file", "pri", "force", "fc", "base", "group", "val", "row", "rol", "cle", "record", "config", "comment", "action", "tx", "item", "member", "desc", "test", "filter", "rec", "Rule", "fd", "disable"], "vnc": ["svnr", "vrdc", "vns", "vrmn", " vnr", "Vnr", "vpdc", "vnt", "vpnc", "vnv", "vcn", "evmn", "vtcn", " vnv", "Vnc", "vpcn", "vtmn", "Vns", "svnc", " vns", "evne", "vdc", "vpnd", "vnl", "vrnd", "svns", " vnt", "vpnl", "evnt", "vtne", "svnl", "evnc", "svcn", "svdc", "evcn", "vpnv", "vrcn", " vcn", "vne", "svnd", "vnd", "vnr", "vrne", "evnv", "Vcn", "vtnc", "vrnc", "vmn", "vrnl", "vpnt"], "acl": ["policy", "ic", "sound", "ctx", "cl", "anc", "sc", "except", "msg", "annot", "op", "aux", "rol", "ach", "id", "ast", "attr", "mac", "control", "priority", "ack", "config", "ch", "ac", "owner", "ca", "flags", "ace", "media"], "listen": ["allon", "liston", "listening", "allen", "laten", "latense", "clened", "allener", "Listener", "allening", "listened", "latenn", "chainening", "listener", "shortenn", "chainener", "latener", "clense", "latened", "chainenn", "clener", "listense", " liston", "shortener", "Listen", "clen", "shorten", "chainen", "Listenn", " listenn", "shortense", "Listened", "listenn", "clenn", " listening", "latening", " listener", "laton"], "child": ["iv", "Child", "tree", "sound", "bot", "file", "brother", "except", "add", "dev", "key", "cle", "attribute", "ch", "request", "reader", "comment", "entry", "batch", "parent", "test", "core", "q", "root", "instance", "task", "ell", "job", "nt", "server", "ach", "el", "control", "command", "port", "part", "item", "local", "remote", "decl", "relation", "shell", "error", "type", "force", "and", "children", "try", "cell", "close", "shield", "fr", "ll", "echo", "create", "name", "node", "reply", "cl", "get", "client", "cow", "fc", "weak", "group", "ew", "row", "col", "id", "handle", "new", "block", "member", "cache", "handler", "sim", "friend", "other", "def"], "res": ["resources", "rs", "result", "error", "results", "ser", "trans", "ress", "sol", "gr", "def", "rel", "sys", "rx", "val", "aux", "usr", "Res", "vals", "r", "rss", "rc", "resource", "ref", "crit", "rev", "rem", "rest", "rek", "rr", "out", "RES", "req", "reset", "rt", "resh", "resp", "re", "respons", "reg", "fresh", "ret", "response", "der", "rera", "pas", "cons", "us", "rec", "pres", "ro", "rez", "rex", "hr", "resolution"], "rules": ["rs", "fields", "results", "relations", "items", "values", "files", "actions", "frames", "tests", "rows", "vals", "errors", "children", "options", "params", "blocks", "comments", "keys", "views", "Rules", "runs", "flags", "groups", "links", "ops"]}}
{"project": "qemu", "commit_id": "68ab47e4b4ecc1c4649362b8cc1e49794d1a6537", "target": 1, "func": "static void test_validate_fail_alternate(TestInputVisitorData *data,\n\n                                         const void *unused)\n\n{\n\n    UserDefAlternate *tmp;\n\n    Visitor *v;\n\n    Error *err = NULL;\n\n\n\n    v = validate_test_init(data, \"3.14\");\n\n\n\n    visit_type_UserDefAlternate(v, NULL, &tmp, &err);\n\n    error_free_or_abort(&err);\n\n    qapi_free_UserDefAlternate(tmp);\n\n}\n", "idx": 5121, "substitutes": {"data": ["accept", "form", "error", "result", "next", "empty", "dat", "mem", "window", "step", "join", "rel", "raw", "d", "table", "missing", "rew", "ata", "context", "t", "input", "Data", "initial", "mu", "device", "out", "spec", "reader", "batch", "DATA", "obj", "info", "in", "text", "json", "bus", "def", "da"], "unused": ["unspecified", "unusable", "uneuse", "unespecified", " untuse", " untspecified", " unusable", " untused", " untusable", "uneused", "uneusable", "unuse", " unspecified", " unuse"], "tmp": ["uv", "sp", "buff", "xy", "imm", "Temp", "dat", "src", "ctx", "cmp", "sam", "buf", "nt", "aaa", "mk", "p", "mut", "etc", "tn", "vp", "var", "perm", "emp", "temp", "old", "pkg", "attr", "rb", "txt", "nv", "mb", "m", "tab", "nb", "cv", "img", "ptr", "jp", "np", "vt", "obj", "snap", "json", "params", "tt", "mp"], "v": ["vv", "vr", "uv", "vy", "ev", "q", "b", "it", "ov", "u", "h", "av", "i", "vi", "g", "p", "vp", "var", "tv", "o", "t", "r", "w", "sv", "m", "V", "vs", "vc", "vis", "cv", "y", "f", "vt", "vm", "j", "x", "ver", "l"], "err": [" terr", "ev", "rs", "eor", "peer", "error", "Er", "conf", "fee", "kr", "gr", "br", "nr", "eas", "sys", "buf", "aaa", "mr", "msg", "er", "erd", "die", "cmd", "order", "notice", "ec", "ocr", "dev", "usr", "temp", "r", "str", "trace", "rr", "attr", "iter", "cr", "txt", "req", "resp", "der", "ptr", "priv", "obj", "fr", "arr", "res", "coord", "cert"]}}
{"project": "qemu", "commit_id": "c95de7e2c40da4235ceda6d134ae069dae80157e", "target": 1, "func": "static int qcow2_co_flush(BlockDriverState *bs)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    int ret;\n\n\n\n    qemu_co_mutex_lock(&s->lock);\n\n    ret = qcow2_cache_flush(bs, s->l2_table_cache);\n\n    if (ret < 0) {\n\n\n        return ret;\n\n    }\n\n\n\n    ret = qcow2_cache_flush(bs, s->refcount_block_cache);\n\n    if (ret < 0) {\n\n\n        return ret;\n\n    }\n\n\n\n\n    return bdrv_co_flush(bs->file);\n\n}", "idx": 5129, "substitutes": {"bs": ["asis", "bes", "gs", "bis", "ses", "b", "ns", "ubs", "its", "bos", "acs", "ats", "irms", "cks", "bc", "bsp", "cs", "ashes", "bh", "als", "ts", "bles", "hz", "BS", "uses", "css", "cus", "bi", "aus", "js", "ls", "blocks", "sb", "bps", "ims", "ubis", "outs", "rys", "bits", "vs", "hs", "aos", "ss", "bl", "fs", "ks", "sts", "ils", "obs", "bas", "aws", "lbs"], "s": ["as", "rs", "gs", "ses", "bis", "ssl", "b", "less", "ns", "its", "ats", "ies", "h", "sys", "cs", "comm", "os", "als", "p", "ms", "ps", "n", "g", "is", "ts", "has", "ds", "t", "pers", "js", "ls", "sb", "v", "ims", "stats", "iss", "args", "bits", "sa", "hs", "a", "ss", "sq", "ys", "S", "sts", "j", "sis", "aws"], "ret": ["gt", "result", "grad", "pret", "att", "reply", "back", "cont", "rep", "det", "nt", "ry", "prot", "alg", "elt", "prop", "dt", "ext", "cmd", "mt", "addr", " alt", "rets", "val", "del", "usr", "tr", "red", "alt", "err", "str", "prime", " fut", "rev", "rem", "expr", "mac", "out", "try", "txt", "sec", "rt", "reset", "lt", "resp", "re", "fun", "reg", "ptr", "lit", "print", "RET", "cat", "desc", "jp", "Ret", "nz", "ft", "net", "ll", "res", "arr", "vet", "deg", "def", "rm", "cert"]}}
{"project": "FFmpeg", "commit_id": "f7cf12b209c3a1ac2d6b797c585b593a5e9a461d", "target": 1, "func": "static int vc1_init_common(VC1Context *v)\n\n{\n\n    static int done = 0;\n\n    int i = 0;\n\n\n\n    v->hrd_rate = v->hrd_buffer = NULL;\n\n\n\n    /* VLC tables */\n\n    if(!done)\n\n    {\n\n        done = 1;\n\n        init_vlc(&ff_vc1_bfraction_vlc, VC1_BFRACTION_VLC_BITS, 23,\n\n                 ff_vc1_bfraction_bits, 1, 1,\n\n                 ff_vc1_bfraction_codes, 1, 1, INIT_VLC_USE_STATIC);\n\n        init_vlc(&ff_vc1_norm2_vlc, VC1_NORM2_VLC_BITS, 4,\n\n                 ff_vc1_norm2_bits, 1, 1,\n\n                 ff_vc1_norm2_codes, 1, 1, INIT_VLC_USE_STATIC);\n\n        init_vlc(&ff_vc1_norm6_vlc, VC1_NORM6_VLC_BITS, 64,\n\n                 ff_vc1_norm6_bits, 1, 1,\n\n                 ff_vc1_norm6_codes, 2, 2, INIT_VLC_USE_STATIC);\n\n        init_vlc(&ff_vc1_imode_vlc, VC1_IMODE_VLC_BITS, 7,\n\n                 ff_vc1_imode_bits, 1, 1,\n\n                 ff_vc1_imode_codes, 1, 1, INIT_VLC_USE_STATIC);\n\n        for (i=0; i<3; i++)\n\n        {\n\n            init_vlc(&ff_vc1_ttmb_vlc[i], VC1_TTMB_VLC_BITS, 16,\n\n                     ff_vc1_ttmb_bits[i], 1, 1,\n\n                     ff_vc1_ttmb_codes[i], 2, 2, INIT_VLC_USE_STATIC);\n\n            init_vlc(&ff_vc1_ttblk_vlc[i], VC1_TTBLK_VLC_BITS, 8,\n\n                     ff_vc1_ttblk_bits[i], 1, 1,\n\n                     ff_vc1_ttblk_codes[i], 1, 1, INIT_VLC_USE_STATIC);\n\n            init_vlc(&ff_vc1_subblkpat_vlc[i], VC1_SUBBLKPAT_VLC_BITS, 15,\n\n                     ff_vc1_subblkpat_bits[i], 1, 1,\n\n                     ff_vc1_subblkpat_codes[i], 1, 1, INIT_VLC_USE_STATIC);\n\n        }\n\n        for(i=0; i<4; i++)\n\n        {\n\n            init_vlc(&ff_vc1_4mv_block_pattern_vlc[i], VC1_4MV_BLOCK_PATTERN_VLC_BITS, 16,\n\n                     ff_vc1_4mv_block_pattern_bits[i], 1, 1,\n\n                     ff_vc1_4mv_block_pattern_codes[i], 1, 1, INIT_VLC_USE_STATIC);\n\n            init_vlc(&ff_vc1_cbpcy_p_vlc[i], VC1_CBPCY_P_VLC_BITS, 64,\n\n                     ff_vc1_cbpcy_p_bits[i], 1, 1,\n\n                     ff_vc1_cbpcy_p_codes[i], 2, 2, INIT_VLC_USE_STATIC);\n\n            init_vlc(&ff_vc1_mv_diff_vlc[i], VC1_MV_DIFF_VLC_BITS, 73,\n\n                     ff_vc1_mv_diff_bits[i], 1, 1,\n\n                     ff_vc1_mv_diff_codes[i], 2, 2, INIT_VLC_USE_STATIC);\n\n        }\n\n        for(i=0; i<8; i++)\n\n            init_vlc(&ff_vc1_ac_coeff_table[i], AC_VLC_BITS, vc1_ac_sizes[i],\n\n                     &vc1_ac_tables[i][0][1], 8, 4,\n\n                     &vc1_ac_tables[i][0][0], 8, 4, INIT_VLC_USE_STATIC);\n\n        init_vlc(&ff_msmp4_mb_i_vlc, MB_INTRA_VLC_BITS, 64,\n\n                 &ff_msmp4_mb_i_table[0][1], 4, 2,\n\n                 &ff_msmp4_mb_i_table[0][0], 4, 2, INIT_VLC_USE_STATIC);\n\n    }\n\n\n\n    /* Other defaults */\n\n    v->pq = -1;\n\n    v->mvrange = 0; /* 7.1.1.18, p80 */\n\n\n\n    return 0;\n\n}\n", "idx": 5138, "substitutes": {"v": ["vv", "ev", "uv", "vr", "q", "b", "ov", "c", "h", "av", "vi", "ve", "p", "g", "inv", "n", "vp", "var", "dev", "tv", "t", "value", "w", "sv", "k", "vo", "nv", "m", "V", "vc", "vs", "cv", "f", "vt", "conv", "vm", "j", "x", "ver", "l"], "i": ["init", "this", "ic", "ij", "asi", "ini", " bi", "ei", "ci", "b", " ii", "chain", "it", "sp", "im", "u", "cli", "oi", "gi", "mi", "qi", "ta", "ip", "er", "li", "p", "si", "ami", "zi", "n", "tim", "ind", "xi", "index", "o", "t", "hi", "pi", "bi", "multi", "ri", "dr", "me", "ui", "js", "ki", "ji", "err", " I", "ti", "iii", "ix", " j", "ai", "m", "status", "I", "batch", "y", "\u0438", "sim", "gu", "iu", "in", "io", "j", "series", "iri", "x", "di", "json", "ii", "name"]}}
{"project": "FFmpeg", "commit_id": "73e8e8dbf969b9a0bc1591abcfeba474a42e47bc", "target": 1, "func": "int av_read_packet(AVFormatContext *s, AVPacket *pkt)\n{\n    int ret, i;\n    AVStream *st;\n    for(;;){\n        AVPacketList *pktl = s->raw_packet_buffer;\n        if (pktl) {\n            *pkt = pktl->pkt;\n            if(s->streams[pkt->stream_index]->codec->codec_id != CODEC_ID_PROBE ||\n               !s->streams[pkt->stream_index]->probe_packets ||\n               s->raw_packet_buffer_remaining_size < pkt->size){\n                AVProbeData *pd = &s->streams[pkt->stream_index]->probe_data;\n                av_freep(&pd->buf);\n                pd->buf_size = 0;\n                s->raw_packet_buffer = pktl->next;\n                s->raw_packet_buffer_remaining_size += pkt->size;\n                av_free(pktl);\n                return 0;\n        av_init_packet(pkt);\n        ret= s->iformat->read_packet(s, pkt);\n        if (ret < 0) {\n            if (!pktl || ret == AVERROR(EAGAIN))\n                return ret;\n            for (i = 0; i < s->nb_streams; i++)\n                s->streams[i]->probe_packets = 0;\n        st= s->streams[pkt->stream_index];\n        switch(st->codec->codec_type){\n        case AVMEDIA_TYPE_VIDEO:\n            if(s->video_codec_id)   st->codec->codec_id= s->video_codec_id;\n            break;\n        case AVMEDIA_TYPE_AUDIO:\n            if(s->audio_codec_id)   st->codec->codec_id= s->audio_codec_id;\n            break;\n        case AVMEDIA_TYPE_SUBTITLE:\n            if(s->subtitle_codec_id)st->codec->codec_id= s->subtitle_codec_id;\n            break;\n        if(!pktl && (st->codec->codec_id != CODEC_ID_PROBE ||\n                     !st->probe_packets))\n            return ret;\n        add_to_pktbuf(&s->raw_packet_buffer, pkt, &s->raw_packet_buffer_end);\n        s->raw_packet_buffer_remaining_size -= pkt->size;\n        if(st->codec->codec_id == CODEC_ID_PROBE){\n            AVProbeData *pd = &st->probe_data;\n            av_log(s, AV_LOG_DEBUG, \"probing stream %d\\n\", st->index);\n            --st->probe_packets;\n            pd->buf = av_realloc(pd->buf, pd->buf_size+pkt->size+AVPROBE_PADDING_SIZE);\n            memcpy(pd->buf+pd->buf_size, pkt->data, pkt->size);\n            pd->buf_size += pkt->size;\n            memset(pd->buf+pd->buf_size, 0, AVPROBE_PADDING_SIZE);\n            if(av_log2(pd->buf_size) != av_log2(pd->buf_size - pkt->size)){\n                //FIXME we dont reduce score to 0 for the case of running out of buffer space in bytes\n                set_codec_from_probe_data(s, st, pd, st->probe_packets > 0 ? AVPROBE_SCORE_MAX/4 : 0);\n                if(st->codec->codec_id != CODEC_ID_PROBE){\n                    pd->buf_size=0;\n                    av_freep(&pd->buf);\n                    av_log(s, AV_LOG_DEBUG, \"probed stream %d\\n\", st->index);", "idx": 5146, "substitutes": {"s": ["styles", "sw", "less", "conf", "c", "http", "h", "terms", "self", "ads", "ps", "ts", "t", "utils", "js", "w", "events", "services", "xs", "ss", "ares", "changes", "series", "j", "sports", "as", "rs", "ses", "results", "https", "os", "g", "ms", "these", "ains", "es", "summary", "v", "stats", "tags", "bits", "m", "vs", "a", "aws", "l", "gs", "ssl", "sg", "times", "ns", "ctx", "ats", "ags", "cs", "comm", "uploads", "p", "is", "has", "r", "sv", "hs", "bs", "y", "sq", "parts", "fs", "S", "sp", "b", "eps", "its", "sys", "qs", "aps", "als", "details", "n", "ds", "ins", "ids", "ls", "ims", "args", "spec", "ex", "sts", "z"], "pkt": [" pkg", "perkt", "dppt", "fett", "facket", "ppwk", "packkt", "payett", "pingacket", "proacket", "apkt", "expkt", "pet", "pingkg", "pingkt", "pct", "brqt", "yshot", " pvc", "Pwk", "fnt", " pmsg", "perelt", "opunct", "wkg", "brett", "upunct", "respkt", "ppct", "pingelt", "apnt", " pett", "payvc", "opkt", "dck", "apacket", "ppkg", "tpshot", "upkg", "ppmsg", "ppck", "dpacket", "ppacket", "ppshot", "respshot", "tpkg", "wpvc", "pqt", "payet", "pvc", "expqt", "packpt", "apkg", "ppnt", " pwk", "pelt", " pct", " pelt", "wpkt", "Pct", "apet", "paykt", "Packet", "upkt", "respkg", "Pnt", "Pett", "ppt", "prokg", "packacket", "ykt", "dkt", "ppkt", "pwk", "brkt", "pkg", "welt", " pnt", "pett", "pppt", "opkg", "expett", "wacket", "dacket", "pmsg", "tpacket", "ppet", "opacket", "apunct", "pck", "Pet", "pnt", "respacket", "tpkt", "punct", "brshot", "dpet", "wkt", "ppelt", "dpkt", "packet", "yett", "fkt", "wpett", "wpet", "yqt", "expshot", " pck", "upacket", "pshot", "perkg", "dmsg", "peracket", "prokt", " pet", "proelt", " packet", "Pkt"], "ret": ["gt", "result", "error", "pret", "ert", "empty", "it", "att", "Return", "ber", "cont", "ter", "det", "xt", "nt", "prot", "at", "cmd", "mt", " Ret", "rets", "len", "val", "ez", "zero", "tr", "red", "t", "alt", "r", "err", "str", "pet", "ref", "after", "inter", "rev", "rem", "nil", "out", "iter", "txt", "not", "rt", "fin", "reset", "resp", "re", "fun", "print", "RET", "tf", "jp", "fail", "Ret", "nz", "ft", "arg", "hash", "j", "res", " RET", "arr", "deg", "def", "rm", "elt", "flag"], "i": ["ic", "ij", "ini", "chain", "uri", "ci", "it", "im", "c", "cli", "oi", "gi", "mi", "qi", "ip", "li", "p", "si", "zi", "n", "ind", "xi", "index", "t", "hi", "pi", "multi", "bi", "ri", "bound", "id", "ui", "ki", "k", "phi", "ir", "ti", "v", "ims", "ix", "ai", "m", "I", "batch", "y", "mc", "us", "sim", "gu", "iu", "info", "in", "j", "x", "di", "ii", "l"], "st": ["must", "put", "sp", "sw", "ct", "src", "end", "est", "step", "stage", "kt", "ost", "set", "nd", "pt", "sc", "nt", "store", "at", "stru", "inst", "mt", "stat", "ts", "std", "usr", "bt", "irst", "t", "se", "ut", "stop", "str", "th", "dr", "ast", "rest", "start", "sh", "rt", "stream", "art", "sn", "stable", "ist", "tmp", "storage", "ST", "test", "dest", "obj", "ste", "td", "ld", "sta", "sts", "ust", "St", "tt", "elt"], "pktl": ["spktl", "prentln", "ptxtl", "spptl", "expwklb", "peltla", "pkwlp", "prentL", "proktli", "prktls", "phpkwle", "prktli", "pactli", "peltlc", "pttli", "pkgl", "pktln", " pktll", "pktli", "expwkl", " pcmdli", "pktll", "pckle", "petln", "pqtli", "punctl", " pktli", "prqtls", "expktlc", "petl", "pwdl", "spktln", "pntle", "pderl", "pcmdli", " pwdls", "pptln", "packetlt", "pwkll", "pktfl", " pwdll", "prqtl", "spptln", "petL", "expktl", "punctlc", "packetl", "expwkla", "pttls", " pktln", " pktlc", "pkwl", "prqtli", "proactl", " pktls", "pptl", "peltlb", "pntls", "pwdlc", "pderln", "pwkls", "pderli", "expwklc", "pkglc", "pktlt", "pkgll", "pttln", "spptli", "pwklc", "pqtle", "pwdll", " pwdlc", "pcmdl", "pactln", "spktli", "punctlb", "prktl", "pptlt", "packetln", "pktlb", "prktle", "pptli", "pktL", "pwkl", "spktlt", "pcmdln", "pktls", "pkwle", "puxl", "pktlp", "pactL", "pkgls", "puxfl", "pactl", "prentli", "pktlc", "pderlt", "ptxtli", "pckfl", "proactli", "pntli", "pwkla", "punctla", "pkwfl", "phpkwl", "proktL", "spptlt", "pqtl", "phpkwfl", "expktlb", "ptxtls", "pntl", "pcklp", "puxlp", "proktln", "proactln", "prqtle", "pckl", "puxle", "pwdls", "pqtls", " pcmdln", "phpktl", " pcmdls", "proactL", "ptxtle", "expktla", "phpkwlp", " pwdl", "proktl", "petls", "packetli", "pktla", "pttl", " pcmdl", "petli", "pwklb", "pcmdls", "phpktlp", "pktle", "phpktfl", "phpktle", "peltl", "prentl"], "pd": ["ecd", "dj", "ctl", "xd", "dat", "po", "rpm", "pb", "ped", "md", "dt", "d", "pat", "dl", "ps", "p", "xx", "bd", "sd", "gd", "ds", "pl", "dh", "edd", "pm", "ud", "PD", "lp", "pard", "pdf", "vd", "dd", "dn", "cd", "np", "dp", "hd", "pp", "td", "ld", "tk", "pes", "wd", "tp", "fd", "od"], "probe_packets": ["probe_framesETS", "probe_packeters", "probe_packETS", "probe_messens", "probe_preseters", "probe_presens", "probe_packet", "probe_pagesens", "probe_messet", "probe_framesets", "probe_pagesets", "probe_messETS", "probe_buffeters", "probe_pens", "probe_pageset", "probe_pETS", "probe_buffens", "probe_presets", "probe_pageseters", "probe_framesens", "probe_preset", "probe_pets", "probe_pet", "probe_frameset", "probe_packens", "probe_buffet", "probe_buffets", "probe_messets"]}}
{"project": "qemu", "commit_id": "df8ad9f128c15aa0a0ebc7b24e9a22c9775b67af", "target": 1, "func": "static int nbd_can_accept(void)\n\n{\n\n    return nb_fds < shared;\n\n}\n", "idx": 5171, "substitutes": {}}
{"project": "qemu", "commit_id": "b4f72e31b924bec2c18fe0b2a8c6462dbed9dcb2", "target": 1, "func": "static int net_connect(struct XenDevice *xendev)\n\n{\n\n    struct XenNetDev *netdev = container_of(xendev, struct XenNetDev, xendev);\n\n    int rx_copy;\n\n\n\n    if (xenstore_read_fe_int(&netdev->xendev, \"tx-ring-ref\",\n\n                             &netdev->tx_ring_ref) == -1) {\n\n        return -1;\n\n    }\n\n    if (xenstore_read_fe_int(&netdev->xendev, \"rx-ring-ref\",\n\n                             &netdev->rx_ring_ref) == -1) {\n\n        return 1;\n\n    }\n\n    if (xenstore_read_fe_int(&netdev->xendev, \"event-channel\",\n\n                             &netdev->xendev.remote_port) == -1) {\n\n        return -1;\n\n    }\n\n\n\n    if (xenstore_read_fe_int(&netdev->xendev, \"request-rx-copy\", &rx_copy) == -1) {\n\n        rx_copy = 0;\n\n    }\n\n    if (rx_copy == 0) {\n\n        xen_be_printf(&netdev->xendev, 0, \"frontend doesn't support rx-copy.\\n\");\n\n        return -1;\n\n    }\n\n\n\n    netdev->txs = xc_gnttab_map_grant_ref(netdev->xendev.gnttabdev,\n\n                                          netdev->xendev.dom,\n\n                                          netdev->tx_ring_ref,\n\n                                          PROT_READ | PROT_WRITE);\n\n    netdev->rxs = xc_gnttab_map_grant_ref(netdev->xendev.gnttabdev,\n\n                                          netdev->xendev.dom,\n\n                                          netdev->rx_ring_ref,\n\n                                          PROT_READ | PROT_WRITE);\n\n    if (!netdev->txs || !netdev->rxs) {\n\n        return -1;\n\n    }\n\n    BACK_RING_INIT(&netdev->tx_ring, netdev->txs, XC_PAGE_SIZE);\n\n    BACK_RING_INIT(&netdev->rx_ring, netdev->rxs, XC_PAGE_SIZE);\n\n\n\n    xen_be_bind_evtchn(&netdev->xendev);\n\n\n\n    xen_be_printf(&netdev->xendev, 1, \"ok: tx-ring-ref %d, rx-ring-ref %d, \"\n\n                  \"remote port %d, local port %d\\n\",\n\n                  netdev->tx_ring_ref, netdev->rx_ring_ref,\n\n                  netdev->xendev.remote_port, netdev->xendev.local_port);\n\n\n\n    net_tx_packets(netdev);\n\n    return 0;\n\n}\n", "idx": 5172, "substitutes": {"xendev": ["xenerv", "xeniv", "wendev", "xendingiver", "xendoc", "xbeginoc", "xestiver", "myendev", "xenee", "xentereps", "xendsov", "xendingel", "zendedew", "xndew", "xndee", "axendev", "xendeman", "exentoc", "xentiver", "xendediver", "exentiver", "xendsel", "xenderev", "xENDdev", "xentserv", "xndiv", "xendef", "xenev", "xentiv", "myendingiver", "xendseman", "xestiv", "oxenddev", "xentew", "xndev", "xEndev", "exendev", "zenddev", "myendingel", "exentiv", "xendeerv", "xendererv", "exendec", " xndev", "xenddev", "xendingiv", "xendingdev", "xederv", "exendoc", "xndiver", "myendingdev", "xendek", "xenterDev", "exendiver", "xenedev", "xenderv", "wendediver", "oxendev", "xendedee", "xfindev", "myendingev", "xbeginserv", "xnderv", "xestdev", "xendingeps", "xendeddev", "wendedev", "exentec", "zendeddev", "exendeg", "xentdev", "zendev", "wenderv", "exentev", "xenteps", "xstarterv", "xbegindev", " xenddev", " xendee", "axendeps", "wenddev", "xendee", "exentek", "wendederv", "xEnddev", "axendingeps", "oxbeginDev", " xendiv", "xenedesc", "exentdev", "exentel", "xentel", "zendedev", "xENDerv", "xendeev", "exendek", "axenddev", "xfindel", "xendedev", " xndee", "wxentov", "wxendov", "xenterv", "axendDev", "xenterdev", "zendew", "xentek", " xndef", "myendel", "xendedserv", " xndiv", "xENDek", "xentec", "oxbegindev", "exenterv", "wenerv", "exendserv", "axendingDev", "xenedef", "xentDev", "xendiver", "xenterev", "xentoc", "xedev", "xestec", "xendel", "oxendDev", "wenev", "axendingev", "exenteg", "xndDev", "xENDev", "wxenteman", "xstartev", "xeneddev", "xestev", "oxbeginev", "xndesc", "wendiver", "xendingev", "xendederv", "exendiv", " xendesc", "xendov", "zendedeg", "xestek", "wxendel", "xndeg", "xendedoc", "xbeginee", "xendec", " xndesc", "xenteg", "xbeginDev", "xfindov", "axendingdev", "wxendeman", "wendeddev", "xbeginev", "xentev", "xeddev", "xenteman", "xendiv", "xendingDev", "xentee", "xfindeman", "xendedesc", "exenddev", "exendel", "xendedew", "xnddev", "xstartdev", "xendedef", "xentov", "xendedel", "exentserv", "xendserv", "xediver", "xbeginel", "xndef", "zendeg", "xendsev", "xendedeg", "wxentel", "wxentev", "xEndec", "xendedDev", "xendeg", "xbegineg", "myendiver", " xnddev", "myenddev", "exenderv", "xendeps", "xendesc", "wxendev", "xEndek", "xendew", " xendef", "oxendee", "xendDev", "oxbeginee"], "netdev": ["plainev", "networkdriver", "nerev", "matvalid", "netscam", "netdebug", "nedevice", "ntdiv", "nercam", "ntdriver", "conndev", " netdata", "networkdraw", "networkev", "etvar", "munenv", "networkDEV", "netsdebug", "netdevice", "batvalid", "monDEV", "netdata", "etgo", "webev", "potDev", "webval", "networkver", " netdevice", "netDEV", "motvalid", "noteDEV", "monpad", "natdevelop", "potver", "netsver", "nextgo", "NETdevice", "ntdevice", "natve", "networkdev", "connDEV", "potvalid", "netev", "networkdiv", "potprop", "netdraw", "netDev", "ntver", "mungu", "networkdata", "natprop", "nerDev", "networkdevelop", "netsgo", "etdiv", "plainvalid", "etdev", "mundev", "etvalid", "mundevice", "plaindevice", "etdevice", "webcam", " netvalid", "nepad", "netdevelop", "nextdev", "plaingo", "endev", "netgo", "natdev", "nerdebug", "netserv", "matver", "nutDev", "plaindraw", "mondev", "matDev", "nutdev", "netver", "etcam", " netcam", "nextdevice", "netpriv", " netdriver", "natvar", "webgu", "notedev", "potdev", "netvalid", "netsev", " netver", "netve", "networkdevice", " netserv", "webver", "webserv", " netgo", "natcam", "nerprop", "totaldev", "plaindev", "nerve", "networkdebug", " netbuild", "netdiv", "netsdevelop", "enval", "mondevice", "networkvalid", "nutpriv", "webdraw", "nerdev", " netdiv", "ntdev", "motdebug", "neDEV", "nerserv", "netpad", "netsdev", "plaingu", "etenv", "networkval", "batDev", "networkDev", "matcam", "connbuild", " netpriv", "plainve", "matve", "endevice", "webDEV", "plaindebug", "NETdata", "netsvalid", "enpriv", "natgo", "netval", "netvar", "networkserv", "nextvalid", "motev", "webpriv", " netpad", "nerpriv", "netcam", "netprop", " netdebug", "webdevice", "natev", "matgu", "batver", "nutDEV", "networkbuild", "networkvar", "netdriver", "totalev", "nerdevice", "matdev", "netsdevice", "netgu", "natdiv", "motdev", "potve", "notepriv", "nedev", "totalvalid", "etgu", "networkgo", "NETcam", "nutdevice", "batdev", "totalval", "netbuild", "nutserv", "webdev", "potcam", "NETdev", "potev", "notedevice", "matval", "conndevice", "matev", "webenv", "networkpriv", "netenv", " netDev", " netDEV", "webgo", "potgu", "networkcam"], "rx_copy": ["rxmycopy", "rx_match", "rx___cop", "rx_skip", "ry_copy", "rx_map", "rx_clone", "ry_clip", "rx_parent", "rx___copy", "rxlogcop", "rx_cop", "rxmyready", "rx___skip", "tx_ready", "rf_skip", "rxlogclone", "rxmyparent", "rxmyclip", "rf_co", "rx_co", "tx_map", "rf_copy", "tx_parent", "rxlogmap", "rxlogcopy", "tx_clone", "rf_cop", "tx_copy", "rx___co", "tx_clip", "ry_match", "ry_clone", "rx_ready", "rx_clip", "tx_cop"]}}
{"project": "qemu", "commit_id": "5ee5993001cf32addb86a92e2ae8cb090fbc1462", "target": 1, "func": "static bool do_modify_softint(CPUSPARCState *env, uint32_t value)\n\n{\n\n    if (env->softint != value) {\n\n        env->softint = value;\n\n#if !defined(CONFIG_USER_ONLY)\n\n        if (cpu_interrupts_enabled(env)) {\n\n\n            cpu_check_irqs(env);\n\n\n        }\n\n#endif\n\n        return true;\n\n    }\n\n    return false;\n\n}", "idx": 5174, "substitutes": {"env": ["policy", "db", "vv", "ev", "uv", "esc", "window", "end", "ov", "forge", "walker", "ctx", "here", "gov", "conn", "era", "er", "erd", "ext", "eg", "timer", "vp", "ew", "ec", "viron", "enter", "cb", "environment", "hw", "server", "err", "query", " environment", "Environment", "sv", "qv", "NV", "rb", "en", "ah", "v", "txt", "nv", "ef", "req", "emb", "cal", "cfg", "cap", "worker", "vs", "block", "entry", "cv", "doc", "desc", "priv", "ee", "manager", "cur", "obj", "EN", "qt", "e", "engine"], "value": ["widget", "package", "update", "error", "expression", "instance", "weight", "fee", "type", "values", "field", " Value", "state", "description", "ve", "create", "buffer", "val", "property", "index", "data", "key", "total", "input", "initial", "unit", "attribute", "code", "max", "v", "status", "new", "V", "hello", "Value", "address", "current", "VAL", "test", "operator", "size", "time", "variable", "VALUE", "name"]}}
{"project": "FFmpeg", "commit_id": "9af6abdc17deb95c9b1f1d9242ba49b8b5e0b016", "target": 1, "func": "static int decodeTonalComponents (GetBitContext *gb, tonal_component *pComponent, int numBands)\n\n{\n\n    int i,j,k,cnt;\n\n    int   components, coding_mode_selector, coding_mode, coded_values_per_component;\n\n    int   sfIndx, coded_values, max_coded_values, quant_step_index, coded_components;\n\n    int   band_flags[4], mantissa[8];\n\n    float  *pCoef;\n\n    float  scalefactor;\n\n    int   component_count = 0;\n\n\n\n    components = get_bits(gb,5);\n\n\n\n    /* no tonal components */\n\n    if (components == 0)\n\n        return 0;\n\n\n\n    coding_mode_selector = get_bits(gb,2);\n\n    if (coding_mode_selector == 2)\n\n\n\n\n    coding_mode = coding_mode_selector & 1;\n\n\n\n    for (i = 0; i < components; i++) {\n\n        for (cnt = 0; cnt <= numBands; cnt++)\n\n            band_flags[cnt] = get_bits1(gb);\n\n\n\n        coded_values_per_component = get_bits(gb,3);\n\n\n\n        quant_step_index = get_bits(gb,3);\n\n        if (quant_step_index <= 1)\n\n\n\n\n        if (coding_mode_selector == 3)\n\n            coding_mode = get_bits1(gb);\n\n\n\n        for (j = 0; j < (numBands + 1) * 4; j++) {\n\n            if (band_flags[j >> 2] == 0)\n\n                continue;\n\n\n\n            coded_components = get_bits(gb,3);\n\n\n\n            for (k=0; k<coded_components; k++) {\n\n                sfIndx = get_bits(gb,6);\n\n\n\n                pComponent[component_count].pos = j * 64 + (get_bits(gb,6));\n\n                max_coded_values = SAMPLES_PER_FRAME - pComponent[component_count].pos;\n\n                coded_values = coded_values_per_component + 1;\n\n                coded_values = FFMIN(max_coded_values,coded_values);\n\n\n\n                scalefactor = ff_atrac_sf_table[sfIndx] * iMaxQuant[quant_step_index];\n\n\n\n                readQuantSpectralCoeffs(gb, quant_step_index, coding_mode, mantissa, coded_values);\n\n\n\n                pComponent[component_count].numCoefs = coded_values;\n\n\n\n                /* inverse quant */\n\n                pCoef = pComponent[component_count].coef;\n\n                for (cnt = 0; cnt < coded_values; cnt++)\n\n                    pCoef[cnt] = mantissa[cnt] * scalefactor;\n\n\n\n                component_count++;\n\n            }\n\n        }\n\n    }\n\n\n\n    return component_count;\n\n}", "idx": 5190, "substitutes": {"gb": ["uf", "gc", "eg", "hub", "cb", "pg", "sb", "ruby", "Int", "ch", "fb", "GB", "gt", "gh", "csv", "buff", "gm", "ian", "g", "wb", "rb", "bits", "nb", "html", "bm", "db", "yg", "gs", "sg", "bg", "phy", "tg", "mg", "and", "vg", "mb", "cfg", "rg", "bs", "cv", "gnu", "vm", "kb", "gg", "gif", "b", "bn", "pb", "wm", "gd", "bt", "_", "bb", "py", "bf", "goo", "Gb", "img", "storage", "gz", "def"], "pComponent": [" pParameter", "phpComp", "pFrame", "cpComp", " pInstance", "pParameter", "pCell", " pMember", " pCell", "PFrame", "PComp", "tComp", "mMember", "phpInstance", "phpComponent", "podMember", "cpInstance", "phpParameter", "mCell", "PComponent", " pChild", "tFrame", "tComponent", "PChild", "mComp", "tChild", "cpParameter", "podComponent", " pComp", " pFrame", "pComp", "mComponent", "pInstance", "podCell", "pMember", "cpComponent", "pChild", "podComp"], "numBands": [" numBrards", "numBomes", "numBrodes", "numBrards", "numRodes", " numBromes", " numBounds", " numBrounds", "numBRards", "numEBards", "numBRounds", "numBodes", "numCounds", "numCands", "numBRands", "numEBands", "numCBands", "numCBasks", "numBanded", "numCBounds", "numEBounds", " numBrands", "numBrounds", " numBanded", "numCasks", "numCanded", "numRounds", " numBonds", "numBasks", " numBasks", "numBounds", "numBards", "numRonds", "numCBanded", " numBodes", "numBromes", "numRands", " numBomes", " numBards", "numEBomes", "numBRomes", "numBronds", "numBrands", "numBonds"], "i": ["ic", "ij", "ini", "asi", "ci", "b", "it", "im", "c", "u", "h", "ik", "mi", "ip", "ami", "p", "si", "ie", "zi", "n", "ind", "xi", "index", "pi", "multi", "bi", "ui", "ki", "phi", "out", "ti", "v", "ims", "ix", "ai", "m", "I", "y", "ia", "us", "sim", "io", "iu", "e", "in", "by", "x", "di", "ni", "ii"], "j": ["dj", "ja", "ij", "q", "b", "bj", "jo", "it", "jj", "c", "job", "J", "br", "h", "kid", "ian", "aj", "g", "p", "n", "ind", "uj", "index", "tr", "bo", "key", "o", "jc", "col", "js", "str", "el", "pos", "ji", "pr", "out", "try", "oj", "v", "jac", "m", "ch", "adj", "y", "jump", "jp", "jit", "obj", "jl", "kj", "fr", "z", "x", "json", "ii"], "k": ["ck", "q", "uk", "km", "kr", "kh", "kk", "ku", "kt", "kid", "ka", "kind", "K", "ik", "ek", "ok", "ijk", "mk", "p", "ak", "n", "ark", "ke", "context", "kl", "key", "wk", "ki", "unk", "ikk", "kw", "acc", "v", "sk", "m", "dk", "ko", "kick", "ask", "ks", "kj", "z", "tk"], "cnt": ["Cwd", "colNT", "secstant", "crpt", "ucpt", "ucnt", "cuct", " cpt", "cct", "secnt", "crnt", "Crt", "compnt", "cnz", "curt", "cNT", "cot", "Cnt", " cNT", "cstant", "compwd", "ucnc", "conct", "cnc", " cnz", "CNT", "compNT", "connt", "compot", "colnt", "colnc", "Cstant", "cunt", " cwd", "crnc", " crt", "connc", " cct", "secpt", "colrt", "Cot", "conount", "cuount", " cnc", "cwd", "crt", "crnz", "conrt", "secNT", " cot", "Cnc", " cstant", "count", "ucnz", "cpt", " count", "Cpt", "conNT"], "components": ["comensions", "commorts", "proances", "comorts", "ompients", "Compances", "comports", "censions", "comparts", " compands", "compients", "compances", "Compands", "Compaints", "carts", "compands", "compaints", "commonents", "cidates", "Compients", "compodes", "caints", "conents", "configarts", "comonents", "Compensions", "contodes", "commutes", "omponents", "contensions", "proands", "proients", "contonents", "contorts", "configutes", "commodes", "commensions", "cients", "configonents", "comodes", " compients", "commarts", "cutes", "compensions", "ompaints", "Components", "computes", "configidates", "commidates", "ompensions", " compances", "compidates", "proonents"], "coding_mode_selector": ["coding_mode_SelectOR", "coding_mode_connectator", "coding_mode_lectensor", "coding_mode_selectensor", "coding_mode_successor", "coding_mode_connectlor", "coding_mode_connectors", "coding_mode_Selectator", "coding_mode_lectutor", "coding_mode_connectOR", "coding_mode_Selectors", "coding_mode_connectutor", "coding_mode_selectutor", "coding_mode_electensor", "coding_mode_elector", "coding_mode_collector", "coding_mode_Selector", "coding_mode_motOR", "coding_mode_selectator", "coding_mode_successoring", "coding_mode_Selectlor", "coding_mode_selectors", "coding_mode_selectlor", "coding_mode_successors", "coding_mode_selectoring", "coding_mode_lectors", "coding_mode_selectOR", "coding_mode_selectractor", "coding_mode_Selectutor", "coding_mode_lectator", "coding_mode_electOR", "coding_mode_electors", "coding_mode_Selectoring", "coding_mode_lector", "coding_mode_motractor", "coding_mode_connector", "coding_mode_collectoring", "coding_mode_Selectensor", "coding_mode_collectors", "coding_mode_motors", "coding_mode_lectOR", "coding_mode_electlor", "coding_mode_motor", "coding_mode_Selectractor"], "coding_mode": ["coder_metadata", "codingistmode", "coder_side", "coder_settings", "coding___mode", "coder_mode", "coding___type", "coding_side", "coding___side", "coding___method", "codingistmetadata", "coding_type", "coder_method", "coder_option", "codingThetype", "coder_type", "codingThemode", "coding_option", "coding_settings", "codingThesettings", "codingistoption", "coding_metadata", "codingisttype", "coding_method"], "coded_values_per_component": ["coded_values_per2sample", "coded_values_per2component", "coded_values_Per_sample", "coded_values_per2comp", "coded_values_Per_component", "coded_values_PER_channel", "coded_values_per_frame", "coded_values_per_sample", "coded_values_per_part", "coded_values_Per_comp", "coded_values_Per_frame", "coded_values_per64part", "coded_values_PER_part", "coded_values_PER_component", "coded_values_per_channel", "coded_values_PER_sample", "coded_values_per64frame", "coded_values_per2frame", "coded_values_per64sample", "coded_values_per64component", "coded_values_PER_frame", "coded_values_per_comp"], "sfIndx": ["sfindy", "SFindX", "sfindix", "SFindx", "sfindx", "sfIndix", "sfIdex", "sfIdx", "sfIndy", "sbIdix", "SFIndx", "sfIndexix", "SFIndX", "sbIdex", "SFindex", "sfINDX", "sbIdx", "SFindix", "SFIndix", "sfIndex", "sfindex", "sfIndexx", "sfINDx", "sfIndexex", "SFIndex", "sbIndix", "sbIdy", "sfINDix", "sfIndX", "sfIndexy", "sfIdix", "sfINDex", "sfindX", "sbIndex", "sbIndy", "sfIdy", "sbIndx", "sfIdX"], "coded_values": ["cod_vals", "oded_states", "coded_states", "codedThetimes", "oded_codes", "oded_times", "cod_maps", "coded_maps", "coded_models", "oded_files", "oded_value", "cod_values", "codedThestates", "codedThefiles", "codedThevalues", "coded_value", "coded_files", "coded_codes", "oded_vals", "oded_values", "coded_vals", "coded_times", "oded_models"], "max_coded_values": ["max_coded__codes", "max_codedJbytes", "max_coded__lines", "max_oded_codes", "max_oded_parts", "max_coded__value", "max_codededparts", "max_coded_parts", "max_coded_lines", "max_oded_lines", "max_codededbytes", "max_coded__values", "max_coded_rows", "max_oded_rows", "max_codedJvalues", "max_coded_codes", "max_oded_values", "max_coded_value", "max_oded_bytes", "max_oded_value", "max_coded_bytes", "max_codededvalues", "max_codedJparts"], "quant_step_index": ["quant_step_position", "quant_step_Index", "quant_step2Index", "quant_Step_position", "quant_Step_Index", "quant_Step_size", "quant_step2ind", "quant_Step_i", "quant_step_i", "quant_Step_ind", "quant_step_length", "quant_step2size", "quant_Step_id", "quant_step2index", "quant_step_id", "quant_step_size", "quant_step_ind", "quant_Step_length", "quant_Step_index"], "coded_components": ["coded_coorts", "coded_appients", "coded_chices", "coded_appices", "coded_comients", "coded_comrees", "coded_comonents", "coded_corees", "coded_comices", "coded_appsonents", "coded_commorts", "coded_comorts", "coded_chounds", "coded_chonents", "coded_Components", "coded_coients", "coded_appsarts", "coded_appsices", "coded_chorts", "coded_commrees", "coded_commonents", "coded_Comports", "coded_apponents", "coded_comparts", "coded_appsients", "coded_Compounds", "coded_comarts", "coded_comounds", "coded_commients", "coded_comprees", "coded_comports", "coded_compounds", "coded_compients", "coded_Compices", "coded_coonents", "coded_apparts", "coded_compices"], "band_flags": ["bandlyFlags", "Band_flag", "Band_mask", "band__styles", "bandlyoptions", "band_Flags", "band_flag", "Band_flags", "Band_styles", "band__flag", "Band_groups", "band_properties", "band_mask", "Band_properties", "band_options", "bandlyproperties", "Band_options", "band__mask", "bandlyflags", "band_groups", "band_styles", "bandlygroups", "bandlyflag", "Band_Flags", "band__flags"], "mantissa": ["Maintiate", "Mantiate", "motice", "Mantitude", "Mantice", "Mantissa", "Maintissa", "maintiate", "maintice", "mantitude", "Maintice", "maintissa", "motiate", "mantsiate", "mantsissa", "mantiate", "maintitude", "motissa", "mantice", "motitude", "mantsice", "mantsitude", "Maintitude"], "pCoef": ["pCoffe", "pCalef", "pCaleff", "pcCoffe", "pCoeff", "pSeffe", "pSeef", "pSeec", "pCef", "pcCef", "pcCoeff", "pCeff", "pSeeff", "pcCoef", "pcCffe", "pcCeff", "pCalec", "pCffe", "pCec", "pcCoec", "pcCec", "pCalffe", "pCoec"], "scalefactor": ["scalefort", "scallefunc", "sccalefactor", "scaleffactor", "scallefactor", "scalleffunc", "sccaleffactor", "sccalelfract", "scalelffactor", "scalafactor", "scalefact", "scalepactor", "scalefffactor", "scalepfactor", "scallefact", "scalafort", "scalafunc", "sccalelfactor", "scalafact", "scallefort", "scalepunc", "sccalelfunc", "scalelfactor", "scaleffunc", "scalefunc", "sccalefunc", "sccalefract", "scalelfunc", "sccalelffactor", "scalelfract", "scalleffact", "scaleffact", "scalepract", "scalleffactor", "scalelfort", "scaleffort", "scalelfact", "scalleffort", "scaleffract", "scalefract"], "component_count": ["chip_count", " component_num", "componentitykey", "component2num", "chipitycount", "chip_info", "component2length", "componentNamenum", "component_index", "chipityinfo", "chip_spec", "componentitycount", "chipitykey", "component2count", "chipityspec", "componentityspec", " component2num", "componentNamecount", "componentityinfo", "module_count", " component2length", " component2index", "moduleNamecount", " component_index", "component2index", "component_info", "module_start", "moduleNametype", "component_start", "componentitystart", "moduleNamestart", "module_num", "component_type", "component_spec", "component_length", "component_num", "chip_key", "component_key", " component_length", "componentNametype", "moduleNamenum", " component2count", "componentitytype", "componentitynum", "componentNamestart", "module_type"]}}
{"project": "qemu", "commit_id": "3401c0d95ffb9a9a57093ee002d24d014ffed4f8", "target": 1, "func": "static void do_send_key(const char *string)\n\n{\n\n    char keybuf[16], *q;\n\n    uint8_t keycodes[16];\n\n    const char *p;\n\n    int nb_keycodes, keycode, i;\n\n\n\n    nb_keycodes = 0;\n\n    p = string;\n\n    while (*p != '\\0') {\n\n        q = keybuf;\n\n        while (*p != '\\0' && *p != '-') {\n\n            if ((q - keybuf) < sizeof(keybuf) - 1) {\n\n                *q++ = *p;\n\n            }\n\n            p++;\n\n        }\n\n        *q = '\\0';\n\n        keycode = get_keycode(keybuf);\n\n        if (keycode < 0) {\n\n            term_printf(\"unknown key: '%s'\\n\", keybuf);\n\n            return;\n\n        }\n\n        keycodes[nb_keycodes++] = keycode;\n\n        if (*p == '\\0')\n\n            break;\n\n        p++;\n\n    }\n\n    /* key down events */\n\n    for(i = 0; i < nb_keycodes; i++) {\n\n        keycode = keycodes[i];\n\n        if (keycode & 0x80)\n\n            kbd_put_keycode(0xe0);\n\n        kbd_put_keycode(keycode & 0x7f);\n\n    }\n\n    /* key up events */\n\n    for(i = nb_keycodes - 1; i >= 0; i--) {\n\n        keycode = keycodes[i];\n\n        if (keycode & 0x80)\n\n            kbd_put_keycode(0xe0);\n\n        kbd_put_keycode(keycode | 0x80);\n\n    }\n\n}\n", "idx": 5191, "substitutes": {"keybuf": ["wordcode", "Keybuf", "keybuffer", "charbuf", "Keybuff", "KEYbuffer", "charbuffer", "phrasepad", "phrasecode", "callbuffer", "callcodes", "netbuf", " keypad", "keysbuf", "Keycb", "wordbuff", "phrasebuff", "charcode", "keyscodes", "charcodes", " keycmd", "charbuff", " keybuffer", "keycb", "KEYbuff", " keybag", "KEYcb", "skybag", "charcmd", "keysbuff", "Keybuffer", "keysbuffer", "keypad", "Keycode", "callbuf", "netcodes", "netcb", "keycmd", "charcb", "keybag", "keybuff", "KEYbuf", "skybuffer", "Keybag", "phrasebuf", " keybuff", "Keypad", "wordbuffer", "skybuf", "callbuff", "netcmd", "wordbuf", " keycb"], "q": ["quer", "qual", "b", "quant", "cp", "quote", "c", "u", "qs", "pt", "buf", "qi", "buffer", "ip", "g", "n", "iq", "queue", "t", "Q", "pe", "query", "pkg", "qv", "k", "ue", "qa", "eq", "v", "qq", "qu", "dq", "ch", "quit", "aq", "sq", "f", "que", "qt", "pp", "z", "j", "a"], "keycodes": ["Keybuf", "airbuf", " keylines", "aircodes", "keylines", "eyobjects", "aircases", "eycache", "readlines", "eycodes", "activebuf", "keycache", "Keyobjects", " keycache", "keycod", "keynames", "keycases", "activecases", "Keycod", "linkcases", "playcod", " keyodes", "readodes", "activecod", "linkcod", " keynames", "eyodes", "activecodes", "readcod", "keyodes", "aircod", "Keyodes", "playcodes", " keyobjects", "Keycodes", "Keynames", "Keylines", "Keycache", " keycod", "playnames", "linkcodes", "keyobjects", "linkbuf", "playbuf", "readcodes"], "p": ["post", "pid", "par", "sp", "b", "prefix", "wp", "cp", "ping", "pb", "c", "u", "pc", "h", "pen", "pad", "pod", "pt", "pro", "ip", "g", "pa", "ps", "pat", "n", "d", "php", "piece", "pointer", "pl", "fp", "t", "pair", "pers", "pi", "r", "pe", "str", "w", "pos", "pre", "pkg", "pg", "ap", "pr", "s", "v", "pard", "port", "m", "part", "parse", "y", "jp", "f", "pp", "P", "point", "j", "tp", "l", "path"], "nb_keycodes": ["nb_readcodes", "nb_firebooks", "nb_hashodes", "nb_condbooks", "nbJkeycode", "nb_keystyles", "nb_charvalues", "nb_keycode", "nb_keytags", "nb_keyodes", "nb_charlines", "nb_keymaps", "nb_keysstyles", "nb_checkcode", "nb_notecode", "nb_keyslines", "nb_condcodes", "nb_popbooks", "nbJcheckcodes", "nb_notevalues", "nb_keyscode", "nbJcheckcode", "nb_readlines", "nb_keysmaps", "nb_readmaps", "nbJkeyodes", "nb_charcodes", "nb_keylines", "nb_hashmaps", "nb_keyscodes", "nb_keyboards", "nb_checkcodes", "nb_kestyles", "nb_condodes", "nb_checkodes", "nb_hashcodes", "nb_keybooks", "nb_notemaps", "nb_kecodes", "nb_poptags", "nbJkeyboards", "nb_keysboards", "nb_readstyles", "nb_notecodes", "nb_notelines", "nb_keysodes", "nb_kelines", "nb_charodes", "nbJcheckodes", "nb_noteboards", "nb_keysvalues", "nbJcheckboards", "nb_firecodes", "nbJkeycodes", "nb_firetags", "nb_popodes", "nb_checkboards", "nb_condtags", "nb_fireodes", "nb_keyvalues", "nb_noteodes", "nb_hashlines", "nb_kemaps", "nb_popcodes"], "keycode": ["keycomment", " keyframe", "posecode", "Keycoded", "cysee", "posecat", "bycod", "jsoncomment", "ycoe", "bytecode", "Keystroke", " keycache", " keycoe", " keyce", "keyclass", "cycode", "eyce", "playstroke", "keyvalue", " keyline", "Keycode", "jsonclass", "eycode", "kvalue", " keycoded", " keyCode", "kce", "kcoded", "firecat", "playtry", "jsoncode", " keycat", "condce", "ycode", "kcoe", "yclass", "locklink", "ysee", " keyvalue", "xcode", "keycache", "KeyCode", " keytry", "byline", "lockcode", "keycard", "xstroke", "ycoded", "aircod", "bytetry", "cycomment", "ycondition", "querycoded", "bytestroke", "kcode", "condframe", "lockcod", "notecod", "kstroke", "airsee", "keycod", "keylink", "keycoded", "keystroke", "playcard", "keytry", "bytecard", "posecache", "notesee", "notelink", "bycondition", "keyline", "yline", "keyframe", "yvalue", "condcode", "firestroke", "eycoe", "airlink", " keycod", "notecode", "posestroke", "charcard", "charce", "querystroke", "keycoe", " keystroke", "ycomment", "kcard", "kcache", "charcode", "ycod", "condcoe", "playcode", "xcoded", "aircode", "keysee", "firecache", "bycode", "keycondition", "jsonsee", "xCode", "keyCode", "firecode", "locksee", "eyframe", "querycache", "cyclass", "querycode", "keyce", "keycat", " keycondition", " keycard"], "i": ["init", "this", "ic", "ini", "ij", "chain", "ei", "uri", "ci", "it", "im", "ori", "cli", "oi", "gi", "mi", "qi", "my", "ip", "li", "si", "ami", "ie", "zi", "is", "iq", "ind", "xi", "index", "ri", "hi", "pi", "multi", "bi", "me", "id", "ui", "ki", "ji", "slice", "record", "list", "phi", "ir", "ti", "iter", "ims", "iy", "ix", "ai", "m", "I", "remote", "mc", "fi", "us", "iu", "in", "info", "j", "iri", "di", "\u0438", "json", "ii"]}}
{"project": "qemu", "commit_id": "5d39c799c3245244ebb1e89da0177dbc089962b2", "target": 0, "func": "void do_migrate_set_speed(Monitor *mon, const QDict *qdict, QObject **ret_data)\n\n{\n\n    double d;\n\n    char *ptr;\n\n    FdMigrationState *s;\n\n    const char *value = qdict_get_str(qdict, \"value\");\n\n\n\n    d = strtod(value, &ptr);\n\n    switch (*ptr) {\n\n    case 'G': case 'g':\n\n        d *= 1024;\n\n    case 'M': case 'm':\n\n        d *= 1024;\n\n    case 'K': case 'k':\n\n        d *= 1024;\n\n    default:\n\n        break;\n\n    }\n\n\n\n    max_throttle = (uint32_t)d;\n\n    s = migrate_to_fms(current_migration);\n\n\n\n    if (s) {\n\n        qemu_file_set_rate_limit(s->file, max_throttle);\n\n    }\n\n    \n\n}\n", "idx": 5198, "substitutes": {"mon": ["MON", "wat", "con", "mi", "util", "mut", "on", "dog", "monitor", "meter", "mu", "dm", " monitor", "watch", "Monitor", "man", "bean", "m", "fn", "dir", "Mon", "serv", "mm", "manager", "Mu", "mons", "mx", "mp"], "qdict": ["qumsg", "sqobj", "quconf", "qudict", "qualdict", "sqdom", "sqdb", "qdb", "quobj", " qobj", "sqdata", "qdata", " qmsg", "qualdb", "qmsg", "sqmsg", "dqdb", "sqdict", "sqconf", "qdom", "qualdata", "qconf", "dqdom", "dqdata", "qobj", " qconf", "qualdom", "dqdict"], "ret_data": ["return_content", "ret_obj", "ret_content", "retregobj", "retregcontent", "retregdata", "retrowcontent", "retrowobj", "return_obj", "retrowdata", "return_data"], "d": ["depth", " delta", "dc", " dy", "dat", "c", "h", "dev", "ind", "t", "D", "w", "pos", "dm", " D", " dx", "dn", " dw", " den", " diff", "j", "x", " disp", "di", " dr", " dra", "q", "dig", "dt", "g", "dx", "out", "mind", "dim", "v", " dd", "m", "done", "dp", " det", "td", "length", "a", "dy", "p", "sd", "r", "dh", "dr", "dd", "diff", "dra", "did", "dis", " dur", " dist", "fd", "b", "i", " done", "n", "gd", " del", "ds", "data", " Dj", "f", "pd", "e", "z"], "ptr": ["iv", "vr", "sp", "ped", "pc", "pen", "pad", "pt", "vector", "pointers", "p", "addr", "ps", "ts", "context", "ind", "pair", "inters", "rob", "pointer", "tr", "pl", "index", "str", "dr", "th", "ref", "pos", "inter", "proc", "expr", "attr", "rev", "pr", "prime", "Ptr", "tip", "iter", "req", "tmp", "desc", "address", "tile", "test", "eth", "hl", "length", "ctr", "j", "arr", "tp"], "s": ["rs", "gs", "sp", "ssl", "b", "sw", "ns", "c", "h", "sys", "cs", "still", "os", "p", "g", "ps", "n", "is", "ts", "ds", "o", "t", "es", "r", "w", "ins", "sv", "ls", "sm", "sb", "v", "stats", "sl", "m", "sa", "st", "hs", "spec", "ss", "sn", "south", "su", "bs", "socket", "f", "fs", "e", "S", "sts", "j", "sports", "a", "l"], "value": ["widget", "content", "vr", "result", "expression", "type", "values", "field", "description", "buffer", "vp", "val", "property", "data", "key", "str", "attribute", "sv", "ue", "v", "memory", "status", "Value", "address", "current", "message", "sample", "language", "json", "VALUE", "text", "reference", "name", "image", "sequence"]}}
{"project": "qemu", "commit_id": "27a69bb088bee6d4efea254659422fb9c751b3c7", "target": 0, "func": "static inline void gen_efdneg(DisasContext *ctx)\n\n{\n\n    if (unlikely(!ctx->spe_enabled)) {\n\n        gen_exception(ctx, POWERPC_EXCP_APU);\n\n        return;\n\n    }\n\n#if defined(TARGET_PPC64)\n\n    tcg_gen_xori_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)], 0x8000000000000000LL);\n\n#else\n\n    tcg_gen_mov_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)]);\n\n    tcg_gen_xori_tl(cpu_gprh[rD(ctx->opcode)], cpu_gprh[rA(ctx->opcode)], 0x80000000);\n\n#endif\n\n}\n", "idx": 5201, "substitutes": {"ctx": ["ck", "ctl", "c", "kt", "sc", "inst", "ind", "cb", "kl", "crit", "xs", "txt", "ork", "req", "pause", "tmp", "kg", "batch", "jp", "mc", "cur", "xp", "kj", "cu", "work", "today", "abc", "loc", "nt", "mk", "typ", "context", "config", "desc", "np", "Context", "ctr", "urg", "cf", "ct", "prefix", "gp", "bc", "anc", "cm", "co", "nc", "std", "hw", "history", "pkg", "kw", "cfg", "cv", "kb", "act", "cp", "wcs", "cmp", "cl", "wx", "lex", "cmd", "etc", "unc", "aux", "lc", "cc", "xc", "jac", "resp", "tx", "obj", "warn", "conn", "tc"]}}
{"project": "qemu", "commit_id": "42a268c241183877192c376d03bd9b6d527407c7", "target": 0, "func": "static void gen_srlq(DisasContext *ctx)\n\n{\n\n    int l1 = gen_new_label();\n\n    int l2 = gen_new_label();\n\n    TCGv t0 = tcg_temp_local_new();\n\n    TCGv t1 = tcg_temp_local_new();\n\n    TCGv t2 = tcg_temp_local_new();\n\n    tcg_gen_andi_tl(t2, cpu_gpr[rB(ctx->opcode)], 0x1F);\n\n    tcg_gen_movi_tl(t1, 0xFFFFFFFF);\n\n    tcg_gen_shr_tl(t2, t1, t2);\n\n    tcg_gen_andi_tl(t0, cpu_gpr[rB(ctx->opcode)], 0x20);\n\n    tcg_gen_brcondi_tl(TCG_COND_EQ, t0, 0, l1);\n\n    gen_load_spr(t0, SPR_MQ);\n\n    tcg_gen_and_tl(cpu_gpr[rA(ctx->opcode)], t0, t2);\n\n    tcg_gen_br(l2);\n\n    gen_set_label(l1);\n\n    tcg_gen_shr_tl(t0, cpu_gpr[rS(ctx->opcode)], t2);\n\n    tcg_gen_and_tl(t0, t0, t2);\n\n    gen_load_spr(t1, SPR_MQ);\n\n    tcg_gen_andc_tl(t1, t1, t2);\n\n    tcg_gen_or_tl(cpu_gpr[rA(ctx->opcode)], t0, t1);\n\n    gen_set_label(l2);\n\n    tcg_temp_free(t0);\n\n    tcg_temp_free(t1);\n\n    tcg_temp_free(t2);\n\n    if (unlikely(Rc(ctx->opcode) != 0))\n\n        gen_set_Rc0(ctx, cpu_gpr[rA(ctx->opcode)]);\n\n}\n", "idx": 5219, "substitutes": {"ctx": ["ck", "ctl", "conf", "c", "kt", "scope", "ka", "sc", "self", "addr", "ind", "cb", "kl", "js", "crit", "wordpress", "xs", "req", "tmp", "kg", "batch", "jp", "mc", "xp", "x", "work", "cu", "today", "abc", "loc", "nt", "bh", "context", "push", "expr", "config", "np", "check", "cf", "ct", "prefix", "voc", "bc", "p", "cm", " cx", "nc", "std", "hw", "history", "pkg", "kw", "cfg", "cv", "act", "cp", "wcs", "cmp", "cl", "wx", "sys", "lex", "cmd", "dl", "etc", "aux", "xc", "cc", "scl", "jac", "resp", "tx", "gz", "obj", "wd", "conn", "tc"]}}
{"project": "qemu", "commit_id": "51b19ebe4320f3dcd93cea71235c1219318ddfd2", "target": 0, "func": "static size_t send_control_msg(VirtIOSerial *vser, void *buf, size_t len)\n\n{\n\n    VirtQueueElement elem;\n\n    VirtQueue *vq;\n\n\n\n    vq = vser->c_ivq;\n\n    if (!virtio_queue_ready(vq)) {\n\n        return 0;\n\n    }\n\n    if (!virtqueue_pop(vq, &elem)) {\n\n        return 0;\n\n    }\n\n\n\n    /* TODO: detect a buffer that's too short, set NEEDS_RESET */\n\n    iov_from_buf(elem.in_sg, elem.in_num, 0, buf, len);\n\n\n\n    virtqueue_push(vq, &elem, len);\n\n    virtio_notify(VIRTIO_DEVICE(vser), vq);\n\n    return len;\n\n}\n", "idx": 5222, "substitutes": {"vser": ["svobj", "Vser", "vicsel", "svSer", "Viter", "vobj", "vtur", " vsoc", "vicser", "Vtur", "svser", "nvsec", "svcer", " vSer", "nvsoc", "svtur", "vsoc", "vsel", "nvSer", "Vsel", "vsec", "svsoc", "nvser", "sviter", "viciter", "svsel", "victur", " vsec", " vicer", "vicer", "vSer", " vobj", "nvobj", " vcer", "svicer", "vcer", "nvicer", "svsec", "viter", "nvcer"], "buf": ["db", "bytes", "uf", "buff", " buff", "b", "bn", "mem", "pb", "bg", "br", "bc", "box", "Buffer", "ob", "buffer", "msg", "raw", "seq", "bh", "cmd", "cb", "queue", "wb", "bb", "vec", "Buff", "rb", "bf", "txt", "cap", "block", " buffer", "fb", "cv", "img", "batch", "doc", "bin"], "len": ["all", "sp", "ln", "mem", "end", " clen", "wid", " fmt", "h", "Len", "cmp", " bl", "compl", "nt", "lf", "seq", "n", "lib", "nc", "val", "ind", "fl", "pl", "kl", "t", "lan", "str", "err", "el", "pos", "syn", "lp", "en", "v", " length", "fun", "fin", "resp", "ret", "le", "L", "size", "e", "length", "ll", "nl", "enc", "ld", "l", " l", "elt", "vec"], "elem": ["gelem", "melement", "gelev", "Elems", "telement", "ielem", "melt", "elev", "velem", "atelement", "atelev", " eld", "meq", "Elev", "Elt", "melev", "meld", "elete", "atelem", "elelem", "ielev", "telete", "Element", "elelement", "gelete", "eld", "element", "melem", "elelems", "teq", "velev", "ateq", "Eld", "elems", "velt", "Elem", "elelt", " elt", "eq", "gelement", "elelev", "ielement", "velement", "ielete", " elev", " elems", "telem", "telev", "eleld", "elt"], "vq": [" vp", "invdq", "evq", "vqueue", " vqueue", "nvque", " vue", "Vq", "viqq", " vdq", "invkg", " vque", "uvq", "vidq", " vld", " vcu", "vmdq", "invque", "evque", "vcu", "Vld", "vip", "bqueue", "vp", "uvcu", "vkg", "vmq", "vmque", "uvqueue", "iq", "evdq", " vcs", "evld", "nvcu", "uvcs", "vque", "vld", "vue", "bque", "vqq", "idq", "ique", " vqq", "nq", "evue", "ndq", "nvqueue", "vmkg", "vcs", "vdq", "nvcs", "np", "Vque", "viq", "bq", " vkg", "nqq", "invq", "Vue", "nvq"]}}
{"project": "qemu", "commit_id": "9a10bbb4e83b184faef6fa744396a6775283c0aa", "target": 0, "func": "void ich9_pm_init(PCIDevice *lpc_pci, ICH9LPCPMRegs *pm,\n\n                  qemu_irq sci_irq)\n\n{\n\n    memory_region_init(&pm->io, OBJECT(lpc_pci), \"ich9-pm\", ICH9_PMIO_SIZE);\n\n    memory_region_set_enabled(&pm->io, false);\n\n    memory_region_add_subregion(pci_address_space_io(lpc_pci),\n\n                                0, &pm->io);\n\n\n\n    acpi_pm_tmr_init(&pm->acpi_regs, ich9_pm_update_sci_fn, &pm->io);\n\n    acpi_pm1_evt_init(&pm->acpi_regs, ich9_pm_update_sci_fn, &pm->io);\n\n    acpi_pm1_cnt_init(&pm->acpi_regs, &pm->io, pm->s4_val);\n\n\n\n    acpi_gpe_init(&pm->acpi_regs, ICH9_PMIO_GPE0_LEN);\n\n    memory_region_init_io(&pm->io_gpe, OBJECT(lpc_pci), &ich9_gpe_ops, pm,\n\n                          \"acpi-gpe0\", ICH9_PMIO_GPE0_LEN);\n\n    memory_region_add_subregion(&pm->io, ICH9_PMIO_GPE0_STS, &pm->io_gpe);\n\n\n\n    memory_region_init_io(&pm->io_smi, OBJECT(lpc_pci), &ich9_smi_ops, pm,\n\n                          \"acpi-smi\", 8);\n\n    memory_region_add_subregion(&pm->io, ICH9_PMIO_SMI_EN, &pm->io_smi);\n\n\n\n    pm->irq = sci_irq;\n\n    qemu_register_reset(pm_reset, pm);\n\n    pm->powerdown_notifier.notify = pm_powerdown_req;\n\n    qemu_register_powerdown_notifier(&pm->powerdown_notifier);\n\n\n\n    acpi_cpu_hotplug_init(pci_address_space_io(lpc_pci), OBJECT(lpc_pci),\n\n                          &pm->gpe_cpu, ICH9_CPU_HOTPLUG_IO_BASE);\n\n\n\n    if (pm->acpi_memory_hotplug.is_enabled) {\n\n        acpi_memory_hotplug_init(pci_address_space_io(lpc_pci), OBJECT(lpc_pci),\n\n                                 &pm->acpi_memory_hotplug);\n\n    }\n\n}\n", "idx": 5229, "substitutes": {"lpc_pci": ["lpc_pce", "lpc__mcm", "lpc__mcu", "lpc_dci", "lpc_mcu", "lpc_ipcu", "lpc_pcu", "lpc_gcu", "lpc_mco", "lpc_dso", "lpc_epcul", "lpc_epci", "lpc_gki", "lpc_ppcci", "lpc__pce", "lpc__pci", "lpc_dcm", "lpc_pco", "lpc_cpcm", "lpc_mpi", "lpc_ppci", "lpc_gcci", "lpc_ppi", "lpc_cpci", "lpc_cpcu", "lpc_dcul", "lpc_pki", "lpc_ipci", "lpc_pso", "lpc__mce", "lpc__pcm", "lpc_mce", "lpc_dce", "lpc_pcul", "lpc_ppki", "lpc_dco", "lpc_ppcu", "lpc_mci", "lpc_epso", "lpc_pcm", "lpc__pcu", "lpc__mci", "lpc_dpi", "lpc_ipcm", "lpc_mcm", "lpc_plcul", "lpc_cppi", "lpc_epcu", "lpc_pcci", "lpc_dki", "lpc_ipce", "lpc_plcu", "lpc_dcci", "lpc_dcu", "lpc_plso", "lpc_plci", "lpc_gci"], "pm": ["policy", "pid", "imm", "po", "im", "px", "ps", "dev", "perm", "phys", "pi", "pg", "module", "dm", "ams", "tmp", "mod", "test", "activity", "vim", "post", "um", "PM", "wp", "gm", "managed", "asm", "sam", "cam", "mi", "my", "ms", "process", "master", "v", "m", "am", "pool", "pp", "bm", "json", "prom", "rpm", "pc", "ctx", "em", "pt", "mr", "ami", "p", "cm", "pa", "mt", "pkg", "rem", "nm", "dd", "mm", "gem", "hm", "vm", "param", "nom", "rm", "mp", "cp", "pb", "term", "ram", "wm", "program", "vp", "temp", "pr", "member", "pn", "obj", "wd", "mx"], "sci_irq": ["sci_mirqs", "sci_irch", "sci_mrch", "sci_mrqs", "sci_irv", "sci_hrqs", "sci_mrQ", "sci_irsqu", "sci_pirv", "sci_pirqu", "sci_mrqu", "sci_pirq", "sci_hrq", "sci_mrv", "sci_irqs", "sci_hrch", "sci_irsQ", "sci_mrq", "sci_mirch", "sci_irsv", "sci_irqu", "sci_mirq", "sci_irQ", "sci_pirQ", "sci_irsq"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "uint32_t omap_badwidth_read8(void *opaque, target_phys_addr_t addr)\n\n{\n\n    uint8_t ret;\n\n\n\n    OMAP_8B_REG(addr);\n\n    cpu_physical_memory_read(addr, (void *) &ret, 1);\n\n    return ret;\n\n}\n", "idx": 5250, "substitutes": {"opaque": ["buffc", "ospc", "ospaque", "opacity", "buffaque", "buffacity", "osacity", "ospacity", "oskt", "buffkt", "osc", "opc", "ospkt", "osaque", "opkt"], "addr": ["sp", "mem", "src", "asm", "ctx", "pad", "set", "store", "offset", " address", "self", "arch", "map", "p", "cmd", "add", "mt", "bind", "seek", "var", "arp", "url", "row", "index", "data", "hw", "t", "alt", "err", "dh", "dr", "ref", "id", "attr", "align", "ad", "handle", "ix", "ack", "ash", "alloc", "off", "tx", "ptr", "address", "ident", "ord", "obj", "ag", "hash", "adr", "arr", "work", "act"], "ret": ["gt", "result", "q", "ert", "mem", "reply", "cont", "ter", "buf", "last", "nt", "mt", " Ret", "rets", "val", "t", "alt", "r", "err", "ref", "rem", "out", "txt", "rt", "resp", "re", "new", "reg", "ptr", "lit", "print", "RET", "Ret", "ft", "arg", "info", "hash", "j", "res", "arr", "rm", "elt", "flag"]}}
{"project": "qemu", "commit_id": "af7e9e74c6a62a5bcd911726a9e88d28b61490e0", "target": 1, "func": "static inline void IRQ_setbit(IRQ_queue_t *q, int n_IRQ)\n\n{\n\n    q->pending++;\n\n    set_bit(q->queue, n_IRQ);\n\n}\n", "idx": 5263, "substitutes": {"q": ["ck", "next", "conf", "c", "h", "ox", "up", "cl", "i", "qs", "pt", "state", "comm", "ob", "qi", "p", "n", "iq", "queue", "o", "t", "Q", "r", "w", "th", "query", "pkg", "ue", "qa", "eq", "v", "ix", "req", "qu", "qq", "requ", "dq", "m", "ch", "quit", "entry", "aq", "y", "sq", "count", "que", "qt", "ql", "z"], "n_IRQ": ["n_MRQU", "n_IRQueue", "n_irQ", "n_IRMQ", "n_irMQ", "n_RCQ", "n_DIRQL", "n_IRCQueue", "n_MRQ", "n_DIRQueue", "n_RCQuery", "n_AIRQU", "n_IRCQuery", "n_AIRQueue", "n_IRCMQ", "n_AIRQ", "n_MRQL", "n_IRQuery", "n_RCQueue", "n_AIRQL", "n_RCMQ", "n_DIRQ", "n_IRQL", "n_MRQueue", "n_irQuery", "n_IRQU", "n_DIRQU", "n_IRCQ", "n_irQueue"], "pending": ["nues", "nid", "queueid", "pid", "queuestate", "dending", "nstate", "pues", "nending", "did", "queueues", "pstate", "queueending", "dstate", "dues"]}}
{"project": "FFmpeg", "commit_id": "77d2ef13a8fa630e5081f14bde3fd20f84c90aec", "target": 1, "func": "static int matroska_decode_buffer(uint8_t** buf, int* buf_size,\n\n                                  MatroskaTrack *track)\n\n{\n\n    MatroskaTrackEncoding *encodings = track->encodings.elem;\n\n    uint8_t* data = *buf;\n\n    int isize = *buf_size;\n\n    uint8_t* pkt_data = NULL;\n\n    int pkt_size = isize;\n\n    int result = 0;\n\n    int olen;\n\n\n\n    if (pkt_size >= 10000000)\n\n        return -1;\n\n\n\n    switch (encodings[0].compression.algo) {\n\n    case MATROSKA_TRACK_ENCODING_COMP_HEADERSTRIP:\n\n        return encodings[0].compression.settings.size;\n\n    case MATROSKA_TRACK_ENCODING_COMP_LZO:\n\n        do {\n\n            olen = pkt_size *= 3;\n\n            pkt_data = av_realloc(pkt_data, pkt_size+AV_LZO_OUTPUT_PADDING);\n\n            result = av_lzo1x_decode(pkt_data, &olen, data, &isize);\n\n        } while (result==AV_LZO_OUTPUT_FULL && pkt_size<10000000);\n\n        if (result)\n\n            goto failed;\n\n        pkt_size -= olen;\n\n        break;\n\n#if CONFIG_ZLIB\n\n    case MATROSKA_TRACK_ENCODING_COMP_ZLIB: {\n\n        z_stream zstream = {0};\n\n        if (inflateInit(&zstream) != Z_OK)\n\n            return -1;\n\n        zstream.next_in = data;\n\n        zstream.avail_in = isize;\n\n        do {\n\n            pkt_size *= 3;\n\n            pkt_data = av_realloc(pkt_data, pkt_size);\n\n            zstream.avail_out = pkt_size - zstream.total_out;\n\n            zstream.next_out = pkt_data + zstream.total_out;\n\n            result = inflate(&zstream, Z_NO_FLUSH);\n\n        } while (result==Z_OK && pkt_size<10000000);\n\n        pkt_size = zstream.total_out;\n\n        inflateEnd(&zstream);\n\n        if (result != Z_STREAM_END)\n\n            goto failed;\n\n        break;\n\n    }\n\n#endif\n\n#if CONFIG_BZLIB\n\n    case MATROSKA_TRACK_ENCODING_COMP_BZLIB: {\n\n        bz_stream bzstream = {0};\n\n        if (BZ2_bzDecompressInit(&bzstream, 0, 0) != BZ_OK)\n\n            return -1;\n\n        bzstream.next_in = data;\n\n        bzstream.avail_in = isize;\n\n        do {\n\n            pkt_size *= 3;\n\n            pkt_data = av_realloc(pkt_data, pkt_size);\n\n            bzstream.avail_out = pkt_size - bzstream.total_out_lo32;\n\n            bzstream.next_out = pkt_data + bzstream.total_out_lo32;\n\n            result = BZ2_bzDecompress(&bzstream);\n\n        } while (result==BZ_OK && pkt_size<10000000);\n\n        pkt_size = bzstream.total_out_lo32;\n\n        BZ2_bzDecompressEnd(&bzstream);\n\n        if (result != BZ_STREAM_END)\n\n            goto failed;\n\n        break;\n\n    }\n\n#endif\n\n    default:\n\n        return -1;\n\n    }\n\n\n\n    *buf = pkt_data;\n\n    *buf_size = pkt_size;\n\n    return 0;\n\n failed:\n\n    av_free(pkt_data);\n\n    return -1;\n\n}\n", "idx": 5277, "substitutes": {"buf": ["read", "bytes", "cast", "uf", "buff", "b", "dat", "mem", "window", "h", "br", "bc", "pad", "Buffer", "buffer", "seq", "p", "cmd", "var", "cb", "wb", "queue", "input", "w", "rc", "pos", "pkg", "rb", "v", "cap", "block", "alloc", "bs", "tmp", "cv", "batch", "doc", "bl", "que", "enc", "arr"], "buf_size": ["buf_length", "buf_len", "buf2SIZE", "buf_Size", "buff_SIZE", "buff_Size", "buf_count", "buf2length", "buf_SIZE", "buff_count", "buff_len", "buff_length", "buf2size", "buf2len", "buff_size"], "track": ["train", "race", "match", "sound", "metadata", "run", "pack", "met", "store", "bind", "cmd", "stat", "seek", "round", "sync", "tr", "queue", "index", "t", "r", "trace", "rack", "record", "tracking", "tracks", "handle", "claim", "transform", "Track", "ack", "stream", "tab", "report", "batch", "fire", "kick", "session", "search", "roll", "rm"], "encodings": ["ENCODing", "encordering", "enccoding", "eccodings", "encodeding", "ecodings", "encordings", "ENCodering", "encording", "enccodings", "ENCodings", "eccodions", "encordrings", "encodeders", "encoders", "ENCoding", "eccoders", "ecoders", "encordions", "encODrings", "enccodities", "ENCODering", "encODers", "ENCODers", "encODering", "ecoding", "eccodering", "enccodions", "encodrings", "encODions", "enccoders", "ecodering", "ENCoders", "encODings", "eccodrings", "encODing", "encodions", "encodering", "encordities", "encodedering", "enccodrings", "enccodering", "ecodities", "ecodions", "encodedings", "encorders", "encODities", "ENCODings", "ecodrings", "encoding", "encodities", "eccoding", "eccodities"], "data": ["read", "bytes", "result", "xy", "error", "aw", "next", "results", "open", "dat", "mem", "window", "end", "empty", "type", "offset", " Data", "buffer", "raw", "map", "p", "table", "d", "n", "good", " DATA", "len", "ata", "t", "r", "Data", "str", "w", "value", "initial", "pos", "mu", "start", "out", "iter", "array", "batch", "cache", "DATA", "size", "info", "length", "name", "image", "bin"], "pkt_data": ["pct_size", "pkt_str", "packet_len", "packetipdata", "pct_step", "packet_Data", "pkt_Data", "packetipid", "pkt___length", "pktipid", "packet_size", "pkt_buffer", "pkt1name", "pkt___time", "pkt2len", "pkt2data", "pnt_buffer", "pkt_time", "packet_buffer", "pktlystep", "packet_length", "pkt_size", "packet_str", "pkt___window", "pkt2size", "packet_time", "pkt_rel", "pkt_num", "pnt_size", "pnt_mem", "pkt1num", "pkt_mem", "pkt_window", "packet_cache", "pkt1str", "pct_data", "pktiprel", "packetipcache", "pktlysize", "pktipcache", "packet_rel", "pktlylen", "pkt___data", "packetiprel", "pktlybuffer", "pkt_name", "packet_name", "pktipdata", "pkt_id", "pkt2name", "pktlydata", "packet_id", "pkt_step", "pktlymem", "pkt_len", "pct_len", "packet_data", "pnt_data", "pkt_length", "pkt_cache", "packet_num", "pkt1data", "packet_window"], "olen": ["aled", "mn", "oin", "sofar", "killed", "mem", "oul", "written", "ln", "zon", "wid", "sol", "innie", "half", "aken", "uin", "mel", "ken", "den", "alg", "wan", "won", "rn", "ele", "filled", "len", "equipped", "ilee", "failed", "kl", "alt", " leftover", "temp", "regon", "haven", "lan", "het", "led", "held", "lol", "legal", "linger", "ldon", "cn", "oled", "hat", "sid", "rown", "lvl", "broken", "done", "claimed", "olid", "agger", "angled", "occupied", "lost", "known", "seen", "nom", "hung", "didn"]}}
{"project": "FFmpeg", "commit_id": "63b1866ae1e19ff0d694746a84e2eac859cda462", "target": 0, "func": "static void ac3_extract_exponents_c(uint8_t *exp, int32_t *coef, int nb_coefs)\n\n{\n\n    int i;\n\n\n\n    for (i = 0; i < nb_coefs; i++) {\n\n        int e;\n\n        int v = abs(coef[i]);\n\n        if (v == 0)\n\n            e = 24;\n\n        else {\n\n            e = 23 - av_log2(v);\n\n            if (e >= 24) {\n\n                e = 24;\n\n                coef[i] = 0;\n\n            }\n\n            av_assert2(e >= 0);\n\n        }\n\n        exp[i] = e;\n\n    }\n\n}\n", "idx": 5281, "substitutes": {"coef": ["coefficients", "Coef", "Coeff", "Coff", "coefficient", "Coefficient", "calef", "coneff", "Coefficients", "conef", "conefficients", " coff", "conefficient", " coefficients", "coff", "calefficient", "caleff", "conff", " coeff", "coeff", "calefficients"], "nb_coefs": ["nb_cocfrs", "nb_coofs", "nb_cooferences", "nb_coofrs", "nb_coifes", "nb_coefferences", "nb_coeffes", "nb_cocferences", "nb_coifs", "nb_cocfs", "nb_coifls", "nb_coeffls", "nb_coeffs", "nb_coeffries", "nb_coffs", "nb_coefes", "nb_coffries", "nb_coffls", "nb_coefls", "nb_coeffrs", "nb_coffes", "nb_coefries", "nb_coeferences", "nb_coifries", "nb_coefrs"], "i": ["init", "ic", "ini", "ij", "chain", "uri", "ei", "ci", " ii", "it", " m", "im", "oi", "gi", "mi", "qi", "ip", "li", "si", "zi", "n", "is", "ind", "xi", "index", "o", " ti", "key", "pi", "multi", "bi", "hi", "go", "me", "id", "ui", "ki", "ji", "slice", "list", " I", "phi", "ti", " pi", "s", "v", "ims", "iy", "ix", "ai", "m", "ri", "status", "I", "batch", "y", "print", "\u0438", "fi", "sim", "iu", "point", "info", "l", "series", "j", "di", "x", "json", "ii", "name", "sequence"], "e": ["ev", "error", "et", "ei", "b", "ate", "end", "eb", "est", "c", "h", "EEE", "fe", "em", "te", "er", "we", "g", "d", "eg", "ie", "ent", "ec", "ge", "ae", "ed", "o", "ce", "se", "es", "element", "pe", "err", "r", "el", "me", "entity", "eur", "ue", "en", "v", "be", "ef", "eu", "m", "ee", "diff", "f", "de", "ex", "eeee", "oe", "one", "E", "a", "x", "ne", "le"]}}
{"project": "qemu", "commit_id": "b2dfd71c4843a762f2befe702adb249cf55baf66", "target": 0, "func": "static void vhost_log_stop(MemoryListener *listener,\n\n                           MemoryRegionSection *section)\n\n{\n\n    /* FIXME: implement */\n\n}\n", "idx": 5283, "substitutes": {"listener": ["Listeners", "isteners", "listening", "LISTening", "Listening", "istender", "Listender", "LISTeners", "listeners", "listender", "istening", "istener", "Listener", "LISTender", "LISTener"], "section": ["portion", "header", "event", "region", "channel", "job", "page", "description", "sections", "lex", "division", "sect", "group", "course", "environment", "key", "Section", "tag", "sector", "cell", "comment", "entry", "version", "journal", "directory", "ment", "setting", "ECTION"]}}
{"project": "qemu", "commit_id": "79853e18d904b0a4bcef62701d48559688007c93", "target": 0, "func": "static void spapr_hotplug_req_event(sPAPRDRConnector *drc, uint8_t hp_action)\n\n{\n\n    struct hp_log_full *new_hp;\n\n    struct rtas_error_log *hdr;\n\n    struct rtas_event_log_v6 *v6hdr;\n\n    struct rtas_event_log_v6_maina *maina;\n\n    struct rtas_event_log_v6_mainb *mainb;\n\n    struct rtas_event_log_v6_hp *hp;\n\n    sPAPRDRConnectorClass *drck = SPAPR_DR_CONNECTOR_GET_CLASS(drc);\n\n    sPAPRDRConnectorType drc_type = drck->get_type(drc);\n\n\n\n    new_hp = g_malloc0(sizeof(struct hp_log_full));\n\n    hdr = &new_hp->hdr;\n\n    v6hdr = &new_hp->v6hdr;\n\n    maina = &new_hp->maina;\n\n    mainb = &new_hp->mainb;\n\n    hp = &new_hp->hp;\n\n\n\n    hdr->summary = cpu_to_be32(RTAS_LOG_VERSION_6\n\n                               | RTAS_LOG_SEVERITY_EVENT\n\n                               | RTAS_LOG_DISPOSITION_NOT_RECOVERED\n\n                               | RTAS_LOG_OPTIONAL_PART_PRESENT\n\n                               | RTAS_LOG_INITIATOR_HOTPLUG\n\n                               | RTAS_LOG_TYPE_HOTPLUG);\n\n    hdr->extended_length = cpu_to_be32(sizeof(*new_hp)\n\n                                       - sizeof(new_hp->hdr));\n\n\n\n    spapr_init_v6hdr(v6hdr);\n\n    spapr_init_maina(maina, 3 /* Main-A, Main-B, HP */);\n\n\n\n    mainb->hdr.section_id = cpu_to_be16(RTAS_LOG_V6_SECTION_ID_MAINB);\n\n    mainb->hdr.section_length = cpu_to_be16(sizeof(*mainb));\n\n    mainb->subsystem_id = 0x80; /* External environment */\n\n    mainb->event_severity = 0x00; /* Informational / non-error */\n\n    mainb->event_subtype = 0x00; /* Normal shutdown */\n\n\n\n    hp->hdr.section_id = cpu_to_be16(RTAS_LOG_V6_SECTION_ID_HOTPLUG);\n\n    hp->hdr.section_length = cpu_to_be16(sizeof(*hp));\n\n    hp->hdr.section_version = 1; /* includes extended modifier */\n\n    hp->hotplug_action = hp_action;\n\n\n\n\n\n    switch (drc_type) {\n\n    case SPAPR_DR_CONNECTOR_TYPE_PCI:\n\n        hp->drc.index = cpu_to_be32(drck->get_index(drc));\n\n        hp->hotplug_identifier = RTAS_LOG_V6_HP_ID_DRC_INDEX;\n\n        hp->hotplug_type = RTAS_LOG_V6_HP_TYPE_PCI;\n\n        break;\n\n    default:\n\n        /* we shouldn't be signaling hotplug events for resources\n\n         * that don't support them\n\n         */\n\n        g_assert(false);\n\n        return;\n\n    }\n\n\n\n    rtas_event_log_queue(RTAS_LOG_TYPE_HOTPLUG, new_hp);\n\n\n\n    qemu_irq_pulse(xics_get_qirq(spapr->icp, spapr->check_exception_irq));\n\n}\n", "idx": 5298, "substitutes": {"drc": ["Dsc", "Drc", "cRC", "rpc", " duc", "dsc", "Dric", "sdrc", " dpc", "rrc", "droc", "edrc", "duc", " droc", "Droc", "edroc", "rRC", " dric", " dsc", "rsrc", "edRC", "sdpc", "dsrc", " dsrc", "crc", "sdRC", "edsc", "Duc", "DRC", " dRC", "sdsrc", "cric", "dric", "dRC", "dpc", "cuc"], "hp_action": ["hp_cmd", "HP_cmd", "hp_act", "HP_type", "HP_action", "hp_type", "HP_act"], "new_hp": ["new_ping", "new_ht", "new_phy", " new_ip", "new2phy", "new_ip", "new_hl", "newJhl", "unique_hr", "new__hl", "new2hp", "new___gp", "unique_eth", "freshJphy", "new___php", "new_rh", "new__hyper", "new____phy", "NEW_rh", "new_ha", "now_eth", "remote_ha", "freshJhp", "fresh_phy", "new__eth", " new_host", "new____hp", "new_hr", "newJhp", "new_hyper", "new2php", "remote_hp", "newlycp", "news_ht", "new_sh", "new_host", "news_sh", "new___ht", "remote___hp", "new____ping", "remote___phy", "new___ip", "news_hyper", "remote___ha", "new_gp", "new2gp", "newJgp", "new___hp", "remote_phy", "old___hp", "now_hyper", "new___host", "newlyhr", "newJphy", "new_phil", "new__gp", "old___phy", "old_hp", " new_phy", "new___ping", "new____ha", "new__hp", "NEW_health", "news_ha", "new_cp", "new___phy", "freshJgp", "news_phy", "new_php", "news_hp", "new__phy", "newlyhp", "fresh_gp", "NEW_phil", "newlyeth", "new___ha", "new_health", "unique_cp", "old___gp", "new_ih", "new__php", "new__ih", "old_phy", "unique_hp", "remote_ping", "remote___ping", "now_hp", "old_php", "fresh_hp", "fresh_hl", "new_eth", "old___php", "news_php", "old_gp", "now_ih", "NEW_hp", "freshJhl"], "hdr": ["bhder", "Hder", "ohld", " hrd", "shder", "hedr", "ohars", "Hbr", "thrid", "ohder", "phder", "highDR", "highheader", "hhheader", " hder", " hpar", "highdr", "thpar", "thrr", " hr", "hheader", "bhheader", "phpar", "hbr", "phrd", "hld", "thder", "phDR", "hhdr", "Hheader", "shrid", "ohr", "ahDR", " hheader", "shrr", "Hr", "phdr", "ohheader", "ohbr", "ahdr", " hrr", "ohDR", "shdr", " hld", "ahder", "hars", "thrd", "heder", "Hars", "hr", " hbr", "HDR", " hDR", "hder", "ohdr", "phheader", "highars", "hDR", "hrr", "thheader", "hrd", "ahheader", "thdr", "Hdr", "hpar", "hhder", "hrid", "heheader", "bhdr", " hrid", "Hld"], "v6hdr": ["v6ohdr", "v6hrec", "v6dhrec", "v4hDR", "v6achld", "v6Hld", "v6khDR", "v6HDR", "v616dhrec", "v6hder", "v4ohdr", "v616hDR", "v6Hdr", "v6khix", "v4ohDR", "v6dhDR", "v4hpr", "v6dhix", "v4phdr", "v6phpr", "v4hld", "v6vdr", "v6ohld", "v6phr", "v6dhdr", "v616hdr", "v6phrr", "v4Hder", "v4hder", "v4ohr", "v6chrr", "v4HDR", "v6chder", "v6vld", "v6hpr", "v6phDR", "v6phld", "v6Hix", "v616hrec", "v6Hder", "v4Hrr", "v6khdr", "v4hrr", "v616dhix", "v6hDR", "v616dhDR", "v6vDR", "v4phpr", "v4phDR", "v6hrr", "v6phder", "v6Hr", "v4Hdr", "v616dhdr", "v6ohr", "v4hr", "v6chDR", "v616hix", "v4hdr", "v4ohld", "v6chdr", "v6achDR", "v4phld", "v6hld", "v6hix", "v6achdr", "v6vpr", "v6achpr", "v6hr", "v6ohDR", "v6Hrr", "v6phdr", "v6khrec", "v6Hrec"], "maina": ["masterb", "Mainc", "sideb", "masteras", "sideA", " mainea", "mainas", "Mainae", "Maina", "sideba", "masterea", "Mainba", " mainA", "Mainas", " mainae", "masterc", "sidea", "Mainea", "mastera", "ainA", " mainc", "mainae", " mainas", "masterae", "mainba", "MainA", "masterA", "ainb", "mainc", "ainba", "mainea", "aina", "Mainb", "mainA"], "mainb": ["mainby", "Mainr", "primaryh", "Mainback", " maind", " mainl", " mainba", "maine", "mastera", "mainbar", "Mainh", "masterbb", " mainbb", " mainh", "primaryback", "Mainb", " mainv", "masterr", "masterbody", "genb", "Mainf", "mainback", "mainv", " mainf", "centralbar", "Maina", "masterf", "dona", "sidee", "centrala", "mainba", "mind", "matebar", "mainbb", "done", "matebb", "minl", "mainl", "masterd", " maine", "minb", "matea", "primarya", " mainbody", "mateb", "genby", "sidea", "minbb", "minv", "primaryb", "centralbb", " mainback", "Mainbar", "masterv", "mainf", "masterb", "masterby", "donb", "centralb", "sideb", "masterbar", "sideba", "mainh", "mainr", "mina", " mainbar", "maind", "donba", " mainby", "masterl", "genbody", "mainbody", " mainr"], "hp": ["ph", "hops", "ots", "mn", "mot", "gp", "cp", "wp", "git", "http", "h", "prof", "phy", "hess", "oh", "physical", "ht", "ip", "ps", "p", "cmd", "chip", "vp", "php", "hz", "hw", "phys", "hi", "history", "dh", "dr", "HP", "proc", "pkg", "pr", "phi", "lp", "hap", "apache", "driver", "hs", "hyper", "ptr", "ih", "np", "hm", "hist", "eth", "hd", "pp", "health", "hl", "pha", "ha", "html", "drm", "hop", "tp", "tt"], "drck": ["rk", "ptrk", "prcker", "ptrkk", "ptrcki", " drkk", "rck", "prk", "ptrck", " drcker", "rkk", "drcki", "prck", "drkk", "drk", " drk", "rcker", "prcki", "drcker", " drcki", "prkk"]}}
{"project": "qemu", "commit_id": "425532d71d5d295cc9c649500e4969ac621ce51d", "target": 0, "func": "static TCGReg tcg_out_tlb_load(TCGContext *s, TCGReg addr, int mem_index,\n\n                               TCGMemOp s_bits, int which)\n\n{\n\n    const TCGReg r0 = TCG_REG_O0;\n\n    const TCGReg r1 = TCG_REG_O1;\n\n    const TCGReg r2 = TCG_REG_O2;\n\n    int tlb_ofs;\n\n\n\n    /* Shift the page number down.  */\n\n    tcg_out_arithi(s, r1, addr, TARGET_PAGE_BITS, SHIFT_SRL);\n\n\n\n    /* Mask out the page offset, except for the required alignment.  */\n\n    tcg_out_movi(s, TCG_TYPE_TL, TCG_REG_T1,\n\n                 TARGET_PAGE_MASK | ((1 << s_bits) - 1));\n\n\n\n    /* Mask the tlb index.  */\n\n    tcg_out_arithi(s, r1, r1, CPU_TLB_SIZE - 1, ARITH_AND);\n\n    \n\n    /* Mask page, part 2.  */\n\n    tcg_out_arith(s, r0, addr, TCG_REG_T1, ARITH_AND);\n\n\n\n    /* Shift the tlb index into place.  */\n\n    tcg_out_arithi(s, r1, r1, CPU_TLB_ENTRY_BITS, SHIFT_SLL);\n\n\n\n    /* Relative to the current ENV.  */\n\n    tcg_out_arith(s, r1, TCG_AREG0, r1, ARITH_ADD);\n\n\n\n    /* Find a base address that can load both tlb comparator and addend.  */\n\n    tlb_ofs = offsetof(CPUArchState, tlb_table[mem_index][0]);\n\n    if (!check_fit_tl(tlb_ofs + sizeof(CPUTLBEntry), 13)) {\n\n        tcg_out_addi(s, r1, tlb_ofs & ~0x3ff);\n\n        tlb_ofs &= 0x3ff;\n\n    }\n\n\n\n    /* Load the tlb comparator and the addend.  */\n\n    tcg_out_ld(s, TCG_TYPE_TL, r2, r1, tlb_ofs + which);\n\n    tcg_out_ld(s, TCG_TYPE_PTR, r1, r1, tlb_ofs+offsetof(CPUTLBEntry, addend));\n\n\n\n    /* subcc arg0, arg2, %g0 */\n\n    tcg_out_cmp(s, r0, r2, 0);\n\n\n\n    /* If the guest address must be zero-extended, do so now.  */\n\n    if (SPARC64 && TARGET_LONG_BITS == 32) {\n\n        tcg_out_arithi(s, r0, addr, 0, SHIFT_SRL);\n\n        return r0;\n\n    }\n\n    return addr;\n\n}\n", "idx": 5304, "substitutes": {"s": ["as", "rs", "gs", "ses", "q", "b", "sw", "sg", "ssl", "csv", "ns", "conf", "c", "its", "h", "ats", "aws", "i", "qs", "sys", "cs", "comm", "self", "g", "p", "ms", "ps", "n", "d", "is", "ts", "ds", "sync", "t", "es", "r", "w", "js", "ins", "an", "sv", "ls", "sm", "sb", "space", "v", "ties", "stats", "ims", "m", "hs", "ss", "y", "sq", "socket", "fs", "obj", "ex", "S", "sts", "z", "x", "a"], "addr": ["db", "rs", "prefix", "mem", "src", "asm", "ctx", "offset", "rel", "store", "pad", " address", "arch", "ip", "map", "cmd", "add", "oad", "arp", "url", "hw", "r", "from", "dr", "rc", "ref", "id", "pkg", "rr", "start", "ad", "host", "handle", "Address", "ack", "alloc", "ptr", "gz", "alias", "address", "ag", "eth", "hash", "adr", "nl", "a", "name"], "mem_index": ["memory_Index", "memory_ind", "mem2index", "mem2Index", "mem_num", "mem_Index", "mem_ind", "memory_num", "mem_number", "mem2ind", "memory_index", "mem2number", "memory_number"], "s_bits": ["s_ps", "s_bit", "s___bit", "s___ps", "p__bits", "p_bits", "s__mask", "s__blocks", " s_bit", "s___blocks", "s__bits", "s___mask", "s__ps", "s__bit", "p_bit", "s_blocks", "s___bits", "p__blocks", "p__bit", "s_mask", "p_ps", "p_blocks", " s_blocks", "p__ps", " s_mask"], "which": ["every", "this", "method", "filename", "how", "ctl", "type", "find", "colour", "using", "what", "clus", "cmd", "whose", "focus", "selected", "chip", "selection", "is", " Which", "index", "and", "from", "Which", "bit", "each", "wit", "nil", "who", "whether", "hat", "why", "where", "command", "select", "isc", "ptr", "through", "eth", "via", "ctr"], "tlb_ofs": ["tlb_OFS", "tlb_oftS", "tlb_dirS", "tlb_defs", "tlb_OFd", "tlb_offS", "tlb_effd", "tlb_offsb", "tlb_fonts", "tlb_ofty", "tlb_effS", "tlb_Ofs", "tlb_ofS", "tlb_OFis", "tlb_ofis", "tlb_ofts", "tlb_dirg", "tlb_ofsb", "tlb_ofr", "tlb_Ofi", "tlb_offx", "tlb_tells", "tlb_ofx", "tlb_ofg", "tlb_fontr", "tlb_dirs", "tlb_Ofr", "tlb_OFi", "tlb_ofy", "tlb_OFs", "tlb_offs", "tlb_effg", "tlb_bufg", "tlb_tellS", "tlb_OFts", "tlb_defis", "tlb_effs", "tlb_fontd", "tlb_Ofd", "tlb_offts", "tlb_OFx", "tlb_ofd", "tlb_defy", "tlb_defS", "tlb_OFy", "tlb_bufs", "tlb_tellx", "tlb_OFr", "tlb_OFsb", "tlb_effsb", "tlb_fonti", "tlb_oftis", "tlb_ofi", "tlb_bufS", "tlb_effts", "tlb_offd"]}}
{"project": "qemu", "commit_id": "838ef602498b8d1985a231a06f5e328e2946a81d", "target": 0, "func": "static int curl_sock_cb(CURL *curl, curl_socket_t fd, int action,\n\n                        void *s, void *sp)\n\n{\n\n    DPRINTF(\"CURL (AIO): Sock action %d on fd %d\\n\", action, fd);\n\n    switch (action) {\n\n        case CURL_POLL_IN:\n\n            qemu_aio_set_fd_handler(fd, curl_multi_do, NULL, s);\n\n            break;\n\n        case CURL_POLL_OUT:\n\n            qemu_aio_set_fd_handler(fd, NULL, curl_multi_do, s);\n\n            break;\n\n        case CURL_POLL_INOUT:\n\n            qemu_aio_set_fd_handler(fd, curl_multi_do, curl_multi_do, s);\n\n            break;\n\n        case CURL_POLL_REMOVE:\n\n            qemu_aio_set_fd_handler(fd, NULL, NULL, NULL);\n\n            break;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 5306, "substitutes": {"curl": ["Curl", "ccURL", "Cssl", " cURL", "ccssl", "cURL", "cll", "ccurl", "ccll", "CURL", " cssl", "cssl", " cll", "Cll"], "fd": ["db", "cf", "form", "uf", "ff", "dat", "dial", "ctx", "def", "nd", "lf", "buffer", "fc", " df", "d", "dt", "dl", " sd", "bd", "sd", "gd", "ds", "unc", "cb", "fl", "data", "fp", "func", "callback", "fps", " fid", "ind", "std", " d", "ud", "ad", "fed", "dd", "df", "stream", "fin", "fn", "fb", "ptr", "gz", "cond", "handler", "sf", "disk", "f", "FD", "fi", "pd", "fs", "desc", "hd", "td", "ld", "fr", "da"], "action": ["policy", "draw", "form", "event", "function", " ACTION", "call", "step", "type", "c", "operation", "state", "aj", "activation", "what", "actions", "flow", "cmd", "ak", "typ", "op", "index", "func", "pos", "k", "ACTION", "code", "mode", "effect", "change", "ACT", "fun", "aff", "status", "ction", "ac", "acl", "off", "version", "mod", " act", "activity", "j", "format", "a", "Action", "name", "act", "trigger"], "s": ["as", "rs", "gs", "b", "sg", "ns", "c", "ats", "aws", "i", "sc", "cs", "si", "d", "ms", "p", "n", "ps", "ts", "ds", "t", "seconds", "r", "js", "ins", "space", "sv", "ls", "sb", "v", "args", "sl", "sa", "ss", "sn", "bs", "socket", "sf", "f", "sq", "fs", "S", "sts", "a"], "sp": ["sw", "ns", "pc", "ctx", " ss", "fx", "sc", "ps", "p", "si", "osp", "vp", "fp", "dh", "js", "SP", "sv", "ap", "esp", "sk", "sh", "resp", "vs", "ss", "tmp", "ptr", "sf", "np", "pp"]}}
{"project": "FFmpeg", "commit_id": "428098165de4c3edfe42c1b7f00627d287015863", "target": 1, "func": "SwsFunc yuv2rgb_get_func_ptr (SwsContext *c)\n\n{\n\n#if defined(HAVE_MMX2) || defined(HAVE_MMX)\n\n    if(c->flags & SWS_CPU_CAPS_MMX2){\n\n\tswitch(c->dstFormat){\n\n\tcase PIX_FMT_RGB32: return yuv420_rgb32_MMX2;\n\n\tcase PIX_FMT_BGR24: return yuv420_rgb24_MMX2;\n\n\tcase PIX_FMT_BGR565: return yuv420_rgb16_MMX2;\n\n\tcase PIX_FMT_BGR555: return yuv420_rgb15_MMX2;\n\n\t}\n\n    }\n\n    if(c->flags & SWS_CPU_CAPS_MMX){\n\n\tswitch(c->dstFormat){\n\n\tcase PIX_FMT_RGB32: return yuv420_rgb32_MMX;\n\n\tcase PIX_FMT_BGR24: return yuv420_rgb24_MMX;\n\n\tcase PIX_FMT_BGR565: return yuv420_rgb16_MMX;\n\n\tcase PIX_FMT_BGR555: return yuv420_rgb15_MMX;\n\n\t}\n\n    }\n\n#endif\n\n#ifdef HAVE_MLIB\n\n    {\n\n\tSwsFunc t= yuv2rgb_init_mlib(c);\n\n\tif(t) return t;\n\n    }\n\n#endif\n\n#ifdef HAVE_ALTIVEC\n\n    if (c->flags & SWS_CPU_CAPS_ALTIVEC)\n\n    {\n\n\tSwsFunc t = yuv2rgb_init_altivec(c);\n\n\tif(t) return t;\n\n    }\n\n#endif\n\n\n\n    av_log(c, AV_LOG_WARNING, \"No accelerated colorspace conversion found\\n\");\n\n\n\n    switch(c->dstFormat){\n\n    case PIX_FMT_BGR32:\n\n    case PIX_FMT_RGB32: return yuv2rgb_c_32;\n\n    case PIX_FMT_RGB24: return yuv2rgb_c_24_rgb;\n\n    case PIX_FMT_BGR24: return yuv2rgb_c_24_bgr;\n\n    case PIX_FMT_RGB565:\n\n    case PIX_FMT_BGR565:\n\n    case PIX_FMT_RGB555:\n\n    case PIX_FMT_BGR555: return yuv2rgb_c_16;\n\n    case PIX_FMT_RGB8:\n\n    case PIX_FMT_BGR8:  return yuv2rgb_c_8_ordered_dither;\n\n    case PIX_FMT_RGB4:\n\n    case PIX_FMT_BGR4:  return yuv2rgb_c_4_ordered_dither;\n\n    case PIX_FMT_RGB4_BYTE:\n\n    case PIX_FMT_BGR4_BYTE:  return yuv2rgb_c_4b_ordered_dither;\n\n    case PIX_FMT_MONOBLACK:  return yuv2rgb_c_1_ordered_dither;\n\n    default:\n\n    \tassert(0);\n\n    }\n\n    return NULL;\n\n}\n", "idx": 5308, "substitutes": {"c": ["cf", "dc", "gc", "chain", "b", "call", "ct", "cp", "conf", "pc", "ctx", "h", "cl", "cont", "cam", "bc", "set", "con", "cs", "sc", "fc", "p", "d", "cm", "g", "co", "n", "etc", "nc", "ec", "unc", "cb", "lc", "ce", "t", "r", "cc", "w", "rc", "icc", "cn", "cr", "v", "container", "m", "ch", "ac", "vc", "cv", "cd", "ca", "cache", "f", "mc", "cur", "conv", "C", "e", "l", "z", "enc", "com", "cu", "abc", "tc"]}}
{"project": "qemu", "commit_id": "e5f34cdd2da54f28d90889a3afd15fad2d6105ff", "target": 1, "func": "static void vnc_set_share_mode(VncState *vs, VncShareMode mode)\n\n{\n\n#ifdef _VNC_DEBUG\n\n    static const char *mn[] = {\n\n        [0]                           = \"undefined\",\n\n        [VNC_SHARE_MODE_CONNECTING]   = \"connecting\",\n\n        [VNC_SHARE_MODE_SHARED]       = \"shared\",\n\n        [VNC_SHARE_MODE_EXCLUSIVE]    = \"exclusive\",\n\n        [VNC_SHARE_MODE_DISCONNECTED] = \"disconnected\",\n\n    };\n\n    fprintf(stderr, \"%s/%d: %s -> %s\\n\", __func__,\n\n            vs->csock, mn[vs->share_mode], mn[mode]);\n\n#endif\n\n\n\n    if (vs->share_mode == VNC_SHARE_MODE_EXCLUSIVE) {\n\n        vs->vd->num_exclusive--;\n\n    }\n\n    vs->share_mode = mode;\n\n    if (vs->share_mode == VNC_SHARE_MODE_EXCLUSIVE) {\n\n        vs->vd->num_exclusive++;\n\n    }\n\n}\n", "idx": 5314, "substitutes": {"vs": ["vv", "rs", "vr", "uv", "ev", "ses", "gs", "lv", "ns", "ov", "eps", "wcs", "vers", "values", "vi", "qs", "cs", "aps", "ps", "ms", "lines", "blogs", "inv", "vp", "ts", "ports", "ds", "pages", "details", "fps", "is", "es", "vals", "vl", "js", "ins", "sv", "ls", "sb", "xs", "services", "v", "ims", "stats", "Vs", "VS", "views", "vc", "hs", "ss", "bs", "serv", "lbs", "parts", "vt", "fs", "ves", "vm", "ks", "docs", "sts", "posts", "changes", "otes", "obs", "news", "ver", "ils", "lists"], "mode": ["mate", "xy", "power", "node", "metadata", "type", "md", "direction", "move", "cmp", "set", "state", " macro", "self", "Mode", "te", "mid", "mt", "ms", "settings", "option", "ODE", "perm", "sty", "multi", "pe", "value", "me", "module", " ty", "options", "mac", "device", "send", "role", "dim", "command", "status", "m", "mit", "MODE", "mm", "member", "mod", "test", "de", "size", "time", "format", "ase", "pty", "name", "ode", " mirror"], "mn": ["km", "ln", "fm", "ns", "mph", "mun", "md", "mus", "mis", "mi", "mr", "wm", "ms", "ml", "mt", "gn", "tn", "nc", "wn", "pers", "san", "ins", "mu", "mins", "sv", "dm", "nm", "yn", "ng", "cn", "mind", "kn", "nos", "man", "mos", "mb", "mit", "fn", "dn", "mm", "np", "mc", "MN", "ems", "pres", "men", "mx", "mp"], "vd": ["ued", "db", "vv", "cod", "lv", "xd", "md", "nd", "vid", "ve", "dt", "VD", "vision", "bd", "gd", "sd", "ds", "ead", "ud", "dll", "nv", "dd", "df", "vc", "dn", "desc", "disk", "ord", "pd", "hd", "vm", "ld", "sta", "wd", "fd"], "num_exclusive": ["numwsecondary", "count_free", "num__secondary", "number_exclusive", "numEexclusive", "num__exclusive", "num_free", "count_ex", "num_ex", "count__exclusive", "count_external", "count__free", "numEfree", "numwwindows", "num__windows", "count__ex", "numwexternal", "num_windows", "numEex", "number_secondary", "num__free", "num_secondary", "num_external", "number_windows", "numwexclusive", "number_external", "numEexternal", "count_exclusive", "num__ex", "num__external", "count__external"]}}
{"project": "FFmpeg", "commit_id": "7cc8d616aab68ba5534e5a74214786ad08aac5ce", "target": 1, "func": "uint8_t ff_mlp_calculate_parity(const uint8_t *buf, unsigned int buf_size)\n\n{\n\n    uint32_t scratch = 0;\n\n    const uint8_t *buf_end = buf + buf_size;\n\n\n\n\n\n    for (; buf < buf_end - 3; buf += 4)\n\n        scratch ^= *((const uint32_t*)buf);\n\n\n\n    scratch = xor_32_to_8(scratch);\n\n\n\n    for (; buf < buf_end; buf++)\n\n\n\n\n    return scratch;\n\n}", "idx": 5327, "substitutes": {"buf": ["bur", "uf", "keep", "ann", "addr", "cb", "queue", "bu", "pend", "pos", "pg", "iter", "req", "batch", "aka", "cur", "loop", "coord", "broad", "loc", "buff", "pad", "wb", "go", "begin", "rb", "port", "pool", "length", "ctr", "urg", "vec", "xff", "db", "end", "ctx", "bc", "Buffer", "msg", "seq", "var", "rc", "bar", "pkg", "Buff", "nm", "alloc", "cv", "bl", "que", "act", "b", "bn", "ff", "window", "cp", "br", "av", "pack", "box", "buffer", "raw", "cmd", "bp", "seek", "func", "err", "bf", "cap", "far", "block", "now", "off", "ptr", "img", "gz", "doc", "obj", "abet", "arr"], "buf_size": ["buf_len", "buf_scale", "buffer_SIZE", "buffer_size", "buf_Size", "buffer_scale", "buf_zone", "buf_count", "buffer_Size", "buf_SIZE", "buff_count", "buff_len", "buff_zone", "buff_size"], "buf_end": [" buf2end", "buf_END", "max_end", "max_size", "buf2start", " buf_start", "buf_ended", "buf2stop", "db_ender", "db_end", " buf_ended", " buf2ended", "max_END", "db_size", "db_stop", "buf_ender", "buf2ender", "buf2end", "buf2size", " buf2start", "max_bound", "buf_stop", "buf2ended", "buf_bound", "buf_start"]}}
{"project": "FFmpeg", "commit_id": "f354f30836a3148275ce60d19bbc581310249ad2", "target": 0, "func": "void ff_er_frame_start(ERContext *s)\n\n{\n\n    if (!s->avctx->err_recognition)\n\n        return;\n\n\n\n    memset(s->error_status_table, ER_MB_ERROR | VP_START | ER_MB_END,\n\n           s->mb_stride * s->mb_height * sizeof(uint8_t));\n\n    s->error_count    = 3 * s->mb_num;\n\n    s->error_occurred = 0;\n\n}\n", "idx": 5353, "substitutes": {"s": ["rs", "gs", "ses", "q", "less", "tes", "ns", "c", "its", "asm", "ats", "h", "eps", "sys", "qs", "cs", "comm", "os", "uploads", "als", "ps", "ms", "details", "n", "tests", "is", "ts", "g", "ds", "t", "es", "se", "plays", "js", "w", "ins", "sv", "ls", "events", "sb", "comments", "ess", "v", "ims", "stats", "spec", "hs", "vs", "ss", "bs", "sn", "states", "sq", "sf", "parts", "fs", "S", "sts", "sports", "aws", "l", "ops"]}}
{"project": "FFmpeg", "commit_id": "f98c9fb27de84dc4f6123537b754eb2fe1a80c02", "target": 0, "func": "av_cold int MPV_common_init(MpegEncContext *s)\n\n{\n\n    int y_size, c_size, yc_size, i, mb_array_size, mv_table_size, x, y, threads;\n\n\n\n    if(s->codec_id == CODEC_ID_MPEG2VIDEO && !s->progressive_sequence)\n\n        s->mb_height = (s->height + 31) / 32 * 2;\n\n    else if (s->codec_id != CODEC_ID_H264)\n\n        s->mb_height = (s->height + 15) / 16;\n\n\n\n    if(s->avctx->pix_fmt == PIX_FMT_NONE){\n\n        av_log(s->avctx, AV_LOG_ERROR, \"decoding to PIX_FMT_NONE is not supported.\\n\");\n\n        return -1;\n\n    }\n\n\n\n    if((s->encoding || (s->avctx->active_thread_type & FF_THREAD_SLICE)) &&\n\n       (s->avctx->thread_count > MAX_THREADS || (s->avctx->thread_count > s->mb_height && s->mb_height))){\n\n        av_log(s->avctx, AV_LOG_ERROR, \"too many threads\\n\");\n\n        return -1;\n\n    }\n\n\n\n    if((s->width || s->height) && av_image_check_size(s->width, s->height, 0, s->avctx))\n\n        return -1;\n\n\n\n    dsputil_init(&s->dsp, s->avctx);\n\n    ff_dct_common_init(s);\n\n\n\n    s->flags= s->avctx->flags;\n\n    s->flags2= s->avctx->flags2;\n\n\n\n    if (s->width && s->height) {\n\n        s->mb_width  = (s->width  + 15) / 16;\n\n        s->mb_stride = s->mb_width + 1;\n\n        s->b8_stride = s->mb_width*2 + 1;\n\n        s->b4_stride = s->mb_width*4 + 1;\n\n        mb_array_size= s->mb_height * s->mb_stride;\n\n        mv_table_size= (s->mb_height+2) * s->mb_stride + 1;\n\n\n\n        /* set chroma shifts */\n\n        avcodec_get_chroma_sub_sample(s->avctx->pix_fmt,&(s->chroma_x_shift),\n\n                                      &(s->chroma_y_shift) );\n\n\n\n        /* set default edge pos, will be overriden in decode_header if needed */\n\n        s->h_edge_pos= s->mb_width*16;\n\n        s->v_edge_pos= s->mb_height*16;\n\n\n\n        s->mb_num = s->mb_width * s->mb_height;\n\n\n\n        s->block_wrap[0]=\n\n        s->block_wrap[1]=\n\n        s->block_wrap[2]=\n\n        s->block_wrap[3]= s->b8_stride;\n\n        s->block_wrap[4]=\n\n        s->block_wrap[5]= s->mb_stride;\n\n\n\n        y_size = s->b8_stride * (2 * s->mb_height + 1);\n\n        c_size = s->mb_stride * (s->mb_height + 1);\n\n        yc_size = y_size + 2 * c_size;\n\n\n\n        /* convert fourcc to upper case */\n\n        s->codec_tag = ff_toupper4(s->avctx->codec_tag);\n\n\n\n        s->stream_codec_tag = ff_toupper4(s->avctx->stream_codec_tag);\n\n\n\n        s->avctx->coded_frame= (AVFrame*)&s->current_picture;\n\n\n\n        FF_ALLOCZ_OR_GOTO(s->avctx, s->mb_index2xy, (s->mb_num+1)*sizeof(int), fail) //error ressilience code looks cleaner with this\n\n        for(y=0; y<s->mb_height; y++){\n\n            for(x=0; x<s->mb_width; x++){\n\n                s->mb_index2xy[ x + y*s->mb_width ] = x + y*s->mb_stride;\n\n            }\n\n        }\n\n        s->mb_index2xy[ s->mb_height*s->mb_width ] = (s->mb_height-1)*s->mb_stride + s->mb_width; //FIXME really needed?\n\n\n\n        if (s->encoding) {\n\n            /* Allocate MV tables */\n\n            FF_ALLOCZ_OR_GOTO(s->avctx, s->p_mv_table_base            , mv_table_size * 2 * sizeof(int16_t), fail)\n\n            FF_ALLOCZ_OR_GOTO(s->avctx, s->b_forw_mv_table_base       , mv_table_size * 2 * sizeof(int16_t), fail)\n\n            FF_ALLOCZ_OR_GOTO(s->avctx, s->b_back_mv_table_base       , mv_table_size * 2 * sizeof(int16_t), fail)\n\n            FF_ALLOCZ_OR_GOTO(s->avctx, s->b_bidir_forw_mv_table_base , mv_table_size * 2 * sizeof(int16_t), fail)\n\n            FF_ALLOCZ_OR_GOTO(s->avctx, s->b_bidir_back_mv_table_base , mv_table_size * 2 * sizeof(int16_t), fail)\n\n            FF_ALLOCZ_OR_GOTO(s->avctx, s->b_direct_mv_table_base     , mv_table_size * 2 * sizeof(int16_t), fail)\n\n            s->p_mv_table           = s->p_mv_table_base            + s->mb_stride + 1;\n\n            s->b_forw_mv_table      = s->b_forw_mv_table_base       + s->mb_stride + 1;\n\n            s->b_back_mv_table      = s->b_back_mv_table_base       + s->mb_stride + 1;\n\n            s->b_bidir_forw_mv_table= s->b_bidir_forw_mv_table_base + s->mb_stride + 1;\n\n            s->b_bidir_back_mv_table= s->b_bidir_back_mv_table_base + s->mb_stride + 1;\n\n            s->b_direct_mv_table    = s->b_direct_mv_table_base     + s->mb_stride + 1;\n\n\n\n            if(s->msmpeg4_version){\n\n                FF_ALLOCZ_OR_GOTO(s->avctx, s->ac_stats, 2*2*(MAX_LEVEL+1)*(MAX_RUN+1)*2*sizeof(int), fail);\n\n            }\n\n            FF_ALLOCZ_OR_GOTO(s->avctx, s->avctx->stats_out, 256, fail);\n\n\n\n            /* Allocate MB type table */\n\n            FF_ALLOCZ_OR_GOTO(s->avctx, s->mb_type  , mb_array_size * sizeof(uint16_t), fail) //needed for encoding\n\n\n\n            FF_ALLOCZ_OR_GOTO(s->avctx, s->lambda_table, mb_array_size * sizeof(int), fail)\n\n\n\n            FF_ALLOCZ_OR_GOTO(s->avctx, s->q_intra_matrix  , 64*32   * sizeof(int), fail)\n\n            FF_ALLOCZ_OR_GOTO(s->avctx, s->q_inter_matrix  , 64*32   * sizeof(int), fail)\n\n            FF_ALLOCZ_OR_GOTO(s->avctx, s->q_intra_matrix16, 64*32*2 * sizeof(uint16_t), fail)\n\n            FF_ALLOCZ_OR_GOTO(s->avctx, s->q_inter_matrix16, 64*32*2 * sizeof(uint16_t), fail)\n\n            FF_ALLOCZ_OR_GOTO(s->avctx, s->input_picture, MAX_PICTURE_COUNT * sizeof(Picture*), fail)\n\n            FF_ALLOCZ_OR_GOTO(s->avctx, s->reordered_input_picture, MAX_PICTURE_COUNT * sizeof(Picture*), fail)\n\n\n\n            if(s->avctx->noise_reduction){\n\n                FF_ALLOCZ_OR_GOTO(s->avctx, s->dct_offset, 2 * 64 * sizeof(uint16_t), fail)\n\n            }\n\n        }\n\n    }\n\n\n\n    s->picture_count = MAX_PICTURE_COUNT * FFMAX(1, s->avctx->thread_count);\n\n    FF_ALLOCZ_OR_GOTO(s->avctx, s->picture, s->picture_count * sizeof(Picture), fail)\n\n    for(i = 0; i < s->picture_count; i++) {\n\n        avcodec_get_frame_defaults((AVFrame *)&s->picture[i]);\n\n    }\n\n\n\n    if (s->width && s->height) {\n\n        FF_ALLOCZ_OR_GOTO(s->avctx, s->error_status_table, mb_array_size*sizeof(uint8_t), fail)\n\n\n\n        if(s->codec_id==CODEC_ID_MPEG4 || (s->flags & CODEC_FLAG_INTERLACED_ME)){\n\n            /* interlaced direct mode decoding tables */\n\n            for(i=0; i<2; i++){\n\n                int j, k;\n\n                for(j=0; j<2; j++){\n\n                    for(k=0; k<2; k++){\n\n                        FF_ALLOCZ_OR_GOTO(s->avctx,    s->b_field_mv_table_base[i][j][k], mv_table_size * 2 * sizeof(int16_t), fail)\n\n                        s->b_field_mv_table[i][j][k] = s->b_field_mv_table_base[i][j][k] + s->mb_stride + 1;\n\n                    }\n\n                    FF_ALLOCZ_OR_GOTO(s->avctx, s->b_field_select_table [i][j], mb_array_size * 2 * sizeof(uint8_t), fail)\n\n                    FF_ALLOCZ_OR_GOTO(s->avctx, s->p_field_mv_table_base[i][j], mv_table_size * 2 * sizeof(int16_t), fail)\n\n                    s->p_field_mv_table[i][j] = s->p_field_mv_table_base[i][j]+ s->mb_stride + 1;\n\n                }\n\n                FF_ALLOCZ_OR_GOTO(s->avctx, s->p_field_select_table[i], mb_array_size * 2 * sizeof(uint8_t), fail)\n\n            }\n\n        }\n\n        if (s->out_format == FMT_H263) {\n\n            /* cbp values */\n\n            FF_ALLOCZ_OR_GOTO(s->avctx, s->coded_block_base, y_size, fail);\n\n            s->coded_block= s->coded_block_base + s->b8_stride + 1;\n\n\n\n            /* cbp, ac_pred, pred_dir */\n\n            FF_ALLOCZ_OR_GOTO(s->avctx, s->cbp_table     , mb_array_size * sizeof(uint8_t), fail)\n\n            FF_ALLOCZ_OR_GOTO(s->avctx, s->pred_dir_table, mb_array_size * sizeof(uint8_t), fail)\n\n        }\n\n\n\n        if (s->h263_pred || s->h263_plus || !s->encoding) {\n\n            /* dc values */\n\n            //MN: we need these for error resilience of intra-frames\n\n            FF_ALLOCZ_OR_GOTO(s->avctx, s->dc_val_base, yc_size * sizeof(int16_t), fail);\n\n            s->dc_val[0] = s->dc_val_base + s->b8_stride + 1;\n\n            s->dc_val[1] = s->dc_val_base + y_size + s->mb_stride + 1;\n\n            s->dc_val[2] = s->dc_val[1] + c_size;\n\n            for(i=0;i<yc_size;i++)\n\n                s->dc_val_base[i] = 1024;\n\n        }\n\n\n\n        /* which mb is a intra block */\n\n        FF_ALLOCZ_OR_GOTO(s->avctx, s->mbintra_table, mb_array_size, fail);\n\n        memset(s->mbintra_table, 1, mb_array_size);\n\n\n\n        /* init macroblock skip table */\n\n        FF_ALLOCZ_OR_GOTO(s->avctx, s->mbskip_table, mb_array_size+2, fail);\n\n        //Note the +1 is for a quicker mpeg4 slice_end detection\n\n        FF_ALLOCZ_OR_GOTO(s->avctx, s->prev_pict_types, PREV_PICT_TYPES_BUFFER_SIZE, fail);\n\n\n\n        s->parse_context.state= -1;\n\n        if((s->avctx->debug&(FF_DEBUG_VIS_QP|FF_DEBUG_VIS_MB_TYPE)) || (s->avctx->debug_mv)){\n\n            s->visualization_buffer[0] = av_malloc((s->mb_width*16 + 2*EDGE_WIDTH) * s->mb_height*16 + 2*EDGE_WIDTH);\n\n            s->visualization_buffer[1] = av_malloc((s->mb_width*16 + 2*EDGE_WIDTH) * s->mb_height*16 + 2*EDGE_WIDTH);\n\n            s->visualization_buffer[2] = av_malloc((s->mb_width*16 + 2*EDGE_WIDTH) * s->mb_height*16 + 2*EDGE_WIDTH);\n\n        }\n\n    }\n\n\n\n    s->context_initialized = 1;\n\n    s->thread_context[0]= s;\n\n\n\n    if (s->width && s->height) {\n\n    if (s->encoding || (HAVE_THREADS && s->avctx->active_thread_type&FF_THREAD_SLICE)) {\n\n        threads = s->avctx->thread_count;\n\n\n\n        for(i=1; i<threads; i++){\n\n            s->thread_context[i]= av_malloc(sizeof(MpegEncContext));\n\n            memcpy(s->thread_context[i], s, sizeof(MpegEncContext));\n\n        }\n\n\n\n        for(i=0; i<threads; i++){\n\n            if(init_duplicate_context(s->thread_context[i], s) < 0)\n\n                goto fail;\n\n            s->thread_context[i]->start_mb_y= (s->mb_height*(i  ) + s->avctx->thread_count/2) / s->avctx->thread_count;\n\n            s->thread_context[i]->end_mb_y  = (s->mb_height*(i+1) + s->avctx->thread_count/2) / s->avctx->thread_count;\n\n        }\n\n    } else {\n\n        if(init_duplicate_context(s, s) < 0) goto fail;\n\n        s->start_mb_y = 0;\n\n        s->end_mb_y   = s->mb_height;\n\n    }\n\n    }\n\n\n\n    return 0;\n\n fail:\n\n    MPV_common_end(s);\n\n    return -1;\n\n}\n", "idx": 5356, "substitutes": {"s": ["styles", "des", "sw", "less", "conf", "c", "h", "sc", "terms", "ads", "ps", "ports", "ts", "settings", "eds", "t", "se", "pers", "js", "w", "ast", "events", "gets", "sb", "xs", "ss", "south", "changes", "sports", "comments", "params", "as", "bes", "rs", "ses", "results", "ants", "os", "g", "ms", "tests", "ains", "sets", "es", "v", "stats", "bits", "vs", "aws", "ows", "l", "ops", "ges", "gs", "bis", "sg", "ar", "ars", "ns", "orders", "ats", "ies", "ags", "cs", "comm", "actions", "p", "aunts", "is", "has", "r", "sv", "hs", "bs", "sq", "parts", "fs", "S", "eps", "its", "qs", "set", "sys", "als", "erences", "details", "n", "ds", "ins", "ids", "ls", "ims", "ties", "args", "views", "states", "obj", "ex", "e", "sts", "mods"], "y_size": ["v_SIZE", "ywshape", "v_shape", "vwsize", "y_id", "ywid", "v_id", "vwid", "v_size", "vwSIZE", "ywsize", "vwshape", "y_SIZE", "y_shape", "ywSIZE"], "c_size": ["cctsize", "cctheight", "cv_height", "c_SIZE", "c_count", "cctSIZE", "cv_SIZE", "cv_count", "cctcount", "cv_size", "c_height"], "yc_size": ["ya_set", "ycptSIZE", "ya_SIZE", "yc_set", "ya_size", "ycptsize", "yc_id", "yc_SIZE", "ycptid", "ya_id", "ycptset"], "i": ["ij", "ci", "b", "it", "im", "c", "mi", "ip", "p", "si", "g", "n", "index", "t", "bi", "pi", "ti", "v", "ai", "m", "I", "f", "in", "ii", "l"], "mb_array_size": ["mb_arr_size", "mb_arr_scale", "mb_array_len", "mb_array_shape", "mb_arrayabsize", "mb_array_space", "mb_arrayabscale", "mb_arr_len", "mb_array_scale", "mb_array_SIZE", "mb_array_name", "mb_arrayabSIZE", "mb_arr_SIZE", "mb_arrayablen"], "mv_table_size": ["mv_table__name", "mv_buffer_SIZE", "mv_table__size", "mv_table_type", "mv_Table_type", "mv_table__type", "mv_buffer_size", "mv_table_space", "mv_table_SIZE", "mv_table_Size", "mv_Table_Size", "mv_table_empty", "mv_table_name", "mv_Table_size", "mv_Table_name", "mv_buffer_empty", "mv_table__Size", "mv_buffer_space"], "x": ["xy", "c", "X", "fx", "xt", "rx", "px", "p", "index", "height", "w", "id", "dx", "xs", "v", "ix", "m", "tx", "f", "ex", "size", "time", "z", "mx", "l"], "y": ["vy", "xy", "b", "cy", "dy", "c", "Y", "p", "sy", "n", "o", "t", "key", "height", "ny", "py", "yy", "v", "iy", "m", "ch", "yt", "ys", "size", "ym"], "threads": ["Threads", "counts", "counteds", " threadi", "threadeds", "Threadeds", "counti", "Threadi", "threadi", " threadeds"]}}
{"project": "FFmpeg", "commit_id": "03847eb8259291b4ff1bd840bd779d0699d71f96", "target": 0, "func": "int av_probe_input_buffer(AVIOContext *pb, AVInputFormat **fmt,\n\n                          const char *filename, void *logctx,\n\n                          unsigned int offset, unsigned int max_probe_size)\n\n{\n\n    AVProbeData pd = { filename ? filename : \"\", NULL, -offset };\n\n    unsigned char *buf = NULL;\n\n    int ret = 0, probe_size;\n\n\n\n    if (!max_probe_size) {\n\n        max_probe_size = PROBE_BUF_MAX;\n\n    } else if (max_probe_size > PROBE_BUF_MAX) {\n\n        max_probe_size = PROBE_BUF_MAX;\n\n    } else if (max_probe_size < PROBE_BUF_MIN) {\n\n        return AVERROR(EINVAL);\n\n    }\n\n\n\n    if (offset >= max_probe_size) {\n\n        return AVERROR(EINVAL);\n\n    }\n\n\n\n    for(probe_size= PROBE_BUF_MIN; probe_size<=max_probe_size && !*fmt;\n\n        probe_size = FFMIN(probe_size<<1, FFMAX(max_probe_size, probe_size+1))) {\n\n        int score = probe_size < max_probe_size ? AVPROBE_SCORE_RETRY : 0;\n\n        int buf_offset = (probe_size == PROBE_BUF_MIN) ? 0 : probe_size>>1;\n\n        void *buftmp;\n\n\n\n        if (probe_size < offset) {\n\n            continue;\n\n        }\n\n\n\n        /* read probe data */\n\n        buftmp = av_realloc(buf, probe_size + AVPROBE_PADDING_SIZE);\n\n        if(!buftmp){\n\n            av_free(buf);\n\n            return AVERROR(ENOMEM);\n\n        }\n\n        buf=buftmp;\n\n        if ((ret = avio_read(pb, buf + buf_offset, probe_size - buf_offset)) < 0) {\n\n            /* fail if error was not end of file, otherwise, lower score */\n\n            if (ret != AVERROR_EOF) {\n\n                av_free(buf);\n\n                return ret;\n\n            }\n\n            score = 0;\n\n            ret = 0;            /* error was end of file, nothing read */\n\n        }\n\n        pd.buf_size += ret;\n\n        pd.buf = &buf[offset];\n\n\n\n        memset(pd.buf + pd.buf_size, 0, AVPROBE_PADDING_SIZE);\n\n\n\n        /* guess file format */\n\n        *fmt = av_probe_input_format2(&pd, 1, &score);\n\n        if(*fmt){\n\n            if(score <= AVPROBE_SCORE_RETRY){ //this can only be true in the last iteration\n\n                av_log(logctx, AV_LOG_WARNING, \"Format %s detected only with low score of %d, misdetection possible!\\n\", (*fmt)->name, score);\n\n            }else\n\n                av_log(logctx, AV_LOG_DEBUG, \"Format %s probed with size=%d and score=%d\\n\", (*fmt)->name, probe_size, score);\n\n        }\n\n    }\n\n\n\n    if (!*fmt) {\n\n        av_free(buf);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    /* rewind. reuse probe buffer to avoid seeking */\n\n    ret = ffio_rewind_with_probe_data(pb, &buf, pd.buf_size);\n\n\n\n    return ret;\n\n}\n", "idx": 5357, "substitutes": {"pb": ["stab", "uf", "bj", "ab", "cp", "conf", "job", "pc", "ctx", "bc", "pro", "bh", "p", "typ", "vp", "cb", "phys", "aus", "lb", "xc", "bb", "ub", "pkg", "proc", "pg", "sb", "lp", "rb", "tx", "cv", "tmp", "jp", "np", "pd", "plan", "PB", "pp", "tk", "tp", "tc", "mp"], "fmt": ["Fformat", "Ftm", "sfformat", "ofmt", "fformat", "sftm", "bfmt", "ftm", " fFormat", " fformat", " ftm", "bfformat", "sflt", "flt", "fFormat", "ofMT", "ofFormat", "Fmt", "offormat", " fMT", "Flt", "fMT", "sfmt", " flt", "bfFormat", "bfMT"], "filename": ["existent", "uri", "buff", "jpg", "bn", "prefix", "src", "metadata", "bol", "whatever", "binary", "file", "files", "buffer", "path", "bh", "wav", "ename", "ame", "location", "seek", "fp", "fle", "username", "held", "sufficient", "fil", "nil", "nm", "gettable", "txt", "whether", "exist", "sbm", "fn", "Filename", "tmp", "aka", "f", "println", "family", "subject", "directory", "length", "json", "a", "text", "name", "source"], "logctx": ["evalmsg", "loghandle", "evalconfig", "lnhandle", "lnctx", "evalctx", "Logmsg", "Loghandle", "logconfig", "logmsg", "evalhandle", "Logconfig", "lnmsg", "Logctx", "lnconfig"], "offset": ["output", "original", "initialized", "error", "et", "padding", "rot", "prefix", "window", "end", "shift", "pad", "set", "i", "buffer", "skip", "annot", "ext", "base", "addr", "esi", "order", "location", "seek", "len", "OFF", "unc", "url", "score", "pointer", "index", "o", "bound", "fp", "range", "row", "position", "slice", "ref", "attribute", "to", "unk", "attr", "align", "start", "timeout", "sector", "handle", "slot", "reset", "offs", "scroll", "off", "tmp", "ptr", "batch", "item", "axis", "cache", "address", "count", "size", "Offset", "length", "origin", "name"], "max_probe_size": ["max_prochange_max", "max_prochange67max", "max_prochange67size", "max_probe_SIZE", "max_prose_type", "max_prochange67SIZE", "max_probe_info", "max_prose_count", "max_prove_Size", "max_probe_Size", "max_probe2size", "max_probe1type", "max_probe67info", "max_probeptSize", "max_prose_time", "max_prove_count", "max_probe_time", "max_prose_SIZE", "max_probe1SIZE", "max_probeptSIZE", "max_probe_name", "max_prose_set", "max_proce_size", "max_probe2max", "max_probe67SIZE", "max_proce_Size", "max_probe_type", "max_probe67max", "max_prochange_size", "max_probe1size", "max_probe_max", "max_proce_max", "max_prose_size", "max_proce_len", "max_probe2len", "max_prose_Size", "max_probeptsize", "max_proce_SIZE", "max_prove_SIZE", "max_prochange67info", "max_prochange_info", "max_prose_data", "max_prove_name", "max_probeptenv", "max_probe_len", "max_probe67size", "max_probe_env", "max_prove_env", "max_probe_set", "max_prochange_SIZE", "max_prove_size", "max_prose_len", "max_probe_data", "max_probe_count"], "buf": ["bag", "bytes", "uf", "gc", "bed", "cb", "queue", "bu", "iter", "txt", "foo", "fb", "tmp", "batch", "cat", "aka", "cur", "dest", "loc", "buff", "next", "mem", "cam", "bh", "norm", "wb", "rb", "port", "pool", "desc", "priv", "xff", "vec", "db", "cf", "ctx", "bg", "bc", "Buffer", "msg", "seq", "prop", "var", "bar", "pkg", "Buff", "attr", "rab", "orig", "alloc", "cv", "abb", "b", "bn", "ff", "window", "cp", "br", "cmp", "box", "buffer", "cmd", "bp", "data", "temp", "err", "ref", "proc", "bf", "cap", "block", "ptr", "img", "gz", "doc", "cache", "obj"], "probe_size": ["prose_count", "probe___Size", "probe_type", "prozo_min", "proce_code", "probe67news", "probe_color", "probable_since", "proutelenmessage", "probe2count", "probe_shift", "proble_size", "proze_max", "procho_type", "probe7global", "procho_length", "probe67max", "probeablestorage", "probe_offset", "probelencolor", "probelenstorage", "probe_scale", "probe67size", "proutelensize", "probable___length", "proutelencolor", "probe___since", "proze_size", "prozo67news", "probe_code", "proute_storage", "probe7since", "proce_name", "prozo_SIZE", "prose_offset", "probe7name", "proute_size", "probe1Size", "probable_Size", "probable___since", "probe1size", "probe_len", "probable_size", "probe___size", "probe1length", "proze_shift", "procho_offset", "prozo_size", "prozo67size", "probe_SIZE", "probe_length", "proute_color", "probe67SIZE", "proce_len", "prose_size", "probelensize", "procho_size", "prose_time", "prozo67SIZE", "probe_message", "probe_name", "probable___size", "prober_length", "probe67scale", "proce_Size", "probe2length", "probe67length", "probeablecolor", "proble_SIZE", "probable___Size", "prose_member", "probe_member", "probe67min", "proble_div", "proce_length", "proute_message", "probe1since", "probe_max", "probe_min", "probe_div", "probelenmessage", "probe_count", "proble_scale", "probe2size", "probe67code", "proce_size", "probe_time", "probable_length", "probe2offset", "probe2type", "probe67shift", "probe_storage", "proutelenstorage", "prober_size", "proce_since", "prober_time", "probe_since", "probe_Size", "proce_global", "probe2SIZE", "probeablesize", "probe_global", "probeablemessage", "probe_news", "prozo_news", "probe2time", "probe67div", "probe___length", "prose_SIZE", "prose_Size", "probe7size", "prozo67min"], "buftmp": ["bufetr", "buxttmp", "buxtr", " buctpp", " buctcp", " buftpp", " buftr", "buxtmb", "buffmp", "buftyp", "buxtrap", "buctmp", "bufftmp", " buktemp", "bucttmp", " buftrap", "boktcp", "buftmb", "buctcp", "buffcp", "buctmb", "bufpp", " bukttmp", "buktr", " buftemp", "buxtemp", "buktyp", "buftcp", " buctmp", " buctmb", " buftmb", "bubtpp", "boktmp", "bubtcp", "buktcp", " buctrap", "bubtmp", "bufetemp", " buktr", " bucttmp", "buktmp", "boftmp", "bufortcp", "buftpp", " buftcp", "buctrap", "bufettmp", "buftr", "bufortmp", "bufmp", "boftcp", "bofttmp", "bubtmb", "bufortyp", "bukttmp", "boktyp", "buffmb", "bufmb", "buctpp", "bufetmp", "bufcp", "boftyp", "bufttmp", "buffrap", "buftrap", "buktemp", "buffyp", "buftemp", " buktmp", " bufttmp", "buxtmp", "buforttmp", "bokttmp"]}}
{"project": "qemu", "commit_id": "0752706de257b38763006ff5bb6b39a97e669ba2", "target": 1, "func": "static void slirp_smb(SlirpState* s, Monitor *mon, const char *exported_dir,\n\n                      struct in_addr vserver_addr)\n\n{\n\n    static int instance;\n\n    char smb_conf[128];\n\n    char smb_cmdline[128];\n\n    FILE *f;\n\n\n\n    snprintf(s->smb_dir, sizeof(s->smb_dir), \"/tmp/qemu-smb.%ld-%d\",\n\n             (long)getpid(), instance++);\n\n    if (mkdir(s->smb_dir, 0700) < 0) {\n\n        config_error(mon, \"could not create samba server dir '%s'\\n\",\n\n                     s->smb_dir);\n\n        return;\n\n    }\n\n    snprintf(smb_conf, sizeof(smb_conf), \"%s/%s\", s->smb_dir, \"smb.conf\");\n\n\n\n    f = fopen(smb_conf, \"w\");\n\n    if (!f) {\n\n        slirp_smb_cleanup(s);\n\n        config_error(mon, \"could not create samba server \"\n\n                     \"configuration file '%s'\\n\", smb_conf);\n\n        return;\n\n    }\n\n    fprintf(f,\n\n            \"[global]\\n\"\n\n            \"private dir=%s\\n\"\n\n            \"smb ports=0\\n\"\n\n            \"socket address=127.0.0.1\\n\"\n\n            \"pid directory=%s\\n\"\n\n            \"lock directory=%s\\n\"\n\n            \"log file=%s/log.smbd\\n\"\n\n            \"smb passwd file=%s/smbpasswd\\n\"\n\n            \"security = share\\n\"\n\n            \"[qemu]\\n\"\n\n            \"path=%s\\n\"\n\n            \"read only=no\\n\"\n\n            \"guest ok=yes\\n\",\n\n            s->smb_dir,\n\n            s->smb_dir,\n\n            s->smb_dir,\n\n            s->smb_dir,\n\n            s->smb_dir,\n\n            exported_dir\n\n            );\n\n    fclose(f);\n\n\n\n    snprintf(smb_cmdline, sizeof(smb_cmdline), \"%s -s %s\",\n\n             SMBD_COMMAND, smb_conf);\n\n\n\n    if (slirp_add_exec(s->slirp, 0, smb_cmdline, &vserver_addr, 139) < 0) {\n\n        slirp_smb_cleanup(s);\n\n        config_error(mon, \"conflicting/invalid smbserver address\\n\");\n\n    }\n\n}\n", "idx": 5361, "substitutes": {"s": ["sw", "less", "c", "h", "state", "self", "ps", "t", "se", "js", "sb", "ss", "south", "j", "params", "source", "as", "rs", "service", "so", "ses", "sam", "store", "g", "es", "an", "v", "stats", "m", "sa", "sis", "aws", "a", " S", "l", "gs", "ns", "ats", "comm", "p", "is", "r", "sv", "sm", "st", "hs", "sub", "bs", "al", "y", "sq", "fs", "S", "sp", "b", "set", "qs", "als", "details", "n", "ds", "sync", "ls", "ties", "sym", "iss", "ims", "sl", "status", "spec", "ex", "sts", "sing"], "mon": ["mate", "MON", "dom", "colm", "mill", "mn", "um", " m", "monkey", "mun", "ox", "met", "den", "mat", "con", "ann", "mi", " mu", "mut", "mt", "mint", "on", "meter", "monitor", "mont", "san", "mer", "mu", "an", " Mon", "dm", "umi", "von", "num", "pai", "man", "m", "mitter", "Mon", "demon", "mm", "son", "tom", "non", "mons", "mx"], "exported_dir": ["exported_DIR", "exported_directory", "exlated_dir", "exports_path", "exported_path", "exported_doc", "exlated_doc", "exports_block", "exlated_DIR", "exports_directory", "exports_dir", "exported_block", "exlated_path"], "vserver_addr": ["vServer_add", "vServer_host", "vserver_add", "vServer_addr", " verver_addr", " verver_add", " vserver__addr", " verver_address", "vserver_host", " vserver_add", " vserver_address", " vserver__address", " vserver__add"], "instance": ["INST", "counter", "power", "node", "ton", " inst", "osi", "ami", "Instance", "inst", "order", "seed", "index", "upload", "pe", "record", "unit", "id", "master", "usage", "once", "ances", " instances", "component", "ance", "nce", "entry", "owner", "parent", "member", "alias", "count", "test", "anti", "performance", "create", "ANCE", "name", "image"], "smb_conf": ["smb__conf", "sdb_cmd", "sdb_cfg", "sdb_def", "smt_con", "smt_conv", "sdb_dir", "smb__def", "smb_cfg", "smb_conv", "smt_config", "sdb_config", "smm_conf", "smm_config", "smb__con", "smb_config", "smm_cfg", "smm_con", "smb_dir", "smb__dir", "sdb_conf", "smb__config", "smb_def", "smt_conf", "smb_con", "sdb_con", "smb__cmd", "smb_cmd"], "smb_cmdline": ["smb_ctrine", "smb__cmdline", "smb_cmdl", "smb_mdline", "smb_commandLine", "smb_Cmdl", "smb_commandeline", "smb_mdl", "smb_cmdLine", "smb_ctrLine", "smb_cmdine", "smb_ctrline", "smb_CmdLine", "smb_commandline", "smb__mdline", "smb_Cmdline", "smb__mdl", "smb_commandl", "smb__cmdLine", "smb__cmdl", "smb_ctrl", "smb_commandine", "smb_cmdeline", "smb_mdeline", "smb_ctreline", "smb__mdLine", "smb_mdLine"], "f": ["cf", "open", "raf", "uf", "b", "xf", "fm", "ff", "ln", "af", "c", "u", "h", "fe", "i", "lf", "file", "fc", "p", "d", "ent", "F", "o", "fp", "t", "r", "w", "rf", "k", "bf", "v", "fac", "ef", "df", "m", "fa", "fn", "fb", "tf", "y", "sf", "fi", "fs", "fo", "l", "e", "fr", "z", "j", "fd"]}}
{"project": "qemu", "commit_id": "bf298f83c35da854632c5be75733a4aa95a780bf", "target": 0, "func": "void tlb_set_page(CPUState *env, target_ulong vaddr,\n\n                  target_phys_addr_t paddr, int prot,\n\n                  int mmu_idx, target_ulong size)\n\n{\n\n    PhysPageDesc *p;\n\n    unsigned long pd;\n\n    unsigned int index;\n\n    target_ulong address;\n\n    target_ulong code_address;\n\n    unsigned long addend;\n\n    CPUTLBEntry *te;\n\n    CPUWatchpoint *wp;\n\n    target_phys_addr_t iotlb;\n\n\n\n    assert(size >= TARGET_PAGE_SIZE);\n\n    if (size != TARGET_PAGE_SIZE) {\n\n        tlb_add_large_page(env, vaddr, size);\n\n    }\n\n    p = phys_page_find(paddr >> TARGET_PAGE_BITS);\n\n    if (!p) {\n\n        pd = IO_MEM_UNASSIGNED;\n\n    } else {\n\n        pd = p->phys_offset;\n\n    }\n\n#if defined(DEBUG_TLB)\n\n    printf(\"tlb_set_page: vaddr=\" TARGET_FMT_lx \" paddr=0x%08x prot=%x idx=%d smmu=%d pd=0x%08lx\\n\",\n\n           vaddr, (int)paddr, prot, mmu_idx, is_softmmu, pd);\n\n#endif\n\n\n\n    address = vaddr;\n\n    if ((pd & ~TARGET_PAGE_MASK) > IO_MEM_ROM && !(pd & IO_MEM_ROMD)) {\n\n        /* IO memory case (romd handled later) */\n\n        address |= TLB_MMIO;\n\n    }\n\n    addend = (unsigned long)qemu_get_ram_ptr(pd & TARGET_PAGE_MASK);\n\n    if ((pd & ~TARGET_PAGE_MASK) <= IO_MEM_ROM) {\n\n        /* Normal RAM.  */\n\n        iotlb = pd & TARGET_PAGE_MASK;\n\n        if ((pd & ~TARGET_PAGE_MASK) == IO_MEM_RAM)\n\n            iotlb |= IO_MEM_NOTDIRTY;\n\n        else\n\n            iotlb |= IO_MEM_ROM;\n\n    } else {\n\n        /* IO handlers are currently passed a physical address.\n\n           It would be nice to pass an offset from the base address\n\n           of that region.  This would avoid having to special case RAM,\n\n           and avoid full address decoding in every device.\n\n           We can't use the high bits of pd for this because\n\n           IO_MEM_ROMD uses these as a ram address.  */\n\n        iotlb = (pd & ~TARGET_PAGE_MASK);\n\n        if (p) {\n\n            iotlb += p->region_offset;\n\n        } else {\n\n            iotlb += paddr;\n\n        }\n\n    }\n\n\n\n    code_address = address;\n\n    /* Make accesses to pages with watchpoints go via the\n\n       watchpoint trap routines.  */\n\n    QTAILQ_FOREACH(wp, &env->watchpoints, entry) {\n\n        if (vaddr == (wp->vaddr & TARGET_PAGE_MASK)) {\n\n            iotlb = io_mem_watch + paddr;\n\n            /* TODO: The memory case can be optimized by not trapping\n\n               reads of pages with a write breakpoint.  */\n\n            address |= TLB_MMIO;\n\n        }\n\n    }\n\n\n\n    index = (vaddr >> TARGET_PAGE_BITS) & (CPU_TLB_SIZE - 1);\n\n    env->iotlb[mmu_idx][index] = iotlb - vaddr;\n\n    te = &env->tlb_table[mmu_idx][index];\n\n    te->addend = addend - vaddr;\n\n    if (prot & PAGE_READ) {\n\n        te->addr_read = address;\n\n    } else {\n\n        te->addr_read = -1;\n\n    }\n\n\n\n    if (prot & PAGE_EXEC) {\n\n        te->addr_code = code_address;\n\n    } else {\n\n        te->addr_code = -1;\n\n    }\n\n    if (prot & PAGE_WRITE) {\n\n        if ((pd & ~TARGET_PAGE_MASK) == IO_MEM_ROM ||\n\n            (pd & IO_MEM_ROMD)) {\n\n            /* Write access calls the I/O callback.  */\n\n            te->addr_write = address | TLB_MMIO;\n\n        } else if ((pd & ~TARGET_PAGE_MASK) == IO_MEM_RAM &&\n\n                   !cpu_physical_memory_is_dirty(pd)) {\n\n            te->addr_write = address | TLB_NOTDIRTY;\n\n        } else {\n\n            te->addr_write = address;\n\n        }\n\n    } else {\n\n        te->addr_write = -1;\n\n    }\n\n}\n", "idx": 5381, "substitutes": {"env": ["policy", "ev", "ei", "esc", "node", "window", "conf", "ctx", "h", "here", "site", "conn", "state", "ve", "er", "erd", "map", "connection", "dev", "ec", "vp", "viron", "context", "eng", "environment", "enter", "hw", "network", "server", "pe", "w", "Environment", "sv", "ue", "en", "v", "ah", "nv", "ef", "config", "worker", "vs", "cv", "vt", "obj", "vm", "e", "shell"], "vaddr": ["pattr", "vmaddress", "vpptr", "vmaddr", "phost", "ppad", "vpad", "ploc", "vphost", "vploc", "vhost", "vpaddr", "vmloc", "xaddress", "pdomain", "vpaddress", " vpkg", "haddress", "vpkg", "vaddress", "maddress", "vloc", "xadr", " vdomain", "padd", "cvadr", "ppkg", "padr", " vhost", "vpadd", "cvpad", "vpattr", "vdomain", "mpad", "vadr", "fptr", "faddr", " vptr", " vaddress", "hptr", "cvaddr", "vattr", "pptr", "fdr", "xdomain", "haddr", "cvaddress", " vadr", " vdr", "vmattr", "paddress", "xaddr", "maddr", "vptr", " vadd", "faddress", "hdr", "vppkg", "madr", "vdr", "vadd"], "paddr": ["ppobj", " padd", "cpaddress", "ppaddr", "pref", "vurl", "tpaddress", "tpurl", "tpaddr", "cpadr", "vobj", "vaddress", " pref", "pcaddr", "maddress", "vref", "phash", "padd", "ppadd", "purl", "padr", " pobj", " padr", "pcaddress", "pcurl", "vadr", " pptr", "pchash", "pptr", "ppptr", "pobj", " paddress", "tphash", "paddress", "mref", "maddr", "cpaddr", "vptr", "cpref", "vhash", "madr", "vadd"], "prot": ["policy", "rot", "conf", "bot", "type", " protocols", "phy", "pro", "kind", "ip", "pat", "sy", "typ", "platform", "tif", " protocol", "ocol", " proto", "top", " PROT", "Prot", "password", "style", "bf", "org", "tz", "ef", "port", "rin", "period", "version", "tf", "eth", "prototype", "net", "format", "inet", "icon", "def"], "mmu_idx": ["mmu_indy", "mmu_indxs", "mmu_Idxc", "mmu_db", "mmu_Idxs", "mmu_indx", "mmu_idxc", "mmu_indxc", "mmu_Idx", "mmu_indb", "mmu_dxs", "mmu_idy", "mmu_dy", "mmu_idxs", "mmu_dx", "mmu_Idy", "mmu_idb"], "size": ["large", "bytes", "sp", "sw", "empty", "SIZE", "mem", " sizes", "fee", "sha", "Size", "set", "page", "buffer", "si", "zone", "g", "body", "len", "network", " Size", "data", "total", "sent", "scale", "pos", "space", "sv", "style", "send", "max", "num", "sh", "small", "city", "sn", "storage", "area", "cache", "count", "capacity", "message", "too", "shape", "sum", "ize", "iz", "e", "length", "z", "news", "name", "speed"], "p": ["ph", "post", "pid", "par", "sp", "cp", "ping", "pb", "c", "pc", "rep", "pt", "page", "ip", "ps", "pa", "d", "pat", "bp", "g", "vp", "n", "php", "pl", "perm", "fp", "t", "pi", "pers", "pe", "pm", "pre", "pg", "pkg", "proc", "ap", "pr", "lp", "v", "m", "parse", "jp", "np", "dp", "pp", "P", "j", "tp", "l", "mp"], "pd": ["ecd", "pid", "dc", "dds", "ctl", "xd", "dat", "cp", "po", "ped", "pb", "ping", "md", "pc", "pps", "pad", "pt", "ppa", "density", "px", "d", "pa", "dt", "pat", "addr", "ps", "bd", "dl", "sd", "ds", "php", "std", "pl", "ppo", "pi", "pe", "dh", "edd", "pm", "pos", "pg", "pkg", "py", "isd", "password", "PD", "lp", "planes", "dim", "pdf", "pard", "dd", "dq", "dn", "ptr", "cd", "disk", "np", "dp", "pn", "hid", "hd", "pp", "td", "ld", "wd", "tp", "fd", "da"], "index": ["sp", "ity", "ctx", "offset", "i", "page", "primary", "ip", "base", "si", "link", "ind", "context", "id", "pos", "code", "port", "Index", "axis", "alias", "count", "info", "hash", "interface", "pin", "inc", "loc"], "address": ["policy", "error", "region", "node", "cp", "end", "offset", "page", "description", "buffer", "path", "ip", "map", "table", "addr", "order", "location", "enter", "network", "pointer", "number", "position", "resource", "attribute", "distance", "device", "password", "start", "code", "memory", "Address", "dd", "port", "command", "array", "block", "comment", "action", "entry", "ptr", "area", "alias", "cache", "message", "shape", "email", "point", "directory", "length", "interface", "adr", "x", "a", "reference", "image", "condition"], "code_address": ["code_location", "codeaddroffset", "page_index", "codeaddraddress", "page_address", "page_addr", "codeaddrindex", "code_offset", "page_order", "code_order", "code_index", "page_location", "page_offset", "code_addr", "codeaddraddr"], "addend": [" adduntil", " addbegin", " addender", "Addender", "addEnd", "adduntil", "endend", " Adduntil", "addender", "addbegin", "Addbegin", " Addend", "endender", " addEnd", "Addend", "endEnd", "endbegin", " AddEnd", "Adduntil", "AddEnd"], "te": ["ta", "TE", "ie", "tm", "ge", "ke", "tr", "ce", "se", "t", "pe", "tw", "ue", "txt", "be", "ote", "ket", "rt", "tx", "de", "ste", "oe", "ace", "tle", "ne", "ape", "tc", "ffe"], "wp": ["ph", "dc", "sp", "cp", "pb", "pc", "ctx", "wx", "pt", "ht", "ip", "WP", "bp", "vp", "wr", "ww", "ep", "fp", "hw", "rw", "iw", "wt", "wk", "wu", "w", "pkg", "wordpress", "pg", "kw", "lp", "dq", "wo", "tx", "yp", "jp", "np", "dp", "tk", "wd", "tp", "mp"], "iotlb": ["ietlab", "ioticzb", "skylab", "natlb", "natlab", "ootlam", "ioticlp", "ioplas", "iolbs", "irislab", "ioplab", "otlb", "riotlp", "hotlp", "iotlas", "dotlp", "dotlab", "iotlab", "motlp", "potlas", "otzb", "natlp", "ioticlas", "iolab", "iotzb", "oidLB", "ietlb", "ietlas", "riotLB", "ootbl", "ioplp", "iotlam", "otlp", "iolp", "iolb", "ietlbs", "ietLB", "motlb", "potlab", "ioplb", "dotlb", "skybl", "ioplbs", "ietlp", "ootlb", "otlas", "potlp", "otlab", "skylam", "irislb", "potlb", "potlbs", "ootlab", "iotlp", "iotlbs", "riotlbs", "oidlbs", "motlab", "dotzb", "riotlb", "hotlas", "otlbs", "irislam", "oidlp", "iotbl", "ioticlb", "natzb", "iotLB", "irisbl", "oidlb", "ietzb", "skylb", "hotlab", "motzb", "hotlb"]}}
{"project": "qemu", "commit_id": "b3a2319792ad5c0f0f8c3d2f4d02b95fd7efbc69", "target": 0, "func": "void *slavio_intctl_init(target_phys_addr_t addr, target_phys_addr_t addrg,\n\n                         const uint32_t *intbit_to_level,\n\n                         qemu_irq **irq, qemu_irq **cpu_irq,\n\n                         unsigned int cputimer)\n\n\n\n{\n\n    int slavio_intctl_io_memory, slavio_intctlm_io_memory, i;\n\n    SLAVIO_INTCTLState *s;\n\n\n\n    s = qemu_mallocz(sizeof(SLAVIO_INTCTLState));\n\n    if (!s)\n\n        return NULL;\n\n\n\n    s->intbit_to_level = intbit_to_level;\n\n    for (i = 0; i < MAX_CPUS; i++) {\n\n\tslavio_intctl_io_memory = cpu_register_io_memory(0, slavio_intctl_mem_read, slavio_intctl_mem_write, s);\n\n\tcpu_register_physical_memory(addr + i * TARGET_PAGE_SIZE, INTCTL_SIZE,\n\n                                     slavio_intctl_io_memory);\n\n    }\n\n\n\n    slavio_intctlm_io_memory = cpu_register_io_memory(0, slavio_intctlm_mem_read, slavio_intctlm_mem_write, s);\n\n    cpu_register_physical_memory(addrg, INTCTLM_SIZE, slavio_intctlm_io_memory);\n\n\n\n    register_savevm(\"slavio_intctl\", addr, 1, slavio_intctl_save, slavio_intctl_load, s);\n\n    qemu_register_reset(slavio_intctl_reset, s);\n\n    *irq = qemu_allocate_irqs(slavio_set_irq, s, 32);\n\n\n\n    *cpu_irq = qemu_allocate_irqs(slavio_set_timer_irq_cpu, s, MAX_CPUS);\n\n    s->cputimer_bit = 1 << s->intbit_to_level[cputimer];\n\n    slavio_intctl_reset(s);\n\n    return s;\n\n}\n", "idx": 5386, "substitutes": {"addr": ["db", "prefix", "ar", "pad", "offset", "at", "ip", "p", "cmd", "add", "mt", "g", "oad", "arp", "on", "hw", "r", "dh", "dr", "rc", "ref", "id", "to", "pkg", "mac", "gate", "ad", "host", "v", "ix", "Address", "rt", "ash", "m", "a", "ac", "now", "off", "tx", "ptr", "grid", "address", "ord", "ag", "eth", "arg", "in", "adr", "ace", "res", "work", "oa", "x", "name", "act"], "addrg": ["addrgm", " addrG", "addg", "dirj", "prefixg", "prefixG", " addrj", " addrgm", "addressg", "dirg", "prefixj", "addrn", "prefixn", "addG", "addmg", "addressG", "addrG", "addressmg", " addrmg", "addrmg", "dirn", "addressgm", "addrj", "addgm", "dirG", " addrn"], "intbit_to_level": ["intbit_TO_levels", "intbit_from_bit", "intbit_to_state", "intbit_TO_mask", "intbit_TO_level", "intbit_from_vel", "intbit_from_level", "intbit_to_bit", "intbit_TO_state", "intbit_to_mask", "intbit_to_field", "intbit_from_Level", "intbit_to_vel", "intbit_to_Level", "intbit_to_levels"], "irq": ["irql", "iru", "interq", " irql", "ierql", "pirql", " irqq", "irqq", "ierdq", " iru", "pirqq", "ierqq", "irdq", "pirq", "piru", "irque", "pirque", "pirdq", " irdq", " irque", "ierq", "interque", "interu", "interql"], "cpu_irq": ["cpu__virq", "cpu_virque", "cpu_ierqa", "cpu__irq", "cpu_irg", "cpu_nirque", "cpu__irquire", "cpu__virquire", "cpu_ironq", "cpu_mirQ", "cpu_ironQ", "cpu_irquire", "cpu_nirq", "cpu_irqa", "cpu__virque", "cpu_nirqa", "cpu_virquire", "cpu_irque", "cpu_nirquire", "cpu_mirg", "cpu__irqa", "cpu_iterg", "cpu_mirque", "cpu_ironque", "cpu_ierque", "cpu_mirq", "cpu_ierquire", "cpu_virqa", "cpu__virqa", "cpu__irque", "cpu_irQ", "cpu_virq", "cpu_irong", "cpu_iterQ", "cpu_ierq", "cpu_iterque", "cpu_iterq"], "cputimer": ["cpetim", "cpetimer", "cpter", "dcpentim", "cputtimer", "cpentime", " cpettimer", "cutime", "ccutim", " cputrim", " cputim", "cputer", "ccutimer", "dcpentime", "cputime", "cputrim", "cutim", "ccuttimer", "ccutrim", "cputim", "cptime", "cutimer", "dcpentimer", "cpenter", " cpetim", "cpentim", "cptim", "dcputer", "cptrim", "cpttimer", "dcpenter", "dcputim", "cpentimer", " cpetrim", " cputtimer", "cpettimer", "cuter", "cptimer", " cpetimer", "cpetrim", "dcputime", "dcputimer"], "slavio_intctl_io_memory": ["slavio_intctl_io_mem", "slavio_intctl_io_position", "slavio_intctl_io2buffer", "slavio_intctl_i_message", "slavio_intctl_io2message", "slavio_intctl_net_mem", "slavio_intctl_i_address", "slavio_intctl_io_buffer", "slavio_intctl_io_network", "slavio_intctl_io2network", "slavio_intctl_io_address", "slavio_intctl_i_mem", "slavio_intctl_net_buffer", "slavio_intctl_net_memory", "slavio_intctl_i_memory", "slavio_intctl_io2memory", "slavio_intctl_i_position", "slavio_intctl_io2mem", "slavio_intctl_net_network", "slavio_intctl_io_message", "slavio_intctl_io2address"], "slavio_intctlm_io_memory": ["slavio_intctlm_io_message", "slavio_intctlm_co_address", "slavio_intctlm_co2memory", "slavio_intctlm_io2address", "slavio_intctlm_io2memory", "slavio_intctlm_i_media", "slavio_intctlm_io2message", "slavio_intctlm_co_message", "slavio_intctlm_i_mem", "slavio_intctlm_i_memory", "slavio_intctlm_i_address", "slavio_intctlm_co_memory", "slavio_intctlm_io_media", "slavio_intctlm_i_storage", "slavio_intctlm_io_storage", "slavio_intctlm_io2storage", "slavio_intctlm_io_mem", "slavio_intctlm_co_storage", "slavio_intctlm_co2storage", "slavio_intctlm_co2message", "slavio_intctlm_io_address", "slavio_intctlm_co2address"], "i": ["ini", "ij", "ei", "ci", "b", "it", "im", "u", "cli", "oi", "gi", "mi", "qi", "ip", "li", "p", "si", "zi", "n", "xi", "ind", "index", "t", "ri", "pi", "multi", "bi", "me", "id", "ui", "ki", "k", "phi", "ti", "v", "ix", "ai", "m", "I", "y", "print", "sql", "sim", "ex", "iu", "in", "j", "x", "di", "ii", "l"], "s": ["sw", "less", "conf", "c", "h", "state", "ps", "ts", "t", "se", "js", "w", "sb", "ss", "socket", "ares", "changes", "j", "params", "source", "rs", "ants", "os", "er", "g", "ms", "tests", "es", "v", "stats", "m", "aws", "a", "l", "gs", "ar", "ns", "ats", "cs", "comm", "p", "is", "r", "sv", "hs", "bs", "y", "sq", "session", "fs", "S", "single", "sp", "b", "its", "sys", "set", "details", "n", "ds", "ins", "space", "ls", "ims", "sl", "spec", "f", "e", "sts", "z"]}}
{"project": "qemu", "commit_id": "1e5ffbedded7ded797f5042d82b70109a712b4c0", "target": 1, "func": "void helper_frndint(void)\n\n{\n\n    ST0 = rint(ST0);\n\n}\n", "idx": 5408, "substitutes": {}}
{"project": "FFmpeg", "commit_id": "fc5a905a6d0c76d9fb8d838ac83f6219a7a5e20f", "target": 0, "func": "static void start_children(FFStream *feed)\n\n{\n\n    if (no_launch)\n\n        return;\n\n\n\n    for (; feed; feed = feed->next) {\n\n        if (feed->child_argv && !feed->pid) {\n\n            feed->pid_start = time(0);\n\n\n\n            feed->pid = fork();\n\n\n\n            if (feed->pid < 0) {\n\n                http_log(\"Unable to create children\\n\");\n\n                exit(1);\n\n            }\n\n            if (!feed->pid) {\n\n                /* In child */\n\n                char pathname[1024];\n\n                char *slash;\n\n                int i;\n\n\n\n                av_strlcpy(pathname, my_program_name, sizeof(pathname));\n\n\n\n                slash = strrchr(pathname, '/');\n\n                if (!slash)\n\n                    slash = pathname;\n\n                else\n\n                    slash++;\n\n                strcpy(slash, \"ffmpeg\");\n\n\n\n                http_log(\"Launch command line: \");\n\n                http_log(\"%s \", pathname);\n\n                for (i = 1; feed->child_argv[i] && feed->child_argv[i][0]; i++)\n\n                    http_log(\"%s \", feed->child_argv[i]);\n\n                http_log(\"\\n\");\n\n\n\n                for (i = 3; i < 256; i++)\n\n                    close(i);\n\n\n\n                if (!ffserver_debug) {\n\n                    i = open(\"/dev/null\", O_RDWR);\n\n                    if (i != -1) {\n\n                        dup2(i, 0);\n\n                        dup2(i, 1);\n\n                        dup2(i, 2);\n\n                        close(i);\n\n                    }\n\n                }\n\n\n\n                /* This is needed to make relative pathnames work */\n\n                chdir(my_program_dir);\n\n\n\n                signal(SIGPIPE, SIG_DFL);\n\n\n\n                execvp(pathname, feed->child_argv);\n\n\n\n                _exit(1);\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 5416, "substitutes": {"feed": ["wait", "pull", "valid", "flow", "add", "link", "hub", "queue", "lo", "connect", "iter", "acc", "entry", "batch", "socket", "loop", "test", "connected", "post", "oooo", "read", "join", "page", "hook", "good", "op", "context", "follow", "rss", "push", "send", "frame", "stream", "config", "load", "report", "jack", "parse", "pass", "supp", "check", "write", "hold", "json", "cf", "update", "accept", "channel", "fe", "mail", "import", "build", "fail", "fs", "feeding", "form", "hyd", "af", "flight", "set", "Feed", "escape", "pop", "food", "row", "data", "full", "each", "alert", "handle", "df", "tab", "poll", "handler", "f", "gen", "atom", "format", "def"], "pathname": ["athsize", " pathsize", "portno", "filename", "portName", "pathnum", "programName", "pathno", "athstart", "Pathnum", "Pathname", "portfile", "Pathkey", "pathnode", "pathstring", "athtree", " pathnode", "athfile", " pathtree", "Pathnode", "athno", "patternnode", "programname", "athname", "patternstring", "Pathtree", "patternName", "filetree", "Pathstart", "pathsize", "ath0", "Pathsize", "pathName", "pathstart", "Path0", "Pathno", "pathkey", " pathstart", "portname", " pathstring", "pathtree", "filenum", "path0", "programkey", " pathno", " pathkey", "programtree", "patternname", " path0", "athName", "PathName", "fileName", "pathfile", "Pathstring", "Pathfile", "athnum", " pathName"], "slash": ["SLsl", "strug", " slush", "stray", "slush", "slsl", "flash", "sashed", "slug", "SLay", "slhash", "strash", "strashed", "slashing", "flashing", "lashing", "lash", "sashing", " sllash", "splashed", " slasher", "SLug", "lug", "slasher", "sslug", "splug", "sslay", " slug", "sllash", "strlash", "splashing", "SLashed", " slhash", "sslashed", "sash", "slay", "splush", "splash", "SLash", "lasher", "sslash", "lhash", "flasher", "flug", "splhash", "spllash", " slashed", "splasher", "lashed", " slsl", "sug", "SLush", "slashed", "splsl", "strasher"], "i": ["chain", "ei", " ii", "im", "c", "h", "gi", "d", "zi", "ind", "t", "hi", "pi", "I", "batch", "mc", "io", "in", "j", "di", "\u0438", "x", "ic", "q", "cgi", "mi", "g", "xi", "index", "bi", "go", "ki", "ti", "v", "ai", "m", "ia", "l", "ci", "it", "u", "ip", "li", "p", "is", "o", "mac", "k", "iy", "y", "fi", "ii", "init", "ini", "ij", "uri", "b", "cli", "oi", "qi", "si", "n", "multi", "me", "ui", "slice", "list", "id", "phi", "ims", "ix", "eu", "print", "sim", "gu", "iu", "e", "point", "z"]}}
{"project": "FFmpeg", "commit_id": "8adff79b6d30d1ae2cb9cf906e1d7fcd759cd638", "target": 1, "func": "static int mov_seek_fragment(AVFormatContext *s, AVStream *st, int64_t timestamp)\n\n{\n\n    MOVContext *mov = s->priv_data;\n\n    int i, j;\n\n\n\n    if (!mov->fragment_index_complete)\n\n        return 0;\n\n\n\n    for (i = 0; i < mov->fragment_index_count; i++) {\n\n        if (mov->fragment_index_data[i]->track_id == st->id) {\n\n            MOVFragmentIndex *index = index = mov->fragment_index_data[i];\n\n            for (j = index->item_count - 1; j >= 0; j--) {\n\n                if (index->items[j].time <= timestamp) {\n\n                    if (index->items[j].headers_read)\n\n                        return 0;\n\n\n\n                    return mov_switch_root(s, index->items[j].moof_offset);\n\n                }\n\n            }\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 5429, "substitutes": {"s": ["rs", "q", "gs", "sp", "b", "ns", "c", "ats", "qs", "set", "sys", "cs", "comm", "sc", "self", "os", "p", "g", "d", "n", "is", "ts", "ds", "t", "es", "r", "js", "w", "sv", "sb", "scl", "v", "stats", "m", "spec", "hs", "stream", "ss", "bs", "sq", "f", "fs", "us", "e", "S", "sts", "z", "x"], "st": ["so", "sp", "sw", "est", "stage", " ST", "ost", "nd", "pt", "sc", "nt", "inst", "std", "tr", "bt", "irst", "t", "stack", "ut", "stop", "str", "th", "ast", "rest", "start", "ss", "Stream", "stable", "ist", "ST", "us", "ste", "sts", "sta", "ust", "St", "tt"], "timestamp": [" timetime", "timance", " timance", "imance", "imetime", "tmestamp", "tmeline", "Timeness", "tmeness", "imestamp", "timeline", "timetime", "timeness", "Timeline", "tmetime", "temestamp", "Timance", "Timestamp", "temetime", "temeline", "temeness", "imeline", " timeline", "Timetime"], "mov": ["mOV", "tmud", "cove", " mood", "voval", "amove", "amud", "movi", "move", "cood", "amovi", "moodle", "cOV", " moodle", "vova", "smood", "mova", "moduleove", "tmovi", "amov", "cov", "tmove", "commov", "commoval", "mav", " mav", " move", "moduleood", "commove", "amOV", "smoodle", "lOV", " mOV", "moduleov", "tmav", " movi", "lov", "moval", "vove", "lood", "moduleoodle", "mutove", "tmOV", "vov", "commova", "smove", "tmov", "amav", "mutOV", "mutov", "love", "mood", "mutud", "mud", "smov"], "i": ["init", "ic", "ini", "ij", "q", "ci", "instance", " ii", "it", "im", "oi", "gi", "mi", "my", "qi", "at", "ip", "er", "li", "ami", "si", "ms", "zi", "ie", "is", "ski", "iq", "xi", "ind", "ri", "bi", "pi", "multi", "me", "id", "ui", "ki", "to", "span", " I", "phi", "ti", "ims", "iy", "ix", "ai", "m", "I", "batch", "y", "ish", "\u0438", "us", "sim", "io", "iu", "e", "in", "by", "x", "di", "ii"], "j": ["dj", "ja", "ev", "ij", "user", "q", "b", "bj", "jo", "it", "jj", "job", "note", "J", "br", "gov", "kid", "pt", "aj", "er", "p", "g", "n", "ind", "uj", "o", "bo", "key", "bi", "jc", "r", "js", "Ja", "el", "str", "ji", "pr", "k", "jet", "oj", "v", "req", "m", "adj", "bs", "jack", "y", "jump", "jp", "count", "f", "jit", "obj", "jl", "je", "kj", "z", "fr", "x", "json", "other", "l"], "index": ["all", "update", "open", "error", "root", "instance", "empty", "node", "type", "run", "h", "active", "page", "find", "ok", "valid", "online", "map", "table", "IND", "order", "archive", "link", "n", "group", "zero", "ind", "row", "data", "range", "available", "position", "connect", "initial", "pos", "list", "to", "ion", "level", "max", "out", "num", "iter", "author", "cache", "status", "config", "Index", "date", "rule", "fail", "address", "count", "f", "test", "size", "ex", "e", "engine", "point", "check", "search", "info", "connected", "x", "ne", "l", "image"]}}
{"project": "FFmpeg", "commit_id": "39bb30f6640fe1faf4bbc779a79786028febc95d", "target": 1, "func": "static int mxf_read_track(MXFTrack *track, ByteIOContext *pb, int tag)\n\n{\n\n    switch(tag) {\n\n    case 0x4801:\n\n        track->track_id = get_be32(pb);\n\n        break;\n\n    case 0x4804:\n\n        get_buffer(pb, track->track_number, 4);\n\n        break;\n\n    case 0x4B01:\n\n        track->edit_rate.den = get_be32(pb);\n\n        track->edit_rate.num = get_be32(pb);\n\n        break;\n\n    case 0x4803:\n\n        get_buffer(pb, track->sequence_ref, 16);\n\n        break;\n\n    }\n\n    return 0;\n\n}\n", "idx": 5430, "substitutes": {"track": ["package", "train", "form", "gc", "reflect", "task", "window", "met", "sys", "pt", "store", "find", "sort", "recent", "skip", "stat", "rank", "seek", "mt", "sync", "index", "tr", "row", "t", "follow", "trace", "rack", "record", "pkg", "tracking", "rr", "route", "send", "start", "tracks", "component", "claim", "stall", "transform", "req", "Track", "dd", "ack", "port", "rt", "project", "tab", "report", "mm", "batch", "tf", "kick", "trip", "rec", "check", "roll", "hold", "tp", "install"], "pb": ["stab", "uf", "buff", "gc", "b", "bj", "obb", "prefix", "gp", "cp", "wp", "asm", "pc", "pack", "bc", "sys", "pt", "buf", "client", "buffer", "px", "p", "pa", "bp", "orp", "vp", "typ", "pl", "wb", "fp", "lb", "pm", "bb", "ub", "pkg", "pg", "proc", "lp", "bps", "emb", "resp", "bs", "fb", "cv", "pool", "jp", "np", "dp", "amp", "obj", "xp", "vm", "PB", "pp", "tk", "tp", "mp"], "tag": ["TAG", "event", "match", "error", "feat", "prefix", "type", "pack", "field", "tar", "pad", "state", "riot", "label", "key", "peg", "bit", "word", "id", "Tag", "style", "level", "code", "gate", "commit", "tags", "oid", "feature", "reg", "comment", "date", "batch", "our", "bug", "cat", "count", "ag", "snap", "bad", "tail", "name", "flag"]}}
{"project": "FFmpeg", "commit_id": "e947b75b1c76ef6793209c2c445b8c224a28717a", "target": 1, "func": "int ff_wms_parse_sdp_a_line(AVFormatContext *s, const char *p)\n\n{\n\n    int ret = 0;\n\n    if (av_strstart(p, \"pgmpu:data:application/vnd.ms.wms-hdr.asfv1;base64,\", &p)) {\n\n        AVIOContext pb;\n\n        RTSPState *rt = s->priv_data;\n\n        AVDictionary *opts = NULL;\n\n        int len = strlen(p) * 6 / 8;\n\n        char *buf = av_mallocz(len);\n\n        AVInputFormat *iformat;\n\n\n\n        if (!buf)\n\n            return AVERROR(ENOMEM);\n\n        av_base64_decode(buf, p, len);\n\n\n\n        if (rtp_asf_fix_header(buf, len) < 0)\n\n            av_log(s, AV_LOG_ERROR,\n\n                   \"Failed to fix invalid RTSP-MS/ASF min_pktsize\\n\");\n\n        init_packetizer(&pb, buf, len);\n\n        if (rt->asf_ctx) {\n\n            avformat_close_input(&rt->asf_ctx);\n\n        }\n\n\n\n        if (!(iformat = av_find_input_format(\"asf\")))\n\n            return AVERROR_DEMUXER_NOT_FOUND;\n\n\n\n        rt->asf_ctx = avformat_alloc_context();\n\n        if (!rt->asf_ctx) {\n\n            av_free(buf);\n\n            return AVERROR(ENOMEM);\n\n        }\n\n        rt->asf_ctx->pb      = &pb;\n\n        av_dict_set(&opts, \"no_resync_search\", \"1\", 0);\n\n\n\n        if ((ret = ff_copy_whiteblacklists(rt->asf_ctx, s)) < 0) {\n\n            av_dict_free(&opts);\n\n            return ret;\n\n        }\n\n\n\n        ret = avformat_open_input(&rt->asf_ctx, \"\", iformat, &opts);\n\n        av_dict_free(&opts);\n\n        if (ret < 0) {\n\n            av_free(buf);\n\n            return ret;\n\n        }\n\n        av_dict_copy(&s->metadata, rt->asf_ctx->metadata, 0);\n\n        rt->asf_pb_pos = avio_tell(&pb);\n\n        av_free(buf);\n\n        rt->asf_ctx->pb = NULL;\n\n    }\n\n    return ret;\n\n}\n", "idx": 5437, "substitutes": {"s": ["rs", "gs", "ses", "b", "sg", "ns", "conf", "sr", "c", "its", "ats", "h", "aws", "sys", "set", "state", "cs", "sc", "qs", "os", "ps", "g", "n", "ts", "settings", "ds", "t", "es", "r", "w", "js", "sv", "ls", "sb", "xs", "v", "stats", "hs", "st", "vs", "ss", "bs", "sn", "serv", "sq", "socket", "f", "fs", "e", "S", "sts", "res", "a"], "p": ["q", "sp", "padding", "b", "wp", "cp", "ping", "c", "pc", "h", "pad", "pro", "i", "pt", "at", "ps", "pa", "g", "d", "n", "pat", "vp", "bp", "o", "fp", "t", "data", "r", "str", "pkg", "ap", "pr", "lp", "v", "m", "part", "jp", "np", "f", "pn", "pp", "P", "j", "a", "tp", "l"], "pb": ["db", "apa", "uf", "buff", "sp", "b", "bj", "wp", "cp", "pc", "ctx", " outp", "pan", " PB", " xp", "pt", "bh", "tg", "ps", "pa", "bp", "vp", "cb", "pl", "wb", " pl", "t", " resp", "fp", " proto", "ub", "ref", "pkg", "pg", "sb", "lp", "rb", "txt", " np", "tab", "bs", "nb", "tmp", "tx", "cv", "batch", "pas", "jp", "np", "pac", "dp", "PB", "pp", "td", "kb", "tk", "tp", "mp"], "rt": ["gt", "rs", "vr", "rot", "feat", "ct", "it", "att", "ctx", "nd", "pt", "nt", "rx", "ht", "rn", "at", "dt", "rect", "addr", "mt", "NT", "round", "cmd", "ts", "RT", "ind", "usr", "bt", "hw", "t", "wt", "rw", "r", "rc", "rev", "rr", "rh", "rb", "txt", "ot", "req", "rl", "ack", "lt", "rm", "reg", "art", "rin", "ret", "tx", "ptr", "vt", "rd", "apt", "ft", "qt", "rec", "hd", "net", "fr", "res", "irt", "tt", "act"], "opts": ["optmt", "ropTS", "optptions", " copms", "opTS", " opmt", " opters", " opments", "optms", "optt", "optts", "optters", " copments", " copths", "porTS", " opms", "iopcs", "iopts", "opms", "opcs", "ropments", "Opmt", "opmt", "optents", "optments", "Opts", "opths", "ropts", " copcs", "ports", "optTS", "opents", "optct", " copts", "optths", " opt", "opt", "opct", "iopths", " opct", "porments", "opptions", "operters", "operct", " copents", " opents", "operms", "opters", "optcs", "iopms", "opments", " opptions", "Opt", "Opptions", "operts"], "buf": ["bytes", "uf", "buff", "gc", "b", "mem", "cp", "br", "h", "pack", "bc", "box", "pad", "cam", "Buffer", "ob", "buffer", "msg", "raw", "seq", "bh", "cmd", "bp", "len", "vp", "cb", "data", "fp", "wb", "queue", "rw", "str", "ref", "vec", "pkg", "pg", "Buff", "proc", "rb", "bin", "v", "txt", "cap", "tx", "mb", "block", "bs", "tmp", "cv", "batch", "img", "ptr", " buffer", "bl", "gz", "doc", "fb", "conv", "arr", "text", "ctx", "xff"], "iformat": [" uniformsate", "instat", "instate", "ivariart", " uniformiat", " uniformAT", "iformate", "iefant", "initialate", "mindati", "mindat", "iefart", " uniformsat", " uniformet", " uniformset", "\u30a7ap", "iformati", "instiat", "iformart", "iformAT", "iformap", "\u30a7at", " uniformsiat", "mindAT", "iformiat", "initialati", " uniformati", "iformant", "\u30a7art", "iefat", "mindate", "instet", "initialAT", " uniformate", "ivariant", "\u30a7ant", "ivariat", "ivariap", "iefap", "initialat", " uniformat", "iformet"]}}
{"project": "FFmpeg", "commit_id": "9a3f10695a011861dcf5a649e3e72580b1a4eed4", "target": 1, "func": "static int ra144_encode_frame(AVCodecContext *avctx, uint8_t *frame,\n\n                              int buf_size, void *data)\n\n{\n\n    static const uint8_t sizes[LPC_ORDER] = {64, 32, 32, 16, 16, 8, 8, 8, 8, 4};\n\n    static const uint8_t bit_sizes[LPC_ORDER] = {6, 5, 5, 4, 4, 3, 3, 3, 3, 2};\n\n    RA144Context *ractx;\n\n    PutBitContext pb;\n\n    int32_t lpc_data[NBLOCKS * BLOCKSIZE];\n\n    int32_t lpc_coefs[LPC_ORDER][MAX_LPC_ORDER];\n\n    int shift[LPC_ORDER];\n\n    int16_t block_coefs[NBLOCKS][LPC_ORDER];\n\n    int lpc_refl[LPC_ORDER];    /**< reflection coefficients of the frame */\n\n    unsigned int refl_rms[NBLOCKS]; /**< RMS of the reflection coefficients */\n\n    int energy = 0;\n\n    int i, idx;\n\n\n\n    if (buf_size < FRAMESIZE) {\n\n        av_log(avctx, AV_LOG_ERROR, \"output buffer too small\\n\");\n\n        return 0;\n\n    }\n\n    ractx = avctx->priv_data;\n\n\n\n    /**\n\n     * Since the LPC coefficients are calculated on a frame centered over the\n\n     * fourth subframe, to encode a given frame, data from the next frame is\n\n     * needed. In each call to this function, the previous frame (whose data are\n\n     * saved in the encoder context) is encoded, and data from the current frame\n\n     * are saved in the encoder context to be used in the next function call.\n\n     */\n\n    for (i = 0; i < (2 * BLOCKSIZE + BLOCKSIZE / 2); i++) {\n\n        lpc_data[i] = ractx->curr_block[BLOCKSIZE + BLOCKSIZE / 2 + i];\n\n        energy += (lpc_data[i] * lpc_data[i]) >> 4;\n\n    }\n\n    for (i = 2 * BLOCKSIZE + BLOCKSIZE / 2; i < NBLOCKS * BLOCKSIZE; i++) {\n\n        lpc_data[i] = *((int16_t *)data + i - 2 * BLOCKSIZE - BLOCKSIZE / 2) >>\n\n                      2;\n\n        energy += (lpc_data[i] * lpc_data[i]) >> 4;\n\n    }\n\n    energy = ff_energy_tab[quantize(ff_t_sqrt(energy >> 5) >> 10, ff_energy_tab,\n\n                                    32)];\n\n\n\n    ff_lpc_calc_coefs(&ractx->lpc_ctx, lpc_data, NBLOCKS * BLOCKSIZE, LPC_ORDER,\n\n                      LPC_ORDER, 16, lpc_coefs, shift, FF_LPC_TYPE_LEVINSON,\n\n                      0, ORDER_METHOD_EST, 12, 0);\n\n    for (i = 0; i < LPC_ORDER; i++)\n\n        block_coefs[NBLOCKS - 1][i] = -(lpc_coefs[LPC_ORDER - 1][i] <<\n\n                                        (12 - shift[LPC_ORDER - 1]));\n\n\n\n    /**\n\n     * TODO: apply perceptual weighting of the input speech through bandwidth\n\n     * expansion of the LPC filter.\n\n     */\n\n\n\n    if (ff_eval_refl(lpc_refl, block_coefs[NBLOCKS - 1], avctx)) {\n\n        /**\n\n         * The filter is unstable: use the coefficients of the previous frame.\n\n         */\n\n        ff_int_to_int16(block_coefs[NBLOCKS - 1], ractx->lpc_coef[1]);\n\n        ff_eval_refl(lpc_refl, block_coefs[NBLOCKS - 1], avctx);\n\n    }\n\n    init_put_bits(&pb, frame, buf_size);\n\n    for (i = 0; i < LPC_ORDER; i++) {\n\n        idx = quantize(lpc_refl[i], ff_lpc_refl_cb[i], sizes[i]);\n\n        put_bits(&pb, bit_sizes[i], idx);\n\n        lpc_refl[i] = ff_lpc_refl_cb[i][idx];\n\n    }\n\n    ractx->lpc_refl_rms[0] = ff_rms(lpc_refl);\n\n    ff_eval_coefs(ractx->lpc_coef[0], lpc_refl);\n\n    refl_rms[0] = ff_interp(ractx, block_coefs[0], 1, 1, ractx->old_energy);\n\n    refl_rms[1] = ff_interp(ractx, block_coefs[1], 2,\n\n                            energy <= ractx->old_energy,\n\n                            ff_t_sqrt(energy * ractx->old_energy) >> 12);\n\n    refl_rms[2] = ff_interp(ractx, block_coefs[2], 3, 0, energy);\n\n    refl_rms[3] = ff_rescale_rms(ractx->lpc_refl_rms[0], energy);\n\n    ff_int_to_int16(block_coefs[NBLOCKS - 1], ractx->lpc_coef[0]);\n\n    put_bits(&pb, 5, quantize(energy, ff_energy_tab, 32));\n\n    for (i = 0; i < NBLOCKS; i++)\n\n        ra144_encode_subblock(ractx, ractx->curr_block + i * BLOCKSIZE,\n\n                              block_coefs[i], refl_rms[i], &pb);\n\n    flush_put_bits(&pb);\n\n    ractx->old_energy = energy;\n\n    ractx->lpc_refl_rms[1] = ractx->lpc_refl_rms[0];\n\n    FFSWAP(unsigned int *, ractx->lpc_coef[0], ractx->lpc_coef[1]);\n\n    for (i = 0; i < NBLOCKS * BLOCKSIZE; i++)\n\n        ractx->curr_block[i] = *((int16_t *)data + i) >> 2;\n\n    return FRAMESIZE;\n\n}\n", "idx": 5452, "substitutes": {"avctx": [" avconn", "abctx", "abcc", "capcp", "ajctl", "savctx", "abtmp", "avtx", "avtmp", "avcp", "ajcontext", "avconn", "ajctx", " avcp", "avertmp", " avcontext", "savcontext", "Avctl", "avcss", "avcontext", "capcss", "savcss", "abtx", "Avctx", " avtx", "Avconn", "Avcontext", " avcc", " avctl", "capcontext", "avercc", " avtmp", "avctl", "capctx", " avcss", "avcc", "avertx", "ajconn", "savcp", "averctx"], "frame": ["rame", "event", "error", "call", "window", "channel", "Frame", "fram", "iframe", "field", "buffer", "flow", "frames", " frames", "row", "ce", "code", "feature", "command", "block", "version", "f", "message", "face", "time", "image", "sequence"], "buf_size": ["buf_length", "buf_len", "buf2SIZE", "buf_number", " buf_number", "buf_Size", "uf_size", "buf_SIZE", "bufbuflen", "uf_length", "bufbufSIZE", " buf_SIZE", "bufbufnumber", " buf_len", "uf_Size", "buf2size", "bufbufsize", "buf2len", "buf2number", "uf_SIZE"], "data": ["bytes", "chain", "padding", "next", "empty", "window", "step", "type", "feed", "buf", "state", " Data", "buffer", "raw", "table", "frames", " DATA", "rew", "ata", "zero", "pointer", "index", "Data", "value", "mu", "memory", "bits", "block", " buffer", "response", "batch", "area", "DATA", "message", "size", "length", "res", "text", "def", "image", "bin"], "sizes": ["ssized", " sized", "ssamples", "sized", " samples", "csizers", "sizers", "ssizers", "csized", "ssizes", " sizers", "csizes", "samples", "csamples"], "bit_sizes": ["bit_sizers", "bit_siz", "bit_ssizes", "bit_shizes", "bit_ssiz", "bit_shiz", "bit_Siz", "bit_shize", "bit_shizers", "bit_Size", "bit_size", "bit_Sizes", "bit_ssize", "bit_ssizers", "bit_Sizers"], "ractx": ["processx", "racty", "connectlex", "investx", "actX", "investX", "connecty", "ractiony", "collecty", "ractedor", "rentlex", "processtx", "renttx", "investor", "collector", "rentx", "ractor", "rentxt", "ractionz", "ractionlex", "acttx", "ractionx", "processX", "ractedX", "collectx", "actx", "connectx", "ractionxt", "ractionor", "ractedz", "rentX", "connectX", "collectxt", "ractX", "renty", "ractlex", "investz", "ractxt", "racttx", "ractionX", "rentor", "ractz", "ractedx"], "pb": ["uf", " clipboard", " buf", " PB", " envelope", "buf", " pref", "p", " peer", " pl", " protocol", " sketch", " eb", " proto", " anew", "sb", " ssh", " pc", " np", " prob", " pa", " ep", " offset", " p", "PB", " blob", " ab", " prot", " pe"], "lpc_data": ["lpc2DATA", " L_", "lcu___Data", "l_", "lpc_dat", "lPC_cache", "lcu___data", "lPC_block", "lpc4values", "lPC_options", "lpc0Data", "lpc_DATA", "lpc___options", "lpc_fields", "lmic4name", "lpc4data", "lcu_Data", "lpc_dict", "lpc_block", "lpo_dict", "lpc_name", "lpc_cache", "lcu___dat", "lpcityfields", "lcu_data", "lpcityDATA", "lpcityblock", "lpc2options", "lpc2table", "lpc___DATA", "lpcitydata", "lpc0key", "lpc___data", "lmic4data", "lcu___name", "lcu_name", "lpc8Data", "lpc_key", "lPC_data", "lPC2data", "lpc0data", "lwp_data", "lpo_data", "lpc_values", "lpc___table", "lmic4values", "lwp_value", "lPC2options", "lpc8data", "lpc_options", "lpc_value", "lmic_Data", "lcu_dat", "lPC_fields", "lmic_name", " l_", "lpc___params", "lpc_params", "L_", "lpc8values", "lmic4Data", "lpo_key", "lpc_table", "lpc4Data", "lmic_values", "lpc4name", "lwp_params", "lPC_table", "lpc___name", "lpc8name", "lpc_Data", "lPC2table", "lpc___value", "lwp_table", "lPC_DATA", "lpc0dict", "lPC2DATA", "lmic_data", "lpc2data", "lpo_Data", "lpc___dat", "lpc___Data"], "lpc_coefs": ["lpc_coepps", "lpc_coefions", "lpc_coefls", "lpc_coeffls", "lpc_coffs", "lpc_coeffs", "lpc_coepions", "lpc_coeffps", "lpc_coffls", "lpc_coefps", "lpc_coeffions", "lpc_coffps", "lpc_coeps", "lpc_coepls", "lpc_coffions"], "LPC_ORDER": ["LPC_IDR", "LPC_ORDer", "LPC_NUMER", "LPC_IDER", "LPC_IDBER", "LPC_NUMR", "LPC_NUMERS", "LPC_OWNer", "LPC_ORDR", "LPC_OrdER", "LPC_ENTBER", "LPC_ENTER", "LPC_IDAR", "LPC_IDer", "LPC_ORDAR", "LPC_ORer", "LPC_DIRR", "LPC_ORERS", "LPC_Order", "LPC_OWNERS", "LPC_NUMer", "LPC_IDERS", "LPC_NUMAR", "LPC_NUMBER", "LPC_DIRER", "LPC_ENTERS", "LPC_OWNR", "LPC_ENTR", "LPC_OWNER", "LPC_OWNBER", "LPC_ENTer", "LPC_ORDBER", "LPC_ORER", "LPC_ORBER", "LPC_DIRer", "LPC_OrdBER", "LPC_OrdAR", "LPC_DIRBER", "LPC_ORDERS"], "shift": ["power", "pack", "offset", "set", "sup", "center", "flow", "seed", "scale", "push", "ref", "align", "balance", "mix", "start", "transform", "shr", "Shift", "version", "alias", "jump", "mask", "diff", "hash", "xff"], "block_coefs": ["block_coffs", "block_coefls", "block_cofferences", "block_coeffs", "block_coeffls", "block_coefferences", "block_cooferences", "block_coffers", "block_coeffers", "block_coofers", "block_coofls", "block_coffls", "block_coeferences", "block_coofs", "block_coefers"], "NBLOCKS": ["NFLOCKS", "NBLOCKSI", "NSLANKSI", "NCLOCKSIZE", "NBLOCKs", "NSLANKSIZE", "NCLOCKS", "NSLOCKSI", "NSLANKINS", "NBLANKSI", "NBLOCKINS", "NBLANKSIZE", "NSLANKS", "NBLOCSIZE", "NBLOCS", "NBLICKINS", "NBLKES", "NBLICKs", "NBLOCs", "NBLACKSIZE", "NCLOCKs", "NSLOCKs", "NBLKs", "NFLANKES", "NBLKS", "NCLANKS", "NBLICKSIZE", "NSLOCKS", "NBLANKES", "NBLOCKES", "NBLANKs", "NBLOCKSIZE", "NBLACKs", "NBLICKS", "NBLANKS", "NCLANKSIZE", "NBLOCES", "NCLOCKES", "NCLANKs", "NBLICKSI", "NSLOCKINS", "NFLANKs", "NBLACKINS", "NCLANKES", "NFLOCKES", "NBLACKES", "NFLOCKs", "NBLANKINS", "NSLOCKSIZE", "NFLANKS", "NSLANKs", "NBLACKS", "NBLACKSI"], "lpc_refl": ["lpc_rfl", "lpc_refr", "lpc_grefr", "lpc2refl", "lpc2rcl", "lpc2recl", "lpc_mfl", "lpc_grefl", "lpc_mpl", "lpc_mfr", "lpc2rpl", "lpc_grepl", "lpc2rfr", "lpc2refr", "lpc_rpl", "lpc_rfr", "lpc_grecl", "lpc_mcl", "lpc2repl", "lpc_rcl", "lpc_repl", "lpc2rfl", "lpc_recl"], "refl_rms": ["refl_rmi", "refl_rMS", "refl_orps", "refl_orMS", "refl_rems", "refl_reMS", "refl_urmi", "refl_urps", "refl_remi", "refl_rps", "refl_orms", "refl_urMS", "refl_ormi", "refl_urms", "refl_reps"], "i": ["init", "this", "ic", "ini", "ij", "asi", "ei", "uri", "ci", "depth", "chain", "it", "im", "c", "cli", "h", "oi", "gi", "mi", "qi", "ip", "li", "p", "si", "ami", "zi", "n", "is", "xi", "ind", "index", "o", "ri", "hi", "pi", "bi", "multi", "dr", "me", "id", "ui", "ki", "list", "ji", "phi", "ti", "v", "ims", "iii", "ix", "ai", "m", "a", "I", "remote", "batch", "parent", "y", "\u0438", "mc", "f", "us", "io", "sim", "iu", "e", "in", "j", "series", "x", "di", "ii", "l"], "idx": ["idX", " idi", "idi", "ridi", "indx", "indi", "ridX", "idex", "ridx", "index", " idex", "indX", " idX", "ridex"]}}
{"project": "FFmpeg", "commit_id": "86ab6b6e08e2982fb5785e0691c0a7e289339ffb", "target": 0, "func": "static void decode0(GetByteContext *gb, RangeCoder *rc, unsigned cumFreq, unsigned freq, unsigned total_freq)\n\n{\n\n    int t = rc->range * (uint64_t)cumFreq / total_freq;\n\n\n\n    rc->code1 += t + 1;\n\n    rc->range = rc->range * (uint64_t)(freq + cumFreq) / total_freq - (t + 1);\n\n\n\n    while (rc->range < TOP && bytestream2_get_bytes_left(gb) > 0) {\n\n        unsigned byte = bytestream2_get_byte(gb);\n\n        rc->code = (rc->code << 8) | byte;\n\n        rc->code1 <<= 8;\n\n        rc->range <<= 8;\n\n    }\n\n}\n", "idx": 5457, "substitutes": {"gb": ["db", "gt", "yg", "gh", "gs", "gc", "buff", "gif", "sg", "gp", "gm", "eb", "pb", "bg", "bc", "cgi", "bsp", "buffer", "eg", "px", "tg", "g", "hub", "gd", "cb", "bt", "hw", "bb", "pg", "sb", "rb", "bf", "gio", "vg", "mb", "cfg", "nb", "rg", "fb", "gz", "Gb", "storage", "img", "GB", "vm", "kb", "gg"], "rc": ["ck", "dc", "gc", "c", "auc", "ec", "ce", "arc", "oc", "cr", "req", "ack", "cur", "ctrl", "loc", "rs", "ic", "instance", "rn", "ocr", "lib", "ri", "rw", "roc", "expr", "rb", "lp", "config", "uc", "ac", "desc", "info", "irc", "ctr", "ci", "src", "pc", "anc", "cs", "rx", "ry", "ric", "nc", "usr", "r", "rr", "rt", "rin", "isc", "cv", "rent", "hl", "res", "auth", "hr", "rm", "cmp", "wx", "sys", "fc", "etc", "aux", "sync", "row", "lc", "cc", "proc", "rh", "rl", "rac", "frac", "rd", "obj", "rec", "RC", "tc"], "cumFreq": ["cumFq", "cumFrereq", "cumfreQ", " cumfreqs", " cumfreq", "cumFrreq", "cumfreve", "cumFreck", "cumFrerequency", " cumFreqs", "cumFrck", "cumfreck", "cumFreve", "cuFreq", "cumFiqs", "cumfreq", "cumSpeq", "cumFreeQ", " cumfreve", "cumFck", "cumFreereq", "cuFrereq", " cumFreQ", "cumFreQ", "cuFq", " cumfreQ", "cumfreqs", "cumfrereq", "cuFQ", "cumfrerequency", "cumSpeve", "cumFreeq", " cumFrereq", " cumfrerequency", "cumFrq", "cumFiQ", "cumFreqs", "cumFirequency", "cumFrQ", "cumSpeQ", "cuFck", "cumFreeve", "cumFQ", "cuFreck", "cumSpereq", "cumFiq", "cuFreQ", " cumfrereq", " cumFrerequency", " cumFreve"], "freq": ["Freq", "frereq", "frreq", "Freqq", "frqq", "frqs", "freqq", "freQ", "FreQ", "Frereq", "frQ", " frereq", " freqq", "Freqs", "freqs", " freqs", "frq", " freQ"], "total_freq": ["total_ratej", "total_Freqs", "total_freqq", "total_feqs", "total_feq", "total_feQ", "total_freQ", "total_rateqs", "total_ratei", "total_rei", "total_waveqq", "total_reqs", "total_frej", "total_feix", "total_waveQ", "total_waveqs", "total_req", "total_rateq", "total_frei", "total_Freqq", "total_FreQ", "total_Frej", "total_Frei", "total_waveq", "total_Freix", "total_Freq", "total_rej", "total_freqs", "total_freix"]}}
{"project": "qemu", "commit_id": "64a31d5c3d73396a88563d7a504654edc85aa854", "target": 0, "func": "static int dmg_open(BlockDriverState *bs, const char *filename, int flags)\n\n{\n\n    BDRVDMGState *s = bs->opaque;\n\n    off_t info_begin,info_end,last_in_offset,last_out_offset;\n\n    uint32_t count;\n\n    uint32_t max_compressed_size=1,max_sectors_per_chunk=1,i;\n\n    int64_t offset;\n\n\n\n    s->fd = open(filename, O_RDONLY | O_BINARY);\n\n    if (s->fd < 0)\n\n        return -errno;\n\n    bs->read_only = 1;\n\n    s->n_chunks = 0;\n\n    s->offsets = s->lengths = s->sectors = s->sectorcounts = NULL;\n\n\n\n    /* read offset of info blocks */\n\n    offset = lseek(s->fd, -0x1d8, SEEK_END);\n\n    if (offset < 0) {\n\n        goto fail;\n\n    }\n\n\n\n    info_begin = read_off(s->fd, offset);\n\n    if (info_begin == 0) {\n\n\tgoto fail;\n\n    }\n\n\n\n    if (read_uint32(s->fd, info_begin) != 0x100) {\n\n        goto fail;\n\n    }\n\n\n\n    count = read_uint32(s->fd, info_begin + 4);\n\n    if (count == 0) {\n\n        goto fail;\n\n    }\n\n    info_end = info_begin + count;\n\n\n\n    offset = info_begin + 0x100;\n\n\n\n    /* read offsets */\n\n    last_in_offset = last_out_offset = 0;\n\n    while (offset < info_end) {\n\n        uint32_t type;\n\n\n\n\tcount = read_uint32(s->fd, offset);\n\n\tif(count==0)\n\n\t    goto fail;\n\n        offset += 4;\n\n\n\n\ttype = read_uint32(s->fd, offset);\n\n\tif (type == 0x6d697368 && count >= 244) {\n\n\t    int new_size, chunk_count;\n\n\n\n            offset += 4;\n\n            offset += 200;\n\n\n\n\t    chunk_count = (count-204)/40;\n\n\t    new_size = sizeof(uint64_t) * (s->n_chunks + chunk_count);\n\n\t    s->types = qemu_realloc(s->types, new_size/2);\n\n\t    s->offsets = qemu_realloc(s->offsets, new_size);\n\n\t    s->lengths = qemu_realloc(s->lengths, new_size);\n\n\t    s->sectors = qemu_realloc(s->sectors, new_size);\n\n\t    s->sectorcounts = qemu_realloc(s->sectorcounts, new_size);\n\n\n\n\t    for(i=s->n_chunks;i<s->n_chunks+chunk_count;i++) {\n\n\t\ts->types[i] = read_uint32(s->fd, offset);\n\n\t\toffset += 4;\n\n\t\tif(s->types[i]!=0x80000005 && s->types[i]!=1 && s->types[i]!=2) {\n\n\t\t    if(s->types[i]==0xffffffff) {\n\n\t\t\tlast_in_offset = s->offsets[i-1]+s->lengths[i-1];\n\n\t\t\tlast_out_offset = s->sectors[i-1]+s->sectorcounts[i-1];\n\n\t\t    }\n\n\t\t    chunk_count--;\n\n\t\t    i--;\n\n\t\t    offset += 36;\n\n\t\t    continue;\n\n\t\t}\n\n\t\toffset += 4;\n\n\n\n\t\ts->sectors[i] = last_out_offset+read_off(s->fd, offset);\n\n\t\toffset += 8;\n\n\n\n\t\ts->sectorcounts[i] = read_off(s->fd, offset);\n\n\t\toffset += 8;\n\n\n\n\t\ts->offsets[i] = last_in_offset+read_off(s->fd, offset);\n\n\t\toffset += 8;\n\n\n\n\t\ts->lengths[i] = read_off(s->fd, offset);\n\n\t\toffset += 8;\n\n\n\n\t\tif(s->lengths[i]>max_compressed_size)\n\n\t\t    max_compressed_size = s->lengths[i];\n\n\t\tif(s->sectorcounts[i]>max_sectors_per_chunk)\n\n\t\t    max_sectors_per_chunk = s->sectorcounts[i];\n\n\t    }\n\n\t    s->n_chunks+=chunk_count;\n\n\t}\n\n    }\n\n\n\n    /* initialize zlib engine */\n\n    s->compressed_chunk = qemu_malloc(max_compressed_size+1);\n\n    s->uncompressed_chunk = qemu_malloc(512*max_sectors_per_chunk);\n\n    if(inflateInit(&s->zstream) != Z_OK)\n\n\tgoto fail;\n\n\n\n    s->current_chunk = s->n_chunks;\n\n\n\n    return 0;\n\nfail:\n\n    close(s->fd);\n\n    return -1;\n\n}\n", "idx": 5482, "substitutes": {"bs": ["as", "bes", "rs", "gs", "bis", "ses", "b", "ns", "ubs", "blog", "pb", "its", "bos", "acs", "bc", "cks", "cs", "os", "bh", "ps", "ms", "bp", "ts", "ds", "BS", "fps", "es", "bi", "aus", "js", "ls", "sb", "bps", "stats", "bits", "vs", "hs", "aos", "ss", "bl", "fs", "ks", "bm", "obs"], "filename": ["uri", "jpg", "prefix", "bol", "binary", "description", "file", "files", "buffer", "ename", "ame", "FN", "location", "SourceFile", "kan", "fp", "kl", "fle", "username", "ames", "fil", "nm", "txt", "fn", "Filename", "dir", "f", "fs", "family", "directory", "subject", "source", "names", "journal", "name", "path"], "flags": ["fields", "ns", "conf", "ags", "locks", "kind", "files", "ts", "settings", " options", "vals", "types", "options", "Flag", "properties", "tags", "args", "bits", "status", " whence", "FLAG", "Flags", "fs", " flag", "faces", "flag"], "s": ["sw", "less", "ches", "http", "h", "ers", "locks", "self", "ads", "ps", "ports", "ts", "t", "se", "pers", "js", "w", "gets", "sb", "xs", "ss", "changes", "j", "sports", "params", "as", "rs", "so", "ses", "results", "ubs", "sam", "os", "g", "ms", "tests", "ains", "es", "ears", "stats", "bits", "m", "vs", "sis", "aws", "l", "ops", "gs", "bis", "ns", "ats", "ies", "ags", "cs", "comm", "p", "is", "sv", "hs", "y", "sq", "parts", "fs", "S", "res", "b", "eps", "its", "qs", "sys", "als", "erences", "details", "n", "ds", "ins", "ids", "ls", "ims", "sl", "views", "status", "sn", "states", "sts", "mods"], "info_begin": ["index_center", "info_enter", "inf_enter", "info_coord", " info2begin", "info_commit", "info64EGIN", "info2Begin", " info_gun", "inf_EGIN", "infoThebind", "info_Begin", "infoTheBegin", "info67bind", "index_Begin", " info2Begin", "infoThego", "info_EGIN", "info_center", "info67gun", "info67go", " info2coord", "info11commit", "info2gun", "infoThebegin", "info2begin", "index_begin", "info2coord", "info64begin", "inf_begin", "info_go", "info64enter", "info_gun", "index_end", " info_go", " info2gun", "info67begin", "info_bind", " info_EGIN", "info67coord", "info11Begin", "info11begin", "info67Begin", " info_bind", " info_coord", " info_commit", " info_Begin"], "info_end": [" info_stop", "info2start", "info00start", "INFO_begin", "info2ended", " info_start", "info_END", "info_stop", "INFO_post", "info00begin", "info_post", "info00end", "INFO_end", "info_start", "inf_start", "inf_end", "info00post", "info2end", "inf_End", "info_ended", "info2End", " info_END", "INFO_start", "info_End", "inf_ended"], "last_in_offset": ["last_out_Offset", "last_inptoffset", "last_in_error", "last_out_length", "last_inptOffset", "last_out_off", "last_in_Offset", "last_in_off", "last_in_length", "last_inpterror", "last_out_error", "last_inptlength"], "last_out_offset": ["last_in_point", "last_out_Offset", "last_in_index", "last_in_Offset", "last_out_point", "last_out_index", "last_out_addr", "last_in_size", "last_out_size", "last_in_addr"], "count": ["depth", "chain", "conf", "c", "more", "h", "add", "num", "comment", "frequency", "batch", "current", "core", "sum", "size", "flag", "counter", "read", "success", "page", "cycle", "base", "Count", "index", "code", "max", "v", "country", "command", "nb", "version", "cd", "info", "collection", "check", "length", "ctr", "class", "ct", "kind", "force", "p", "len", "total", "limit", "try", "found", "cond", "ount", "C", "hash", "name", "act", "all", "result", "call", "cont", "amount", "table", "cmd", "body", "n", "number", "cc", "list", "cache", "currency", "z"], "i": ["init", "ci", "b", "it", "c", "ip", "p", "n", "ind", "index", "t", "pi", "limit", "id", "ti", "iter", "v", "m", "I", "y", "f", "info", "e", "j", "x", "ii", "l"], "offset": ["operation", "addr", "order", "pointer", "fp", "key", "trace", "after", "pos", "attribute", "iso", "reset", "offs", "ET", "frequency", "entry", "batch", "size", "origin", "flag", "output", "atomic", "next", "instance", "eta", "pad", "store", "until", "ta", "adjusted", "base", "iterator", "OFF", "zero", "option", "index", "bound", "position", "top", "start", "timeout", "balance", "volume", "action", "item", "address", "before", "info", "length", "Offset", "error", "et", "prefix", "end", "shift", "field", "skip", "at", "extra", "mt", "no", "len", "o", "limit", "to", "style", "oid", "scroll", "sp", "padding", "set", "buffer", "amount", "location", "seek", "number", "ref", "id", "slot", "now", "off", "ptr", "alias", "f", "point", "e", "offer"], "type": ["TYPE", "cast", "ty", "error", "event", "ct", "weight", "ping", "category", "kind", "state", "buffer", "what", "base", "table", "ype", "key", "t", "types", "pe", "unit", "tag", "id", "role", "word", "style", "try", "token", "where", "status", "comment", "ptr", "Type", "message", "test", "size", "info", "time", "check", "length", "tc", "format", "class", "title", "name", "color"], "new_size": [" new_SIZE", "newlexsize", "new_offset", " new_area", "new__count", "newlexSIZE", "new67area", "new_len", "newlexSize", "new____Size", "new67len", "new__Size", "new____count", " new_score", "new67Size", "new____error", "new____size", "new_count", "new_score", " new_Size", "new__size", " new_len", " new_error", "new_error", "new__offset", "new_Size", " new_offset", "new_SIZE", " new_count", "newlexscore", "new_area", "new67size"], "chunk_count": ["chown_amount", "chunk_size", "chacket8num", "chacket8size", "chunkjmax", "chunk32list", "chunk6length", "chunk8length", "chacket_num", "chunk6count", "chownjcount", "chunks_count", "chunkjcounter", "chown_max", "chunk_amount", "chunk32count", "chunk8num", "chunk_list", "chunk32num", "chunks_length", "chown_count", "chunk8total", "chacket8count", "chownjcounter", "chunk8list", "chunk8count", "chacket8list", "chownjamount", "chunk_total", "chunkjcount", "chunk6total", "chown_counter", "chunk6ind", "chunk_max", "chunk_counter", "chacket_size", "chacket_list", "chunks_total", "chunkjamount", "chunk8size", "chacket_count", "chunk32size", "chunk_num", "chunk_length", "chunks_ind", "chunk8ind", "chownjmax", "chunk_ind"]}}
{"project": "qemu", "commit_id": "df8bf7a7fe75eb5d5caffa55f5cd4292b757aea6", "target": 1, "func": "bool net_rx_pkt_is_vlan_stripped(struct NetRxPkt *pkt)\n\n{\n\n    assert(pkt);\n\n\n\n    return pkt->vlan_stripped;\n\n}\n", "idx": 5490, "substitutes": {"pkt": ["put", "ppnt", " pix", " pct", "Pact", "Pct", "pnt", "pcmd", "vnt", " pact", " pkin", "Pcmd", "vcmd", " pcmd", "Pnt", "ppact", "pkin", "paix", "ppkt", "pix", "vkin", "pct", "pakt", "pact", "pput", " pnt", "Put", "pant", "Pkin", "vkt", " put", "Pix", "Pkt"]}}
{"project": "qemu", "commit_id": "0920a17199d23b3def3a60fa1fbbdeadcdda452d", "target": 1, "func": "static Visitor *validate_test_init_raw(TestInputVisitorData *data,\n\n                                       const char *json_string)\n\n{\n\n    Visitor *v;\n\n\n\n    data->obj = qobject_from_json(json_string);\n\n    g_assert(data->obj != NULL);\n\n\n\n    data->qiv = qmp_input_visitor_new_strict(data->obj);\n\n    g_assert(data->qiv != NULL);\n\n\n\n    v = qmp_input_get_visitor(data->qiv);\n\n    g_assert(v != NULL);\n\n\n\n    return v;\n\n}\n", "idx": 5500, "substitutes": {"data": ["draw", "open", "empty", "dat", "rel", "pro", "state", "defined", "valid", "d", "add", "dev", "query", "device", "api", "num", "request", "reader", "batch", "made", "message", "size", "work", "di", "da", "package", "read", "define", "join", "store", "missing", "process", "Data", "start", "normal", "command", "config", "date", "done", "action", "info", "check", "json", "db", "accept", "update", "aw", "error", "ns", "dal", "map", "no", "ata", "delete", "debug", "dd", "select", "analy", "al", "DATA", "auth", "definition", "name", "form", "call", "table", "details", "ds", "input", "initial", "id", "mu", "ad", "component", "where", "storage", "obj", "database", "format", "def", "image"], "json_string": [" jsonWresource", "jsonswdump", "json_join", "son_dump", "jsonetjoin", "son_str", "jsonetstring", " jsonWs", " json_str", "jsonetstr", "jsonWstr", "json_resource", "jsonswstring", " json_s", " json_resource", " jsonWstr", "jsonswstr", "son_string", "son_join", "jsonetdump", "json_dump", "json_s", "jsonWresource", "jsonWs", "jsonWstring", " jsonWstring", "jsonswjoin", "json_str"], "v": ["iv", "vv", "vr", "uv", "vy", "ev", "q", "lv", "b", "it", "ov", "u", "h", "av", "view", "vi", "i", "ve", "g", "p", "inv", "vp", "var", "mint", "dev", "tv", "nov", "t", "value", "sv", "qv", "vo", "vu", "nv", "m", "V", "vc", "vs", "cv", "y", "f", "vt", "conv", "vm", "j", "x", "ver", "l"]}}
{"project": "qemu", "commit_id": "660edd4eda903e32811a4929d1434cceda3284aa", "target": 1, "func": "static int connect_namedsocket(const char *path)\n\n{\n\n    int sockfd, size;\n\n    struct sockaddr_un helper;\n\n\n\n    sockfd = socket(AF_UNIX, SOCK_STREAM, 0);\n\n    if (sockfd < 0) {\n\n        fprintf(stderr, \"socket %s\\n\", strerror(errno));\n\n        return -1;\n\n    }\n\n    strcpy(helper.sun_path, path);\n\n    helper.sun_family = AF_UNIX;\n\n    size = strlen(helper.sun_path) + sizeof(helper.sun_family);\n\n    if (connect(sockfd, (struct sockaddr *)&helper, size) < 0) {\n\n        fprintf(stderr, \"socket error\\n\");\n\n\n        return -1;\n\n    }\n\n\n\n    /* remove the socket for security reasons */\n\n    unlink(path);\n\n    return sockfd;\n\n}", "idx": 5508, "substitutes": {"path": ["user", "filename", "chain", "PATH", "prefix", "type", "h", "kind", "self", "file", "template", "p", "rect", "cmd", "context", "pointer", "full", "key", "history", "temp", "value", "w", "th", "ref", "proc", "pkg", "txt", "host", "transform", "Path", "port", "m", "stream", "config", "dir", "spec", "pattern", "ath", "address", "message", "test", "dest", "ATH", "patch", "format", "x", "text", "name"], "sockfd": ["sipfd", " socksf", "persocketfs", "sockedhandle", " sockedstream", " sockptr", " sockstream", "socksfs", " sockFD", "sockedptr", "sinkfs", "sipFD", " sockhandle", "sockf", "sockfc", "sockptr", "sockdir", "sckptr", "sigfd", "persockfc", "sckFD", "socketFD", "sipptr", "sockfs", "sockedfc", " socksFD", "sackfd", "sigdir", "sixhandle", "sinkfd", "sackFD", "sinkptr", "sockedfd", "sockedFD", "sigFD", "socketfd", " sckfc", "sockhandle", " sipptr", "sOCKfd", "sigf", " socksdir", "sockstream", "sckfd", "sackstream", "sixfd", "socksFD", " sockedfd", "socksptr", " sockedhandle", "sinkfc", "socksfd", "persocketfc", "sockedstream", "socksfc", " sockf", "sckfc", "sOCKFD", "sOCKdir", "persockfs", "socketfs", " sipfd", "sipfc", " sipFD", " sckfd", " sipfc", " sockfc", "persockfd", " sockdir", "sixFD", "sinkFD", "persocketfd", "sackhandle", "persocketFD", " socksfd", "sockFD", "sOCKf", "socksf", "socketfc", "sixstream", " sckptr", " sckFD", "persockFD", " sockedFD", "socksdir"], "size": ["large", "grow", "empty", "SIZE", "mem", "fee", "sha", "Size", "offset", "g", "n", "ose", "len", "seek", "zero", " Size", "total", "sent", "height", "scale", "number", "space", "send", "max", "sh", "small", "city", "sn", "storage", "area", "capacity", "count", "message", "too", "shape", "sum", "ize", "length", "z", "news", "name"], "helper": ["hHelper", "halpper", "helpper", "helHelper", "perhelp", " Helpers", "hhelp", "perper", "helpping", "helpers", "helping", "helter", "helpHelper", "utilping", "utilpers", "perHelper", "helpter", "perpers", " Helter", "toolper", "hper", "happer", "shpper", "shter", "toolber", "halter", "utilpper", "utilper", "haber", "helber", "hiter", "perping", "hpers", "toolpers", "shpers", "haper", "hipers", "helppper", "shper", "hapers", "helphelp", "helhelp", " Helper", "helpber", "halpers", "hipper", "toolpper", " Helpper", "perpper", "halber", "hiper", "hater", "helppers", "halper"]}}
{"project": "qemu", "commit_id": "a1c3e4b839f8e7ec7f1792b8a11c63ca845aa021", "target": 1, "func": "static void ehci_mem_writel(void *ptr, target_phys_addr_t addr, uint32_t val)\n{\n    EHCIState *s = ptr;\n    uint32_t *mmio = (uint32_t *)(&s->mmio[addr]);\n    uint32_t old = *mmio;\n    int i;\n    trace_usb_ehci_mmio_writel(addr, addr2str(addr), val);\n    /* Only aligned reads are allowed on OHCI */\n    if (addr & 3) {\n        fprintf(stderr, \"usb-ehci: Mis-aligned write to addr 0x\"\n                TARGET_FMT_plx \"\\n\", addr);\n        return;\n    if (addr >= PORTSC && addr < PORTSC + 4 * NB_PORTS) {\n        handle_port_status_write(s, (addr-PORTSC)/4, val);\n        trace_usb_ehci_mmio_change(addr, addr2str(addr), *mmio, old);\n        return;\n    if (addr < OPREGBASE) {\n        fprintf(stderr, \"usb-ehci: write attempt to read-only register\"\n                TARGET_FMT_plx \"\\n\", addr);\n        return;\n    /* Do any register specific pre-write processing here.  */\n    switch(addr) {\n    case USBCMD:\n        if (val & USBCMD_HCRESET) {\n            ehci_reset(s);\n            val = s->usbcmd;\n            break;\n        /* not supporting dynamic frame list size at the moment */\n        if ((val & USBCMD_FLS) && !(s->usbcmd & USBCMD_FLS)) {\n            fprintf(stderr, \"attempt to set frame list size -- value %d\\n\",\n                    val & USBCMD_FLS);\n            val &= ~USBCMD_FLS;\n        if (((USBCMD_RUNSTOP | USBCMD_PSE | USBCMD_ASE) & val) !=\n            ((USBCMD_RUNSTOP | USBCMD_PSE | USBCMD_ASE) & s->usbcmd)) {\n            if (s->pstate == EST_INACTIVE) {\n                SET_LAST_RUN_CLOCK(s);\n            s->usbcmd = val; /* Set usbcmd for ehci_update_halt() */\n            ehci_update_halt(s);\n            qemu_mod_timer(s->frame_timer, qemu_get_clock_ns(vm_clock));\n        break;\n    case USBSTS:\n        val &= USBSTS_RO_MASK;              // bits 6 through 31 are RO\n        ehci_clear_usbsts(s, val);          // bits 0 through 5 are R/WC\n        val = s->usbsts;\n        ehci_update_irq(s);\n        break;\n    case USBINTR:\n        val &= USBINTR_MASK;\n        break;\n    case FRINDEX:\n        val &= 0x00003ff8; /* frindex is 14bits and always a multiple of 8 */\n        break;\n    case CONFIGFLAG:\n        val &= 0x1;\n        if (val) {\n            for(i = 0; i < NB_PORTS; i++)\n                handle_port_owner_write(s, i, 0);\n        break;\n    case PERIODICLISTBASE:\n        if (ehci_periodic_enabled(s)) {\n            fprintf(stderr,\n              \"ehci: PERIODIC list base register set while periodic schedule\\n\"\n              \"      is enabled and HC is enabled\\n\");\n        break;\n    case ASYNCLISTADDR:\n        if (ehci_async_enabled(s)) {\n            fprintf(stderr,\n              \"ehci: ASYNC list address register set while async schedule\\n\"\n              \"      is enabled and HC is enabled\\n\");\n        break;\n    *mmio = val;\n    trace_usb_ehci_mmio_change(addr, addr2str(addr), *mmio, old);", "idx": 5509, "substitutes": {"ptr": ["sp", "mem", "att", "ctx", "h", "cont", "pad", "pt", "store", "ry", "pointers", "p", "rect", "add", "ps", "ts", "ind", "pointer", "tr", "t", "r", "dh", "js", "dr", "th", "ref", "err", "inter", "proc", "rev", "pr", "Ptr", "handle", "v", "req", "rt", "ash", "resp", "alloc", "ret", "address", "obj", "ctr", "arr"], "addr": ["ck", "grad", "kt", "rel", "state", "arm", "order", "add", "ind", "url", "alt", "phys", "pos", "iter", "ack", "ret", "size", "adr", "coord", "x", "work", "loc", "elt", "rs", "mem", "pad", "index", "old", "inter", "v", "tz", "ac", "address", "np", "eth", "ctr", "ace", "trans", "ar", "src", "md", "ctx", "offset", "msg", "at", "ip", "mt", "len", "var", "on", "hw", "r", "dh", "dr", "rc", "pkg", "rev", "attr", "mac", "host", "Address", "rt", "dd", "ash", "ord", "hash", "net", "ld", "hl", "res", "oa", "name", "act", "init", "sp", "ser", "cmp", "lat", "set", "sys", "cmd", "arp", "row", "data", "err", "ref", "id", "gate", "ad", "handle", "ix", "tx", "alias", "obj", "arg", "arr", "tp"], "val": ["grad", "sol", "rel", "buf", "valid", "dev", " value", "alt", "key", "value", "pos", "num", "aval", "ret", "eval", "test", "x", "elt", "loc", " ret", "mem", "Val", "ve", "pol", "index", "vals", "sel", "old", "el", "inter", "v", " arg", "hold", "it", " update", "ctx", "pt", " v", " vel", " valid", "prop", "p", "vol", "len", "var", "rol", "bal", "sv", "cal", "orig", "V", "reg", "al", "VAL", "hash", "res", "cho", "set", "cmd", "stat", "data", "ival", " Val", "err", "ref", "pr", "slot", "status", "resp", "tx", "doc", "vt", "obj", "arg", "high", " eval", "def"], "s": ["rs", "sp", "gs", "ses", "ssl", "b", "sw", "ns", "c", "h", "ats", "sam", "sys", "qs", "state", "cs", "self", "comm", "store", "set", "os", "p", "ps", "ms", "als", "n", "g", "is", "ts", "sd", "ds", "sync", "t", "es", "se", "r", "js", "w", "sv", "ls", "sm", "sb", "v", "ims", "stats", "sl", "bits", "status", "m", "spec", "hs", "st", "vs", "ss", "bs", "serv", "sq", "fs", "obj", "e", "S", "sts", "changes", "j", "z", "aws"], "mmio": ["lammios", "mmia", "mlia", "ramios", "wmiol", " mmcho", " mmie", " mmao", "ramao", "mmmios", "memcho", "mmi", " mmiot", "memie", "memio", "mmios", "mmcho", "ramiot", "lammao", "mpios", "mmiol", " mmia", "mpiol", "lammiot", "dmio", "mmao", "wmio", "mlie", "mlios", "mpi", "memios", "dmios", " mmIO", " mmios", "lammio", "mpio", "mmmio", "mmmiol", "wmios", "memIO", "ramio", "mmiot", "dmIO", "wmi", "memia", "mmmi", "mlio", "mmIO", "dmcho", "mmie"], "i": [" rel", " tmp", " res", " ip", " stored", " sp", "set", "Val", " max", " out", "p", " init", "or", "t", " start", " err", "r", " var", "v", " ref", " offset", " len", "x", " dist", " l"]}}
{"project": "FFmpeg", "commit_id": "cf7d2f2d2134c0854edf2db91e7436ac2bc9874f", "target": 0, "func": "static av_cold int dnxhd_encode_init(AVCodecContext *avctx)\n\n{\n\n    DNXHDEncContext *ctx = avctx->priv_data;\n\n    int i, index, bit_depth, ret;\n\n\n\n    switch (avctx->pix_fmt) {\n\n    case AV_PIX_FMT_YUV422P:\n\n        bit_depth = 8;\n\n        break;\n\n    case AV_PIX_FMT_YUV422P10:\n\n        bit_depth = 10;\n\n        break;\n\n    default:\n\n        av_log(avctx, AV_LOG_ERROR,\n\n               \"pixel format is incompatible with DNxHD\\n\");\n\n        return AVERROR(EINVAL);\n\n    }\n\n\n\n    ctx->cid = ff_dnxhd_find_cid(avctx, bit_depth);\n\n    if (!ctx->cid) {\n\n        av_log(avctx, AV_LOG_ERROR,\n\n               \"video parameters incompatible with DNxHD\\n\");\n\n        return AVERROR(EINVAL);\n\n    }\n\n    av_log(avctx, AV_LOG_DEBUG, \"cid %d\\n\", ctx->cid);\n\n\n\n    index = ff_dnxhd_get_cid_table(ctx->cid);\n\n    if (index < 0)\n\n        return index;\n\n    ctx->cid_table = &ff_dnxhd_cid_table[index];\n\n\n\n    ctx->m.avctx    = avctx;\n\n    ctx->m.mb_intra = 1;\n\n    ctx->m.h263_aic = 1;\n\n\n\n    avctx->bits_per_raw_sample = ctx->cid_table->bit_depth;\n\n\n\n    ff_blockdsp_init(&ctx->bdsp, avctx);\n\n    ff_fdctdsp_init(&ctx->m.fdsp, avctx);\n\n    ff_mpv_idct_init(&ctx->m);\n\n    ff_mpegvideoencdsp_init(&ctx->m.mpvencdsp, avctx);\n\n    ff_pixblockdsp_init(&ctx->m.pdsp, avctx);\n\n    if (!ctx->m.dct_quantize)\n\n        ctx->m.dct_quantize = ff_dct_quantize_c;\n\n\n\n    if (ctx->cid_table->bit_depth == 10) {\n\n        ctx->m.dct_quantize     = dnxhd_10bit_dct_quantize;\n\n        ctx->get_pixels_8x4_sym = dnxhd_10bit_get_pixels_8x4_sym;\n\n        ctx->block_width_l2     = 4;\n\n    } else {\n\n        ctx->get_pixels_8x4_sym = dnxhd_8bit_get_pixels_8x4_sym;\n\n        ctx->block_width_l2     = 3;\n\n    }\n\n\n\n    if (ARCH_X86)\n\n        ff_dnxhdenc_init_x86(ctx);\n\n\n\n    ctx->m.mb_height = (avctx->height + 15) / 16;\n\n    ctx->m.mb_width  = (avctx->width  + 15) / 16;\n\n\n\n    if (avctx->flags & AV_CODEC_FLAG_INTERLACED_DCT) {\n\n        ctx->interlaced   = 1;\n\n        ctx->m.mb_height /= 2;\n\n    }\n\n\n\n    ctx->m.mb_num = ctx->m.mb_height * ctx->m.mb_width;\n\n\n\n#if FF_API_QUANT_BIAS\n\nFF_DISABLE_DEPRECATION_WARNINGS\n\n    if (ctx->intra_quant_bias == FF_DEFAULT_QUANT_BIAS &&\n\n        avctx->intra_quant_bias != FF_DEFAULT_QUANT_BIAS)\n\n        ctx->intra_quant_bias = avctx->intra_quant_bias;\n\nFF_ENABLE_DEPRECATION_WARNINGS\n\n#endif\n\n    // XXX tune lbias/cbias\n\n    if ((ret = dnxhd_init_qmat(ctx, ctx->intra_quant_bias, 0)) < 0)\n\n        return ret;\n\n\n\n    /* Avid Nitris hardware decoder requires a minimum amount of padding\n\n     * in the coding unit payload */\n\n    if (ctx->nitris_compat)\n\n        ctx->min_padding = 1600;\n\n\n\n    if ((ret = dnxhd_init_vlc(ctx)) < 0)\n\n        return ret;\n\n    if ((ret = dnxhd_init_rc(ctx)) < 0)\n\n        return ret;\n\n\n\n    FF_ALLOCZ_OR_GOTO(ctx->m.avctx, ctx->slice_size,\n\n                      ctx->m.mb_height * sizeof(uint32_t), fail);\n\n    FF_ALLOCZ_OR_GOTO(ctx->m.avctx, ctx->slice_offs,\n\n                      ctx->m.mb_height * sizeof(uint32_t), fail);\n\n    FF_ALLOCZ_OR_GOTO(ctx->m.avctx, ctx->mb_bits,\n\n                      ctx->m.mb_num * sizeof(uint16_t), fail);\n\n    FF_ALLOCZ_OR_GOTO(ctx->m.avctx, ctx->mb_qscale,\n\n                      ctx->m.mb_num * sizeof(uint8_t), fail);\n\n\n\n#if FF_API_CODED_FRAME\n\nFF_DISABLE_DEPRECATION_WARNINGS\n\n    avctx->coded_frame->key_frame = 1;\n\n    avctx->coded_frame->pict_type = AV_PICTURE_TYPE_I;\n\nFF_ENABLE_DEPRECATION_WARNINGS\n\n#endif\n\n\n\n    if (avctx->thread_count > MAX_THREADS) {\n\n        av_log(avctx, AV_LOG_ERROR, \"too many threads\\n\");\n\n        return AVERROR(EINVAL);\n\n    }\n\n\n\n    ctx->thread[0] = ctx;\n\n    for (i = 1; i < avctx->thread_count; i++) {\n\n        ctx->thread[i] = av_malloc(sizeof(DNXHDEncContext));\n\n        memcpy(ctx->thread[i], ctx, sizeof(DNXHDEncContext));\n\n    }\n\n\n\n    return 0;\n\nfail:  // for FF_ALLOCZ_OR_GOTO\n\n    return AVERROR(ENOMEM);\n\n}\n", "idx": 5539, "substitutes": {"avctx": ["wavhistory", "wavkt", "AVctx", "ajcrit", "averdj", "vercp", "AVcp", " avcmp", "awtx", "awctx", "avtmp", "avcp", " avdj", "navjac", "ajctx", " avhistory", "avertmp", "avtc", "avcontext", "savhistory", "avjac", " avsetup", "wavcfg", "ajjp", "avcomp", "avecp", "avcfg", "vercmp", "avkt", "savtx", "averctx", "AVcmp", "AVcontext", "avercrit", "avejp", "avcmd", "AVcfg", "afctx", "savctx", "savtmp", "aveconf", "avcrit", "avconn", " avcrit", "avecomp", "avecontext", "navctx", "afconn", "avesetup", "avhistory", "navdj", "avectx", "verctx", "avecrit", "avetc", "wavctx", "ajcm", "averreq", "avercomp", "avcb", "avertx", "avconf", "avecmd", "wavcontext", "navcontext", " avconn", "avecm", "avtx", "awcmp", "avercfg", "avdj", " avkt", "averconn", " avcontext", "wavcmd", "avercontext", " avtx", "avetmp", " avjac", "avertc", " avcfg", "averjp", "savcrit", " avtmp", "avsetup", " avcomp", "avercmp", "averjac", "avereq", "avercb", "avercm", "afcmp", "avecmp", "avreq", "avercmd", "savcmd", "avjp", "awcontext", "avetx", "ajtc", "ajkt", "avecfg", " avcmd", "aversetup", "AVtx", "savcontext", "avecb", "savconf", "AVcrit", "vercfg", "avcmp", "averkt", " avconf", "avcm", "avekt", "afcontext", "wavreq", " avcb"], "ctx": ["ck", "dc", "gc", "ctl", "conf", "c", "kt", "scope", "sc", "inst", "settings", "cb", "kl", "ppo", "dad", "crit", "module", "cn", "that", "txt", "req", "iat", "jp", "mc", "xp", "iac", "ctrl", "cu", "params", "abc", "loc", "cookie", "nt", "context", "expr", "timeout", "command", "config", "ac", "local", "ca", "desc", "np", "ia", "conv", "info", "td", "check", "Context", "json", "acl", "cf", "ct", "prefix", "voc", "bc", "anc", "msg", "prop", "cm", "co", "nc", "course", "std", "hw", "history", "rc", "pkg", "kw", "cfg", "cv", "act", "cas", "cp", "cmp", "wx", "sys", "ok", "cmd", "etc", "unc", "aux", "lc", "func", "temp", "xc", "cc", "proc", "jac", "resp", "tx", "handler", "obj", "point", "conn", "tc"], "i": [" bi", "ci", "b", " ii", "it", "c", " v", "mi", "ip", "li", "p", "si", "n", "pi", "bi", "ti", "v", " j", "ai", "m", "I", "y", "e", "j", "x", "ii", "l"], "index": ["init", "condition", "success", "result", "error", "instance", "empty", "err", "offset", "find", "set", "table", "IND", "missing", "no", "seek", "location", "n", "val", "ind", "row", "data", "inn", "key", "zero", "query", "input", "col", "number", "position", "initial", "id", "pos", "connect", "slice", "list", "nil", "ion", "level", "timeout", "max", "iter", "num", "value", "port", "new", "request", "Index", "axis", "count", "address", "test", "fail", "search", "size", "info", "point", "unknown", "length", "interface", "check", "x", "column", "image", "loc"], "bit_depth": [" bit_length", "bittdensity", " bit_deep", "bitlengthdensity", "bitLengthdepth", "bit_level", "bit_module", "bit_density", " bit_distance", "bittlength", "byte_domain", "bit2length", "bitlengthdetails", "bitlengthdepth", "bit_Depth", "bit_details", "bitlengthlength", "bit_width", "bit_default", " bit_details", "bit_distance", "bit_length", " bit_Depth", "bittdepth", "bittdetails", "bit2depth", "bit_deep", "bit_size", " bit_level", "bit2size", " bit_module", " bit_density", "bit_domain", "bitLengthlength", "byte_depth", "bitLengthmodule", "bitLengthdeep", "byte_width", "byte_size", "bit2width", "byte_length", "byte_default"], "ret": ["gt", "result", "match", "mem", "rel", "mi", "rew", "val", "alt", "ref", "bool", "rem", "out", "txt", "reset", "new", "re", "print", "jp", "fi", "ft", "ll", "res", "arr"]}}
{"project": "FFmpeg", "commit_id": "ccce723c6d0ea1ea89ea6c47160a07d37cdeeba2", "target": 0, "func": "static int vc1_decode_frame(AVCodecContext *avctx, void *data,\n\n                            int *data_size, AVPacket *avpkt)\n\n{\n\n    const uint8_t *buf = avpkt->data;\n\n    int buf_size = avpkt->size, n_slices = 0, i;\n\n    VC1Context *v = avctx->priv_data;\n\n    MpegEncContext *s = &v->s;\n\n    AVFrame *pict = data;\n\n    uint8_t *buf2 = NULL;\n\n    const uint8_t *buf_start = buf, *buf_start_second_field = NULL;\n\n    int mb_height, n_slices1=-1;\n\n    struct {\n\n        uint8_t *buf;\n\n        GetBitContext gb;\n\n        int mby_start;\n\n    } *slices = NULL, *tmp;\n\n\n\n    v->second_field = 0;\n\n\n\n    if(s->flags & CODEC_FLAG_LOW_DELAY)\n\n        s->low_delay = 1;\n\n\n\n    /* no supplementary picture */\n\n    if (buf_size == 0 || (buf_size == 4 && AV_RB32(buf) == VC1_CODE_ENDOFSEQ)) {\n\n        /* special case for last picture */\n\n        if (s->low_delay == 0 && s->next_picture_ptr) {\n\n            *pict = s->next_picture_ptr->f;\n\n            s->next_picture_ptr = NULL;\n\n\n\n            *data_size = sizeof(AVFrame);\n\n        }\n\n\n\n        return buf_size;\n\n    }\n\n\n\n    if (s->avctx->codec->capabilities&CODEC_CAP_HWACCEL_VDPAU) {\n\n        if (v->profile < PROFILE_ADVANCED)\n\n            avctx->pix_fmt = AV_PIX_FMT_VDPAU_WMV3;\n\n        else\n\n            avctx->pix_fmt = AV_PIX_FMT_VDPAU_VC1;\n\n    }\n\n\n\n    //for advanced profile we may need to parse and unescape data\n\n    if (avctx->codec_id == AV_CODEC_ID_VC1 || avctx->codec_id == AV_CODEC_ID_VC1IMAGE) {\n\n        int buf_size2 = 0;\n\n        buf2 = av_mallocz(buf_size + FF_INPUT_BUFFER_PADDING_SIZE);\n\n\n\n        if (IS_MARKER(AV_RB32(buf))) { /* frame starts with marker and needs to be parsed */\n\n            const uint8_t *start, *end, *next;\n\n            int size;\n\n\n\n            next = buf;\n\n            for (start = buf, end = buf + buf_size; next < end; start = next) {\n\n                next = find_next_marker(start + 4, end);\n\n                size = next - start - 4;\n\n                if (size <= 0) continue;\n\n                switch (AV_RB32(start)) {\n\n                case VC1_CODE_FRAME:\n\n                    if (avctx->hwaccel ||\n\n                        s->avctx->codec->capabilities&CODEC_CAP_HWACCEL_VDPAU)\n\n                        buf_start = start;\n\n                    buf_size2 = vc1_unescape_buffer(start + 4, size, buf2);\n\n                    break;\n\n                case VC1_CODE_FIELD: {\n\n                    int buf_size3;\n\n                    if (avctx->hwaccel ||\n\n                        s->avctx->codec->capabilities&CODEC_CAP_HWACCEL_VDPAU)\n\n                        buf_start_second_field = start;\n\n                    tmp = av_realloc(slices, sizeof(*slices) * (n_slices+1));\n\n                    if (!tmp)\n\n                        goto err;\n\n                    slices = tmp;\n\n                    slices[n_slices].buf = av_mallocz(buf_size + FF_INPUT_BUFFER_PADDING_SIZE);\n\n                    if (!slices[n_slices].buf)\n\n                        goto err;\n\n                    buf_size3 = vc1_unescape_buffer(start + 4, size,\n\n                                                    slices[n_slices].buf);\n\n                    init_get_bits(&slices[n_slices].gb, slices[n_slices].buf,\n\n                                  buf_size3 << 3);\n\n                    /* assuming that the field marker is at the exact middle,\n\n                       hope it's correct */\n\n                    slices[n_slices].mby_start = s->mb_height >> 1;\n\n                    n_slices1 = n_slices - 1; // index of the last slice of the first field\n\n                    n_slices++;\n\n                    break;\n\n                }\n\n                case VC1_CODE_ENTRYPOINT: /* it should be before frame data */\n\n                    buf_size2 = vc1_unescape_buffer(start + 4, size, buf2);\n\n                    init_get_bits(&s->gb, buf2, buf_size2 * 8);\n\n                    ff_vc1_decode_entry_point(avctx, v, &s->gb);\n\n                    break;\n\n                case VC1_CODE_SLICE: {\n\n                    int buf_size3;\n\n                    tmp = av_realloc(slices, sizeof(*slices) * (n_slices+1));\n\n                    if (!tmp)\n\n                        goto err;\n\n                    slices = tmp;\n\n                    slices[n_slices].buf = av_mallocz(buf_size + FF_INPUT_BUFFER_PADDING_SIZE);\n\n                    if (!slices[n_slices].buf)\n\n                        goto err;\n\n                    buf_size3 = vc1_unescape_buffer(start + 4, size,\n\n                                                    slices[n_slices].buf);\n\n                    init_get_bits(&slices[n_slices].gb, slices[n_slices].buf,\n\n                                  buf_size3 << 3);\n\n                    slices[n_slices].mby_start = get_bits(&slices[n_slices].gb, 9);\n\n                    n_slices++;\n\n                    break;\n\n                }\n\n                }\n\n            }\n\n        } else if (v->interlace && ((buf[0] & 0xC0) == 0xC0)) { /* WVC1 interlaced stores both fields divided by marker */\n\n            const uint8_t *divider;\n\n            int buf_size3;\n\n\n\n            divider = find_next_marker(buf, buf + buf_size);\n\n            if ((divider == (buf + buf_size)) || AV_RB32(divider) != VC1_CODE_FIELD) {\n\n                av_log(avctx, AV_LOG_ERROR, \"Error in WVC1 interlaced frame\\n\");\n\n                goto err;\n\n            } else { // found field marker, unescape second field\n\n                if (avctx->hwaccel ||\n\n                    s->avctx->codec->capabilities&CODEC_CAP_HWACCEL_VDPAU)\n\n                    buf_start_second_field = divider;\n\n                tmp = av_realloc(slices, sizeof(*slices) * (n_slices+1));\n\n                if (!tmp)\n\n                    goto err;\n\n                slices = tmp;\n\n                slices[n_slices].buf = av_mallocz(buf_size + FF_INPUT_BUFFER_PADDING_SIZE);\n\n                if (!slices[n_slices].buf)\n\n                    goto err;\n\n                buf_size3 = vc1_unescape_buffer(divider + 4, buf + buf_size - divider - 4, slices[n_slices].buf);\n\n                init_get_bits(&slices[n_slices].gb, slices[n_slices].buf,\n\n                              buf_size3 << 3);\n\n                slices[n_slices].mby_start = s->mb_height >> 1;\n\n                n_slices1 = n_slices - 1;\n\n                n_slices++;\n\n            }\n\n            buf_size2 = vc1_unescape_buffer(buf, divider - buf, buf2);\n\n        } else {\n\n            buf_size2 = vc1_unescape_buffer(buf, buf_size, buf2);\n\n        }\n\n        init_get_bits(&s->gb, buf2, buf_size2*8);\n\n    } else\n\n        init_get_bits(&s->gb, buf, buf_size*8);\n\n\n\n    if (v->res_sprite) {\n\n        v->new_sprite  = !get_bits1(&s->gb);\n\n        v->two_sprites =  get_bits1(&s->gb);\n\n        /* res_sprite means a Windows Media Image stream, AV_CODEC_ID_*IMAGE means\n\n           we're using the sprite compositor. These are intentionally kept separate\n\n           so you can get the raw sprites by using the wmv3 decoder for WMVP or\n\n           the vc1 one for WVP2 */\n\n        if (avctx->codec_id == AV_CODEC_ID_WMV3IMAGE || avctx->codec_id == AV_CODEC_ID_VC1IMAGE) {\n\n            if (v->new_sprite) {\n\n                // switch AVCodecContext parameters to those of the sprites\n\n                avctx->width  = avctx->coded_width  = v->sprite_width;\n\n                avctx->height = avctx->coded_height = v->sprite_height;\n\n            } else {\n\n                goto image;\n\n            }\n\n        }\n\n    }\n\n\n\n    if (s->context_initialized &&\n\n        (s->width  != avctx->coded_width ||\n\n         s->height != avctx->coded_height)) {\n\n        ff_vc1_decode_end(avctx);\n\n    }\n\n\n\n    if (!s->context_initialized) {\n\n        if (ff_msmpeg4_decode_init(avctx) < 0 || ff_vc1_decode_init_alloc_tables(v) < 0)\n\n            goto err;\n\n\n\n        s->low_delay = !avctx->has_b_frames || v->res_sprite;\n\n\n\n        if (v->profile == PROFILE_ADVANCED) {\n\n            s->h_edge_pos = avctx->coded_width;\n\n            s->v_edge_pos = avctx->coded_height;\n\n        }\n\n    }\n\n\n\n    /* We need to set current_picture_ptr before reading the header,\n\n     * otherwise we cannot store anything in there. */\n\n    if (s->current_picture_ptr == NULL || s->current_picture_ptr->f.data[0]) {\n\n        int i = ff_find_unused_picture(s, 0);\n\n        if (i < 0)\n\n            goto err;\n\n        s->current_picture_ptr = &s->picture[i];\n\n    }\n\n\n\n    // do parse frame header\n\n    v->pic_header_flag = 0;\n\n    if (v->profile < PROFILE_ADVANCED) {\n\n        if (ff_vc1_parse_frame_header(v, &s->gb) < 0) {\n\n            goto err;\n\n        }\n\n    } else {\n\n        if (ff_vc1_parse_frame_header_adv(v, &s->gb) < 0) {\n\n            goto err;\n\n        }\n\n    }\n\n\n\n    if (avctx->debug & FF_DEBUG_PICT_INFO)\n\n        av_log(v->s.avctx, AV_LOG_DEBUG, \"pict_type: %c\\n\", av_get_picture_type_char(s->pict_type));\n\n\n\n    if ((avctx->codec_id == AV_CODEC_ID_WMV3IMAGE || avctx->codec_id == AV_CODEC_ID_VC1IMAGE)\n\n        && s->pict_type != AV_PICTURE_TYPE_I) {\n\n        av_log(v->s.avctx, AV_LOG_ERROR, \"Sprite decoder: expected I-frame\\n\");\n\n        goto err;\n\n    }\n\n\n\n    if ((s->mb_height >> v->field_mode) == 0) {\n\n        av_log(v->s.avctx, AV_LOG_ERROR, \"image too short\\n\");\n\n        goto err;\n\n    }\n\n\n\n    // process pulldown flags\n\n    s->current_picture_ptr->f.repeat_pict = 0;\n\n    // Pulldown flags are only valid when 'broadcast' has been set.\n\n    // So ticks_per_frame will be 2\n\n    if (v->rff) {\n\n        // repeat field\n\n        s->current_picture_ptr->f.repeat_pict = 1;\n\n    } else if (v->rptfrm) {\n\n        // repeat frames\n\n        s->current_picture_ptr->f.repeat_pict = v->rptfrm * 2;\n\n    }\n\n\n\n    // for skipping the frame\n\n    s->current_picture.f.pict_type = s->pict_type;\n\n    s->current_picture.f.key_frame = s->pict_type == AV_PICTURE_TYPE_I;\n\n\n\n    /* skip B-frames if we don't have reference frames */\n\n    if (s->last_picture_ptr == NULL && (s->pict_type == AV_PICTURE_TYPE_B || s->dropable)) {\n\n        goto err;\n\n    }\n\n    if ((avctx->skip_frame >= AVDISCARD_NONREF && s->pict_type == AV_PICTURE_TYPE_B) ||\n\n        (avctx->skip_frame >= AVDISCARD_NONKEY && s->pict_type != AV_PICTURE_TYPE_I) ||\n\n         avctx->skip_frame >= AVDISCARD_ALL) {\n\n        goto end;\n\n    }\n\n\n\n    if (s->next_p_frame_damaged) {\n\n        if (s->pict_type == AV_PICTURE_TYPE_B)\n\n            goto end;\n\n        else\n\n            s->next_p_frame_damaged = 0;\n\n    }\n\n\n\n    if (ff_MPV_frame_start(s, avctx) < 0) {\n\n        goto err;\n\n    }\n\n\n\n    v->s.current_picture_ptr->f.interlaced_frame = (v->fcm != PROGRESSIVE);\n\n    v->s.current_picture_ptr->f.top_field_first  = v->tff;\n\n\n\n    s->me.qpel_put = s->dsp.put_qpel_pixels_tab;\n\n    s->me.qpel_avg = s->dsp.avg_qpel_pixels_tab;\n\n\n\n    if ((CONFIG_VC1_VDPAU_DECODER)\n\n        &&s->avctx->codec->capabilities&CODEC_CAP_HWACCEL_VDPAU)\n\n        ff_vdpau_vc1_decode_picture(s, buf_start, (buf + buf_size) - buf_start);\n\n    else if (avctx->hwaccel) {\n\n        if (v->field_mode && buf_start_second_field) {\n\n            // decode first field\n\n            s->picture_structure = PICT_BOTTOM_FIELD - v->tff;\n\n            if (avctx->hwaccel->start_frame(avctx, buf_start, buf_start_second_field - buf_start) < 0)\n\n                goto err;\n\n            if (avctx->hwaccel->decode_slice(avctx, buf_start, buf_start_second_field - buf_start) < 0)\n\n                goto err;\n\n            if (avctx->hwaccel->end_frame(avctx) < 0)\n\n                goto err;\n\n\n\n            // decode second field\n\n            s->gb = slices[n_slices1 + 1].gb;\n\n            s->picture_structure = PICT_TOP_FIELD + v->tff;\n\n            v->second_field = 1;\n\n            v->pic_header_flag = 0;\n\n            if (ff_vc1_parse_frame_header_adv(v, &s->gb) < 0) {\n\n                av_log(avctx, AV_LOG_ERROR, \"parsing header for second field failed\");\n\n                goto err;\n\n            }\n\n            v->s.current_picture_ptr->f.pict_type = v->s.pict_type;\n\n\n\n            if (avctx->hwaccel->start_frame(avctx, buf_start_second_field, (buf + buf_size) - buf_start_second_field) < 0)\n\n                goto err;\n\n            if (avctx->hwaccel->decode_slice(avctx, buf_start_second_field, (buf + buf_size) - buf_start_second_field) < 0)\n\n                goto err;\n\n            if (avctx->hwaccel->end_frame(avctx) < 0)\n\n                goto err;\n\n        } else {\n\n            s->picture_structure = PICT_FRAME;\n\n            if (avctx->hwaccel->start_frame(avctx, buf_start, (buf + buf_size) - buf_start) < 0)\n\n                goto err;\n\n            if (avctx->hwaccel->decode_slice(avctx, buf_start, (buf + buf_size) - buf_start) < 0)\n\n                goto err;\n\n            if (avctx->hwaccel->end_frame(avctx) < 0)\n\n                goto err;\n\n        }\n\n    } else {\n\n        if (v->fcm == ILACE_FRAME && s->pict_type == AV_PICTURE_TYPE_B)\n\n            goto err; // This codepath is still incomplete thus it is disabled\n\n\n\n        ff_er_frame_start(s);\n\n\n\n        v->bits = buf_size * 8;\n\n        v->end_mb_x = s->mb_width;\n\n        if (v->field_mode) {\n\n            uint8_t *tmp[2];\n\n            s->current_picture.f.linesize[0] <<= 1;\n\n            s->current_picture.f.linesize[1] <<= 1;\n\n            s->current_picture.f.linesize[2] <<= 1;\n\n            s->linesize                      <<= 1;\n\n            s->uvlinesize                    <<= 1;\n\n            tmp[0]          = v->mv_f_last[0];\n\n            tmp[1]          = v->mv_f_last[1];\n\n            v->mv_f_last[0] = v->mv_f_next[0];\n\n            v->mv_f_last[1] = v->mv_f_next[1];\n\n            v->mv_f_next[0] = v->mv_f[0];\n\n            v->mv_f_next[1] = v->mv_f[1];\n\n            v->mv_f[0] = tmp[0];\n\n            v->mv_f[1] = tmp[1];\n\n        }\n\n        mb_height = s->mb_height >> v->field_mode;\n\n        for (i = 0; i <= n_slices; i++) {\n\n            if (i > 0 &&  slices[i - 1].mby_start >= mb_height) {\n\n                if (v->field_mode <= 0) {\n\n                    av_log(v->s.avctx, AV_LOG_ERROR, \"Slice %d starts beyond \"\n\n                           \"picture boundary (%d >= %d)\\n\", i,\n\n                           slices[i - 1].mby_start, mb_height);\n\n                    continue;\n\n                }\n\n                v->second_field = 1;\n\n                v->blocks_off   = s->mb_width  * s->mb_height << 1;\n\n                v->mb_off       = s->mb_stride * s->mb_height >> 1;\n\n            } else {\n\n                v->second_field = 0;\n\n                v->blocks_off   = 0;\n\n                v->mb_off       = 0;\n\n            }\n\n            if (i) {\n\n                v->pic_header_flag = 0;\n\n                if (v->field_mode && i == n_slices1 + 2) {\n\n                    if (ff_vc1_parse_frame_header_adv(v, &s->gb) < 0) {\n\n                        av_log(v->s.avctx, AV_LOG_ERROR, \"Field header damaged\\n\");\n\n                        continue;\n\n                    }\n\n                } else if (get_bits1(&s->gb)) {\n\n                    v->pic_header_flag = 1;\n\n                    if (ff_vc1_parse_frame_header_adv(v, &s->gb) < 0) {\n\n                        av_log(v->s.avctx, AV_LOG_ERROR, \"Slice header damaged\\n\");\n\n                        continue;\n\n                    }\n\n                }\n\n            }\n\n            s->start_mb_y = (i == 0) ? 0 : FFMAX(0, slices[i-1].mby_start % mb_height);\n\n            if (!v->field_mode || v->second_field)\n\n                s->end_mb_y = (i == n_slices     ) ? mb_height : FFMIN(mb_height, slices[i].mby_start % mb_height);\n\n            else\n\n                s->end_mb_y = (i <= n_slices1 + 1) ? mb_height : FFMIN(mb_height, slices[i].mby_start % mb_height);\n\n            if (s->end_mb_y <= s->start_mb_y) {\n\n                av_log(v->s.avctx, AV_LOG_ERROR, \"end mb y %d %d invalid\\n\", s->end_mb_y, s->start_mb_y);\n\n                continue;\n\n            }\n\n            ff_vc1_decode_blocks(v);\n\n            if (i != n_slices)\n\n                s->gb = slices[i].gb;\n\n        }\n\n        if (v->field_mode) {\n\n            v->second_field = 0;\n\n            if (s->pict_type == AV_PICTURE_TYPE_B) {\n\n                memcpy(v->mv_f_base, v->mv_f_next_base,\n\n                       2 * (s->b8_stride * (s->mb_height * 2 + 1) + s->mb_stride * (s->mb_height + 1) * 2));\n\n            }\n\n            s->current_picture.f.linesize[0] >>= 1;\n\n            s->current_picture.f.linesize[1] >>= 1;\n\n            s->current_picture.f.linesize[2] >>= 1;\n\n            s->linesize                      >>= 1;\n\n            s->uvlinesize                    >>= 1;\n\n        }\n\n        av_dlog(s->avctx, \"Consumed %i/%i bits\\n\",\n\n                get_bits_count(&s->gb), s->gb.size_in_bits);\n\n//  if (get_bits_count(&s->gb) > buf_size * 8)\n\n//      return -1;\n\n        if(s->error_occurred && s->pict_type == AV_PICTURE_TYPE_B)\n\n            goto err;\n\n        if(!v->field_mode)\n\n            ff_er_frame_end(s);\n\n    }\n\n\n\n    ff_MPV_frame_end(s);\n\n\n\n    if (avctx->codec_id == AV_CODEC_ID_WMV3IMAGE || avctx->codec_id == AV_CODEC_ID_VC1IMAGE) {\n\nimage:\n\n        avctx->width  = avctx->coded_width  = v->output_width;\n\n        avctx->height = avctx->coded_height = v->output_height;\n\n        if (avctx->skip_frame >= AVDISCARD_NONREF)\n\n            goto end;\n\n#if CONFIG_WMV3IMAGE_DECODER || CONFIG_VC1IMAGE_DECODER\n\n        if (vc1_decode_sprites(v, &s->gb))\n\n            goto err;\n\n#endif\n\n        *pict      = v->sprite_output_frame;\n\n        *data_size = sizeof(AVFrame);\n\n    } else {\n\n        if (s->pict_type == AV_PICTURE_TYPE_B || s->low_delay) {\n\n            *pict = s->current_picture_ptr->f;\n\n        } else if (s->last_picture_ptr != NULL) {\n\n            *pict = s->last_picture_ptr->f;\n\n        }\n\n        if (s->last_picture_ptr || s->low_delay) {\n\n            *data_size = sizeof(AVFrame);\n\n            ff_print_debug_info(s, pict);\n\n        }\n\n    }\n\n\n\nend:\n\n    av_free(buf2);\n\n    for (i = 0; i < n_slices; i++)\n\n        av_free(slices[i].buf);\n\n    av_free(slices);\n\n    return buf_size;\n\n\n\nerr:\n\n    av_free(buf2);\n\n    for (i = 0; i < n_slices; i++)\n\n        av_free(slices[i].buf);\n\n    av_free(slices);\n\n    return -1;\n\n}\n", "idx": 5567, "substitutes": {"avctx": ["cvctx", "ahcookie", "vrcas", " avcmp", "awtx", "awctx", "vrctl", "vrctx", "camctx", "vtx", "Avctl", "avcontext", "aveconn", "avjac", "avectl", "vccmd", "vccfg", "avcfg", "Avtx", "awjac", "afctl", "averctx", "avcmd", "averpkg", "afctx", "camctl", "avercookie", "vercmd", " avcas", "cvcontext", "avconn", "avcookie", "verctx", "avectx", "wavctx", "cvtx", "avctl", "afjp", " avcookie", " avconn", "avpkg", "vccas", "vrtx", "vertx", "avtx", "vcontext", "verjac", "abcontext", " avcontext", "avtxt", "wavconn", "ahctx", "ahpkg", " avtx", " avpkg", "Avconn", "vctx", " avjac", " avcfg", "camcmp", "wavtx", "vrcontext", "vrcmp", " avtxt", "avertxt", "abctx", "afcmp", "ahtxt", "avjp", "avetx", "vcctx", " avcmd", "camjp", "vrcmd", "avcas", "abconn", "abtx", "cvcmp", "vconn", "Avctx", "wavctl", "awcmd", "avcmp", "vrjp", "vrcfg"], "data": ["output", "content", "this", "present", "bytes", "padding", "empty", "dat", "window", "RAW", "pad", "rel", "file", "ATA", "buffer", "raw", "d", "p", "n", "missing", " DATA", "name", "ata", "zero", "t", "input", "value", "str", "Data", "nothing", "mu", "png", "INFO", "m", "frame", "block", "batch", "doc", "area", "f", "DATA", "message", "obj", "length", "snap", "text", "a", "def", "image", "bin"], "data_size": ["buf_length", "buf_Size", "buf_size", " data_Size", "data_length", "data_SIZE", "data_Size", " data_send", "data_send", " data_SIZE"], "avpkt": ["avppkt", "avpadat", "awpth", " avPdat", "awcpck", "avdpacket", "awpck", "avPj", " avPconn", "avpawd", " avpdat", "awpkt", "avpakt", " avPkt", " avpconn", " avPj", "avpj", "avPct", "avPkt", "avpaacket", "avpdat", " avpacket", "avcpck", " avPwd", "avpacket", "avdpj", "avPconn", " avpj", "avPth", "avcpct", "awcpth", "awcpkt", "avpconn", "avpreconn", "avprkt", "avpracket", "avPwd", "avppct", "avpck", "avprdat", "avcpkt", "avprej", "avdpconn", " avpwd", "awcpct", "awpct", "avppth", "avpct", "avprekt", "avPacket", "avpth", "avppck", "avPck", "avPdat", "avdpkt", "avpreacket", "avcpth", "avpwd", "avprwd", " avPacket"], "buf": ["init", "bytes", "uv", "uf", "buff", "b", "dat", "mem", "SIZE", "ff", "src", "pb", "ctx", "br", "cmp", "bc", "box", "cam", "Buffer", "buffer", "msg", "raw", "map", "seq", "p", "bh", "cmd", "cb", "queue", "t", "wb", "r", "err", "ref", "pos", "pkg", "pg", "Buff", "begin", "max", "rb", "bin", "txt", "cap", "emb", "orig", "alloc", "cv", "batch", "xff", "img", "fb", "bl", "doc", "cur", "conv", "enc", "vec"], "i": ["ij", "ci", "b", "it", "im", "c", "mi", "qi", "p", "si", "g", "n", "t", "bi", "pi", "id", "phi", "ti", "m", "I", "f", "j", "z", "di", "x", "ii", "l"], "v": ["iv", "vv", "vr", "uv", "ev", "q", "b", "lv", "c", "u", "h", "av", "vi", "ve", "p", "g", "n", "vp", "tv", "t", "va", "w", "sv", "rev", "qv", "env", "video", "nv", "m", "vs", "V", "vc", "cv", "f", "vt", "conv", "vm", "j", "ver", "l"], "s": ["sw", "less", "c", "ers", "h", "scope", "ps", "ts", "t", "se", "js", "w", "sb", "services", "ss", "j", "comments", "rs", "ses", "cam", "sam", "https", "os", "g", "ms", "context", "es", "soc", "stats", "m", "vs", "serv", "conv", "aws", "a", "gs", "ssl", "ns", "abilities", "ctx", "ats", "ies", "cs", "p", "is", "sv", "sm", "st", "hs", "bs", "sq", "session", "fs", "S", "sp", "b", "wcs", "its", "sys", "qs", "set", "n", "ds", "ins", "space", "ls", "sh", "sl", "status", "spec", "f", "e", "sts", "z"], "pict": ["feat", "buff", "ct", "Pic", "ctx", "kt", "Pict", "cam", "Capt", "phot", "fig", "pt", "mat", "qi", "msg", "ht", "seq", "prop", "fat", "stat", "picture", "pkg", "png", "pr", "txt", "fac", "pic", "img", "iat", "doc", "pas", "np", "fi", "obj", "Picture", "pres", "capt", "act"], "buf2": ["buff3", "buf0", "buff1", "uf3", "buff0", "uf2", "uf1", "buf1", "buffer3", "buf3", "uf0", "buffer2", "buff2", "buffer1", "buffer0"], "buf_start": ["buf2id", "uf_id", "buf2start", "buf_size", "uf_size", "buf_id", "uf_end", "uf_start", "buf_end", "buf2end", "buf2size"], "buf_start_second_field": ["buf_start_first_fields", "buf_start_first_field", "buf_start_second_fields", "buf_start_second_length", "buf_start_first_byte", "buf_start_first_length", "buf_start_second_byte"], "mb_height": ["mbavmax", "mb_size", "buf_size", "buf_max", "mb_max", "mbavheight", "buf_height", "mbavwidth", "mbavsize", "buf_width", "mb_width"], "slices": ["slicices", "Slimes", "splions", "slimions", "slicions", "splices", "slimets", "sizions", "slimices", "slimes", "Slicions", "slicets", "splets", "Slimets", "sples", "sizices", "Slices", "sizets", "Slimions", "Slicices", "Slicets", "Slimices", "sizes"], "tmp": ["boxes", "uv", "xy", "sp", "src", "cam", "cmp", "mk", "seq", "etc", "perm", "temp", "js", "pos", "proc", "png", "txt", "img", "cv", "ptr", "cond", "np", "obj", "test", "conv", "photos", "params", "mp"], "size": ["content", "bytes", "empty", "SIZE", "window", "fee", "type", "offset", "Size", "buffer", "body", "len", "height", "scale", "limit", "space", "send", "count", "address", "message", "shape", "ize", "time", "length", "name"], "n_slices": ["n_Scoes", "n_Slices", "n_slicides", "n_Scoides", "n_slimES", "n_slimses", "n_scoES", "n_sples", "n_slicses", "n_scoses", "n_ScoES", "n_scoes", "n_Slicides", "n_Slicses", "n_Scoses", "n_splES", "n_SlicES", "n_slicES", "n_slimides", "n_scoides", "n_slimes", "n_splides", "n_splses"]}}
{"project": "qemu", "commit_id": "b85114f8cfbede8b153db68875973ef0790bf296", "target": 0, "func": "void blk_apply_root_state(BlockBackend *blk, BlockDriverState *bs)\n\n{\n\n    bs->detect_zeroes = blk->root_state.detect_zeroes;\n\n}\n", "idx": 5581, "substitutes": {"blk": [" blb", "plak", "blak", "blck", "brak", " blj", "plck", "brb", "Blj", "Blb", "brck", "plk", "brk", "blb", "blj", "Blck", "Blk", " blak", " blck", "plj", "Blak"], "bs": ["gb", "bytes", "gs", "bis", "b", "bn", "ns", "ubs", "pb", "bos", "its", "acs", "bc", "sys", "qs", "bsp", "os", "als", "ms", "ts", "uts", "ds", "BS", "aus", "js", "bb", "ls", "sb", "s", "bps", "bits", "aos", "ss", "zb", "bl", "fs", "bas", "bm", "obs", "bus", "lbs"]}}
{"project": "qemu", "commit_id": "42119fa3568dc7e8c82447c861678a5987d06d91", "target": 0, "func": "vcard_emul_mirror_card(VReader *vreader)\n\n{\n\n    /*\n\n     * lookup certs using the C_FindObjects. The Stan Cert handle won't give\n\n     * us the real certs until we log in.\n\n     */\n\n    PK11GenericObject *firstObj, *thisObj;\n\n    int cert_count;\n\n    unsigned char **certs;\n\n    int *cert_len;\n\n    VCardKey **keys;\n\n    PK11SlotInfo *slot;\n\n    VCard *card;\n\n\n\n    slot = vcard_emul_reader_get_slot(vreader);\n\n    if (slot == NULL) {\n\n        return NULL;\n\n    }\n\n\n\n    firstObj = PK11_FindGenericObjects(slot, CKO_CERTIFICATE);\n\n    if (firstObj == NULL) {\n\n        return NULL;\n\n    }\n\n\n\n    /* count the certs */\n\n    cert_count = 0;\n\n    for (thisObj = firstObj; thisObj;\n\n                             thisObj = PK11_GetNextGenericObject(thisObj)) {\n\n        cert_count++;\n\n    }\n\n\n\n    if (cert_count == 0) {\n\n        PK11_DestroyGenericObjects(firstObj);\n\n        return NULL;\n\n    }\n\n\n\n    /* allocate the arrays */\n\n    vcard_emul_alloc_arrays(&certs, &cert_len, &keys, cert_count);\n\n\n\n    /* fill in the arrays */\n\n    cert_count = 0;\n\n    for (thisObj = firstObj; thisObj;\n\n                             thisObj = PK11_GetNextGenericObject(thisObj)) {\n\n        SECItem derCert;\n\n        CERTCertificate *cert;\n\n        SECStatus rv;\n\n\n\n        rv = PK11_ReadRawAttribute(PK11_TypeGeneric, thisObj,\n\n                                   CKA_VALUE, &derCert);\n\n        if (rv != SECSuccess) {\n\n            continue;\n\n        }\n\n        /* create floating temp cert. This gives us a cert structure even if\n\n         * the token isn't logged in */\n\n        cert = CERT_NewTempCertificate(CERT_GetDefaultCertDB(), &derCert,\n\n                                       NULL, PR_FALSE, PR_TRUE);\n\n        SECITEM_FreeItem(&derCert, PR_FALSE);\n\n        if (cert == NULL) {\n\n            continue;\n\n        }\n\n\n\n        certs[cert_count] = cert->derCert.data;\n\n        cert_len[cert_count] = cert->derCert.len;\n\n        keys[cert_count] = vcard_emul_make_key(slot, cert);\n\n        cert_count++;\n\n        CERT_DestroyCertificate(cert); /* key obj still has a reference */\n\n    }\n\n\n\n    /* now create the card */\n\n    card = vcard_emul_make_card(vreader, certs, cert_len, keys, cert_count);\n\n    g_free(certs);\n\n    g_free(cert_len);\n\n    g_free(keys);\n\n\n\n    return card;\n\n}\n", "idx": 5582, "substitutes": {"firstObj": [" firstArg", "currentObject", " firstNow", "firstOb", "startOb", "smallObj", "fullArg", "topObj", "thisOb", "firstArg", "firstCtrl", "smallPos", "startObject", "thisObject", "topArg", "masterOb", "fullRes", " firstCtrl", "firstNow", "topObject", " firstVo", "firstVo", "topVo", "fullVo", "topRes", "topPos", "masterPos", "smallCtrl", "currentOb", "fullObj", "topNow", "smallOb", "startObj", "firstObject", "fullPos", " firstPos", " firstObject", "firstPos", "firstRes", " firstOb", "thisNow", "currentObj", " firstRes", "topOb", "fullOb", "masterObj", "masterCtrl"], "thisObj": ["thisInst", " thisLt", "methodObj", "parentInst", "hereOb", "nowOb", "nowObject", "parentObj", "theseNow", " thisArg", "hereObj", " thisOb", "curOb", "thisAss", "nowLt", " thisObject", "hereCtrl", "thisobj", "singleVo", "rightOb", "hereObject", "currentObject", "todayObj", "theseObj", "curObj", "nowInst", "currentEx", "thisRes", "sinceObj", "firstCtrl", "firstStr", "thisObject", "theseObject", "thisArg", "singleOb", "thisVo", "sinceVo", "thatExt", "thisVol", "thatObj", "sinceEx", "firstOb", " thisobj", "thisOb", " thisStr", "sinceStr", "singleInst", "nowVo", "currentArg", "firstVo", " thisRes", "theseEx", "currentobj", "thisEx", " thisVo", "firstobj", "parentOb", "curVo", "thisLt", "thisExt", "curAss", "todayLt", "currentObj", "thisStr", " thisVol", "rightAss", "methodVol", "firstArg", "rightVo", "nowObj", "todayOb", "currentCtrl", "singleObj", "firstNow", " thisEx", "currentOb", "firstExt", "firstEx", "currentNow", "firstVol", "thatRes", "singleAss", "firstObject", "firstRes", "methodOb", "thisCtrl", "thisNow", "parentVo", " thisExt", "rightObj"], "cert_count": ["certCountbase", "ctr_sum", "ert_Count", "cert5amount", " cert_length", "cert64count", "Cert_list", "cert_cache", "cert_amount", "cert_sum", "cert67counter", "Cert_Count", "ert_count", "certCountdouble", "cert64counter", "der_index", "Cert_count", "cert2add", " cert_counter", "cert5id", "cert64sum", "certzlist", "cert67sum", "cert_base", "thread_count", "ert_mount", "cert_add", "ert_search", "cert_child", "certzcollection", "cert5code", "cert_index", "cert2counter", "cert_double", "der_base", "ert_code", "cert_found", "ctr_add", "ptr_count", "ptr_group", "ctr_counter", "cert_mount", "cert67count", "certCountlen", "ptr_child", "der_cache", "cert_list", "ctr2sum", " cert_Count", "cert5mount", "cert5count", "cert64add", "certptgroup", "ert_cache", "certzcount", "ctr2counter", "cert67add", "cert_length", "certptcount", "ctr_count", "certptchild", "cert_group", "cert_code", "ctr2add", "cert_id", "cert2count", "thread_len", "cert5Count", "ert_id", "cert5search", "cert_Count", "ert_amount", "der_double", "certzCount", "ert_found", "thread_Count", "certCountcount", "Cert_collection", "der_len", "der_code", "cert_collection", "cert2sum", "der_count", "cert_search", "ctr2count", "cert_counter"], "certs": [" certts", "certigs", "Certs", "ertrs", "ertts", "celcs", "ertls", "alerts", "ertc", "celses", "certains", "celgs", "alertses", "certes", "Certigs", "certts", "ertes", " certes", "Certc", "contains", "extts", "Certls", "paths", "ptcs", "extrs", "exts", "pts", "alertgs", " certigs", "contts", "celes", "ptrs", " certls", "alertxs", "certc", "certcs", " certcs", "pathxs", "ertigs", "ertcs", "ptts", "extcs", "ctigs", "certxs", "conts", "celts", "certls", "cels", "cts", "pathgs", "ctts", "contigs", "erts", "pathses", "ctains", "celxs", "certrs", "certses", "certgs", " certc", " certains"], "cert_len": [" cert_gen", "cert_lib", "ert_len", "cert_Len", "cert64Len", "ver_len", "Cert_list", "cert64lib", "cert_lim", "ert_list", "cert_mem", "ert_Len", " cert_lib", "cert2length", "ert_mem", "cert64len", "cert2list", " cert64lib", "cert67gen", "ver_gen", "cert2Len", "cert_sl", "cert_list", "cert2mem", "cert67lim", "ver_lim", "cert2len", "cert_length", "Cert_length", "Cert_len", " cert_size", "ver_sl", " cert_Len", "cert_gen", " cert64len", "cert_size", " cert64gen", "cert67sl", "cert67len", " cert64Len", "Cert_Len", "cert64gen"], "keys": ["fields", "ots", "weights", "writers", "items", "ics", "ers", "values", "vers", "locks", "balls", "cats", "files", "actions", "bys", "ps", "pins", "als", "ports", "rows", "ds", "workers", "banks", "eds", "cards", "key", "types", "headers", "vals", "lights", "ids", "services", "xs", "checks", "tags", "books", "images", "users", "ams", "els", "codes", "bs", "parts", "ves", "ks", "Keys", "groups", "rots", "names", "scripts", "chains", "ops"], "slot": ["service", "sp", "magic", "ct", "layout", "ser", "binding", "node", "usb", "note", "ctx", "lot", "scope", "pt", "table", "zone", "si", "vol", "zo", "seed", "location", "option", " slots", "index", "pointer", "kl", "key", "row", "slice", "ref", "pos", "module", "role", "space", "soc", "timeout", "handle", "tz", "ot", "sid", "sl", "Slot", "gro", "shot", "tab", "pot", "item", "storage", "pool", "kit", "session", "spot", "loop", "snap", "j", "lock", "z", "holder", "journal", "loc"], "card": ["cf", "cast", "gc", "cas", " cards", "craft", "ar", "c", "pack", "cont", "carry", "raw", "deck", "var", "php", "ARD", "row", "ard", "and", "cards", "t", "wild", "cc", "dr", "list", "board", "arc", "rar", "cap", "book", "cell", "new", "cart", "guard", "controller", "ul", "cat", "roll", "ll", "star", "car", "Card"], "derCert": ["DerPub", "DerItem", "derPub", " derItem", "delServ", "DERKey", "ercert", "descert", "sercert", "DERServ", "derCtrl", "dItem", "dCert", "delKey", "drCrit", "derAlert", "erServ", "delCrit", " derServ", " derCrit", "drAlert", "DerCtrl", "delAlert", "DERCert", " derCtrl", "DerCert", "DERcert", "DerServ", "derItem", "dCtrl", "serVal", "DerKey", "drCert", " derPub", "erAlert", "serPub", "delcert", "desVal", "derVal", "drcert", "desPub", "derServ", "derKey", "dercert", "erCrit", "drKey", "delCert", "drPub", "DerCrit", "DerVal", " dercert", "Dercert", "erCert", "dcert", "serCert", "desCert", "erKey", "derCrit"], "cert": ["deb", "cf", "cast", "result", "ct", "ert", "ssl", "cp", "note", "Cert", "cont", "tar", "cel", "pt", "con", "compl", "valid", "cmd", "vol", "good", "val", "ind", "ERT", "tr", "pair", "ce", "key", "t", "temp", "mail", "alt", "trust", "str", "crypt", "crit", "proc", "pg", "pkg", "alert", "acc", "cr", "cal", "req", "cell", "secret", "cfg", "date", "pot", "der", "ret", "ptr", "ca", "pub", "cat", "mod", "cur", "test", "obj", "ctr", "ver", "conn", "car", "def"], "rv": ["srv", " rve", "rrve", "rvd", "rbvr", "prvr", "rbvd", "crv", "crve", "srm", "errv", "rbv", "rvr", "crvr", "rbf", "srvr", "rf", " rm", "prf", " rvd", "rrvr", "crf", " rvr", " rf", "errf", "prv", "rve", "srve", "rrv", "rrm", "errvd", "errvr", "rm", "prve"]}}
{"project": "qemu", "commit_id": "9be385980d37e8f4fd33f605f5fb1c3d144170a8", "target": 0, "func": "static uint64_t megasas_fw_time(void)\n\n{\n\n    struct tm curtime;\n\n    uint64_t bcd_time;\n\n\n\n    qemu_get_timedate(&curtime, 0);\n\n    bcd_time = ((uint64_t)curtime.tm_sec & 0xff) << 48 |\n\n        ((uint64_t)curtime.tm_min & 0xff)  << 40 |\n\n        ((uint64_t)curtime.tm_hour & 0xff) << 32 |\n\n        ((uint64_t)curtime.tm_mday & 0xff) << 24 |\n\n        ((uint64_t)curtime.tm_mon & 0xff)  << 16 |\n\n        ((uint64_t)(curtime.tm_year + 1900) & 0xffff);\n\n\n\n    return bcd_time;\n\n}\n", "idx": 5587, "substitutes": {"curtime": ["grdate", "currentdate", "currenttimer", "curTime", "urresponse", "cmprate", "thinkdate", "clientresponse", " curTime", "closeword", "curdata", " curinstance", "Curtime", "charitem", "urdate", " curdata", "Curtimer", " curtimer", "curtim", "cmdtime", "curtimer", " curcase", "conttime", "currule", "closecase", "curcase", "currenttime", "closetime", " curtim", "Curdate", "grtim", "curresponse", "objtime", "CurTime", "urrule", "chartime", "curdate", "cmdword", "clientitem", "conttim", "curword", "charresponse", "grtimer", "pubword", "urinstance", "cmpword", "curitem", "curinstance", "conttimer", "urrate", "thinkmetadata", "urpost", "thinkpost", "ctrltimeout", "pubtime", "pubcase", "urword", "contdate", "ctrrate", "ctrtime", "pubdata", "clientword", "objcase", "uritem", "curtimeout", "ctrlcase", "thinktime", "curmetadata", "cmdinstance", "curpost", "cmprule", "closedata", " curtimeout", "objtimeout", "urmetadata", "urtime", "ctrldata", " curmetadata", "clienttime", " curword", "charword", " curdate", "grtime", " curpost", "ctrrule", "cmddate", "objdata", "ctrltime", "currate", "ctrword", "cmptime", "currentTime"], "bcd_time": ["bcdamtime", "bcd_Time", "bcdjTime", "bdd_rate", "bdd_time", "bCD_time", "bcdtrate", "bcd_rate", "bdd_Time", "bcdtTime", "bcdjcode", "bcdamrate", "bcdamvalue", "bcdtvalue", "bcdamTime", "bpd_rate", "bcd_times", "bpd_time", "bcd_value", "bcdttime", "bcdjrate", "bcd_code", "bcdjtime", "bpd_code", "bCD_t", "bcd_t", "bCD_times", "bpd_Time", "bCD_data", "bcd_data", "bdd_value"]}}
{"project": "qemu", "commit_id": "107e4b352cc309f9bd7588ef1a44549200620078", "target": 1, "func": "static OfDpaFlow *of_dpa_flow_alloc(uint64_t cookie)\n\n{\n\n    OfDpaFlow *flow;\n\n    int64_t now = qemu_clock_get_ms(QEMU_CLOCK_VIRTUAL) / 1000;\n\n\n\n    flow = g_new0(OfDpaFlow, 1);\n\n    if (!flow) {\n\n        return NULL;\n\n    }\n\n\n\n    flow->cookie = cookie;\n\n    flow->mask.tbl_id = 0xffffffff;\n\n\n\n    flow->stats.install_time = flow->stats.refresh_time = now;\n\n\n\n    return flow;\n\n}\n", "idx": 5607, "substitutes": {"cookie": ["policy", "pid", "gc", "magic", "copy", "node", "ookie", "metadata", "mem", "jar", "window", "term", " Cookie", "cmp", "binary", "kind", "store", "stay", "login", "cycle", "table", "cmd", "domain", "chip", "label", "cb", "uid", "key", "callback", "keeper", "id", "attr", "remember", "timeout", "cook", "code", "token", "cn", "sid", "cell", "company", "tmp", "entry", "batch", " cookies", "cache", "session", "mask", "aco", "lock", "name", "flag", "bin"], "flow": ["draw", "event", "way", "step", "low", "feed", "scope", "tower", "goal", "order", "queue", "fp", "w", "forward", "qa", "fine", "bridge", "foo", "batch", "loop", "message", "down", "payment", "Flow", "q", "mill", "instance", "flash", "up", "zip", "board", "control", "send", "out", "ow", "grab", "command", "frame", "stream", "load", "port", "loss", "ward", "pool", "hold", "relation", "cf", "aw", "export", "channel", "flake", "card", "loader", "import", "bolt", "usage", "plant", "container", "lif", "cell", "session", "fail", "flows", "form", "call", "window", "access", "fee", "buffer", "cow", "OW", "foreign", "row", "fl", "future", "wall", "df", "new", "tf", "f", "allow", "lock", "fw", "transfer", "sequence"]}}
{"project": "FFmpeg", "commit_id": "fc9b22dd2e5de851a89245b5357e710b93587278", "target": 0, "func": "static int rtp_open(URLContext *h, const char *uri, int flags)\n\n{\n\n    RTPContext *s;\n\n    int port, is_output, ttl, local_port;\n\n    char hostname[256];\n\n    char buf[1024];\n\n    char path[1024];\n\n    const char *p;\n\n\n\n    is_output = (flags & URL_WRONLY);\n\n\n\n    s = av_mallocz(sizeof(RTPContext));\n\n    if (!s)\n\n        return AVERROR(ENOMEM);\n\n    h->priv_data = s;\n\n\n\n    url_split(NULL, 0, NULL, 0, hostname, sizeof(hostname), &port,\n\n              path, sizeof(path), uri);\n\n    /* extract parameters */\n\n    ttl = -1;\n\n    local_port = -1;\n\n    p = strchr(uri, '?');\n\n    if (p) {\n\n        if (find_info_tag(buf, sizeof(buf), \"ttl\", p)) {\n\n            ttl = strtol(buf, NULL, 10);\n\n        }\n\n        if (find_info_tag(buf, sizeof(buf), \"localport\", p)) {\n\n            local_port = strtol(buf, NULL, 10);\n\n        }\n\n    }\n\n\n\n    build_udp_url(buf, sizeof(buf),\n\n                  hostname, port, local_port, ttl);\n\n    if (url_open(&s->rtp_hd, buf, flags) < 0)\n\n        goto fail;\n\n    local_port = udp_get_local_port(s->rtp_hd);\n\n    /* XXX: need to open another connection if the port is not even */\n\n\n\n    /* well, should suppress localport in path */\n\n\n\n    build_udp_url(buf, sizeof(buf),\n\n                  hostname, port + 1, local_port + 1, ttl);\n\n    if (url_open(&s->rtcp_hd, buf, flags) < 0)\n\n        goto fail;\n\n\n\n    /* just to ease handle access. XXX: need to suppress direct handle\n\n       access */\n\n    s->rtp_fd = udp_get_file_handle(s->rtp_hd);\n\n    s->rtcp_fd = udp_get_file_handle(s->rtcp_hd);\n\n\n\n    h->max_packet_size = url_get_max_packet_size(s->rtp_hd);\n\n    h->is_streamed = 1;\n\n    return 0;\n\n\n\n fail:\n\n    if (s->rtp_hd)\n\n        url_close(s->rtp_hd);\n\n    if (s->rtcp_hd)\n\n        url_close(s->rtcp_hd);\n\n    av_free(s);\n\n    return AVERROR(EIO);\n\n}\n", "idx": 5617, "substitutes": {"h": ["ph", "b", "c", "http", "here", "kh", "comm", "oh", "ht", "bh", "eh", "hw", "t", "history", "dh", "w", "th", "rh", "k", "v", "ah", "host", "handle", "sh", "m", "hs", "he", "y", "ih", "hm", "hd", "l", "hash", "hl", "H", "ssh", "hh", "x", "hr", "hp"], "uri": ["filename", "q", "uni", "prefix", "http", "u", "i", "description", "qi", "ip", " URI", "href", "domain", "connection", "picture", "vp", "url", "fp", "ri", "username", "query", "ui", "resource", "route", "password", "qu", "URI", "uu", "remote", "ur", "address", "message", "subject", "html", "iri", "format", "origin", "name"], "flags": ["members", "fields", "alf", "weights", "affles", " Flags", "wcs", "amps", "ats", "ags", "ints", "locks", "kind", "aps", "acts", "pins", "frames", "ms", "details", "ports", "settings", "ts", "bugs", "uses", "fps", "vals", "types", "options", "atts", "params", "planes", "properties", "stats", "tags", "args", "mates", "bits", "status", "vs", "Flags", "FLAG", "limits", "cond", "lbs", "mask", "parts", "fs", "heads", "posts", "packages", "doms", "features", "faces", "flag"], "s": ["sw", "less", "c", "sc", "self", "ps", "d", "ts", "settings", "t", "se", "js", "w", "sb", "ss", "south", "socket", "j", "as", "rs", "so", "ses", "sam", "https", "os", "g", "ms", "es", "v", "stats", "m", "sa", "vs", "serv", "us", "aws", "a", "l", "ops", "gs", "ssl", "ns", "ats", "cs", "comm", "is", "has", "o", "r", "sv", "hs", "st", "bs", "y", "sq", "fs", "S", "sp", "b", "its", "i", "qs", "sys", "als", "n", "ds", "ins", "ls", "ims", "sh", "args", "sl", "status", "spec", "f", "e", "sts", "z"], "port": ["pport", "pid", "ort", "ORT", "window", "cp", "channel", "type", "http", "eport", "direction", "pad", "page", "state", "client", "file", "ip", "ported", "order", "connection", "Port", "duration", "ports", "len", "row", "index", "line", "queue", "t", "key", "server", "pi", "pe", "number", "limit", "PORT", "id", "pos", "position", "trace", "proxy", "pr", "timeout", "device", "host", "v", "priority", "component", " sport", "version", "ptr", "batch", "socket", "address", "count", "size", "length", "database", " Port"], "is_output": [" is_network", "is__enabled", "is_hidden", "Is_hidden", "is_input", " is_input", "is__output", "is__input", "Is_output", "is_network", "Is_input", " is_hidden", "Is_enabled", "is__hidden", "is_enabled"], "ttl": ["gtm", "payl", "etttl", "TTol", "ntm", "rtll", "attd", "attnl", "tll", "TTl", "payll", "nttl", "ottl", "otl", "tdtl", "tttl", "otol", "tl", "ttll", "ntol", "ettl", "paytl", "ettol", "rttl", "tdl", "traceol", "ott", "tltl", "traced", "ttm", "attol", "ttol", "ttnl", "gtol", "otL", "payol", "TTt", "rtl", "rtol", "tld", "ttd", "ttt", "tracel", "ettll", "gtl", "TTtl", "otnl", "tL", "TTL", "ttL", "attl", "tracetl", "TTm", "tdol", "gttl", "ntl", "atttl", "tdnl", "tt", "tlol"], "local_port": ["sameLocalports", "localLocalport", "same_Port", "local_ort", "local_server", " local_ports", "sameLocalport", "sameLocalPort", " local_peer", " local_server", "local___ports", "localLocalports", "local_pport", " local_ort", "localLocalpport", " local_Port", "local_ports", "local_PORT", "same_pport", "sameLocalpport", "local___port", "local_boat", " local_boat", "same_ports", " local_PORT", "localLocalPort", "local_peer", "local___peer", "same_port", "local_Port"], "hostname": [" hostName", "hostName", "nickna", "Hostna", "HostName", " hostnum", "bindName", "hostnumber", "Hostnames", "domainnumber", "Hostname", " hostnumber", " hostna", "ipno", "hostna", "nickName", " hostno", "ipnum", "hostnames", "hostno", "domainname", "ostName", "ipName", "Hostame", "bindname", "nickname", "bindame", "domainnames", "domainName", "hostame", "ostnumber", "bindnames", "Hostnumber", "ostname", "Hostno", " hostame", " hostnames", "hostnum", "ipname", "Hostnum"], "buf": ["bag", "bytes", "uv", "uf", "late", "bed", "addr", "cb", "queue", "fp", "trace", "pg", "iter", "txt", "fb", "tmp", "batch", "cur", "bin", "buff", "mem", "cam", "pad", "wb", "rw", "str", "rb", "dir", "nb", "pool", "desc", "np", "conv", "length", "text", "vec", "xff", "db", "end", "ctx", "bc", "Buffer", "comm", "msg", "map", "usr", "r", "bar", "pkg", "Buff", "cfg", "cv", "ba", "cast", "filename", "b", "bn", "window", "cp", "pb", "br", "box", "mat", "buffer", "raw", "cmd", "bp", "vp", "eng", "data", "bt", "err", "proc", "cap", "ptr", "img", "doc", "cache"], "path": ["package", "user", "pid", "chain", "root", "PATH", "prefix", "type", "binary", "client", "file", "template", "prop", "base", "cmd", "stat", "body", "url", "context", "pointer", "full", "key", "history", "server", "id", "pkg", "rev", "route", "host", "component", "Path", "config", "dir", "part", "pattern", "ath", "alias", "desc", "time", "info", "length", "format", "text", "name"], "p": ["ph", "pid", "q", "sp", "b", "wp", "cp", "ping", "pb", "c", "u", "pc", "rep", "i", "pt", "prop", "ps", "pa", "pat", "d", "n", "vp", "op", "o", "data", "t", "fp", "r", "pre", "pg", "pkg", "ap", "pr", "lp", "v", "m", "jp", "np", "f", "pn", "pp", "P", "a", "tp", "l"]}}
{"project": "FFmpeg", "commit_id": "01ecb7172b684f1c4b3e748f95c5a9a494ca36ec", "target": 1, "func": "static float get_band_cost_UPAIR7_mips(struct AACEncContext *s,\n\n                                       PutBitContext *pb, const float *in,\n\n                                       const float *scaled, int size, int scale_idx,\n\n                                       int cb, const float lambda, const float uplim,\n\n                                       int *bits)\n\n{\n\n    const float Q34 = ff_aac_pow34sf_tab[POW_SF2_ZERO - scale_idx + SCALE_ONE_POS - SCALE_DIV_512];\n\n    const float IQ  = ff_aac_pow2sf_tab [POW_SF2_ZERO + scale_idx - SCALE_ONE_POS + SCALE_DIV_512];\n\n    int i;\n\n    float cost = 0;\n\n    int qc1, qc2, qc3, qc4;\n\n    int curbits = 0;\n\n\n\n    uint8_t *p_bits  = (uint8_t *)ff_aac_spectral_bits[cb-1];\n\n    float   *p_codes = (float   *)ff_aac_codebook_vectors[cb-1];\n\n\n\n    for (i = 0; i < size; i += 4) {\n\n        const float *vec, *vec2;\n\n        int curidx, curidx2, sign1, count1, sign2, count2;\n\n        int   *in_int = (int   *)&in[i];\n\n        float *in_pos = (float *)&in[i];\n\n        float di0, di1, di2, di3;\n\n        int t0, t1, t2, t3, t4;\n\n\n\n        qc1 = scaled[i  ] * Q34 + ROUND_STANDARD;\n\n        qc2 = scaled[i+1] * Q34 + ROUND_STANDARD;\n\n        qc3 = scaled[i+2] * Q34 + ROUND_STANDARD;\n\n        qc4 = scaled[i+3] * Q34 + ROUND_STANDARD;\n\n\n\n        __asm__ volatile (\n\n            \".set push                                          \\n\\t\"\n\n            \".set noreorder                                     \\n\\t\"\n\n\n\n            \"ori        %[t4],      $zero,      7               \\n\\t\"\n\n            \"ori        %[sign1],   $zero,      0               \\n\\t\"\n\n            \"ori        %[sign2],   $zero,      0               \\n\\t\"\n\n            \"slt        %[t0],      %[t4],      %[qc1]          \\n\\t\"\n\n            \"slt        %[t1],      %[t4],      %[qc2]          \\n\\t\"\n\n            \"slt        %[t2],      %[t4],      %[qc3]          \\n\\t\"\n\n            \"slt        %[t3],      %[t4],      %[qc4]          \\n\\t\"\n\n            \"movn       %[qc1],     %[t4],      %[t0]           \\n\\t\"\n\n            \"movn       %[qc2],     %[t4],      %[t1]           \\n\\t\"\n\n            \"movn       %[qc3],     %[t4],      %[t2]           \\n\\t\"\n\n            \"movn       %[qc4],     %[t4],      %[t3]           \\n\\t\"\n\n            \"lw         %[t0],      0(%[in_int])                \\n\\t\"\n\n            \"lw         %[t1],      4(%[in_int])                \\n\\t\"\n\n            \"lw         %[t2],      8(%[in_int])                \\n\\t\"\n\n            \"lw         %[t3],      12(%[in_int])               \\n\\t\"\n\n            \"slt        %[t0],      %[t0],      $zero           \\n\\t\"\n\n            \"movn       %[sign1],   %[t0],      %[qc1]          \\n\\t\"\n\n            \"slt        %[t2],      %[t2],      $zero           \\n\\t\"\n\n            \"movn       %[sign2],   %[t2],      %[qc3]          \\n\\t\"\n\n            \"slt        %[t1],      %[t1],      $zero           \\n\\t\"\n\n            \"sll        %[t0],      %[sign1],   1               \\n\\t\"\n\n            \"or         %[t0],      %[t0],      %[t1]           \\n\\t\"\n\n            \"movn       %[sign1],   %[t0],      %[qc2]          \\n\\t\"\n\n            \"slt        %[t3],      %[t3],      $zero           \\n\\t\"\n\n            \"sll        %[t0],      %[sign2],   1               \\n\\t\"\n\n            \"or         %[t0],      %[t0],      %[t3]           \\n\\t\"\n\n            \"movn       %[sign2],   %[t0],      %[qc4]          \\n\\t\"\n\n            \"slt        %[count1],  $zero,      %[qc1]          \\n\\t\"\n\n            \"slt        %[t1],      $zero,      %[qc2]          \\n\\t\"\n\n            \"slt        %[count2],  $zero,      %[qc3]          \\n\\t\"\n\n            \"slt        %[t2],      $zero,      %[qc4]          \\n\\t\"\n\n            \"addu       %[count1],  %[count1],  %[t1]           \\n\\t\"\n\n            \"addu       %[count2],  %[count2],  %[t2]           \\n\\t\"\n\n\n\n            \".set pop                                           \\n\\t\"\n\n\n\n            : [qc1]\"+r\"(qc1), [qc2]\"+r\"(qc2),\n\n              [qc3]\"+r\"(qc3), [qc4]\"+r\"(qc4),\n\n              [sign1]\"=&r\"(sign1), [count1]\"=&r\"(count1),\n\n              [sign2]\"=&r\"(sign2), [count2]\"=&r\"(count2),\n\n              [t0]\"=&r\"(t0), [t1]\"=&r\"(t1), [t2]\"=&r\"(t2), [t3]\"=&r\"(t3),\n\n              [t4]\"=&r\"(t4)\n\n            : [in_int]\"r\"(in_int)\n\n            : \"memory\"\n\n        );\n\n\n\n        curidx = 8 * qc1;\n\n        curidx += qc2;\n\n\n\n        curidx2 = 8 * qc3;\n\n        curidx2 += qc4;\n\n\n\n        curbits += p_bits[curidx];\n\n        curbits += upair7_sign_bits[curidx];\n\n        vec     = &p_codes[curidx*2];\n\n\n\n        curbits += p_bits[curidx2];\n\n        curbits += upair7_sign_bits[curidx2];\n\n        vec2    = &p_codes[curidx2*2];\n\n\n\n        __asm__ volatile (\n\n            \".set push                                          \\n\\t\"\n\n            \".set noreorder                                     \\n\\t\"\n\n\n\n            \"lwc1       %[di0],     0(%[in_pos])                \\n\\t\"\n\n            \"lwc1       %[di1],     4(%[in_pos])                \\n\\t\"\n\n            \"lwc1       %[di2],     8(%[in_pos])                \\n\\t\"\n\n            \"lwc1       %[di3],     12(%[in_pos])               \\n\\t\"\n\n            \"abs.s      %[di0],     %[di0]                      \\n\\t\"\n\n            \"abs.s      %[di1],     %[di1]                      \\n\\t\"\n\n            \"abs.s      %[di2],     %[di2]                      \\n\\t\"\n\n            \"abs.s      %[di3],     %[di3]                      \\n\\t\"\n\n            \"lwc1       $f0,        0(%[vec])                   \\n\\t\"\n\n            \"lwc1       $f1,        4(%[vec])                   \\n\\t\"\n\n            \"lwc1       $f2,        0(%[vec2])                  \\n\\t\"\n\n            \"lwc1       $f3,        4(%[vec2])                  \\n\\t\"\n\n            \"nmsub.s    %[di0],     %[di0],     $f0,    %[IQ]   \\n\\t\"\n\n            \"nmsub.s    %[di1],     %[di1],     $f1,    %[IQ]   \\n\\t\"\n\n            \"nmsub.s    %[di2],     %[di2],     $f2,    %[IQ]   \\n\\t\"\n\n            \"nmsub.s    %[di3],     %[di3],     $f3,    %[IQ]   \\n\\t\"\n\n\n\n            \".set pop                                           \\n\\t\"\n\n\n\n            : [di0]\"=&f\"(di0), [di1]\"=&f\"(di1),\n\n              [di2]\"=&f\"(di2), [di3]\"=&f\"(di3)\n\n            : [in_pos]\"r\"(in_pos), [vec]\"r\"(vec),\n\n              [vec2]\"r\"(vec2), [IQ]\"f\"(IQ)\n\n            : \"$f0\", \"$f1\", \"$f2\", \"$f3\",\n\n              \"memory\"\n\n        );\n\n\n\n        cost += di0 * di0 + di1 * di1\n\n                + di2 * di2 + di3 * di3;\n\n    }\n\n\n\n    if (bits)\n\n        *bits = curbits;\n\n    return cost * lambda + curbits;\n\n}\n", "idx": 5621, "substitutes": {"s": ["as", "rs", "sp", "gs", "ssl", "sg", "ns", "c", "cs", "sc", "ps", "p", "ds", "es", "w", "sv", "sb", "sl", "sa", "ss", "bs", "sn", "sq", "fs", "e", "sts", "a"], "pb": ["uf", "cp", "pc", "ctx", "p", "pa", "bp", "vp", "pl", "fp", "BP", "lb", "pm", "sb", "rb", "lp", "bf", "bps", "xb", "nb", "cv", "np", "pp", "bm", "tk", "tp", "tc", "mp"], "in": ["init", "all", "aled", "tin", "nin", "ar", "it", "mat", "con", "isin", "In", "raw", "at", "p", "add", "vin", "is", "ind", "data", "input", "din", "ins", "pos", "IN", "out", "inf", "m", "rin", "config", "ac", "scan", "gin", "mc", "conv", "sum", "gen", "pin", "params", "inc", "inn", "bin"], "scaled": ["staled", "escaped", "escaled", "shalled", "escanned", "escalled", "SCale", "escaling", " unscalled", "scashed", "scaling", " unscaled", "descanned", "scalled", "shaled", " scanned", "escales", "shashed", "shaved", "scales", " scashed", "Scaled", " scalled", "shaling", "descaled", "scale", "shale", "scanned", "SCaped", "SCaved", " unscaved", "stale", "shanned", " scale", "staped", "escashed", "Scalled", "SCaling", "SCalled", "stalled", "descalled", "scaped", " unscaling", "Scales", "scaved", " scales", "escale", "SCaled", "descaling", "Scanned", " scaling"], "size": ["bytes", "ci", "SIZE", "fee", "c", "shift", "Size", "offset", "set", "sc", "cs", "see", "g", "si", "cm", "score", "len", "name", "win", "range", "pi", "scale", "send", "mode", "code", "dim", "small", "m", "ze", "sn", "area", "count", "np", "shape", "ize", "iz", "check", "length", "z", "l", "loc"], "scale_idx": ["scale_Idy", "scale_idexs", "scale_infox", "scale_ideX", "scale_itw", "scale_infow", "scale_idxs", "scale_idy", "scale_itX", "scale_Idxs", "scale_infoX", "scale_infoco", "scale_idX", "scale_Idx", "scale_idw", "scale_itco", "scale_IdX", "scale_idey", "scale_Idw", "scale_idco", "scale_idex", "scale_itx", "scale_Idco"], "cb": ["ck", "db", "cf", "gb", "dc", "gc", "cp", "conf", "cli", "ctx", "bc", "sc", "oi", "ob", "cor", "fc", "bp", "nc", "lc", "wb", "callback", "bound", "lb", "cc", "rc", "bb", "sb", "rb", "bf", "cr", "cfg", "cell", "cale", "nb", "CB", "bs", "cv", "cd", "tc", "ctr", "coord", "ctrl", "cu", "crop", "loc"], "lambda": ["aug", " nu", "Lim", "Alpha", "lr", "Lu", "alpha", "beta", " gamma", "lam", "lu", "eye", "elta", "nu", "mas", " lam", "mu", "dB", "phi", "igma", "ima", "appa", "mega", "tap", "pha", "Mu", "da"], "uplim": ["uselib", "iuplim", "iuppims", "iuppib", "uppims", "iuppom", "uselim", "uphim", "uppim", "uphib", "iuplib", "iuppim", "iuplom", "uplib", "uselims", "uselom", "uppib", "uphom", "iuplims", "uphims", "uppom", "uplom", "uplims"], "bits": ["bytes", "gs", "bis", "ns", "items", "its", "ats", "ints", "qs", "cs", "pins", "rows", "vals", "bit", "ins", "ls", "blocks", "xs", "units", "bps", "outs", "codes", "bs", "limits", "fs", "heads", "flags"], "i": ["init", "this", "ic", "ini", "ij", "asi", " bi", "ei", "ci", "b", " ii", "uri", "it", "im", "c", "u", "cli", "oi", "gi", "mi", "ip", "li", "p", "si", "zi", "n", "is", "xi", "ind", "index", "o", "t", " ti", "bi", "pi", "multi", "go", "ri", "me", "id", "ui", "ki", "slice", "ji", "err", "hi", "phi", "ti", "v", "ims", "iii", "ix", " j", "ai", "m", "status", "I", "batch", "y", "\u0438", "f", "sim", "iu", "info", "j", "di", "x", "ii", "l"], "qc1": [" qr1", "qr2", "qut3", "qunc8", "qunc1", "qrc1", "qrc3", "qlc1", "qr0", "qr1", "qunc2", " qr0", " qr2", "quc3", "qlc0", "qrc5", "qut1", " qc0", " qc8", "qunc0", "quc1", "quc0", "qlc3", "qc0", " qr8", "qt5", "qrc8", "qr8", "qrc2", "quc5", "qc8", "qut0", "qc5", "qt0", "qut5", "qt3", "qt1", "qlc5", "qrc0"], "qc2": ["eqlcTwo", "qcr6", "Qt6", "qlc4", "qc6", "QtTwo", "qcc1", "qlcTwo", "qcc6", "Qc2", "qunc22", "qcc2", "qec2", "QcTwo", "qt2", "qecTwo", "eqc4", "qunc2", "qt6", "eqcTwo", "qec22", "qunc4", "eqlc4", "Qc1", "eqlc22", "qec4", "eqc2", "qlc22", "quncTwo", "Qt2", "qcr1", "eqc22", "qcTwo", "qtTwo", "Qt1", "qlc2", "qt1", "qcr2", "eqlc2", "qccTwo", "qc22", "Qc6", "qcrTwo"], "qc3": ["qupc2", "qupc43", "qtthree", "quc8", "qcthree", "qupcthree", "qcThree", "quc2", "qpc43", "qupc3", "qpc2", "qn3", "qt2", "qt43", "qarcthree", "qufc3", "qdc3", "qdcThree", "qpcthree", "quc3", "qfc3", "qarc43", "qucthree", "quc43", "qarc2", "qfc4", "qfc8", "qarc3", "qn8", "qdc4", "qucThree", "qc43", "qufc8", "qfcThree", "qdc8", "qnThree", "qc8", "qufc4", "qufcThree", "qn4", "qt3", "qpc3", "quc4"], "qc4": ["Qc44", "qr4", "ql8", "ql2", "qr2", "Qc8", "Qt4", " qn8", "Qt44", "Qc2", " qn2", "qt2", "qt4", "qcr4", "qn2", "qt8", "qn5", " qc8", "Qt2", "Qc4", "qn8", "ql44", "qt44", "qcr44", "qt5", "qr5", "qcr8", "qr8", " qn5", "ql4", "qc8", "qc5", "qn4", "Qt8", "qcr2", " qc5", "qc44", " qn4"], "p_bits": ["np_its", "p__codes", "p__bits", "p_ints", "np_codes", "np_bits", "np_ints", "p_its", "p__its", "p__ints"], "p_codes": [" p_code", " p_ops", "p_code", "p_names", "p_ops", " p_names"], "vec": ["iv", "ev", "q", "mat", "buf", "sc", "vector", "ve", "cs", "seq", "vol", "vert", "ec", "var", "val", "vals", "col", "v", "spec", "vis", "vc", "cv", "conv", "res", "ver", "act", "bin"], "vec2": [" vec1", "vec6", "vol2", "vec1", "vol1", "cv1", "cv6", " vec6", "cv2", "cv3", "vec3", "vol3", " vec3", "vol6"], "curidx": ["curIdex", "curidy", "curidk", "curridx", "CurIdk", "Curidx", "curidex", "curidsk", "curridex", "curIdx", "CurIdy", "curidsex", "CurIdx", "curridy", "curIdk", "Curidex", "curridk", "Curidk", "CurIdex", "curidsy", "Curidy", "curIdy", "curidsx"], "curidx2": ["curidex4", "curidex1", "curidy2", "curindx2", "curidxt4", "curidex0", "curidxt2", "curindx4", "curindxt2", "curidy1", "curidex2", "curindxt1", "curindx1", "curidx4", "curindxt4", "curidy0", "curindx0", "curidy4", "curindxt0", "curidx0", "curidx1", "curidxt1", "curidxt0"], "sign1": [" sign3", "sum01", "Sign1", "Sign01", "sum1", "Sign3", "sign01", " sign01", "sum3", "sign3"], "count1": ["cycleone", "countone", "collectx", "countx", "collect0", "collect1", " countx", "cycle1", " countone", "cycle0", "cyclex", "count0", "collectone", " count0"], "sign2": ["sign0", "sum2", "sum6", "score6", "sum1", "score1", "sign6", " sign6", " sign0", "sum0", "score0", "score2"], "count2": ["count3", "Count3", " count5", "sum02", " count3", "count5", "sum2", " count02", "Count2", "Count02", "sum3", "Count5", "count02", "sum5"], "in_int": ["in___int", "in_str", "in___float", "out_int", "in___ind", "out_str", "in_float", "out_float", "in___str", "in_ind", "out_ind"], "in_pos": ["in2pos", "in_cos", "in2int", "out_position", "out_pos", "in_position", "out_int", "in2cos", "out_cos", "in2position"], "di0": [" di50", "di50", "ci0", "Di50", "Di0", "ci1", "Di1", "ci3", "Di3", "ci50"], "di1": ["si0", " diOne", "diOne", "di4", "si4", "chi4", "chi0", "chi1", "si1", " di4", "siOne", "chiOne"], "di2": [" di5", "i5", "Di5", "Di6", "di4", "di6", "Di4", "i4", "Di2", "i2", "i6", "di5", " di6", " di4"], "di3": ["Di03", "di4", "i03", "i3", "Di8", "di8", "Di4", "i4", " di8", "i8", "Di3", " di4", " di03", "di03"], "t0": ["at00", " t00", "at1", "t00", "y00", "y1", "y0", "at0"], "t1": ["tt1", "T0", "te01", "T01", "T1", "tt0", "te1", "te0", "t01", "tt91", "t91", "T91", "te91", "tt01"], "t2": ["tt1", "dt2", "tttwo", "dttwo", "dt102", "tt102", "T1", "dt1", "tt2", "ttwo", "t102", "Ttwo", "T102", "T2"], "t3": ["t03", "t6", "et03", "tthree", "vthree", "v03", " t6", "v3", " t03", " tthree", "et3", "et6", "etthree", "v6"], "t4": ["Tfour", "T4", "int5", "int3", "T3", "int4", " t5", "t5", " tfour", "intfour", "tfour", "T5"]}}
{"project": "qemu", "commit_id": "c1990ebfa11265d3aa9b6a4d5d1a02bd3f9ac5c6", "target": 1, "func": "QObject *json_parser_parse_err(QList *tokens, va_list *ap, Error **errp)\n\n{\n\n    JSONParserContext ctxt = {};\n\n    QList *working = qlist_copy(tokens);\n\n    QObject *result;\n\n\n\n    result = parse_value(&ctxt, &working, ap);\n\n\n\n    QDECREF(working);\n\n\n\n    error_propagate(errp, ctxt.err);\n\n\n\n    return result;\n\n}\n", "idx": 5624, "substitutes": {"tokens": ["tocens", "Tokens", "targens", "targets", "tokskens", "tokkens", "tolENS", "tokentials", "stokkens", "Tokkens", "tolentials", "TocENS", "targkens", "tolkens", "Tokentials", "toksets", "stockens", "Tocentials", "tocets", "tokets", "tojkens", "tocentials", "tokENS", "toksens", "Tockens", "tokents", "tockens", "tolens", "tojENS", "tojens", "tocents", "stokets", "stocens", "stocents", "targents", "toksents", "stokens", "Tocens", "tocENS", "stokents", "TokENS", "tojentials", "stocets"], "ap": ["apa", "et", " AP", "app", "ar", "ab", "att", " sp", "av", "aps", "ip", "p", "pa", "arp", "ep", "api", "Ap", "ipp", "cap", "hap", "ac", "al", " sap", "am", "tap", "apt", "amp", "ag", "ing", "snap", "AP", " rap", "apping", "appy", "gap", "ape", "mp"], "errp": [" errP", " errps", "dieP", "erp", "erpat", "errps", " errpat", "eorps", "errpy", "diep", "errpa", "dangerP", "erps", "dangerpa", "dangerpy", "errP", "errpat", "dangerp", "diepy", "eorP", " errpa", "diepa", "erP", " errpy", "eorp", "eorpat"], "working": ["playing", "padding", "winning", "worked", "ching", "thinking", "Working", "using", "acting", "workers", "aux", "processing", "being", "testing", "looking", "picked", "ending", "ordering", "facing", "works", "learning", "including", "worker", "tx", "opening", "starting", "loading", "picking", "walking", "tmp", "moving", "xp", "existing", "ing", "checking", "running", "work", "packing", "standing", "going"], "result": ["output", "mate", "this", "package", "success", "all", "event", "match", "next", "results", "root", "instance", "Result", "self", "valid", "goal", "same", "the", "p", "data", "total", "r", "master", "nil", "successful", "out", "that", "complete", "final", "new", "either", "answer", "ret", "response", "tmp", "cache", "f", "cur", "test", "obj", "message", "current", "unknown", "res", "work", "json", "other", "object"]}}
{"project": "qemu", "commit_id": "6817efea3a0d1bf87be815970cdb014c5a64b628", "target": 1, "func": "static int init_directories(BDRVVVFATState* s,\n\n                            const char *dirname, int heads, int secs,\n\n                            Error **errp)\n\n{\n\n    bootsector_t* bootsector;\n\n    mapping_t* mapping;\n\n    unsigned int i;\n\n    unsigned int cluster;\n\n\n\n    memset(&(s->first_sectors[0]),0,0x40*0x200);\n\n\n\n    s->cluster_size=s->sectors_per_cluster*0x200;\n\n    s->cluster_buffer=g_malloc(s->cluster_size);\n\n\n\n    /*\n\n     * The formula: sc = spf+1+spf*spc*(512*8/fat_type),\n\n     * where sc is sector_count,\n\n     * spf is sectors_per_fat,\n\n     * spc is sectors_per_clusters, and\n\n     * fat_type = 12, 16 or 32.\n\n     */\n\n    i = 1+s->sectors_per_cluster*0x200*8/s->fat_type;\n\n    s->sectors_per_fat=(s->sector_count+i)/i; /* round up */\n\n\n\n    s->offset_to_fat = s->offset_to_bootsector + 1;\n\n    s->offset_to_root_dir = s->offset_to_fat + s->sectors_per_fat * 2;\n\n\n\n    array_init(&(s->mapping),sizeof(mapping_t));\n\n    array_init(&(s->directory),sizeof(direntry_t));\n\n\n\n    /* add volume label */\n\n    {\n\n        direntry_t* entry=array_get_next(&(s->directory));\n\n        entry->attributes=0x28; /* archive | volume label */\n\n        memcpy(entry->name, s->volume_label, sizeof(entry->name));\n\n    }\n\n\n\n    /* Now build FAT, and write back information into directory */\n\n    init_fat(s);\n\n\n\n    s->cluster_count=sector2cluster(s, s->sector_count);\n\n\n\n    mapping = array_get_next(&(s->mapping));\n\n    mapping->begin = 0;\n\n    mapping->dir_index = 0;\n\n    mapping->info.dir.parent_mapping_index = -1;\n\n    mapping->first_mapping_index = -1;\n\n    mapping->path = g_strdup(dirname);\n\n    i = strlen(mapping->path);\n\n    if (i > 0 && mapping->path[i - 1] == '/')\n\n        mapping->path[i - 1] = '\\0';\n\n    mapping->mode = MODE_DIRECTORY;\n\n    mapping->read_only = 0;\n\n    s->path = mapping->path;\n\n\n\n    for (i = 0, cluster = 0; i < s->mapping.next; i++) {\n\n        /* MS-DOS expects the FAT to be 0 for the root directory\n\n         * (except for the media byte). */\n\n        /* LATER TODO: still true for FAT32? */\n\n        int fix_fat = (i != 0);\n\n        mapping = array_get(&(s->mapping), i);\n\n\n\n        if (mapping->mode & MODE_DIRECTORY) {\n\n            mapping->begin = cluster;\n\n            if(read_directory(s, i)) {\n\n                error_setg(errp, \"Could not read directory %s\",\n\n                           mapping->path);\n\n                return -1;\n\n            }\n\n            mapping = array_get(&(s->mapping), i);\n\n        } else {\n\n            assert(mapping->mode == MODE_UNDEFINED);\n\n            mapping->mode=MODE_NORMAL;\n\n            mapping->begin = cluster;\n\n            if (mapping->end > 0) {\n\n                direntry_t* direntry = array_get(&(s->directory),\n\n                        mapping->dir_index);\n\n\n\n                mapping->end = cluster + 1 + (mapping->end-1)/s->cluster_size;\n\n                set_begin_of_direntry(direntry, mapping->begin);\n\n            } else {\n\n                mapping->end = cluster + 1;\n\n                fix_fat = 0;\n\n            }\n\n        }\n\n\n\n        assert(mapping->begin < mapping->end);\n\n\n\n        /* next free cluster */\n\n        cluster = mapping->end;\n\n\n\n        if(cluster > s->cluster_count) {\n\n            error_setg(errp,\n\n                       \"Directory does not fit in FAT%d (capacity %.2f MB)\",\n\n                       s->fat_type, s->sector_count / 2000.0);\n\n            return -1;\n\n        }\n\n\n\n        /* fix fat for entry */\n\n        if (fix_fat) {\n\n            int j;\n\n            for(j = mapping->begin; j < mapping->end - 1; j++)\n\n                fat_set(s, j, j+1);\n\n            fat_set(s, mapping->end - 1, s->max_fat_value);\n\n        }\n\n    }\n\n\n\n    mapping = array_get(&(s->mapping), 0);\n\n    s->sectors_of_root_directory = mapping->end * s->sectors_per_cluster;\n\n    s->last_cluster_of_root_directory = mapping->end;\n\n\n\n    /* the FAT signature */\n\n    fat_set(s,0,s->max_fat_value);\n\n    fat_set(s,1,s->max_fat_value);\n\n\n\n    s->current_mapping = NULL;\n\n\n\n    bootsector = (bootsector_t *)(s->first_sectors\n\n                                  + s->offset_to_bootsector * 0x200);\n\n    bootsector->jump[0]=0xeb;\n\n    bootsector->jump[1]=0x3e;\n\n    bootsector->jump[2]=0x90;\n\n    memcpy(bootsector->name,\"QEMU    \",8);\n\n    bootsector->sector_size=cpu_to_le16(0x200);\n\n    bootsector->sectors_per_cluster=s->sectors_per_cluster;\n\n    bootsector->reserved_sectors=cpu_to_le16(1);\n\n    bootsector->number_of_fats=0x2; /* number of FATs */\n\n    bootsector->root_entries=cpu_to_le16(s->sectors_of_root_directory*0x10);\n\n    bootsector->total_sectors16=s->sector_count>0xffff?0:cpu_to_le16(s->sector_count);\n\n    /* media descriptor: hard disk=0xf8, floppy=0xf0 */\n\n    bootsector->media_type = (s->offset_to_bootsector > 0 ? 0xf8 : 0xf0);\n\n    s->fat.pointer[0] = bootsector->media_type;\n\n    bootsector->sectors_per_fat=cpu_to_le16(s->sectors_per_fat);\n\n    bootsector->sectors_per_track = cpu_to_le16(secs);\n\n    bootsector->number_of_heads = cpu_to_le16(heads);\n\n    bootsector->hidden_sectors = cpu_to_le32(s->offset_to_bootsector);\n\n    bootsector->total_sectors=cpu_to_le32(s->sector_count>0xffff?s->sector_count:0);\n\n\n\n    /* LATER TODO: if FAT32, this is wrong */\n\n    /* drive_number: fda=0, hda=0x80 */\n\n    bootsector->u.fat16.drive_number = s->offset_to_bootsector == 0 ? 0 : 0x80;\n\n    bootsector->u.fat16.signature=0x29;\n\n    bootsector->u.fat16.id=cpu_to_le32(0xfabe1afd);\n\n\n\n    memcpy(bootsector->u.fat16.volume_label, s->volume_label,\n\n           sizeof(bootsector->u.fat16.volume_label));\n\n    memcpy(bootsector->u.fat16.fat_type,\n\n           s->fat_type == 12 ? \"FAT12   \" : \"FAT16   \", 8);\n\n    bootsector->magic[0]=0x55; bootsector->magic[1]=0xaa;\n\n\n\n    return 0;\n\n}\n", "idx": 5630, "substitutes": {"s": ["sw", "less", "conf", "c", "h", "state", "self", "ps", "ports", "ts", "settings", "t", "se", "utils", "js", "w", "events", "sb", "xs", "services", "ss", "south", "changes", "series", "sports", "esm", "params", "source", "as", "rs", "service", "csv", "ses", "results", "sam", "store", "https", "os", "g", "ms", "tests", "es", "simple", "an", "v", "stats", "m", "vs", "a", "aws", "l", "ops", "gs", "ns", "ats", "ies", "comm", "cs", "p", "is", "r", "sv", "sm", "hs", "bs", "y", "parts", "fs", "S", "single", "b", "eps", "its", "set", "qs", "sys", "stat", "details", "n", "ds", "sync", "full", "space", "ls", "ims", "sym", "sl", "status", "spec", "states", "storage", "sts"], "dirname": ["dirame", "portName", "disknam", "pathnames", "diskname", "dirnames", "pathName", "portnam", " dirnames", "portname", "DIRnames", "DIRame", "dirnam", " dirnam", "pathame", " dirn", "dirn", "DIRName", "dirName", "portn", "diskName", "pathname", " dirName", "diskn", "DIRname", " dirame"], "heads": ["irs", "its", "h", "ints", "locks", "urs", "maps", "sections", "ashes", "ms", "ts", "cycles", "sets", "headers", "ths", "blocks", "sh", "reads", "loads", "offs", "resh", "head", "runs", "bs", "uns", "ih", "ires", "links"], "secs": ["secp", "seqp", "seqsd", "secsd", "strss", "strs", "seqss", "strp", "micross", "microp", "seqs", "secss", "micros", "microsd", "strsd"], "errp": ["ersp", "errorsp", "errorp", " errsp", "errsp", " errps", "errr", " errr", "errorr", "erps", "erp", "errorps", "errps", "err"], "bootsector": ["rootsector", "Bootsection", "ootsector", "ootsection", "Bootsector", "Bootvector", "rootsection", "bootsection", "bootvector", "ootvector", "rootvector"], "mapping": [" map", "remutation", "mmapping", "omapping", "mapped", "smapped", "mmappings", "cmapping", "dapping", "mmapped", "omap", "ematching", "matching", "smapping", " mutation", "lapping", "ominding", " mapped", "Mappings", "imatching", "Mutation", "dap", "vapped", "smap", "mmapper", "remapped", " moding", "lapped", "commoding", "imapped", "Mapper", "commapped", "vap", "tmapping", "tmap", "imapping", "Mmap", "Mapping", "lapper", "smapper", "commapper", "emapper", "Matching", "mmap", "cmapper", "tmapper", "map", " mapper", "dapped", "emapping", "mappings", "remapper", " matching", "cmapped", "vapping", " mappings", "cmap", "tmapped", "vapper", "mapper", "latching", "Map", "omapped", "minding", "Mapped", "mutation", "moding", "omapper", "dinding", "remapping", "imapper", "dapper", "ommap", "emapped", "emoding", "Minding", " mmap", "commapping"], "i": ["init", "ic", "ij", "chain", "ci", "b", "it", "im", "c", "u", "cli", "h", "ori", "oi", "gi", "mi", "qi", "ip", "li", "p", "si", "zi", "n", "is", "ind", "xi", "index", "o", "ni", "t", "data", "bi", "pi", "multi", "slice", "id", "ui", "list", "phi", "ti", "v", "ix", "ai", "m", "status", "I", "batch", "y", "\u0438", "f", "fi", "io", "sim", "info", "iu", "e", "iri", "z", "di", "a", "x", "ii", "l"], "cluster": ["custers", "pluration", "gluster", "gluration", "curation", "custer", "pluster", "cust", "clusters", "glust", "plusters", "glusters", "cluration", "clust", "plust"], "entry": ["folder", "existent", "event", "instance", "it", "jar", "channel", "def", "page", "nt", "ry", "file", "er", "ent", "ie", "connection", "link", "archive", "or", "option", "row", "pair", "line", "ner", "se", "element", "key", "index", "ary", "import", "delete", "record", "section", "resource", "attribute", "word", "byte", "child", "try", "port", "cell", "dir", "comment", "item", "member", "rent", "de", "Entry", "e", "directory", "ment", "office", "name"]}}
{"project": "qemu", "commit_id": "e1f8c729fa890c67bb4532f22c22ace6fb0e1aaf", "target": 0, "func": "void pxa25x_timer_init(target_phys_addr_t base, qemu_irq *irqs)\n\n{\n\n    pxa2xx_timer_info *s = pxa2xx_timer_init(base, irqs);\n\n    s->freq = PXA25X_FREQ;\n\n    s->tm4 = NULL;\n\n}\n", "idx": 5646, "substitutes": {"base": ["b", "root", "prefix", " Base", "eta", "type", "back", "real", "phy", "set", "buffer", "template", "profile", " bases", "p", "bp", "name", "data", "bound", "se", "from", "Base", "ref", "mac", "bf", "bid", "orig", "reset", "mb", "common", "re", "basic", "birth", "stable", "area", "kit", "address", "f", "info", "check", "bas", "ase", "origin", "create", "based"], "irqs": ["arqs", " mirqs", "mirqs", "pirqs", "pirques", " ircs", " ircles", "ibrqs", " irfs", "ircs", "ibrqu", "irfs", "pirqu", " mircles", "mircs", "ibrques", "arqu", "arcs", " mircs", "mirfs", "irques", "ibrcs", "irqu", " mirfs", "ircles", "mircles", "arques", "pircs"], "s": ["rs", "service", "so", "gs", "ns", "sol", "ats", "h", "aws", "i", "set", "store", "comm", "ps", "p", "details", "is", "ts", "settings", "ds", "sync", "t", "js", "ins", "sv", "ls", "sb", "services", "stats", "sl", "sa", "spec", "bs", "ss", "response", "su", "sq", "fs", "info", "S", "sts", "j", "a", "source"]}}
{"project": "qemu", "commit_id": "0919ac787641db11024912651f3bc5764d4f1286", "target": 0, "func": "struct omap_mpu_state_s *omap2420_mpu_init(unsigned long sdram_size,\n\n                const char *core)\n\n{\n\n    struct omap_mpu_state_s *s = (struct omap_mpu_state_s *)\n\n            g_malloc0(sizeof(struct omap_mpu_state_s));\n\n    ram_addr_t sram_base, q2_base;\n\n    qemu_irq *cpu_irq;\n\n    qemu_irq dma_irqs[4];\n\n    DriveInfo *dinfo;\n\n    int i;\n\n    SysBusDevice *busdev;\n\n    struct omap_target_agent_s *ta;\n\n\n\n    /* Core */\n\n    s->mpu_model = omap2420;\n\n    s->env = cpu_init(core ?: \"arm1136-r2\");\n\n    if (!s->env) {\n\n        fprintf(stderr, \"Unable to find CPU definition\\n\");\n\n        exit(1);\n\n    }\n\n    s->sdram_size = sdram_size;\n\n    s->sram_size = OMAP242X_SRAM_SIZE;\n\n\n\n    s->wakeup = qemu_allocate_irqs(omap_mpu_wakeup, s, 1)[0];\n\n\n\n    /* Clocks */\n\n    omap_clk_init(s);\n\n\n\n    /* Memory-mapped stuff */\n\n    cpu_register_physical_memory(OMAP2_Q2_BASE, s->sdram_size,\n\n                    (q2_base = qemu_ram_alloc(NULL, \"omap2.dram\",\n\n                                              s->sdram_size)) | IO_MEM_RAM);\n\n    cpu_register_physical_memory(OMAP2_SRAM_BASE, s->sram_size,\n\n                    (sram_base = qemu_ram_alloc(NULL, \"omap2.sram\",\n\n                                                s->sram_size)) | IO_MEM_RAM);\n\n\n\n    s->l4 = omap_l4_init(OMAP2_L4_BASE, 54);\n\n\n\n    /* Actually mapped at any 2K boundary in the ARM11 private-peripheral if */\n\n    cpu_irq = arm_pic_init_cpu(s->env);\n\n    s->ih[0] = omap2_inth_init(0x480fe000, 0x1000, 3, &s->irq[0],\n\n                    cpu_irq[ARM_PIC_CPU_IRQ], cpu_irq[ARM_PIC_CPU_FIQ],\n\n                    omap_findclk(s, \"mpu_intc_fclk\"),\n\n                    omap_findclk(s, \"mpu_intc_iclk\"));\n\n\n\n    s->prcm = omap_prcm_init(omap_l4tao(s->l4, 3),\n\n                    s->irq[0][OMAP_INT_24XX_PRCM_MPU_IRQ], NULL, NULL, s);\n\n\n\n    s->sysc = omap_sysctl_init(omap_l4tao(s->l4, 1),\n\n                    omap_findclk(s, \"omapctrl_iclk\"), s);\n\n\n\n    for (i = 0; i < 4; i ++)\n\n        dma_irqs[i] =\n\n                s->irq[omap2_dma_irq_map[i].ih][omap2_dma_irq_map[i].intr];\n\n    s->dma = omap_dma4_init(0x48056000, dma_irqs, s, 256, 32,\n\n                    omap_findclk(s, \"sdma_iclk\"),\n\n                    omap_findclk(s, \"sdma_fclk\"));\n\n    s->port->addr_valid = omap2_validate_addr;\n\n\n\n    /* Register SDRAM and SRAM ports for fast DMA transfers.  */\n\n    soc_dma_port_add_mem(s->dma, qemu_get_ram_ptr(q2_base),\n\n                         OMAP2_Q2_BASE, s->sdram_size);\n\n    soc_dma_port_add_mem(s->dma, qemu_get_ram_ptr(sram_base),\n\n                         OMAP2_SRAM_BASE, s->sram_size);\n\n\n\n    s->uart[0] = omap2_uart_init(omap_l4ta(s->l4, 19),\n\n                    s->irq[0][OMAP_INT_24XX_UART1_IRQ],\n\n                    omap_findclk(s, \"uart1_fclk\"),\n\n                    omap_findclk(s, \"uart1_iclk\"),\n\n                    s->drq[OMAP24XX_DMA_UART1_TX],\n\n                    s->drq[OMAP24XX_DMA_UART1_RX],\n\n                    \"uart1\",\n\n                    serial_hds[0]);\n\n    s->uart[1] = omap2_uart_init(omap_l4ta(s->l4, 20),\n\n                    s->irq[0][OMAP_INT_24XX_UART2_IRQ],\n\n                    omap_findclk(s, \"uart2_fclk\"),\n\n                    omap_findclk(s, \"uart2_iclk\"),\n\n                    s->drq[OMAP24XX_DMA_UART2_TX],\n\n                    s->drq[OMAP24XX_DMA_UART2_RX],\n\n                    \"uart2\",\n\n                    serial_hds[0] ? serial_hds[1] : NULL);\n\n    s->uart[2] = omap2_uart_init(omap_l4ta(s->l4, 21),\n\n                    s->irq[0][OMAP_INT_24XX_UART3_IRQ],\n\n                    omap_findclk(s, \"uart3_fclk\"),\n\n                    omap_findclk(s, \"uart3_iclk\"),\n\n                    s->drq[OMAP24XX_DMA_UART3_TX],\n\n                    s->drq[OMAP24XX_DMA_UART3_RX],\n\n                    \"uart3\",\n\n                    serial_hds[0] && serial_hds[1] ? serial_hds[2] : NULL);\n\n\n\n    s->gptimer[0] = omap_gp_timer_init(omap_l4ta(s->l4, 7),\n\n                    s->irq[0][OMAP_INT_24XX_GPTIMER1],\n\n                    omap_findclk(s, \"wu_gpt1_clk\"),\n\n                    omap_findclk(s, \"wu_l4_iclk\"));\n\n    s->gptimer[1] = omap_gp_timer_init(omap_l4ta(s->l4, 8),\n\n                    s->irq[0][OMAP_INT_24XX_GPTIMER2],\n\n                    omap_findclk(s, \"core_gpt2_clk\"),\n\n                    omap_findclk(s, \"core_l4_iclk\"));\n\n    s->gptimer[2] = omap_gp_timer_init(omap_l4ta(s->l4, 22),\n\n                    s->irq[0][OMAP_INT_24XX_GPTIMER3],\n\n                    omap_findclk(s, \"core_gpt3_clk\"),\n\n                    omap_findclk(s, \"core_l4_iclk\"));\n\n    s->gptimer[3] = omap_gp_timer_init(omap_l4ta(s->l4, 23),\n\n                    s->irq[0][OMAP_INT_24XX_GPTIMER4],\n\n                    omap_findclk(s, \"core_gpt4_clk\"),\n\n                    omap_findclk(s, \"core_l4_iclk\"));\n\n    s->gptimer[4] = omap_gp_timer_init(omap_l4ta(s->l4, 24),\n\n                    s->irq[0][OMAP_INT_24XX_GPTIMER5],\n\n                    omap_findclk(s, \"core_gpt5_clk\"),\n\n                    omap_findclk(s, \"core_l4_iclk\"));\n\n    s->gptimer[5] = omap_gp_timer_init(omap_l4ta(s->l4, 25),\n\n                    s->irq[0][OMAP_INT_24XX_GPTIMER6],\n\n                    omap_findclk(s, \"core_gpt6_clk\"),\n\n                    omap_findclk(s, \"core_l4_iclk\"));\n\n    s->gptimer[6] = omap_gp_timer_init(omap_l4ta(s->l4, 26),\n\n                    s->irq[0][OMAP_INT_24XX_GPTIMER7],\n\n                    omap_findclk(s, \"core_gpt7_clk\"),\n\n                    omap_findclk(s, \"core_l4_iclk\"));\n\n    s->gptimer[7] = omap_gp_timer_init(omap_l4ta(s->l4, 27),\n\n                    s->irq[0][OMAP_INT_24XX_GPTIMER8],\n\n                    omap_findclk(s, \"core_gpt8_clk\"),\n\n                    omap_findclk(s, \"core_l4_iclk\"));\n\n    s->gptimer[8] = omap_gp_timer_init(omap_l4ta(s->l4, 28),\n\n                    s->irq[0][OMAP_INT_24XX_GPTIMER9],\n\n                    omap_findclk(s, \"core_gpt9_clk\"),\n\n                    omap_findclk(s, \"core_l4_iclk\"));\n\n    s->gptimer[9] = omap_gp_timer_init(omap_l4ta(s->l4, 29),\n\n                    s->irq[0][OMAP_INT_24XX_GPTIMER10],\n\n                    omap_findclk(s, \"core_gpt10_clk\"),\n\n                    omap_findclk(s, \"core_l4_iclk\"));\n\n    s->gptimer[10] = omap_gp_timer_init(omap_l4ta(s->l4, 30),\n\n                    s->irq[0][OMAP_INT_24XX_GPTIMER11],\n\n                    omap_findclk(s, \"core_gpt11_clk\"),\n\n                    omap_findclk(s, \"core_l4_iclk\"));\n\n    s->gptimer[11] = omap_gp_timer_init(omap_l4ta(s->l4, 31),\n\n                    s->irq[0][OMAP_INT_24XX_GPTIMER12],\n\n                    omap_findclk(s, \"core_gpt12_clk\"),\n\n                    omap_findclk(s, \"core_l4_iclk\"));\n\n\n\n    omap_tap_init(omap_l4ta(s->l4, 2), s);\n\n\n\n    s->synctimer = omap_synctimer_init(omap_l4tao(s->l4, 2), s,\n\n                    omap_findclk(s, \"clk32-kHz\"),\n\n                    omap_findclk(s, \"core_l4_iclk\"));\n\n\n\n    s->i2c[0] = omap2_i2c_init(omap_l4tao(s->l4, 5),\n\n                    s->irq[0][OMAP_INT_24XX_I2C1_IRQ],\n\n                    &s->drq[OMAP24XX_DMA_I2C1_TX],\n\n                    omap_findclk(s, \"i2c1.fclk\"),\n\n                    omap_findclk(s, \"i2c1.iclk\"));\n\n    s->i2c[1] = omap2_i2c_init(omap_l4tao(s->l4, 6),\n\n                    s->irq[0][OMAP_INT_24XX_I2C2_IRQ],\n\n                    &s->drq[OMAP24XX_DMA_I2C2_TX],\n\n                    omap_findclk(s, \"i2c2.fclk\"),\n\n                    omap_findclk(s, \"i2c2.iclk\"));\n\n\n\n    s->gpio = qdev_create(NULL, \"omap2-gpio\");\n\n    qdev_prop_set_int32(s->gpio, \"mpu_model\", s->mpu_model);\n\n    qdev_prop_set_ptr(s->gpio, \"iclk\", omap_findclk(s, \"gpio_iclk\"));\n\n    qdev_prop_set_ptr(s->gpio, \"fclk0\", omap_findclk(s, \"gpio1_dbclk\"));\n\n    qdev_prop_set_ptr(s->gpio, \"fclk1\", omap_findclk(s, \"gpio2_dbclk\"));\n\n    qdev_prop_set_ptr(s->gpio, \"fclk2\", omap_findclk(s, \"gpio3_dbclk\"));\n\n    qdev_prop_set_ptr(s->gpio, \"fclk3\", omap_findclk(s, \"gpio4_dbclk\"));\n\n    if (s->mpu_model == omap2430) {\n\n        qdev_prop_set_ptr(s->gpio, \"fclk4\", omap_findclk(s, \"gpio5_dbclk\"));\n\n    }\n\n    qdev_init_nofail(s->gpio);\n\n    busdev = sysbus_from_qdev(s->gpio);\n\n    sysbus_connect_irq(busdev, 0, s->irq[0][OMAP_INT_24XX_GPIO_BANK1]);\n\n    sysbus_connect_irq(busdev, 3, s->irq[0][OMAP_INT_24XX_GPIO_BANK2]);\n\n    sysbus_connect_irq(busdev, 6, s->irq[0][OMAP_INT_24XX_GPIO_BANK3]);\n\n    sysbus_connect_irq(busdev, 9, s->irq[0][OMAP_INT_24XX_GPIO_BANK4]);\n\n    ta = omap_l4ta(s->l4, 3);\n\n    sysbus_mmio_map(busdev, 0, omap_l4_region_base(ta, 1));\n\n    sysbus_mmio_map(busdev, 1, omap_l4_region_base(ta, 0));\n\n    sysbus_mmio_map(busdev, 2, omap_l4_region_base(ta, 2));\n\n    sysbus_mmio_map(busdev, 3, omap_l4_region_base(ta, 4));\n\n    sysbus_mmio_map(busdev, 4, omap_l4_region_base(ta, 5));\n\n\n\n    s->sdrc = omap_sdrc_init(0x68009000);\n\n    s->gpmc = omap_gpmc_init(s, 0x6800a000, s->irq[0][OMAP_INT_24XX_GPMC_IRQ],\n\n                             s->drq[OMAP24XX_DMA_GPMC]);\n\n\n\n    dinfo = drive_get(IF_SD, 0, 0);\n\n    if (!dinfo) {\n\n        fprintf(stderr, \"qemu: missing SecureDigital device\\n\");\n\n        exit(1);\n\n    }\n\n    s->mmc = omap2_mmc_init(omap_l4tao(s->l4, 9), dinfo->bdrv,\n\n                    s->irq[0][OMAP_INT_24XX_MMC_IRQ],\n\n                    &s->drq[OMAP24XX_DMA_MMC1_TX],\n\n                    omap_findclk(s, \"mmc_fclk\"), omap_findclk(s, \"mmc_iclk\"));\n\n\n\n    s->mcspi[0] = omap_mcspi_init(omap_l4ta(s->l4, 35), 4,\n\n                    s->irq[0][OMAP_INT_24XX_MCSPI1_IRQ],\n\n                    &s->drq[OMAP24XX_DMA_SPI1_TX0],\n\n                    omap_findclk(s, \"spi1_fclk\"),\n\n                    omap_findclk(s, \"spi1_iclk\"));\n\n    s->mcspi[1] = omap_mcspi_init(omap_l4ta(s->l4, 36), 2,\n\n                    s->irq[0][OMAP_INT_24XX_MCSPI2_IRQ],\n\n                    &s->drq[OMAP24XX_DMA_SPI2_TX0],\n\n                    omap_findclk(s, \"spi2_fclk\"),\n\n                    omap_findclk(s, \"spi2_iclk\"));\n\n\n\n    s->dss = omap_dss_init(omap_l4ta(s->l4, 10), 0x68000800,\n\n                    /* XXX wire M_IRQ_25, D_L2_IRQ_30 and I_IRQ_13 together */\n\n                    s->irq[0][OMAP_INT_24XX_DSS_IRQ], s->drq[OMAP24XX_DMA_DSS],\n\n                    omap_findclk(s, \"dss_clk1\"), omap_findclk(s, \"dss_clk2\"),\n\n                    omap_findclk(s, \"dss_54m_clk\"),\n\n                    omap_findclk(s, \"dss_l3_iclk\"),\n\n                    omap_findclk(s, \"dss_l4_iclk\"));\n\n\n\n    omap_sti_init(omap_l4ta(s->l4, 18), 0x54000000,\n\n                    s->irq[0][OMAP_INT_24XX_STI], omap_findclk(s, \"emul_ck\"),\n\n                    serial_hds[0] && serial_hds[1] && serial_hds[2] ?\n\n                    serial_hds[3] : NULL);\n\n\n\n    s->eac = omap_eac_init(omap_l4ta(s->l4, 32),\n\n                    s->irq[0][OMAP_INT_24XX_EAC_IRQ],\n\n                    /* Ten consecutive lines */\n\n                    &s->drq[OMAP24XX_DMA_EAC_AC_RD],\n\n                    omap_findclk(s, \"func_96m_clk\"),\n\n                    omap_findclk(s, \"core_l4_iclk\"));\n\n\n\n    /* All register mappings (includin those not currenlty implemented):\n\n     * SystemControlMod\t48000000 - 48000fff\n\n     * SystemControlL4\t48001000 - 48001fff\n\n     * 32kHz Timer Mod\t48004000 - 48004fff\n\n     * 32kHz Timer L4\t48005000 - 48005fff\n\n     * PRCM ModA\t48008000 - 480087ff\n\n     * PRCM ModB\t48008800 - 48008fff\n\n     * PRCM L4\t\t48009000 - 48009fff\n\n     * TEST-BCM Mod\t48012000 - 48012fff\n\n     * TEST-BCM L4\t48013000 - 48013fff\n\n     * TEST-TAP Mod\t48014000 - 48014fff\n\n     * TEST-TAP L4\t48015000 - 48015fff\n\n     * GPIO1 Mod\t48018000 - 48018fff\n\n     * GPIO Top\t\t48019000 - 48019fff\n\n     * GPIO2 Mod\t4801a000 - 4801afff\n\n     * GPIO L4\t\t4801b000 - 4801bfff\n\n     * GPIO3 Mod\t4801c000 - 4801cfff\n\n     * GPIO4 Mod\t4801e000 - 4801efff\n\n     * WDTIMER1 Mod\t48020000 - 48010fff\n\n     * WDTIMER Top\t48021000 - 48011fff\n\n     * WDTIMER2 Mod\t48022000 - 48012fff\n\n     * WDTIMER L4\t48023000 - 48013fff\n\n     * WDTIMER3 Mod\t48024000 - 48014fff\n\n     * WDTIMER3 L4\t48025000 - 48015fff\n\n     * WDTIMER4 Mod\t48026000 - 48016fff\n\n     * WDTIMER4 L4\t48027000 - 48017fff\n\n     * GPTIMER1 Mod\t48028000 - 48018fff\n\n     * GPTIMER1 L4\t48029000 - 48019fff\n\n     * GPTIMER2 Mod\t4802a000 - 4801afff\n\n     * GPTIMER2 L4\t4802b000 - 4801bfff\n\n     * L4-Config AP\t48040000 - 480407ff\n\n     * L4-Config IP\t48040800 - 48040fff\n\n     * L4-Config LA\t48041000 - 48041fff\n\n     * ARM11ETB Mod\t48048000 - 48049fff\n\n     * ARM11ETB L4\t4804a000 - 4804afff\n\n     * DISPLAY Top\t48050000 - 480503ff\n\n     * DISPLAY DISPC\t48050400 - 480507ff\n\n     * DISPLAY RFBI\t48050800 - 48050bff\n\n     * DISPLAY VENC\t48050c00 - 48050fff\n\n     * DISPLAY L4\t48051000 - 48051fff\n\n     * CAMERA Top\t48052000 - 480523ff\n\n     * CAMERA core\t48052400 - 480527ff\n\n     * CAMERA DMA\t48052800 - 48052bff\n\n     * CAMERA MMU\t48052c00 - 48052fff\n\n     * CAMERA L4\t48053000 - 48053fff\n\n     * SDMA Mod\t\t48056000 - 48056fff\n\n     * SDMA L4\t\t48057000 - 48057fff\n\n     * SSI Top\t\t48058000 - 48058fff\n\n     * SSI GDD\t\t48059000 - 48059fff\n\n     * SSI Port1\t4805a000 - 4805afff\n\n     * SSI Port2\t4805b000 - 4805bfff\n\n     * SSI L4\t\t4805c000 - 4805cfff\n\n     * USB Mod\t\t4805e000 - 480fefff\n\n     * USB L4\t\t4805f000 - 480fffff\n\n     * WIN_TRACER1 Mod\t48060000 - 48060fff\n\n     * WIN_TRACER1 L4\t48061000 - 48061fff\n\n     * WIN_TRACER2 Mod\t48062000 - 48062fff\n\n     * WIN_TRACER2 L4\t48063000 - 48063fff\n\n     * WIN_TRACER3 Mod\t48064000 - 48064fff\n\n     * WIN_TRACER3 L4\t48065000 - 48065fff\n\n     * WIN_TRACER4 Top\t48066000 - 480660ff\n\n     * WIN_TRACER4 ETT\t48066100 - 480661ff\n\n     * WIN_TRACER4 WT\t48066200 - 480662ff\n\n     * WIN_TRACER4 L4\t48067000 - 48067fff\n\n     * XTI Mod\t\t48068000 - 48068fff\n\n     * XTI L4\t\t48069000 - 48069fff\n\n     * UART1 Mod\t4806a000 - 4806afff\n\n     * UART1 L4\t\t4806b000 - 4806bfff\n\n     * UART2 Mod\t4806c000 - 4806cfff\n\n     * UART2 L4\t\t4806d000 - 4806dfff\n\n     * UART3 Mod\t4806e000 - 4806efff\n\n     * UART3 L4\t\t4806f000 - 4806ffff\n\n     * I2C1 Mod\t\t48070000 - 48070fff\n\n     * I2C1 L4\t\t48071000 - 48071fff\n\n     * I2C2 Mod\t\t48072000 - 48072fff\n\n     * I2C2 L4\t\t48073000 - 48073fff\n\n     * McBSP1 Mod\t48074000 - 48074fff\n\n     * McBSP1 L4\t48075000 - 48075fff\n\n     * McBSP2 Mod\t48076000 - 48076fff\n\n     * McBSP2 L4\t48077000 - 48077fff\n\n     * GPTIMER3 Mod\t48078000 - 48078fff\n\n     * GPTIMER3 L4\t48079000 - 48079fff\n\n     * GPTIMER4 Mod\t4807a000 - 4807afff\n\n     * GPTIMER4 L4\t4807b000 - 4807bfff\n\n     * GPTIMER5 Mod\t4807c000 - 4807cfff\n\n     * GPTIMER5 L4\t4807d000 - 4807dfff\n\n     * GPTIMER6 Mod\t4807e000 - 4807efff\n\n     * GPTIMER6 L4\t4807f000 - 4807ffff\n\n     * GPTIMER7 Mod\t48080000 - 48080fff\n\n     * GPTIMER7 L4\t48081000 - 48081fff\n\n     * GPTIMER8 Mod\t48082000 - 48082fff\n\n     * GPTIMER8 L4\t48083000 - 48083fff\n\n     * GPTIMER9 Mod\t48084000 - 48084fff\n\n     * GPTIMER9 L4\t48085000 - 48085fff\n\n     * GPTIMER10 Mod\t48086000 - 48086fff\n\n     * GPTIMER10 L4\t48087000 - 48087fff\n\n     * GPTIMER11 Mod\t48088000 - 48088fff\n\n     * GPTIMER11 L4\t48089000 - 48089fff\n\n     * GPTIMER12 Mod\t4808a000 - 4808afff\n\n     * GPTIMER12 L4\t4808b000 - 4808bfff\n\n     * EAC Mod\t\t48090000 - 48090fff\n\n     * EAC L4\t\t48091000 - 48091fff\n\n     * FAC Mod\t\t48092000 - 48092fff\n\n     * FAC L4\t\t48093000 - 48093fff\n\n     * MAILBOX Mod\t48094000 - 48094fff\n\n     * MAILBOX L4\t48095000 - 48095fff\n\n     * SPI1 Mod\t\t48098000 - 48098fff\n\n     * SPI1 L4\t\t48099000 - 48099fff\n\n     * SPI2 Mod\t\t4809a000 - 4809afff\n\n     * SPI2 L4\t\t4809b000 - 4809bfff\n\n     * MMC/SDIO Mod\t4809c000 - 4809cfff\n\n     * MMC/SDIO L4\t4809d000 - 4809dfff\n\n     * MS_PRO Mod\t4809e000 - 4809efff\n\n     * MS_PRO L4\t4809f000 - 4809ffff\n\n     * RNG Mod\t\t480a0000 - 480a0fff\n\n     * RNG L4\t\t480a1000 - 480a1fff\n\n     * DES3DES Mod\t480a2000 - 480a2fff\n\n     * DES3DES L4\t480a3000 - 480a3fff\n\n     * SHA1MD5 Mod\t480a4000 - 480a4fff\n\n     * SHA1MD5 L4\t480a5000 - 480a5fff\n\n     * AES Mod\t\t480a6000 - 480a6fff\n\n     * AES L4\t\t480a7000 - 480a7fff\n\n     * PKA Mod\t\t480a8000 - 480a9fff\n\n     * PKA L4\t\t480aa000 - 480aafff\n\n     * MG Mod\t\t480b0000 - 480b0fff\n\n     * MG L4\t\t480b1000 - 480b1fff\n\n     * HDQ/1-wire Mod\t480b2000 - 480b2fff\n\n     * HDQ/1-wire L4\t480b3000 - 480b3fff\n\n     * MPU interrupt\t480fe000 - 480fefff\n\n     * STI channel base\t54000000 - 5400ffff\n\n     * IVA RAM\t\t5c000000 - 5c01ffff\n\n     * IVA ROM\t\t5c020000 - 5c027fff\n\n     * IMG_BUF_A\t5c040000 - 5c040fff\n\n     * IMG_BUF_B\t5c042000 - 5c042fff\n\n     * VLCDS\t\t5c048000 - 5c0487ff\n\n     * IMX_COEF\t\t5c049000 - 5c04afff\n\n     * IMX_CMD\t\t5c051000 - 5c051fff\n\n     * VLCDQ\t\t5c053000 - 5c0533ff\n\n     * VLCDH\t\t5c054000 - 5c054fff\n\n     * SEQ_CMD\t\t5c055000 - 5c055fff\n\n     * IMX_REG\t\t5c056000 - 5c0560ff\n\n     * VLCD_REG\t\t5c056100 - 5c0561ff\n\n     * SEQ_REG\t\t5c056200 - 5c0562ff\n\n     * IMG_BUF_REG\t5c056300 - 5c0563ff\n\n     * SEQIRQ_REG\t5c056400 - 5c0564ff\n\n     * OCP_REG\t\t5c060000 - 5c060fff\n\n     * SYSC_REG\t\t5c070000 - 5c070fff\n\n     * MMU_REG\t\t5d000000 - 5d000fff\n\n     * sDMA R\t\t68000400 - 680005ff\n\n     * sDMA W\t\t68000600 - 680007ff\n\n     * Display Control\t68000800 - 680009ff\n\n     * DSP subsystem\t68000a00 - 68000bff\n\n     * MPU subsystem\t68000c00 - 68000dff\n\n     * IVA subsystem\t68001000 - 680011ff\n\n     * USB\t\t68001200 - 680013ff\n\n     * Camera\t\t68001400 - 680015ff\n\n     * VLYNQ (firewall)\t68001800 - 68001bff\n\n     * VLYNQ\t\t68001e00 - 68001fff\n\n     * SSI\t\t68002000 - 680021ff\n\n     * L4\t\t68002400 - 680025ff\n\n     * DSP (firewall)\t68002800 - 68002bff\n\n     * DSP subsystem\t68002e00 - 68002fff\n\n     * IVA (firewall)\t68003000 - 680033ff\n\n     * IVA\t\t68003600 - 680037ff\n\n     * GFX\t\t68003a00 - 68003bff\n\n     * CMDWR emulation\t68003c00 - 68003dff\n\n     * SMS\t\t68004000 - 680041ff\n\n     * OCM\t\t68004200 - 680043ff\n\n     * GPMC\t\t68004400 - 680045ff\n\n     * RAM (firewall)\t68005000 - 680053ff\n\n     * RAM (err login)\t68005400 - 680057ff\n\n     * ROM (firewall)\t68005800 - 68005bff\n\n     * ROM (err login)\t68005c00 - 68005fff\n\n     * GPMC (firewall)\t68006000 - 680063ff\n\n     * GPMC (err login)\t68006400 - 680067ff\n\n     * SMS (err login)\t68006c00 - 68006fff\n\n     * SMS registers\t68008000 - 68008fff\n\n     * SDRC registers\t68009000 - 68009fff\n\n     * GPMC registers\t6800a000   6800afff\n\n     */\n\n\n\n    qemu_register_reset(omap2_mpu_reset, s);\n\n\n\n    return s;\n\n}\n", "idx": 5670, "substitutes": {"sdram_size": ["sdram2SIZE", "sdgram2SIZE", "sdramtname", "sdram_SIZE", "sdgram_SIZE", "sdram_set", "sdram0set", "sdramtset", "sdramtbase", "sdgram_Size", "sdram_Size", "sdrum_style", "sdram2length", "sdgram2size", "sdgram_mode", "sdmem_base", "sdram_base", "sdram0name", "sdram0base", "sdgram_len", "sdram2len", "sdrum_scale", "sdgram_size", "sdrum_SIZE", "sdmem_set", "sdgram_length", "sdram_mode", "sdram_name", "sdram2Size", "sdmem_name", "sdmem_size", "sdram0size", "sdrum_size", "sdram_length", "sdram_len", "sdramtsize", "sdgram2length", "sdgram2Size", "sdram_scale", "sdram2size", "sdram_style"], "core": ["copy", "cy", "node", "gp", "cp", "ether", " Core", "pu", "type", "pc", "c", "ox", "aster", "binary", "sc", "primary", "ve", "cycle", "custom", "force", "cow", "raw", "pure", "base", "er", "ie", "Core", "program", "platform", "score", "ores", "ce", "key", "col", "bit", "board", "k", "gate", "cr", "processor", "cpu", "ca", "cer", "io", "ro", "ready", "ore"], "s": ["des", "less", "c", "h", "d", "ps", "ports", "ts", "settings", "t", "se", "utils", "js", "w", "gets", "sb", "services", "ss", "ares", "changes", "j", "sports", "params", "source", "as", "rs", "service", "so", "ses", "sam", "os", "g", "ms", "tests", "es", "an", "v", "stats", "bits", "m", "sa", "vs", "aws", "a", "l", "ops", "gs", "ns", "ats", "ies", "comm", "cs", "p", "is", "o", "r", "sv", "sm", "hs", "bs", "y", "fs", "S", "sp", "b", "eps", "its", "set", "qs", "als", "details", "n", "ds", "ins", "space", "ls", "ims", "args", "sl", "status", "spec", "states", "obj", "e", "sts"], "sram_base": ["sgram_buffer", "sgram_enable", "sram0enable", "sram0buffer", "sramxsize", "smem_base", "sgram_base", "sram0base", "sram0offset", "sram_offset", "sram_buffer", "sgram_offset", "smem_size", "sram_size", "sramxbase", "sram_enable", "sramxb", "smem_b", "sram_b"], "q2_base": ["q3tbase", "q3_store", "q3tstore", "q3_Base", "q2_Base", "q3_base", "q3tBase", "q12_Base", "q2_ase", "q2_bas", "q12_base", "q2tBase", "q2tbase", "q2_store", "q2tstore", "q12_ase", "q12_bas"], "cpu_irq": ["cpu__pirq", "cpu__irqs", "cpu__pirqs", "cpu_irqs", "cpu_ierqs", "cpu_erqu", "cpu__irq", "cpu_pirq", "cpu_ierqi", "cpu_mirqu", "cpu_iraqs", "cpu_ird", "cpu_pirch", "cpu_mirQ", "cpu_mirqs", "cpu_erqi", "cpu_irk", "cpu_arch", "cpu__pirch", "cpu_ark", "cpu_irqu", "cpu_drqs", "cpu__irQ", "cpu_pirqs", "cpu_erqs", "cpu_erq", "cpu__irch", "cpu_mirch", "cpu_iraqu", "cpu_mirqi", "cpu_mirk", "cpu_arq", "cpu_iraqi", "cpu_mird", "cpu_irch", "cpu_arqs", "cpu_mirq", "cpu_ierQ", "cpu_iraq", "cpu_irak", "cpu__pirQ", "cpu_pirqi", "cpu_drqi", "cpu_irqi", "cpu_drQ", "cpu_irQ", "cpu_irad", "cpu_ard", "cpu_ierq", "cpu_drq", "cpu_pirQ", "cpu_arQ"], "dma_irqs": ["dma_iroq", "dma_rinqs", "dma_pirqs", "dma_pirqu", "dma_pirques", "dma_irq", "dma_rinq", "dma_irqu", "dma_iroques", "dma_pirq", "dma_irques", "dma_iroqu", "dma_iroqs", "dma_rinqu", "dma_rinques"], "dinfo": ["vinf", " ddata", "Ddata", "dinf", "Dinf", "Dinfo", "DInfo", " dInfo", "dInfo", "vInfo", "vinfo", "vdata", "ddata", " dinf"], "i": [" bi", "ci", "b", "it", "oi", "li", "p", "si", "o", "pi", "ki", " I", " pi", "v", "iy", "ai", "m", "I", "y", "ia", "fi", "io", "iu", "e", "j", "di", "ii", "l"], "busdev": ["boardinfo", "boarddev", " busdevice", "busio", "blockdevice", " busio", " businfo", "blockio", "blockinfo", "boardio", "blockdev", "busdevice", "boarddevice", "businfo"], "ta": [" ki", "wa", "sha", "TA", "ra", "ka", "te", "aa", "pa", "tm", "ts", "ata", "Ta", "va", "ti", "au", "tu", "ai", "fa", "sa", "ca", "tta", "tap", "ga", "ha", "ao", "tc", "da", "ba"]}}
{"project": "qemu", "commit_id": "c878da3b27ceeed953c9f9a1eb002d59e9dcb4c6", "target": 0, "func": "static void tcg_out_qemu_ld_slow_path (TCGContext *s, TCGLabelQemuLdst *label)\n\n{\n\n    int s_bits;\n\n    int ir;\n\n    int opc = label->opc;\n\n    int mem_index = label->mem_index;\n\n    int data_reg = label->datalo_reg;\n\n    int data_reg2 = label->datahi_reg;\n\n    int addr_reg = label->addrlo_reg;\n\n    uint8_t *raddr = label->raddr;\n\n    uint8_t **label_ptr = &label->label_ptr[0];\n\n\n\n    s_bits = opc & 3;\n\n\n\n    /* resolve label address */\n\n    reloc_pc14 (label_ptr[0], (tcg_target_long) s->code_ptr);\n\n\n\n    /* slow path */\n\n    ir = 3;\n\n    tcg_out_mov (s, TCG_TYPE_I32, ir++, TCG_AREG0);\n\n#if TARGET_LONG_BITS == 32\n\n    tcg_out_mov (s, TCG_TYPE_I32, ir++, addr_reg);\n\n#else\n\n#ifdef TCG_TARGET_CALL_ALIGN_ARGS\n\n    ir |= 1;\n\n#endif\n\n    tcg_out_mov (s, TCG_TYPE_I32, ir++, label->addrhi_reg);\n\n    tcg_out_mov (s, TCG_TYPE_I32, ir++, addr_reg);\n\n#endif\n\n    tcg_out_movi (s, TCG_TYPE_I32, ir, mem_index);\n\n    tcg_out_call (s, (tcg_target_long) qemu_ld_helpers[s_bits], 1);\n\n    tcg_out32 (s, B | 8);\n\n    tcg_out32 (s, (tcg_target_long) raddr);\n\n    switch (opc) {\n\n    case 0|4:\n\n        tcg_out32 (s, EXTSB | RA (data_reg) | RS (3));\n\n        break;\n\n    case 1|4:\n\n        tcg_out32 (s, EXTSH | RA (data_reg) | RS (3));\n\n        break;\n\n    case 0:\n\n    case 1:\n\n    case 2:\n\n        if (data_reg != 3)\n\n            tcg_out_mov (s, TCG_TYPE_I32, data_reg, 3);\n\n        break;\n\n    case 3:\n\n        if (data_reg == 3) {\n\n            if (data_reg2 == 4) {\n\n                tcg_out_mov (s, TCG_TYPE_I32, 0, 4);\n\n                tcg_out_mov (s, TCG_TYPE_I32, 4, 3);\n\n                tcg_out_mov (s, TCG_TYPE_I32, 3, 0);\n\n            }\n\n            else {\n\n                tcg_out_mov (s, TCG_TYPE_I32, data_reg2, 3);\n\n                tcg_out_mov (s, TCG_TYPE_I32, 3, 4);\n\n            }\n\n        }\n\n        else {\n\n            if (data_reg != 4) tcg_out_mov (s, TCG_TYPE_I32, data_reg, 4);\n\n            if (data_reg2 != 3) tcg_out_mov (s, TCG_TYPE_I32, data_reg2, 3);\n\n        }\n\n        break;\n\n    }\n\n    /* Jump to the code corresponding to next IR of qemu_st */\n\n    tcg_out_b (s, 0, (tcg_target_long) raddr);\n\n}\n", "idx": 5672, "substitutes": {"s": ["as", "rs", "gs", "b", "ssl", "sg", "less", "sw", "ns", "c", "its", "h", "scope", "sys", "set", "cs", "self", "os", "g", "p", "ps", "n", "is", "ts", "ds", "t", "es", "r", "simple", "w", "lang", "js", "ins", "space", "an", "ls", "sm", "sb", "sv", "scl", "out", "ims", "sym", "m", "ss", "south", "y", "sq", "session", "fs", "e", "S", "in", "sts", "z", "x", "a", "l", "source"], "label": ["layout", "call", "b", "prefix", "node", "ell", "target", "type", "ox", "field", "binary", "state", "leader", "mark", "util", "loader", "link", "group", "lib", "name", "val", "ind", "LAB", "line", "data", "button", "index", "process", "range", "value", "el", "Label", "module", "role", "route", "list", "align", "style", "lab", "summary", "span", "sl", "status", "cell", "block", "LI", "tab", "comment", "local", "alias", "desc", "bl", "address", "message", "abel", "info", "il", "l", "loc"], "s_bits": ["s__bytes", "s__properties", "s_bit", "s_properties", " s_its", " s_flags", "t__flags", "s__pins", "t__its", " s_bytes", " s_bit", "s__bits", "t_bits", "t_flags", "s__bit", " s_properties", "s_pins", "s__its", "s_bytes", "t_pins", "t_its", "s__flags", "t__bits", "t__pins", "s_flags", "s_its"], "ir": ["init", "world", "iv", "hr", " IR", "ij", "vr", "nir", "outer", "ris", "ar", "war", "irs", "lr", "igr", "sr", "walker", "Ir", "i", "mi", "ire", "mr", "virt", "mir", "ira", "is", "var", "pir", " wr", "ni", "r", "vir", "river", "dr", "err", "ref", "irm", "inter", "rc", "id", "rr", "ibr", "arc", "nil", "pr", "iter", "rint", "ier", "iso", "ior", "rin", "rid", "dir", "isc", "ptr", "ih", "iro", "iron", " shr", "IR", " sr", " intr", "rir", "irc", "iri", "adr", "imp", "yr", "irt"], "raddr": [" rtag", "rtag", "baddr", "rloc", "waddress", "mattr", "bloc", "rattr", "wref", " rptr", "baddress", " rreg", " rref", "rptr", "wptr", "mreg", " rloc", "mptr", "rref", "vattr", "wreg", "vaddr", " rattr", "mref", "maddr", "wloc", "vptr", "mtag", "bptr", "vtag", "rreg", "waddr", "raddress", " raddress"], "label_ptr": ["label___ptr", "label__pointer", "label_pointer", "lab_addr", "label_desc", "label_pos", "lab_pointer", "label___addr", "label_ts", "label__desc", "label_obj", "loc_pos", "lab_ptr", "label___desc", " label_pointer", "loc_ts", "label__addr", "loc_ptr", " label_addr", "lab_desc", "label_addr", "label___pointer", "loc_addr", " label_obj", "label__ptr"]}}
{"project": "qemu", "commit_id": "46321d6b5f8c880932a6b3d07bd0ff6f892e665c", "target": 0, "func": "static int nbd_negotiate_handle_info(NBDClient *client, uint32_t length,\n\n                                     uint32_t opt, uint16_t myflags,\n\n                                     Error **errp)\n\n{\n\n    int rc;\n\n    char name[NBD_MAX_NAME_SIZE + 1];\n\n    NBDExport *exp;\n\n    uint16_t requests;\n\n    uint16_t request;\n\n    uint32_t namelen;\n\n    bool sendname = false;\n\n    bool blocksize = false;\n\n    uint32_t sizes[3];\n\n    char buf[sizeof(uint64_t) + sizeof(uint16_t)];\n\n    const char *msg;\n\n\n\n    /* Client sends:\n\n        4 bytes: L, name length (can be 0)\n\n        L bytes: export name\n\n        2 bytes: N, number of requests (can be 0)\n\n        N * 2 bytes: N requests\n\n    */\n\n    if (length < sizeof(namelen) + sizeof(requests)) {\n\n        msg = \"overall request too short\";\n\n        goto invalid;\n\n    }\n\n    if (nbd_read(client->ioc, &namelen, sizeof(namelen), errp) < 0) {\n\n        return -EIO;\n\n    }\n\n    be32_to_cpus(&namelen);\n\n    length -= sizeof(namelen);\n\n    if (namelen > length - sizeof(requests) || (length - namelen) % 2) {\n\n        msg = \"name length is incorrect\";\n\n        goto invalid;\n\n    }\n\n    if (nbd_read(client->ioc, name, namelen, errp) < 0) {\n\n        return -EIO;\n\n    }\n\n    name[namelen] = '\\0';\n\n    length -= namelen;\n\n    trace_nbd_negotiate_handle_export_name_request(name);\n\n\n\n    if (nbd_read(client->ioc, &requests, sizeof(requests), errp) < 0) {\n\n        return -EIO;\n\n    }\n\n    be16_to_cpus(&requests);\n\n    length -= sizeof(requests);\n\n    trace_nbd_negotiate_handle_info_requests(requests);\n\n    if (requests != length / sizeof(request)) {\n\n        msg = \"incorrect number of  requests for overall length\";\n\n        goto invalid;\n\n    }\n\n    while (requests--) {\n\n        if (nbd_read(client->ioc, &request, sizeof(request), errp) < 0) {\n\n            return -EIO;\n\n        }\n\n        be16_to_cpus(&request);\n\n        length -= sizeof(request);\n\n        trace_nbd_negotiate_handle_info_request(request,\n\n                                                nbd_info_lookup(request));\n\n        /* We care about NBD_INFO_NAME and NBD_INFO_BLOCK_SIZE;\n\n         * everything else is either a request we don't know or\n\n         * something we send regardless of request */\n\n        switch (request) {\n\n        case NBD_INFO_NAME:\n\n            sendname = true;\n\n            break;\n\n        case NBD_INFO_BLOCK_SIZE:\n\n            blocksize = true;\n\n            break;\n\n        }\n\n    }\n\n\n\n    exp = nbd_export_find(name);\n\n    if (!exp) {\n\n        return nbd_negotiate_send_rep_err(client->ioc, NBD_REP_ERR_UNKNOWN,\n\n                                          opt, errp, \"export '%s' not present\",\n\n                                          name);\n\n    }\n\n\n\n    /* Don't bother sending NBD_INFO_NAME unless client requested it */\n\n    if (sendname) {\n\n        rc = nbd_negotiate_send_info(client, opt, NBD_INFO_NAME, length, name,\n\n                                     errp);\n\n        if (rc < 0) {\n\n            return rc;\n\n        }\n\n    }\n\n\n\n    /* Send NBD_INFO_DESCRIPTION only if available, regardless of\n\n     * client request */\n\n    if (exp->description) {\n\n        size_t len = strlen(exp->description);\n\n\n\n        rc = nbd_negotiate_send_info(client, opt, NBD_INFO_DESCRIPTION,\n\n                                     len, exp->description, errp);\n\n        if (rc < 0) {\n\n            return rc;\n\n        }\n\n    }\n\n\n\n    /* Send NBD_INFO_BLOCK_SIZE always, but tweak the minimum size\n\n     * according to whether the client requested it, and according to\n\n     * whether this is OPT_INFO or OPT_GO. */\n\n    /* minimum - 1 for back-compat, or 512 if client is new enough.\n\n     * TODO: consult blk_bs(blk)->bl.request_alignment? */\n\n    sizes[0] = (opt == NBD_OPT_INFO || blocksize) ? BDRV_SECTOR_SIZE : 1;\n\n    /* preferred - Hard-code to 4096 for now.\n\n     * TODO: is blk_bs(blk)->bl.opt_transfer appropriate? */\n\n    sizes[1] = 4096;\n\n    /* maximum - At most 32M, but smaller as appropriate. */\n\n    sizes[2] = MIN(blk_get_max_transfer(exp->blk), NBD_MAX_BUFFER_SIZE);\n\n    trace_nbd_negotiate_handle_info_block_size(sizes[0], sizes[1], sizes[2]);\n\n    cpu_to_be32s(&sizes[0]);\n\n    cpu_to_be32s(&sizes[1]);\n\n    cpu_to_be32s(&sizes[2]);\n\n    rc = nbd_negotiate_send_info(client, opt, NBD_INFO_BLOCK_SIZE,\n\n                                 sizeof(sizes), sizes, errp);\n\n    if (rc < 0) {\n\n        return rc;\n\n    }\n\n\n\n    /* Send NBD_INFO_EXPORT always */\n\n    trace_nbd_negotiate_new_style_size_flags(exp->size,\n\n                                             exp->nbdflags | myflags);\n\n    stq_be_p(buf, exp->size);\n\n    stw_be_p(buf + 8, exp->nbdflags | myflags);\n\n    rc = nbd_negotiate_send_info(client, opt, NBD_INFO_EXPORT,\n\n                                 sizeof(buf), buf, errp);\n\n    if (rc < 0) {\n\n        return rc;\n\n    }\n\n\n\n    /* If the client is just asking for NBD_OPT_INFO, but forgot to\n\n     * request block sizes, return an error.\n\n     * TODO: consult blk_bs(blk)->request_align, and only error if it\n\n     * is not 1? */\n\n    if (opt == NBD_OPT_INFO && !blocksize) {\n\n        return nbd_negotiate_send_rep_err(client->ioc,\n\n                                          NBD_REP_ERR_BLOCK_SIZE_REQD, opt,\n\n                                          errp,\n\n                                          \"request NBD_INFO_BLOCK_SIZE to \"\n\n                                          \"use this export\");\n\n    }\n\n\n\n    /* Final reply */\n\n    rc = nbd_negotiate_send_rep(client->ioc, NBD_REP_ACK, opt, errp);\n\n    if (rc < 0) {\n\n        return rc;\n\n    }\n\n\n\n    if (opt == NBD_OPT_GO) {\n\n        client->exp = exp;\n\n        QTAILQ_INSERT_TAIL(&client->exp->clients, client, next);\n\n        nbd_export_get(client->exp);\n\n        rc = 1;\n\n    }\n\n    return rc;\n\n\n\n invalid:\n\n    if (nbd_drop(client->ioc, length, errp) < 0) {\n\n        return -EIO;\n\n    }\n\n    return nbd_negotiate_send_rep_err(client->ioc, NBD_REP_ERR_INVALID, opt,\n\n                                      errp, \"%s\", msg);\n\n}\n", "idx": 5673, "substitutes": {"client": ["this", "service", "ci", "ct", "call", "prefix", "window", "channel", "c", "http", "cli", "cl", "Client", "view", "con", "self", "force", "ip", "plugin", "util", "cmd", "co", "connection", "php", "context", "ce", "server", "contact", "connect", "web", "master", "control", "api", "code", "component", "command", "config", "cell", "product", "google", "local", "handler", "cache", "manager", "core", "sim", "info", "net", "public", "conn", "admin"], "length": ["all", "read", "depth", "form", "result", "padding", "root", "next", "SIZE", "half", "end", "type", "h", "operation", "offset", "last", "vector", "ob", "oh", "buffer", "amount", "p", "duration", "location", "len", "total", "data", "history", "available", "full", "maximum", "height", "trace", "value", "Length", "position", "word", "number", "always", "ENGTH", "ow", "phi", "start", "be", "code", "transform", "ength", "command", "volume", "head", "ptr", "build", "capacity", "count", "address", "loop", "message", "shape", "size", "time", "family", "health", "performance", "obs", "json", "bus", "l", "path", "sequence"], "opt": ["accept", "scope", "sys", "ip", "ext", "cmd", "use", "ts", "op", "settings", "option", "attr", "timeout", "max", "exclusive", "slot", "meta", "batch", "parent", "socket", "session", "loop", "unknown", "optional", "global", "write", "other", "params"], "myflags": ["myFlags", "keyFlags", "getFlags", " myFlags", "mymask", "myflag", "keyflag", "getmask", " myflag", "keymask", "keyflags", " mymask", "getflags", "getflag"], "errp": ["dieping", " erp", " errps", " erpass", "ererpar", "arrp", "errpp", "rrpp", "erpa", "dier", "erp", "arrm", "errps", " errpar", "arrping", "ererp", "warnpar", "errorping", "ererpa", "ererps", "errr", "erping", "diep", "diepa", "errpa", "warnpa", "rrp", "iterpp", " errping", " err", "errpass", "err", "errorp", "arrpp", " erping", "erpass", "iterping", "warnps", "iterps", "iterm", "iterp", "rrping", " errpass", " errr", "warnp", "rrm", "errping", "errm", " errpa", "errpar", "errorps"], "rc": [" cursor", " ro", "rs", " cur", " proc", " clen", " rec", " rid", " exc", " sock", " ok", " src", "len", "row", " ans", " pri", "oc", " loc", " row", " ref", " r", "cur", " priv", " c", " code", "RC", " sc", "xff"], "name": ["init", "all", "package", "error", "sp", "prefix", "mem", "window", "named", "type", "only", "file", "order", "ame", "n", "no", "on", "index", "data", "o", "key", "r", "w", "str", "Name", "id", "word", "an", "resource", "attr", "nm", "out", "num", "v", " NAME", "new", "NAME", "part", "comment", "local", "parent", "alias", "member", "address", "message", "size", " Name", "time", "net", "info", "news", "x", "names", "path", " names"], "requests": ["tements", "twents", "requries", "sequces", "requencies", " reques", "responsesters", " requessions", "acquests", "questines", "keysirements", "reqirements", "twems", "wirements", "pents", " requesters", "requues", "questesters", "keysests", "keysines", "questencies", "reces", "Requesters", "questests", "pems", "sequesters", "keysencies", "requessions", "redests", "questers", "questessions", "recests", "recesters", "waesters", "requers", "pests", "requems", "Requers", "tests", "recers", "tries", "acquencies", " requues", "redirements", "Requces", "requeries", "questues", "wairements", "peries", "questces", "tweries", "reqests", "reques", "waries", "reqesters", "wues", "quries", "requines", "responsests", "Requirements", "sequirements", "Requessions", "Reques", "sequues", "redries", "sequries", "quirements", "Requues", "requirements", "acquirements", " requries", "requesters", "requces", " requirements", "redements", "responsirements", "westers", "quests", "recents", "tirements", " requements", "reqers", "wests", "recirements", "requements", "reqes", "waests", "recems", "twests", "receries", "responsues", "Requests", "sequests", "requents", "questirements", "acquines"], "request": ["header", "package", "result", "error", "event", "call", "task", "window", "est", "type", "reply", "shift", "argument", "buffer", "connection", "index", "queue", "pair", "server", "import", "push", "query", "resource", "attribute", "question", "record", "consider", "child", "try", "memory", "suggest", "complete", "req", "reset", "command", "frame", "requ", "response", "version", "item", "hello", "session", "address", "message", "test", "quest", "Request", "QUEST", "time", "ask", "create", "reference", "condition"], "namelen": ["basellown", "namelineet", "baselown", "namesten", "nameliness", "namewen", "namelem", "nomellen", "sanelun", "nameleer", "namelineen", "namelinearen", "namenameown", "namelessen", "baselen", "namearun", "filelinlen", "nameleen", "baseller", "namellener", "namelinlen", "namesteng", "nameliston", "namelistlen", "namellize", "sanetength", "namelinren", "namlenoen", "namemlen", "nameloren", "lifabelet", "namelinoen", "namelz", "namelet", "namelisten", "nomelens", "namearen", "baseler", "namellun", "namelinEN", "namellern", "nameenen", "namenamez", "sanlenren", "namalen", "namelinelen", "namelineens", "namemar", "nameller", "namelinar", "namelessem", "namenameens", "namelade", "namelistear", "namemener", "namewob", "filelinon", "nameloen", "namelaren", "sanelize", "filelon", "namelear", "namelest", "sanelen", "namabelen", "sanetize", "namelens", "nomelern", "nameelener", "namewens", "nameeneng", "nameselens", "nameselength", "sanlenoen", "namelooen", "lifelen", "nomellern", "nameleown", "namearength", "nametength", "namekern", "namesellens", "namesellob", "namemen", "namellob", "sanelren", "namellown", "namesellen", "nameleng", "namalener", "namestener", "namelineem", "namabeler", "nametize", "lifabelem", "nomelEN", "namabelaren", "nameelen", "namlenren", "namellest", "nomelener", "namelinener", "namelesset", "namelren", "nametun", "nomelllen", "namelineon", "baselens", "namelinen", "namellEN", "filellen", "namesellength", "namenen", "namelinear", "namewength", "naminelen", "namelineEN", "namellz", "nameenener", "basellens", "nameneng", "namelinade", "nomellener", "namelown", "nomelest", "nameeleng", "lifabelen", "nomellar", "namearize", "namelEN", "nameken", "nomellade", "namellar", "lifabelaren", "namelon", "namabelown", "lifelem", "namabelem", "namelength", "namellens", "namekest", "namelineear", "nameless", "saneloen", "filelinen", "namelinob", "nameloess", "namestength", "filelear", "filelen", "nameselob", "sanleness", "saneten", "baselz", "namellength", "namlenen", "namelessaren", "namabelet", "namelize", "namleness", "nomelar", "namenength", "nameelength", "namelllen", "namellen", "nomellest", "namenameen", "namellade", "namalength", "nomellens", "naminelern", "namelinon", "namelinz", "nameenength", "sanelength", "lifelet", "nameler", "namelinength", "sanlenen", "basellz", "naminelest", "namelar", "nameselen", "lifelaren", "nameten", "sanetun", "namelener", "namelinens", "namelinown", "nomelade", "basellen", "namelineade", "saneless", "nomellEN", "namenener", "namelern", "filelinear", "nomelen", "namaleng", "namelob", "namelun"], "sizes": ["gists", "gizes", "siz", "sizers", "dizers", "gizers", "dizes", "sists", " sizers", "diz", "dists", "giz", " sists", " siz"], "buf": ["cast", "uf", "buff", "b", "mem", "window", "br", "box", "Buffer", "buffer", "raw", "seq", "map", "var", "cb", "data", "str", "ref", "cap", "block", "alloc", " buffer", "img", "pool", "desc", "def", "ba"], "msg": ["gs", "q", "mag", "mn", "sg", "mem", "gm", "mess", "md", "bg", "ug", "state", "comm", "alg", "eg", "g", "med", "cmd", "ms", "urg", " message", "mg", "ge", "og", "label", "err", "str", "pkg", "nm", "out", "status", "m", "ch", "mb", "cfg", "comment", "rg", "tmp", "mm", "gz", "doc", "jump", "message", "sim", "arg", "j", "res", "broad", "Msg"]}}
{"project": "qemu", "commit_id": "28b70c9dbdce0d517ade9c04c7d7ae05c8b76d2f", "target": 0, "func": "static int scsi_req_stream_length(SCSICommand *cmd, SCSIDevice *dev, uint8_t *buf)\n\n{\n\n    switch (buf[0]) {\n\n    /* stream commands */\n\n    case ERASE_12:\n\n    case ERASE_16:\n\n        cmd->xfer = 0;\n\n        break;\n\n    case READ_6:\n\n    case READ_REVERSE:\n\n    case RECOVER_BUFFERED_DATA:\n\n    case WRITE_6:\n\n        cmd->len = 6;\n\n        cmd->xfer = buf[4] | (buf[3] << 8) | (buf[2] << 16);\n\n        if (buf[1] & 0x01) { /* fixed */\n\n            cmd->xfer *= dev->blocksize;\n\n        }\n\n        break;\n\n    case READ_16:\n\n    case READ_REVERSE_16:\n\n    case VERIFY_16:\n\n    case WRITE_16:\n\n        cmd->len = 16;\n\n        cmd->xfer = buf[14] | (buf[13] << 8) | (buf[12] << 16);\n\n        if (buf[1] & 0x01) { /* fixed */\n\n            cmd->xfer *= dev->blocksize;\n\n        }\n\n        break;\n\n    case REWIND:\n\n    case LOAD_UNLOAD:\n\n        cmd->len = 6;\n\n        cmd->xfer = 0;\n\n        break;\n\n    case SPACE_16:\n\n        cmd->xfer = buf[13] | (buf[12] << 8);\n\n        break;\n\n    case READ_POSITION:\n\n        cmd->xfer = buf[8] | (buf[7] << 8);\n\n        break;\n\n    case FORMAT_UNIT:\n\n        cmd->xfer = buf[4] | (buf[3] << 8);\n\n        break;\n\n    /* generic commands */\n\n    default:\n\n        return scsi_req_length(cmd, dev, buf);\n\n    }\n\n    return 0;\n\n}\n", "idx": 5676, "substitutes": {"cmd": ["init", "act", "content", "cod", "quick", "form", "ct", "call", "att", "cp", "conf", "dep", "md", "cli", "job", "kt", "cmp", "cont", "ctx", "det", "find", "nd", "comm", "nt", "ann", "cor", "msg", "help", "mk", "raw", "ext", "addr", "bind", "add", "op", "del", "and", "utils", "query", "crit", "pkg", "opt", "rest", "control", "send", "txt", "host", "req", "command", "cfg", "config", "resp", "controller", "quit", "kind", "batch", "cd", "exec", "kick", "cat", "desc", "comp", "ctr", "Cmd", "hold", "news", "text", "auth", "wd", "conn", "def", "urg"], "dev": ["db", "ev", "event", "des", "mem", "window", "devices", "dep", "md", "ctx", "def", "cam", "DEV", "det", "dem", "pro", "nt", "ve", " Dev", "addr", "var", "hw", "server", "w", "go", "adv", "proc", "debug", "device", "v", "Device", "dd", "driver", "serv", "home", "doc", "priv", "rend", "serial", "wd", "ver", "Dev", "conn", "env", "develop"], "buf": ["fam", "bag", "uv", "bytes", "uf", "grad", "bed", "cb", "queue", "w", "blocks", "txt", "fb", "tmp", "batch", "cat", "aka", "bin", "buff", "pad", "bh", "wb", "go", "rb", "v", "packed", "desc", "conv", "text", "vec", "agg", "db", "aw", "ctx", "bc", "Buffer", "comm", "msg", "seq", "prop", "len", "var", "val", "bar", "pkg", "Buff", "nm", "orig", "cfg", "bs", "cv", "deg", "act", "b", "bn", "ff", "window", "pb", "br", "pack", "box", "buffer", "raw", "ext", "bp", "etc", "aux", "func", "err", "ref", "proc", "cap", "args", "block", "tab", "off", "img", "doc", "cache", "arr"]}}
{"project": "qemu", "commit_id": "a7812ae412311d7d47f8aa85656faadac9d64b56", "target": 0, "func": "static void gen_tst_cc (DisasContext *dc, TCGv cc, int cond)\n\n{\n\n\tint arith_opt, move_opt;\n\n\n\n\t/* TODO: optimize more condition codes.  */\n\n\n\n\t/*\n\n\t * If the flags are live, we've gotta look into the bits of CCS.\n\n\t * Otherwise, if we just did an arithmetic operation we try to\n\n\t * evaluate the condition code faster.\n\n\t *\n\n\t * When this function is done, T0 should be non-zero if the condition\n\n\t * code is true.\n\n\t */\n\n\tarith_opt = arith_cc(dc) && !dc->flags_uptodate;\n\n\tmove_opt = (dc->cc_op == CC_OP_MOVE) && dc->flags_uptodate;\n\n\tswitch (cond) {\n\n\t\tcase CC_EQ:\n\n\t\t\tif (arith_opt || move_opt) {\n\n\t\t\t\t/* If cc_result is zero, T0 should be \n\n\t\t\t\t   non-zero otherwise T0 should be zero.  */\n\n\t\t\t\tint l1;\n\n\t\t\t\tl1 = gen_new_label();\n\n\t\t\t\ttcg_gen_movi_tl(cc, 0);\n\n\t\t\t\ttcg_gen_brcondi_tl(TCG_COND_NE, cc_result, \n\n\t\t\t\t\t\t   0, l1);\n\n\t\t\t\ttcg_gen_movi_tl(cc, 1);\n\n\t\t\t\tgen_set_label(l1);\n\n\t\t\t}\n\n\t\t\telse {\n\n\t\t\t\tcris_evaluate_flags(dc);\n\n\t\t\t\ttcg_gen_andi_tl(cc, \n\n\t\t\t\t\t\tcpu_PR[PR_CCS], Z_FLAG);\n\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase CC_NE:\n\n\t\t\tif (arith_opt || move_opt)\n\n\t\t\t\ttcg_gen_mov_tl(cc, cc_result);\n\n\t\t\telse {\n\n\t\t\t\tcris_evaluate_flags(dc);\n\n\t\t\t\ttcg_gen_xori_tl(cc, cpu_PR[PR_CCS],\n\n\t\t\t\t\t\tZ_FLAG);\n\n\t\t\t\ttcg_gen_andi_tl(cc, cc, Z_FLAG);\n\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase CC_CS:\n\n\t\t\tcris_evaluate_flags(dc);\n\n\t\t\ttcg_gen_andi_tl(cc, cpu_PR[PR_CCS], C_FLAG);\n\n\t\t\tbreak;\n\n\t\tcase CC_CC:\n\n\t\t\tcris_evaluate_flags(dc);\n\n\t\t\ttcg_gen_xori_tl(cc, cpu_PR[PR_CCS], C_FLAG);\n\n\t\t\ttcg_gen_andi_tl(cc, cc, C_FLAG);\n\n\t\t\tbreak;\n\n\t\tcase CC_VS:\n\n\t\t\tcris_evaluate_flags(dc);\n\n\t\t\ttcg_gen_andi_tl(cc, cpu_PR[PR_CCS], V_FLAG);\n\n\t\t\tbreak;\n\n\t\tcase CC_VC:\n\n\t\t\tcris_evaluate_flags(dc);\n\n\t\t\ttcg_gen_xori_tl(cc, cpu_PR[PR_CCS],\n\n\t\t\t\t\tV_FLAG);\n\n\t\t\ttcg_gen_andi_tl(cc, cc, V_FLAG);\n\n\t\t\tbreak;\n\n\t\tcase CC_PL:\n\n\t\t\tif (arith_opt || move_opt) {\n\n\t\t\t\tint bits = 31;\n\n\n\n\t\t\t\tif (dc->cc_size == 1)\n\n\t\t\t\t\tbits = 7;\n\n\t\t\t\telse if (dc->cc_size == 2)\n\n\t\t\t\t\tbits = 15;\t\n\n\n\n\t\t\t\ttcg_gen_shri_tl(cc, cc_result, bits);\n\n\t\t\t\ttcg_gen_xori_tl(cc, cc, 1);\n\n\t\t\t} else {\n\n\t\t\t\tcris_evaluate_flags(dc);\n\n\t\t\t\ttcg_gen_xori_tl(cc, cpu_PR[PR_CCS],\n\n\t\t\t\t\t\tN_FLAG);\n\n\t\t\t\ttcg_gen_andi_tl(cc, cc, N_FLAG);\n\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase CC_MI:\n\n\t\t\tif (arith_opt || move_opt) {\n\n\t\t\t\tint bits = 31;\n\n\n\n\t\t\t\tif (dc->cc_size == 1)\n\n\t\t\t\t\tbits = 7;\n\n\t\t\t\telse if (dc->cc_size == 2)\n\n\t\t\t\t\tbits = 15;\t\n\n\n\n\t\t\t\ttcg_gen_shri_tl(cc, cc_result, 31);\n\n\t\t\t}\n\n\t\t\telse {\n\n\t\t\t\tcris_evaluate_flags(dc);\n\n\t\t\t\ttcg_gen_andi_tl(cc, cpu_PR[PR_CCS],\n\n\t\t\t\t\t\tN_FLAG);\n\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase CC_LS:\n\n\t\t\tcris_evaluate_flags(dc);\n\n\t\t\ttcg_gen_andi_tl(cc, cpu_PR[PR_CCS],\n\n\t\t\t\t\tC_FLAG | Z_FLAG);\n\n\t\t\tbreak;\n\n\t\tcase CC_HI:\n\n\t\t\tcris_evaluate_flags(dc);\n\n\t\t\t{\n\n\t\t\t\tTCGv tmp;\n\n\n\n\t\t\t\ttmp = tcg_temp_new(TCG_TYPE_TL);\n\n\t\t\t\ttcg_gen_xori_tl(tmp, cpu_PR[PR_CCS],\n\n\t\t\t\t\t\tC_FLAG | Z_FLAG);\n\n\t\t\t\t/* Overlay the C flag on top of the Z.  */\n\n\t\t\t\ttcg_gen_shli_tl(cc, tmp, 2);\n\n\t\t\t\ttcg_gen_and_tl(cc, tmp, cc);\n\n\t\t\t\ttcg_gen_andi_tl(cc, cc, Z_FLAG);\n\n\n\n\t\t\t\ttcg_temp_free(tmp);\n\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase CC_GE:\n\n\t\t\tcris_evaluate_flags(dc);\n\n\t\t\t/* Overlay the V flag on top of the N.  */\n\n\t\t\ttcg_gen_shli_tl(cc, cpu_PR[PR_CCS], 2);\n\n\t\t\ttcg_gen_xor_tl(cc,\n\n\t\t\t\t       cpu_PR[PR_CCS], cc);\n\n\t\t\ttcg_gen_andi_tl(cc, cc, N_FLAG);\n\n\t\t\ttcg_gen_xori_tl(cc, cc, N_FLAG);\n\n\t\t\tbreak;\n\n\t\tcase CC_LT:\n\n\t\t\tcris_evaluate_flags(dc);\n\n\t\t\t/* Overlay the V flag on top of the N.  */\n\n\t\t\ttcg_gen_shli_tl(cc, cpu_PR[PR_CCS], 2);\n\n\t\t\ttcg_gen_xor_tl(cc,\n\n\t\t\t\t       cpu_PR[PR_CCS], cc);\n\n\t\t\ttcg_gen_andi_tl(cc, cc, N_FLAG);\n\n\t\t\tbreak;\n\n\t\tcase CC_GT:\n\n\t\t\tcris_evaluate_flags(dc);\n\n\t\t\t{\n\n\t\t\t\tTCGv n, z;\n\n\n\n\t\t\t\tn = tcg_temp_new(TCG_TYPE_TL);\n\n\t\t\t\tz = tcg_temp_new(TCG_TYPE_TL);\n\n\n\n\t\t\t\t/* To avoid a shift we overlay everything on\n\n\t\t\t\t   the V flag.  */\n\n\t\t\t\ttcg_gen_shri_tl(n, cpu_PR[PR_CCS], 2);\n\n\t\t\t\ttcg_gen_shri_tl(z, cpu_PR[PR_CCS], 1);\n\n\t\t\t\t/* invert Z.  */\n\n\t\t\t\ttcg_gen_xori_tl(z, z, 2);\n\n\n\n\t\t\t\ttcg_gen_xor_tl(n, n, cpu_PR[PR_CCS]);\n\n\t\t\t\ttcg_gen_xori_tl(n, n, 2);\n\n\t\t\t\ttcg_gen_and_tl(cc, z, n);\n\n\t\t\t\ttcg_gen_andi_tl(cc, cc, 2);\n\n\n\n\t\t\t\ttcg_temp_free(n);\n\n\t\t\t\ttcg_temp_free(z);\n\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase CC_LE:\n\n\t\t\tcris_evaluate_flags(dc);\n\n\t\t\t{\n\n\t\t\t\tTCGv n, z;\n\n\n\n\t\t\t\tn = tcg_temp_new(TCG_TYPE_TL);\n\n\t\t\t\tz = tcg_temp_new(TCG_TYPE_TL);\n\n\n\n\t\t\t\t/* To avoid a shift we overlay everything on\n\n\t\t\t\t   the V flag.  */\n\n\t\t\t\ttcg_gen_shri_tl(n, cpu_PR[PR_CCS], 2);\n\n\t\t\t\ttcg_gen_shri_tl(z, cpu_PR[PR_CCS], 1);\n\n\n\n\t\t\t\ttcg_gen_xor_tl(n, n, cpu_PR[PR_CCS]);\n\n\t\t\t\ttcg_gen_or_tl(cc, z, n);\n\n\t\t\t\ttcg_gen_andi_tl(cc, cc, 2);\n\n\n\n\t\t\t\ttcg_temp_free(n);\n\n\t\t\t\ttcg_temp_free(z);\n\n\t\t\t}\n\n\t\t\tbreak;\n\n\t\tcase CC_P:\n\n\t\t\tcris_evaluate_flags(dc);\n\n\t\t\ttcg_gen_andi_tl(cc, cpu_PR[PR_CCS], P_FLAG);\n\n\t\t\tbreak;\n\n\t\tcase CC_A:\n\n\t\t\ttcg_gen_movi_tl(cc, 1);\n\n\t\t\tbreak;\n\n\t\tdefault:\n\n\t\t\tBUG();\n\n\t\t\tbreak;\n\n\t};\n\n}\n", "idx": 5694, "substitutes": {"dc": ["cf", "gc", "ci", "ctl", "dat", "wp", "cp", "c", "pc", "ctx", "kt", "bc", "sys", "sc", "cs", "fc", "DC", "du", "d", "cm", "co", "dl", "cmd", "dt", "nc", "ec", "document", "ds", "mic", "lc", "cci", "func", "dr", "rc", "dm", "mac", "kw", "dd", "vc", "dk", "mm", "cd", "disc", "cca", "desc", "doc", "mc", "dp", "cat", "iac", "rec", "ga", "coord", "di", "cu", "tc", "da"], "cc": ["ck", "cf", "ic", "gc", "ct", "ssl", "ctl", "cz", "craft", "ff", "cp", "jj", "cy", "c", "pc", "ctx", "kk", "cmp", "bc", "ucc", "cont", "cl", " mc", "cs", "sc", "fc", "addr", "co", "cmd", "xx", "nc", "ec", "php", " bc", "ce", "cci", " ecc", "lc", "func", "zz", "tch", "rc", "bb", "ship", "soc", "code", " ac", "acc", " gcc", "cn", "dd", "jac", "cell", "ac", "vc", "isc", "cv", "cca", "mc", " rc", "cong", " c", "pp", "CC", "ll", "cu", "inc", "tc"], "cond": [" Cond", "cod", "chain", "ct", "wait", "when", "conf", "ond", "cmp", "cont", "Condition", "con", "given", "wind", "cmd", "bind", "pred", "ind", "bo", "red", "bit", "bool", "crit", "pos", "sec", "req", "dd", "status", "resp", "command", "comp", "check", "lock", "respond", "hold", "Cond", "condition", "flag"], "arith_opt": ["arich_op", "arith___opt", "arith_opted", "arthur_op", "arthur____opt", "arich___op", "arth_obj", "arth_op", "arth_opt", "arith_Opt", "arithlyopt", "arich___opt", "arith____oss", "arthur_Opt", "arth_loss", "arith_optim", "arith_obj", "arith___obj", "arth_opted", "arith___op", "arith___optim", "arith___pot", "arith____Opt", "arich_opt", "arithlypot", "arthur_oss", "arith_oss", "arithlyop", "arthur____op", "arith____opt", "arthur____Opt", "arithlyoptim", "arith____op", "arith_op", "arthur____oss", "arith_pot", "arith___opted", "arich_pot", "arich___pot", "arich___optim", "arith_loss", "arich_optim", "arthur_opt"], "move_opt": ["moving_lit", "remove_optim", " move_op", "remove_lit", "movelyopt", "moving_to", "fire_opt", "fire_pred", "movelylit", "remove_op", "move_to", "movelyop", "move_optim", "moveingoptim", "moveingpred", "movelyoptim", "moving_op", "movinglylit", "fire_optim", " move_crit", "fireingop", "remove_opt", "moveingop", "fire_op", "fireingoptim", "moving_opt", "move_lit", "fireingpred", "movinglyop", "movinglyopt", "fireingopt", "movinglyto", "move_crit", "moveingopt", "move_op", "move_pred", "move_tr", " move_tr", "movelyto"], "l1": ["liup", " l0", "sl2", "Lmb", "li0", "ling", " l3", "lc1", "L0", "L001", " l001", "li3", "l001", "sl3", "l2", " lng", "li1", "lmb", " lup", "limb", "sl1", " lmb", "li2", "lup", "lc0", "lc2", "lc001", " l2", "l3", "Lng", "l0", "L1", "lng", "slup", "L2"]}}
{"project": "qemu", "commit_id": "b4854f1384176d897747de236f426d020668fa3c", "target": 0, "func": "void do_smm_enter(X86CPU *cpu)\n\n{\n\n    CPUX86State *env = &cpu->env;\n\n    CPUState *cs = CPU(cpu);\n\n    target_ulong sm_state;\n\n    SegmentCache *dt;\n\n    int i, offset;\n\n\n\n    qemu_log_mask(CPU_LOG_INT, \"SMM: enter\\n\");\n\n    log_cpu_state_mask(CPU_LOG_INT, CPU(cpu), CPU_DUMP_CCOP);\n\n\n\n    env->hflags |= HF_SMM_MASK;\n\n    if (env->hflags2 & HF2_NMI_MASK) {\n\n        env->hflags2 |= HF2_SMM_INSIDE_NMI_MASK;\n\n    } else {\n\n        env->hflags2 |= HF2_NMI_MASK;\n\n    }\n\n    cpu_smm_update(env);\n\n\n\n    sm_state = env->smbase + 0x8000;\n\n\n\n#ifdef TARGET_X86_64\n\n    for (i = 0; i < 6; i++) {\n\n        dt = &env->segs[i];\n\n        offset = 0x7e00 + i * 16;\n\n        x86_stw_phys(cs, sm_state + offset, dt->selector);\n\n        x86_stw_phys(cs, sm_state + offset + 2, (dt->flags >> 8) & 0xf0ff);\n\n        x86_stl_phys(cs, sm_state + offset + 4, dt->limit);\n\n        x86_stq_phys(cs, sm_state + offset + 8, dt->base);\n\n    }\n\n\n\n    x86_stq_phys(cs, sm_state + 0x7e68, env->gdt.base);\n\n    x86_stl_phys(cs, sm_state + 0x7e64, env->gdt.limit);\n\n\n\n    x86_stw_phys(cs, sm_state + 0x7e70, env->ldt.selector);\n\n    x86_stq_phys(cs, sm_state + 0x7e78, env->ldt.base);\n\n    x86_stl_phys(cs, sm_state + 0x7e74, env->ldt.limit);\n\n    x86_stw_phys(cs, sm_state + 0x7e72, (env->ldt.flags >> 8) & 0xf0ff);\n\n\n\n    x86_stq_phys(cs, sm_state + 0x7e88, env->idt.base);\n\n    x86_stl_phys(cs, sm_state + 0x7e84, env->idt.limit);\n\n\n\n    x86_stw_phys(cs, sm_state + 0x7e90, env->tr.selector);\n\n    x86_stq_phys(cs, sm_state + 0x7e98, env->tr.base);\n\n    x86_stl_phys(cs, sm_state + 0x7e94, env->tr.limit);\n\n    x86_stw_phys(cs, sm_state + 0x7e92, (env->tr.flags >> 8) & 0xf0ff);\n\n\n\n    x86_stq_phys(cs, sm_state + 0x7ed0, env->efer);\n\n\n\n    x86_stq_phys(cs, sm_state + 0x7ff8, env->regs[R_EAX]);\n\n    x86_stq_phys(cs, sm_state + 0x7ff0, env->regs[R_ECX]);\n\n    x86_stq_phys(cs, sm_state + 0x7fe8, env->regs[R_EDX]);\n\n    x86_stq_phys(cs, sm_state + 0x7fe0, env->regs[R_EBX]);\n\n    x86_stq_phys(cs, sm_state + 0x7fd8, env->regs[R_ESP]);\n\n    x86_stq_phys(cs, sm_state + 0x7fd0, env->regs[R_EBP]);\n\n    x86_stq_phys(cs, sm_state + 0x7fc8, env->regs[R_ESI]);\n\n    x86_stq_phys(cs, sm_state + 0x7fc0, env->regs[R_EDI]);\n\n    for (i = 8; i < 16; i++) {\n\n        x86_stq_phys(cs, sm_state + 0x7ff8 - i * 8, env->regs[i]);\n\n    }\n\n    x86_stq_phys(cs, sm_state + 0x7f78, env->eip);\n\n    x86_stl_phys(cs, sm_state + 0x7f70, cpu_compute_eflags(env));\n\n    x86_stl_phys(cs, sm_state + 0x7f68, env->dr[6]);\n\n    x86_stl_phys(cs, sm_state + 0x7f60, env->dr[7]);\n\n\n\n    x86_stl_phys(cs, sm_state + 0x7f48, env->cr[4]);\n\n    x86_stq_phys(cs, sm_state + 0x7f50, env->cr[3]);\n\n    x86_stl_phys(cs, sm_state + 0x7f58, env->cr[0]);\n\n\n\n    x86_stl_phys(cs, sm_state + 0x7efc, SMM_REVISION_ID);\n\n    x86_stl_phys(cs, sm_state + 0x7f00, env->smbase);\n\n#else\n\n    x86_stl_phys(cs, sm_state + 0x7ffc, env->cr[0]);\n\n    x86_stl_phys(cs, sm_state + 0x7ff8, env->cr[3]);\n\n    x86_stl_phys(cs, sm_state + 0x7ff4, cpu_compute_eflags(env));\n\n    x86_stl_phys(cs, sm_state + 0x7ff0, env->eip);\n\n    x86_stl_phys(cs, sm_state + 0x7fec, env->regs[R_EDI]);\n\n    x86_stl_phys(cs, sm_state + 0x7fe8, env->regs[R_ESI]);\n\n    x86_stl_phys(cs, sm_state + 0x7fe4, env->regs[R_EBP]);\n\n    x86_stl_phys(cs, sm_state + 0x7fe0, env->regs[R_ESP]);\n\n    x86_stl_phys(cs, sm_state + 0x7fdc, env->regs[R_EBX]);\n\n    x86_stl_phys(cs, sm_state + 0x7fd8, env->regs[R_EDX]);\n\n    x86_stl_phys(cs, sm_state + 0x7fd4, env->regs[R_ECX]);\n\n    x86_stl_phys(cs, sm_state + 0x7fd0, env->regs[R_EAX]);\n\n    x86_stl_phys(cs, sm_state + 0x7fcc, env->dr[6]);\n\n    x86_stl_phys(cs, sm_state + 0x7fc8, env->dr[7]);\n\n\n\n    x86_stl_phys(cs, sm_state + 0x7fc4, env->tr.selector);\n\n    x86_stl_phys(cs, sm_state + 0x7f64, env->tr.base);\n\n    x86_stl_phys(cs, sm_state + 0x7f60, env->tr.limit);\n\n    x86_stl_phys(cs, sm_state + 0x7f5c, (env->tr.flags >> 8) & 0xf0ff);\n\n\n\n    x86_stl_phys(cs, sm_state + 0x7fc0, env->ldt.selector);\n\n    x86_stl_phys(cs, sm_state + 0x7f80, env->ldt.base);\n\n    x86_stl_phys(cs, sm_state + 0x7f7c, env->ldt.limit);\n\n    x86_stl_phys(cs, sm_state + 0x7f78, (env->ldt.flags >> 8) & 0xf0ff);\n\n\n\n    x86_stl_phys(cs, sm_state + 0x7f74, env->gdt.base);\n\n    x86_stl_phys(cs, sm_state + 0x7f70, env->gdt.limit);\n\n\n\n    x86_stl_phys(cs, sm_state + 0x7f58, env->idt.base);\n\n    x86_stl_phys(cs, sm_state + 0x7f54, env->idt.limit);\n\n\n\n    for (i = 0; i < 6; i++) {\n\n        dt = &env->segs[i];\n\n        if (i < 3) {\n\n            offset = 0x7f84 + i * 12;\n\n        } else {\n\n            offset = 0x7f2c + (i - 3) * 12;\n\n        }\n\n        x86_stl_phys(cs, sm_state + 0x7fa8 + i * 4, dt->selector);\n\n        x86_stl_phys(cs, sm_state + offset + 8, dt->base);\n\n        x86_stl_phys(cs, sm_state + offset + 4, dt->limit);\n\n        x86_stl_phys(cs, sm_state + offset, (dt->flags >> 8) & 0xf0ff);\n\n    }\n\n    x86_stl_phys(cs, sm_state + 0x7f14, env->cr[4]);\n\n\n\n    x86_stl_phys(cs, sm_state + 0x7efc, SMM_REVISION_ID);\n\n    x86_stl_phys(cs, sm_state + 0x7ef8, env->smbase);\n\n#endif\n\n    /* init SMM cpu state */\n\n\n\n#ifdef TARGET_X86_64\n\n    cpu_load_efer(env, 0);\n\n#endif\n\n    cpu_load_eflags(env, 0, ~(CC_O | CC_S | CC_Z | CC_A | CC_P | CC_C |\n\n                              DF_MASK));\n\n    env->eip = 0x00008000;\n\n    cpu_x86_update_cr0(env,\n\n                       env->cr[0] & ~(CR0_PE_MASK | CR0_EM_MASK | CR0_TS_MASK |\n\n                                      CR0_PG_MASK));\n\n    cpu_x86_update_cr4(env, 0);\n\n    env->dr[7] = 0x00000400;\n\n\n\n    cpu_x86_load_seg_cache(env, R_CS, (env->smbase >> 4) & 0xffff, env->smbase,\n\n                           0xffffffff,\n\n                           DESC_P_MASK | DESC_S_MASK | DESC_W_MASK |\n\n                           DESC_A_MASK);\n\n    cpu_x86_load_seg_cache(env, R_DS, 0, 0, 0xffffffff,\n\n                           DESC_P_MASK | DESC_S_MASK | DESC_W_MASK |\n\n                           DESC_A_MASK);\n\n    cpu_x86_load_seg_cache(env, R_ES, 0, 0, 0xffffffff,\n\n                           DESC_P_MASK | DESC_S_MASK | DESC_W_MASK |\n\n                           DESC_A_MASK);\n\n    cpu_x86_load_seg_cache(env, R_SS, 0, 0, 0xffffffff,\n\n                           DESC_P_MASK | DESC_S_MASK | DESC_W_MASK |\n\n                           DESC_A_MASK);\n\n    cpu_x86_load_seg_cache(env, R_FS, 0, 0, 0xffffffff,\n\n                           DESC_P_MASK | DESC_S_MASK | DESC_W_MASK |\n\n                           DESC_A_MASK);\n\n    cpu_x86_load_seg_cache(env, R_GS, 0, 0, 0xffffffff,\n\n                           DESC_P_MASK | DESC_S_MASK | DESC_W_MASK |\n\n                           DESC_A_MASK);\n\n}\n", "idx": 5707, "substitutes": {"cpu": ["ck", "CPU", "gc", "task", "cum", "mem", "cp", "pty", "rpm", "ola", "c", "pu", "pc", "ctx", "tp", "prof", "phy", "clock", "arch", "p", "cmd", "mx", "nc", "hz", "xi", "process", "hw", "bit", "linux", "proc", "mu", "bench", "mac", "nic", "ork", "hap", "processor", "frame", "apache", "uu", "pool", "jp", "np", "aco", "core", "vm", "cu", "hog", "gpu", "conn"], "env": ["iv", "uv", "gc", "ei", "esc", "skin", "sw", "scope", "buf", "sc", "self", "addr", "ec", "dev", "cb", "environment", "gear", "query", "web", "NV", "en", "ah", "worker", "dn", "operator", "enc", "origin", "esm", "vv", "next", "forge", "kh", "ve", "er", "gn", "context", "eh", "server", "el", "esp", "v", "vs", "der", "serv", "exec", "oe", "shell", "db", "ev", "et", "console", "kernel", "end", "ctx", "eni", "era", "ent", "nc", "viron", "hw", "dh", " environment", "eur", "org", "nv", "head", "response", "cv", "uint", "vm", "engine", "eve", "init", "window", "ov", "eps", "here", "eas", "erd", "ext", "cmd", "inv", "vp", "ew", "eng", "ner", "func", "_", "Environment", "proc", "ef", "eu", "equ", "ee", "manager", "vt", "obj", "qt", "gen", "e", "conn"], "cs": ["ck", "cf", "rs", "gc", "gs", "cas", "CS", "ct", "cp", "ns", "ics", "c", "wcs", "ctx", "acs", "pc", "ats", "cks", "sys", "qs", "sc", "aps", "ces", "acts", "ads", "ps", "cm", "ec", "ts", "nc", "ds", "yes", "css", "cus", "ce", "cc", "js", "rc", "ths", "ls", "sb", "s", "cn", "ims", "checks", "ras", "els", "ch", "vs", "vc", "hs", "ss", "bs", "cv", "sq", "cons", "ys", "ks", "sts", "ctr", "icks", "tc"], "sm_state": ["smammupowered", "shell_start", "smtremote", "smtstat", "sm___remote", "orea_stat", "sm0remote", "stamtstore", "orea7remote", "shell_state", "smxpowered", "sm_role", "sm0monitor", "modelgrstat", " sm_status", "smmtstore", " sm_role", "smammustart", " sm_size", "sm_tag", "sm7remote", "sm_see", " sm_store", "sm___stat", "smammustate", "orea_state", "model_config", "sm_cache", "smxstatus", "inv_status", "sm0store", "shellammupowered", "sm____post", "sta_state", "smtstate", "smgrconfig", "sm7powered", "esm_state", "sta_post", "sm_State", "sm0state", "sm8monitor", "sta_role", " sm_resource", "inv_remote", "smammucache", " sm2State", "sm___state", " sm_State", "sm2stat", "sm8status", "sm8remote", "orea7stat", "sm_resource", "model_states", "sm____role", "sm2start", "sta_store", "shellammucache", "modelgrstates", "inv_state", "sm2resource", "inv0state", "sm2role", "sm____state", "esm_role", "sm0status", "sm7stat", "sm_part", "sm_stat", "perm_see", "perm_powered", "sm_se", "esm_store", "stamtrole", "inv0monitor", "sm_STATE", " sm2resource", "smmtrole", "stamtstate", "sm_config", "sm_start", "sm8state", " sm_se", "sm7part", "smxstate", "sm0role", "sm____store", " sm_start", "sm_status", "modelgrconfig", "stamtpost", "sm_monitor", "smgrstates", "shell_powered", "sm2State", "sm2states", "sm2state", "sm_size", " sm_powered", "sm7state", "orea_remote", "sm2config", "orea7state", "smmtpost", " sm2state", "model_state", "perm_part", "perm_state", "sm2post", "smgrstat", " sm_STATE", " sm_tag", "sm2store", "sm_powered", "sm_post", "smmtstate", "smmtSTATE", "sm7see", "smmttag", "modelgrstate", "sm_remote", "smgrstate", "shell_cache", "inv0status", "sm_states", "smxstore", "shellammustart", "model_stat", "inv0remote", "sm_store", "shellammustate", "esm_status", " sm2start", "inv_monitor"], "dt": ["db", "dj", "gt", "dc", "et", "ct", "ctl", "dat", "pb", "ctx", "kt", "kat", "ta", "elt", "d", "dl", "mt", "tm", "tn", "typ", "ts", "ds", "tif", "bt", "t", "dh", "dm", "lp", "cn", "txt", "tz", "rt", "dd", "dq", "dn", "iat", "dp", "qt", "hd", "DT", "td", "tk", "di", "tp", "fd", "tt", "tc", "ect"], "i": ["ic", "ini", "asi", "ij", " bi", "ci", " ii", "it", "c", "cli", "oi", "gi", "mi", "qi", "ip", "li", "p", "si", "ami", "zi", "n", "is", "xi", "index", "o", "t", "hi", "pi", "multi", "bi", "ri", "me", "id", "ui", "ji", "span", " I", "phi", "ti", "v", "ims", "ix", " j", "ai", "m", "status", "a", "I", "batch", "y", "sim", "gu", "iu", "e", "in", "j", "x", "di", "ii"], "offset": ["output", "error", "outer", "padding", "encrypted", "prefix", "end", "term", "shift", "pad", "set", "buffer", "adjusted", "associated", "ip", "extra", "base", "addr", "order", "location", "seek", "seed", "option", "index", "o", "fp", "key", "pointer", "ut", "queue", "append", "trace", "position", "slice", "ui", "pos", "id", "ref", "attr", "attribute", "align", "style", "start", "timeout", "options", "sector", "ot", "ix", "slot", "iso", "reset", "scroll", "off", "entry", "item", "batch", "remote", "alias", "address", "tile", "size", "point", "info", "Offset", "origin", "reference"]}}
{"project": "qemu", "commit_id": "07caea315a85ebfe90851f9c2e4ef3fdd24117b5", "target": 1, "func": "PCIDevice *pci_nic_init(NICInfo *nd, const char *default_model,\n\n                        const char *default_devaddr)\n\n{\n\n    const char *devaddr = nd->devaddr ? nd->devaddr : default_devaddr;\n\n    PCIDevice *pci_dev;\n\n    DeviceState *dev;\n\n    int i;\n\n\n\n    i = qemu_check_nic_model_list(nd, pci_nic_models, default_model);\n\n    pci_dev = pci_create(pci_nic_names[i], devaddr);\n\n    dev = &pci_dev->qdev;\n\n    if (nd->id)\n\n        dev->id = qemu_strdup(nd->id);\n\n    dev->nd = nd;\n\n    qdev_init(dev);\n\n    nd->private = dev;\n\n    return pci_dev;\n\n}\n", "idx": 5718, "substitutes": {"nd": ["ck", "them", "mn", "ln", "dat", "nih", "ns", "ond", "md", "ctx", "nt", "nor", "nn", "ND", "rn", "wind", "d", "ent", "ant", "dl", "inst", "n", "gn", "nc", "sd", "ind", "std", "wn", "ined", "nil", "rest", "ng", "nv", "vd", "rt", "dd", "fn", "und", "dn", "nb", "dk", "hn", "sn", "cd", "np", "ord", "rd", "pd", "hd", "nda", "td", "ld", "nl", "news", "ne", "fd", "nw", "inn", "od"], "default_model": ["FAULT_mode", "FAULT_device", "Default_model", "default___model", "default___mode", "FAULT___mode", "default_device", "FAULT___device", "Default_Model", "default___device", "default_link", "Default_models", "default_models", "default___link", "FAULT___link", "default_Model", "Default_mode", "default_mode", "FAULT_link", "FAULT___model", "FAULT_model"], "default_devaddr": ["default_Devname", "default_devname", "default_devaddress", "default_privaddr", "default_deviceattr", "default_deviceaddr", "default_deviceaddress", "default_devattr", "default_privaddress", "default_Devaddress", "default_evaddress", "default_privname", "default_evattr", "default_evaddr", "default_evname", "default_Devaddr", "default_Devattr"], "devaddr": [" devaddress", "Devaddress", "avurl", " devptr", "devptr", "Devptr", "deviceptr", " devadd", "Devaddr", "deviceref", "devadr", "devurl", "devaddress", "avaddress", "avadr", "evadd", "deviceurl", " devurl", "deviceaddress", "evaddr", "avaddr", "deviceaddr", "devref", "evref", "deviceadr", "devadd", "evaddress", "Devadd", "deviceadd", " devadr", " devref"], "pci_dev": ["pci_nt", "ppi_ev", "pci_div", "pico_dev", "pci_pad", "pcu_def", "pico_nt", "pico_device", "pci___dev", "pci_ev", "ppi_div", "pci___Dev", "pci___device", "pci_def", "pcu_Dev", "ppi_pad", "ppi_dev", "pci___def", "pci_Dev", "pci_conn", "pico_ev", "pcu_conn", "pcu_device", "pci___conn", "pcu_dev", "pci_device"], "dev": ["dj", "des", "sw", "dat", "h", "DEV", "den", "det", "die", "d", "add", "ind", "w", "device", "watch", "vo", "comment", "test", "de", "sum", "di", "mem", "nt", "ve", "go", "push", "send", "out", "ow", "normal", "v", "serv", "priv", "desc", "info", "env", "ev", "md", "p", "ent", "sd", "var", "val", "del", "tr", "hw", "adv", "debug", "rem", "vd", "dd", "disk", "fo", "res", "ver", "cho", "cast", "ov", "av", "pack", "raw", "cmd", "data", "err", "new", "stable", "obj", "gu", "unknown", "wd", "Dev", "def", "develop"], "i": ["ini", "ij", " bi", "ci", " ii", "it", " m", " x", " v", "oi", "gi", "mi", "qi", "li", "ami", "si", "p", " n", "zi", "n", "is", "xi", "ind", "index", " ti", "t", "bi", "pi", "multi", "id", " I", "k", "phi", "ti", "s", "v", "iy", "ix", " j", "ai", "m", "I", "y", "\u0438", "f", "j", "x", "di", "ii"]}}
{"project": "FFmpeg", "commit_id": "d2ee495fb241fa4ef5b8b56161328c4379d1c79a", "target": 1, "func": "void ff_mlp_init_x86(DSPContext* c, AVCodecContext *avctx)\n\n{\n\n#if HAVE_7REGS && HAVE_TEN_OPERANDS\n\n    c->mlp_filter_channel = mlp_filter_channel_x86;\n\n#endif\n\n}\n", "idx": 5731, "substitutes": {"c": ["cf", "dc", "ci", "b", "ctx", "h", "pc", "bc", "con", "cs", "sc", "fc", "p", "d", "cm", "g", "ec", "lc", "o", "t", "cc", "xc", "v", "m", "ch", "ac", "vc", "uc", "config", "ca", "cd", "f", "mc", "e", "C", "a", "tc"], "avctx": ["avcmp", "avcontext", "ovconn", "Avcontext", "Avcmp", " avconn", "ovcontext", "ovctx", "Avctx", "avconn", "ovcmp", "Avconn", " avcontext", " avcmp"]}}
{"project": "FFmpeg", "commit_id": "295b79b5d8c0cf0a9691f8d6b512aa1e289d528d", "target": 1, "func": "static av_cold int roq_encode_init(AVCodecContext *avctx)\n{\n    RoqContext *enc = avctx->priv_data;\n    av_lfg_init(&enc->randctx, 1);\n    enc->framesSinceKeyframe = 0;\n    if ((avctx->width & 0xf) || (avctx->height & 0xf)) {\n        av_log(avctx, AV_LOG_ERROR, \"Dimensions must be divisible by 16\\n\");\n        return AVERROR(EINVAL);\n    if (avctx->width > 65535 || avctx->height > 65535) {\n        av_log(avctx, AV_LOG_ERROR, \"Dimensions are max %d\\n\", enc->quake3_compat ? 32768 : 65535);\n        return AVERROR(EINVAL);\n    if (((avctx->width)&(avctx->width-1))||((avctx->height)&(avctx->height-1)))\n        av_log(avctx, AV_LOG_ERROR, \"Warning: dimensions not power of two, this is not supported by quake\\n\");\n    enc->width = avctx->width;\n    enc->height = avctx->height;\n    enc->framesSinceKeyframe = 0;\n    enc->first_frame = 1;\n    enc->last_frame    = av_frame_alloc();\n    enc->current_frame = av_frame_alloc();\n    if (!enc->last_frame || !enc->current_frame) {\n    enc->tmpData      = av_malloc(sizeof(RoqTempdata));\n    enc->this_motion4 =\n        av_mallocz_array((enc->width*enc->height/16), sizeof(motion_vect));\n    enc->last_motion4 =\n        av_malloc_array ((enc->width*enc->height/16), sizeof(motion_vect));\n    enc->this_motion8 =\n        av_mallocz_array((enc->width*enc->height/64), sizeof(motion_vect));\n    enc->last_motion8 =\n        av_malloc_array ((enc->width*enc->height/64), sizeof(motion_vect));\n    return 0;", "idx": 5754, "substitutes": {"avctx": ["avegc", "wavkt", "ravcrit", "avcp", "abkt", "ajctx", "ravcu", "ravctx", "varpx", "avcontext", "avjac", "abcu", "Avcontext", "avecp", "navpt", "Avtx", "averco", "avcu", "apctx", "avkt", "averctx", "averpy", "wavcu", "avercrit", "avcmd", "avepool", "avejac", "navcp", "ajpt", "wavjac", "avcrit", "ajcontext", " avcp", "avept", "avecontext", "avpool", "wavca", "navkl", "navctx", "navaddr", "averconfig", "vacheck", "avectx", "avaddr", "wavctx", "avcheck", "averkl", "avcb", "avpx", "avgc", "avert", "navcmd", "avertx", "ajaddr", "avecmd", "varcmd", "varpool", "navpkg", "avca", "avedl", "avpkg", "avdl", "ajdl", "aveca", "avtx", "aveconfig", "avergc", " avkt", "appt", "avercp", "abcontext", "avecu", " avcontext", "averpt", "wavcmd", "Avcb", "avercu", "appkg", "ajrt", "ajgc", "avepy", "avecheck", "vatx", "vardl", " avtx", " avpkg", "vactx", "avco", "wavpy", "varca", "navpx", "ajcmd", "ajpkg", "ajpx", "averjac", "vacu", "avpt", "wavaddr", "abctx", " avcu", "aveco", "avercmd", "abcp", "averrt", " avcheck", "avetx", "ajpool", "ajkt", "navca", "apaddr", "avekl", "ajconfig", "abcrit", "varctx", "ajco", "avecb", "avkl", "varkt", "wavkl", "avconfig", "abtx", "ajcp", "ajca", "Avctx", "aveaddr", "wavcp", "avrt", "avekt", "abpkg", "averca", "avepkg", "ravtx", " avcb", "avpy"], "enc": ["iv", "c", "auc", "kt", "eric", "utt", "buf", "orc", "eg", "ec", "lang", "en", "acc", "oc", "ENC", "num", "ack", "ict", "eval", "disc", "enth", "iac", "abc", "ic", "buff", "encrypted", "ell", "nt", "alg", "chest", "lib", "mont", "coll", "nec", "config", "ac", "desc", "conv", "En", "pres", "acl", "env", "inc", "vec", "et", "ct", "ENT", "ctx", "pc", "anc", "ang", "Enc", "exc", "ent", "util", "nc", "rc", "kw", "sec", "cv", "rent", "ENG", "auth", "act", "cod", "bn", "pack", "con", "fc", "etc", "oder", "unc", "ew", "iq", "eng", "xc", "col", "ens", "proc", "equ", "obj", "rec", "conn"]}}
{"project": "FFmpeg", "commit_id": "fd1588919d2c70288a1a3fea1aefdd3ea2c424bb", "target": 1, "func": "void ff_h264_flush_change(H264Context *h)\n\n{\n\n    int i, j;\n\n\n\n    h->next_outputed_poc = INT_MIN;\n\n    h->prev_interlaced_frame = 1;\n\n    idr(h);\n\n\n\n    h->poc.prev_frame_num = -1;\n\n    if (h->cur_pic_ptr) {\n\n        h->cur_pic_ptr->reference = 0;\n\n        for (j=i=0; h->delayed_pic[i]; i++)\n\n            if (h->delayed_pic[i] != h->cur_pic_ptr)\n\n                h->delayed_pic[j++] = h->delayed_pic[i];\n\n        h->delayed_pic[j] = NULL;\n\n    }\n\n    ff_h264_unref_picture(h, &h->last_pic_for_ec);\n\n\n\n    h->first_field = 0;\n\n    ff_h264_sei_uninit(&h->sei);\n\n    h->recovery_frame = -1;\n\n    h->frame_recovered = 0;\n\n    h->current_slice = 0;\n\n    h->mmco_reset = 1;\n\n    for (i = 0; i < h->nb_slice_ctx; i++)\n\n        h->slice_ctx[i].list_count = 0;\n\n}\n", "idx": 5755, "substitutes": {"h": ["c", "http", "self", "ht", "dev", "php", "hz", "hi", "hhh", "w", "hal", "ah", "ch", "he", "x", "hp", "ph", "gh", "q", "mem", "kh", "bh", "g", "base", "eh", "go", "v", "m", "wh", "info", "pp", "html", "header", "it", "comm", "uh", "p", "zh", "has", "hw", "history", "dh", "th", "HH", "k", "host", "hs", "ho", "y", "hm", "hash", "hl", "hh", "hr", "b", "window", "here", "oh", "help", "temp", "rh", "phi", "handle", "sh", "ih", "cache", "hist", "hd", "ha", "H"], "i": ["chain", "ei", " ii", "im", "c", "gi", "zi", "ind", " ti", "hi", "pi", "uu", "I", "mc", "in", "MI", "x", "\u0438", "di", "ic", "um", "mi", "g", "xi", "index", "ri", "bi", "ki", "ti", "v", "ai", "m", "remote", "us", "info", "a", "l", "ci", "it", "u", "ip", "li", "p", "ami", "is", "ski", "o", " I", "try", "iy", "wi", "y", "fi", "spin", "il", "ii", "ini", "ij", "uri", "b", "cli", "oi", "qi", "si", "ie", "n", "multi", "me", "ui", "ji", "ims", "ix", "status", "ish", "sim", "gu", "iu", "point", "z", "ni"], "j": ["dj", "ja", "ij", "q", "b", "it", "jj", "c", "J", "br", "aj", "at", "li", "p", "g", "si", "n", "ind", "uj", "o", "bi", "jc", "pi", "js", "ji", "pr", "k", "s", "oj", "v", "jac", "m", "y", "jump", "jp", "f", "obj", "jl", "fi", "kj", "z", "fr", "x", "json", "ii", "l"]}}
{"project": "FFmpeg", "commit_id": "4dbcdfa86d1405f7e5c0ec14a4be7d2fb5903d7b", "target": 0, "func": "static int av_set_number2(void *obj, const char *name, double num, int den, int64_t intnum, const AVOption **o_out)\n\n{\n\n    const AVOption *o = av_opt_find(obj, name, NULL, 0, 0);\n\n    void *dst;\n\n    if (o_out)\n\n        *o_out= o;\n\n    if (!o || o->offset<=0)\n\n        return AVERROR_OPTION_NOT_FOUND;\n\n\n\n    if (o->max*den < num*intnum || o->min*den > num*intnum) {\n\n        av_log(obj, AV_LOG_ERROR, \"Value %lf for parameter '%s' out of range\\n\", num, name);\n\n        return AVERROR(ERANGE);\n\n    }\n\n\n\n    dst= ((uint8_t*)obj) + o->offset;\n\n\n\n    switch (o->type) {\n\n    case FF_OPT_TYPE_FLAGS:\n\n    case FF_OPT_TYPE_INT:   *(int       *)dst= llrint(num/den)*intnum; break;\n\n    case FF_OPT_TYPE_INT64: *(int64_t   *)dst= llrint(num/den)*intnum; break;\n\n    case FF_OPT_TYPE_FLOAT: *(float     *)dst= num*intnum/den;         break;\n\n    case FF_OPT_TYPE_DOUBLE:*(double    *)dst= num*intnum/den;         break;\n\n    case FF_OPT_TYPE_RATIONAL:\n\n        if ((int)num == num) *(AVRational*)dst= (AVRational){num*intnum, den};\n\n        else                 *(AVRational*)dst= av_d2q(num*intnum/den, 1<<24);\n\n        break;\n\n    default:\n\n        return AVERROR(EINVAL);\n\n    }\n\n    return 0;\n\n}\n", "idx": 5762, "substitutes": {"obj": ["iv", "vr", "ij", "so", "xy", "bj", "src", "window", "ctx", "cmp", "objects", "nt", "ob", "self", "os", "bh", "rect", "cmd", "co", "inst", "n", "bo", "hw", "t", "phys", "err", "js", "str", "ref", "pos", "pkg", "expr", "opt", "attr", "nm", "out", "rb", "org", "txt", "ot", "oid", "rt", "object", "Obj", "tmp", "ist", "img", "np", "fr", "j", "arr", "conn", "onet", "act"], "name": ["error", "prefix", "named", "type", "def", "ma", "file", "nam", "p", "ame", "n", "no", "var", "val", "label", "data", "key", "number", "str", "w", "me", "id", "word", "reason", "attr", "nm", "cn", "code", "cap", "m", "spec", "NAME", "part", "a", "nan", "parent", "alias", "f", "size", "info", "time", "length", "names", "title", "Name", "path"], "num": ["draw", " number", "uf", "conf", "note", "mon", "valid", " NUM", "dev", "tim", "un", "perm", "phys", "pos", "Number", "en", "anon", "alph", "om", "sum", "coord", "Num", "mult", "um", "quant", "missing", "typ", "zero", "index", "max", "dim", "tu", "m", "nb", "np", "end", "grade", "comm", "msg", "util", "p", "vol", "no", "val", "on", "na", "th", "to", "rem", "nm", "NUM", "cal", "orig", "final", "al", "ord", "net", "nom", "non", "all", "form", "mn", "node", "cum", "cmp", "none", "mat", "con", "nam", "mark", "n", "eng", "multi", "nu", "number", "mu", "new", "block", "off", "f", "gpu"], "den": ["fam", "des", "dat", "DEN", "mon", "ann", "goal", "dan", "die", "vert", "dev", "perm", "pos", "en", "fin", "dn", "nan", "ey", "size", "wen", " len", "bill", "di", "ne", "da", "bin", "uni", "mem", "pen", "don", "una", "du", "norm", "ven", "nov", "mont", "unit", "ki", "von", "mind", "dim", "dir", "der", "conv", "min", "length", "env", "Den", "dal", "dem", " DEN", "vol", "len", "iden", "limit", "rem", "diff", "EN", "non", "ver", "DI", "deg", "mn", " Den", "window", "none", "con", "range", "scale", "nu", "lan", "omin", "gen", "def", "zen"], "intnum": ["INTmon", "longden", "shortum", "internum", "interNUM", "uintn", "integermon", "longnum", "intenum", "shortNUM", "startmon", "intn", "innum", "startnum", "indmon", "intNUM", "longnam", "integernumber", "startnam", "indnumber", "INTnumber", "indn", "Intnum", "INTNUM", " intum", "longum", "integernum", "intden", "longn", " intNUM", "intmem", "intnet", " intnam", "extmon", "uintmem", "stringnum", "extNUM", "stringden", "intern", "uintum", "longmem", "innam", " intenum", "indum", "integerNUM", "INTum", "integernet", "inum", "INTnum", "uintmon", "Intmon", "inmem", "internet", "indenum", "indnam", "interum", "intum", "intmon", "intnam", "startum", "shortmon", "integernam", "integerenum", "stringn", "uintnum", "extnum", "IntNUM", "uintNUM", "uintnam", "INTmem", "extum", "longmon", "uintnumber", "intnumber", "stringum", "intermon", "Intnet", " intmon", "indnum", "uintden", " intnumber", " intmem", "shortnum"], "o_out": ["oginin", "oplaceout", " o_Out", "oginOut", "e_in", "oplaceonly", "o_Out", "o_int", "o_only", " o_type", " o_int", "oplacein", "o_type", "e_only", " o_in", "o_set", "e_set", "oplaceset", "o_in", "o_client", "ogintype", "oginout", "e_out", " o_client"], "o": ["so", "oin", "ano", "po", "oos", "u", "c", "h", "ox", "i", "none", "ou", "oi", "ob", "ta", "os", "er", "p", "d", "co", "oo", "n", "no", "op", "or", "bo", "t", "lo", "ao", "go", "w", "to", "opt", "ion", "out", "ow", "s", "v", "imo", "ot", "vo", "iso", "m", "a", "goo", "owner", "y", "f", "fo", "io", "e", "oe", "O", "one", "ro", "oa", "onet", "l", "image", "object"], "dst": ["dlset", "dna", "dlbl", "dlsts", "dinpend", "odna", "didset", "dcr", "draest", "drasts", "Dset", "dsts", " dsts", "Dsts", "odest", "dpend", "dlst", "Ddest", "didstore", "dest", "drast", "dbl", " dbl", "dindest", "dldest", "dlstore", "dalstore", "dstr", "didST", " dcr", "dast", "dinst", " drest", "diddest", "dspend", "draset", " dstore", "dsST", "drastr", " dST", "didcr", "Drest", "disst", "dalst", "Dst", "dstore", " dna", "dalrest", "odst", " ddest", "didst", "odrest", "disstr", " dpend", "Dbl", "disrest", " dset", "dST", "daST", "dalstr", "ddest", " dstr", "dsdest", "dsst", "dinST", "dlcr", "dadest", "Dna", "Dest", " dest", "disstore", "drest", "Dstr", "dset"]}}
{"project": "qemu", "commit_id": "f8ed85ac992c48814d916d5df4d44f9a971c5de4", "target": 1, "func": "static void qxl_realize_common(PCIQXLDevice *qxl, Error **errp)\n\n{\n\n    uint8_t* config = qxl->pci.config;\n\n    uint32_t pci_device_rev;\n\n    uint32_t io_size;\n\n\n\n    qxl->mode = QXL_MODE_UNDEFINED;\n\n    qxl->generation = 1;\n\n    qxl->num_memslots = NUM_MEMSLOTS;\n\n    qemu_mutex_init(&qxl->track_lock);\n\n    qemu_mutex_init(&qxl->async_lock);\n\n    qxl->current_async = QXL_UNDEFINED_IO;\n\n    qxl->guest_bug = 0;\n\n\n\n    switch (qxl->revision) {\n\n    case 1: /* spice 0.4 -- qxl-1 */\n\n        pci_device_rev = QXL_REVISION_STABLE_V04;\n\n        io_size = 8;\n\n        break;\n\n    case 2: /* spice 0.6 -- qxl-2 */\n\n        pci_device_rev = QXL_REVISION_STABLE_V06;\n\n        io_size = 16;\n\n        break;\n\n    case 3: /* qxl-3 */\n\n        pci_device_rev = QXL_REVISION_STABLE_V10;\n\n        io_size = 32; /* PCI region size must be pow2 */\n\n        break;\n\n    case 4: /* qxl-4 */\n\n        pci_device_rev = QXL_REVISION_STABLE_V12;\n\n        io_size = pow2ceil(QXL_IO_RANGE_SIZE);\n\n        break;\n\n    default:\n\n        error_setg(errp, \"Invalid revision %d for qxl device (max %d)\",\n\n                   qxl->revision, QXL_DEFAULT_REVISION);\n\n        return;\n\n    }\n\n\n\n    pci_set_byte(&config[PCI_REVISION_ID], pci_device_rev);\n\n    pci_set_byte(&config[PCI_INTERRUPT_PIN], 1);\n\n\n\n    qxl->rom_size = qxl_rom_size();\n\n    memory_region_init_ram(&qxl->rom_bar, OBJECT(qxl), \"qxl.vrom\",\n\n                           qxl->rom_size, &error_abort);\n\n    vmstate_register_ram(&qxl->rom_bar, &qxl->pci.qdev);\n\n    init_qxl_rom(qxl);\n\n    init_qxl_ram(qxl);\n\n\n\n    qxl->guest_surfaces.cmds = g_new0(QXLPHYSICAL, qxl->ssd.num_surfaces);\n\n    memory_region_init_ram(&qxl->vram_bar, OBJECT(qxl), \"qxl.vram\",\n\n                           qxl->vram_size, &error_abort);\n\n    vmstate_register_ram(&qxl->vram_bar, &qxl->pci.qdev);\n\n    memory_region_init_alias(&qxl->vram32_bar, OBJECT(qxl), \"qxl.vram32\",\n\n                             &qxl->vram_bar, 0, qxl->vram32_size);\n\n\n\n    memory_region_init_io(&qxl->io_bar, OBJECT(qxl), &qxl_io_ops, qxl,\n\n                          \"qxl-ioports\", io_size);\n\n    if (qxl->id == 0) {\n\n        vga_dirty_log_start(&qxl->vga);\n\n    }\n\n    memory_region_set_flush_coalesced(&qxl->io_bar);\n\n\n\n\n\n    pci_register_bar(&qxl->pci, QXL_IO_RANGE_INDEX,\n\n                     PCI_BASE_ADDRESS_SPACE_IO, &qxl->io_bar);\n\n\n\n    pci_register_bar(&qxl->pci, QXL_ROM_RANGE_INDEX,\n\n                     PCI_BASE_ADDRESS_SPACE_MEMORY, &qxl->rom_bar);\n\n\n\n    pci_register_bar(&qxl->pci, QXL_RAM_RANGE_INDEX,\n\n                     PCI_BASE_ADDRESS_SPACE_MEMORY, &qxl->vga.vram);\n\n\n\n    pci_register_bar(&qxl->pci, QXL_VRAM_RANGE_INDEX,\n\n                     PCI_BASE_ADDRESS_SPACE_MEMORY, &qxl->vram32_bar);\n\n\n\n    if (qxl->vram32_size < qxl->vram_size) {\n\n        /*\n\n         * Make the 64bit vram bar show up only in case it is\n\n         * configured to be larger than the 32bit vram bar.\n\n         */\n\n        pci_register_bar(&qxl->pci, QXL_VRAM64_RANGE_INDEX,\n\n                         PCI_BASE_ADDRESS_SPACE_MEMORY |\n\n                         PCI_BASE_ADDRESS_MEM_TYPE_64 |\n\n                         PCI_BASE_ADDRESS_MEM_PREFETCH,\n\n                         &qxl->vram_bar);\n\n    }\n\n\n\n    /* print pci bar details */\n\n    dprint(qxl, 1, \"ram/%s: %d MB [region 0]\\n\",\n\n           qxl->id == 0 ? \"pri\" : \"sec\",\n\n           qxl->vga.vram_size / (1024*1024));\n\n    dprint(qxl, 1, \"vram/32: %d MB [region 1]\\n\",\n\n           qxl->vram32_size / (1024*1024));\n\n    dprint(qxl, 1, \"vram/64: %d MB %s\\n\",\n\n           qxl->vram_size / (1024*1024),\n\n           qxl->vram32_size < qxl->vram_size ? \"[region 4]\" : \"[unmapped]\");\n\n\n\n    qxl->ssd.qxl.base.sif = &qxl_interface.base;\n\n    if (qemu_spice_add_display_interface(&qxl->ssd.qxl, qxl->vga.con) != 0) {\n\n        error_setg(errp, \"qxl interface %d.%d not supported by spice-server\",\n\n                   SPICE_INTERFACE_QXL_MAJOR, SPICE_INTERFACE_QXL_MINOR);\n\n        return;\n\n    }\n\n    qemu_add_vm_change_state_handler(qxl_vm_change_state_handler, qxl);\n\n\n\n    qxl->update_irq = qemu_bh_new(qxl_update_irq_bh, qxl);\n\n    qxl_reset_state(qxl);\n\n\n\n    qxl->update_area_bh = qemu_bh_new(qxl_render_update_area_bh, qxl);\n\n    qxl->ssd.cursor_bh = qemu_bh_new(qemu_spice_cursor_refresh_bh, &qxl->ssd);\n\n}\n", "idx": 5767, "substitutes": {"qxl": ["qplexli", "iqrxsl", "querpayll", "qtrydl", "qqxpl", "qpxdl", "qnexl", "qwxl", "qyllb", "qinxlr", "iqxli", "qnexel", "ryxla", "qxfhl", "uemxl", "iqrxl", "qxxel", "quxdl", "qxdhl", "qqxplist", "qdxz", "qxfl", "qtrylb", "qplexl", "qqxln", "qrxsl", "qpayll", "quuxli", "qxplist", "qinxla", "tryxdl", "qqxpel", "qxsl", "qtxhl", "corexls", "ryinxli", "qxill", "requdxz", "eqxli", "qmxlc", "qxylp", "qtrysl", "qrxln", "quxfL", "qxyel", "cachexsel", "querxml", "querxll", "qpxla", "corexfl", "requdxlr", "qufxel", "questuxla", "qxsdl", "cachexla", "wxsel", "qxdla", "tryxel", "qxdel", "qxlr", "qxxl", "quuxl", "qpayml", "qaxlr", "quxlr", "uemxlc", "sqxmllen", "qaxla", "qxlp", "qxfla", "requdxll", "ryxlb", "sqxl", "qfxlc", "qqrxln", "iqxl", "qpayln", "sqxfl", "qqxel", "qxdl", "qexlp", "cachexsla", "eqxel", "sqxel", "quxfls", "qxyml", "wxsli", "qtryl", "tryxxdl", "tryxxla", "ryinxla", "qtryel", "wxdl", "qxplp", "wxli", "ryinxlb", "corexl", "qaxml", "qxlb", "qqrxel", "qxiz", "qxhl", "equxl", "qxfls", "qxmlfl", "quxfl", "sqxla", "questxli", "eqxhl", "requxl", "corexfla", "qxlc", "cachexlc", "qrxl", "qxsli", "qeyl", "sqxlen", "qxpfl", "qxL", "qeyel", "qeylp", "quuxla", "ryxli", "qplexlc", "qxmll", "quxls", "qxpl", "quxL", "equxel", "wxsdl", "qaxlen", "sqinxla", "quxfhl", "quxlp", "quxsl", "qxyll", "qdxll", "qfxel", "qxil", "qexli", "qxcla", "qqxml", "qqrxml", "equxhl", "iqxsl", "qxli", "qtryli", "qxyln", "querpayln", "iqrxel", "qrxel", "qinxlb", "quxli", "qaxfl", "qaxl", "qfxl", "qxlen", "sqinxl", "qnexln", "sqinxli", "qqxlp", "qxcl", "qufxl", "qxel", "iqxel", "requxll", "qexdl", "uexdl", "qtryla", "cachexslc", "qmxla", "requdxl", "qnexml", "qqrxl", "qxdlc", "qeylist", "cachexl", "qtxL", "qinxl", "quxla", "wxsl", "qxsel", "querxln", "quxhl", "qxslc", "ryinxl", "qxpls", "corexla", "qrxml", "qdxlr", "qyll", "qylla", "qyli", "qxclr", "questxdl", "qxilr", "corexdl", "qinxli", "qaxll", "iqrxli", "qxla", "qpayl", "qufxlc", "qyl", "qtxl", "qfxla", "qxfL", "questxla", "qxln", "qxml", "quxlc", "cachexsl", "qxz", "qexl", "eqxl", "uemxdl", "qpxel", "qxyli", "tryxla", "qpxl", "questuxl", "qufxlp", "quxll", "tryxl", "querpayml", "qmxhl", "qxmllen", "qyel", "questxl", "qxplen", "qmxls", "qfxdl", "qqxl", "equxli", "qxsla", "cachexel", "uexli", "uexlc", "qmxli", "questuxli", "qmxdl", "requxz", "qwxlp", "qtxls", "sqxmll", "qexlc", "qfxlp", "sqxlr", "querpayl", "qxylist", "corexfdl", "uemxli", "qfxli", "quxl", "qqxlist", "qxpla", "corexfls", "qydl", "qxpdl", "qxll", "qaxln", "qxdli", "qxfdl", "wxel", "qxcli", "qxxdl", "qexel", "qplexdl", "qxyhl", "tryxxl", "qwxel", "requxlr", "querxl", "questuxdl", "qxlist", "qxmlel", "quxel", "qwxlc", "quuxhl", "qxyl", "sqxmlfl", "quxz", "sqxmlel", "qxls", "qmxl", "qdxl", "uexl", "qrxhl", "qaxel", "qqxplp", "tryxxel", "qxxla", "qxpel", "qexla", "qrxli", "sqxli", "sqinxlr", "wxl", "qylli", "qaxli", "ryxl"], "errp": [" errP", " errps", "errorpb", "erp", "errps", "ErP", "errorping", "rrpb", "errr", "Erps", "errpb", "rrp", " errping", "err", "erps", "errorp", "Erp", "errP", "rrping", " errr", "Err", "errping", " errpb", "erP"], "config": ["policy", "content", "tree", "feat", "setup", "ct", "mot", "chain", "conf", "channel", "c", "bc", "cont", "set", "fig", "con", "state", "Config", "map", "profile", "table", "ext", "cmd", "connection", "etc", "settings", "general", "data", "FIG", "history", "input", "support", "rc", "admin", "attribute", "options", " CONFIG", "control", "bits", "cfg", "spec", "driver", "adj", "apache", "controller", "figure", "command", "storage", "lag", "cache", "info", "length", "param", "setting", "bus", "conn", "capt", "def"], "pci_device_rev": ["pci_device2re", "pci_device_id", "pci_device_vol", "pci_dev_serv", "pci_device2ref", "pci_dev_re", "pci_device_res", "pci_deviceistserv", "pci_device_rel", "pci_device_re", "pci_device_ev", "pci_device_info", "pci_dev_id", "pci_deviceistrev", "pci_dev_vol", "pci_dev_ev", "pci_dev_bre", "pci_device_ptr", "pci_dev_rev", "pci_dev_ptr", "pci_dev_ref", "pci_dev_info", "pci_device_ref", "pci_deviceistres", "pci_dev_res", "pci_device2bre", "pci_dev_rel", "pci_device2res", "pci_device2rev", "pci_device_bre", "pci_deviceistvol", "pci_device_serv"], "io_size": ["ioxsize", " io7data", "io_default", "IO_limit", "co00large", "co_large", "cpu_align", "io00align", " io7format", "ioLgeneral", "co_capacity", "ioxformat", "cpu_size", "io_general", "io64format", "io_range", "iozsize", "io64size", "ioLstrength", "io6general", "co00default", "io_format", "io_Size", "io7format", "io64capacity", "IO_size", "io7data", "iolenscale", "io64range", " iozrange", "io00default", "iolenlimit", " io7size", "io00capacity", "cpu6size", " io_format", "io6size", "io7size", "IO_Size", " io_code", "io_large", " iozinfo", "cpu6strength", "io64large", "ioLsize", "iozformat", "iolensize", " io_range", " iozsize", "co_size", "iozrange", "io00general", "co00capacity", "io00size", "io_scale", "io_info", "iolenSize", "cpu_general", "IO_scale", " iozformat", "iozinfo", "io7code", "ioptsize", " io7code", "io00large", "io_data", "io_limit", "io6align", "cpu_strength", "ioxrange", "co_default", "cpu6general", "ioptdefault", " io_info", "io64default", "ioxinfo", "ioptcapacity", "cpu6align", "co00size", " io_data", "io6strength", "io00strength", "io_align", "ioLalign", "io64info", "io_capacity", "io_code", "ioptlarge", "io_strength"]}}
{"project": "FFmpeg", "commit_id": "c23acbaed40101c677dfcfbbfe0d2c230a8e8f44", "target": 1, "func": "static void vc1_inv_trans_8x4_dc_c(uint8_t *dest, int linesize, DCTELEM *block)\n\n{\n\n    int i;\n\n    int dc = block[0];\n\n    const uint8_t *cm;\n\n    dc = ( 3 * dc +  1) >> 1;\n\n    dc = (17 * dc + 64) >> 7;\n\n    cm = ff_cropTbl + MAX_NEG_CROP + dc;\n\n    for(i = 0; i < 4; i++){\n\n        dest[0] = cm[dest[0]];\n\n        dest[1] = cm[dest[1]];\n\n        dest[2] = cm[dest[2]];\n\n        dest[3] = cm[dest[3]];\n\n        dest[4] = cm[dest[4]];\n\n        dest[5] = cm[dest[5]];\n\n        dest[6] = cm[dest[6]];\n\n        dest[7] = cm[dest[7]];\n\n        dest += linesize;\n\n    }\n\n}\n", "idx": 5781, "substitutes": {"dest": ["draw", "dc", "chain", "dat", "way", "wait", "save", "rel", "buf", "last", "see", "addr", "add", "dev", "comb", "alt", "pos", "iter", "transform", "comment", "tmp", "parent", "gest", "sum", "size", "origin", "coord", "source", "loc", "output", "success", "mem", "store", "sort", "seed", "good", "server", "pipe", "reason", "master", "out", "v", "dim", "port", "desc", "address", "decl", "check", "ctr", "trans", "copy", "src", "it", "target", "dep", "shift", "msg", "tr", "usr", "delete", "route", "rest", "mount", "host", "orig", "st", "nom", "result", "sp", "match", "cp", "est", "cont", "table", "n", "temp", "list", "opt", "Dest", "gate", "dist", "status", "spec", "ptr", "reverse", "ist", "search", "global", "transfer"], "linesize": ["lsizer", "lsIZE", " linessize", "linessize", "lsizing", "netsiz", "linesiz", "netsize", "inessize", "linesizing", " linesizes", "inesizer", "linesizes", "linesIZE", "lssize", " linesizing", "inesizes", "lsiz", "netsizing", " linesiz", "netsIZE", " linesizer", " linesIZE", "lsizes", "inesize", "linesizer", "lsize"], "block": ["chain", "event", "copy", "type", "pack", "cl", "join", "box", "field", "set", "buffer", "ip", "map", "link", "group", "row", "line", "stop", "record", "word", "unit", "list", "bf", "cell", "load", "pixel", "scan", "entry", "bl", "BL", "point", "check", "param", "lock", "Block", "trans", "source", "bin"], "i": ["init", "ic", "ini", "asi", "sp", " bi", "ei", "ci", "q", " ii", "chain", "it", " m", "im", "c", " x", " v", "mi", "qi", "ip", "li", "g", "si", "zi", "n", "is", "xi", "ind", "index", " ti", "pi", " err", "bi", "multi", "me", "ui", " I", "phi", "ti", " pi", " iter", "v", "iter", "ims", "ix", "ai", "m", " mi", "I", "batch", "y", "print", "sim", "iu", "point", "j", "z", "x", "di", "ii"], "cm": ["ck", "dc", "form", "gc", "csv", "km", "ci", "ct", "copy", "fm", "cy", "um", "cp", "gm", "conf", "c", "asm", "pc", "gr", "cmp", "cont", "cl", "CM", "cs", "comm", "mr", "fc", "map", "wm", "co", "cmd", "cut", "lc", "cc", "pm", "module", "sem", "sm", "nm", "mode", "cn", "cr", "fine", "mb", "m", "ch", "cv", "mm", "cd", "ca", "mc", "mask", "hm", "vm", "ctr", "bm", "com", "ace", "rom", "ym", "rm", "tc", "mp"]}}
{"project": "FFmpeg", "commit_id": "a70c27e813346a11e5fff3d329ecba82fb76826a", "target": 1, "func": "static always_inline uint8_t vc1_mspel_filter(const uint8_t *src, int stride, int mode, int r)\n\n{\n\n    switch(mode){\n\n    case 0: //no shift\n\n        return src[0];\n\n    case 1: // 1/4 shift\n\n        return (-4*src[-stride] + 53*src[0] + 18*src[stride] - 3*src[stride*2] + 32 - r) >> 6;\n\n    case 2: // 1/2 shift\n\n        return (-src[-stride] + 9*src[0] + 9*src[stride] - src[stride*2] + 8 - r) >> 4;\n\n    case 3: // 3/4 shift\n\n        return (-3*src[-stride] + 18*src[0] + 53*src[stride] - 4*src[stride*2] + 32 - r) >> 6;\n\n    }\n\n    return 0; //should not occur\n\n}\n", "idx": 5789, "substitutes": {"src": ["iv", "stab", "gc", "sw", "ctl", "dat", "sc", "inst", "impl", "cb", "sb", "txt", "req", "ack", "tmp", "gin", "cur", "dest", "in", "enc", "loc", "source", "bin", "rs", "sort", "sel", "str", "stream", "load", "scan", "supp", "np", "comp", "ctr", "ssl", "bj", "sr", "bc", "view", "std", "usr", "hw", "th", "rc", "sec", "ripp", "sur", "rt", "sub", "st", "bs", "usc", "sq", "hl", "warn", "bn", "ser", "lat", "sys", "fc", "etc", "sync", "input", "cc", "bb", "syn", "ins", "proc", "dist", "sl", "rl", "sn", "ul", "img", "ptr", "obj", "ipl", "tp"], "stride": ["scopeope", "arrine", "divide", "keyider", "drine", "volride", "STRope", "sharpause", "sharpipe", "arrride", "divride", "volide", " strider", "Strride", "STRipe", "keyided", "shrine", "strade", "STRide", "wrude", "Strope", "wrided", "scopeude", "keyide", "drride", "divade", "strope", "scopeape", " strade", "arride", "divorate", "sprade", "arrider", "sharpide", " strided", "drider", "strride", "strause", "strude", "driden", "shrorate", "divause", "sysided", " strride", "wride", "scopeide", "stripe", "STRided", "spride", "sysiden", "volided", "Stride", "volider", "strider", " strape", "sharpided", "shrause", "divider", "strape", " stripe", "strine", "scopeided", "sharpride", "divided", "STRride", "dride", "striden", "divine", "Strider", " striden", "sprride", "Strause", "sysider", "Strine", "shride", "sprided", "STRude", "STRine", "wrride", "scoperide", "sprause", "scopeine", "Strided", "strided", "Strape", "scopeider", "STRiden", "sharpiden", "strorate", "drided", "syside", "scopeorate", "scopeause", "keyiden"], "mode": ["depth", "error", "um", "step", "im", "type", "md", "direction", "move", "kind", "state", "Mode", "te", "mid", "d", "order", "mt", "tm", "option", "range", "key", "scale", "str", "position", "id", "module", "role", "theme", "dm", "style", "code", "dim", "command", "m", "status", "ror", "MODE", "mm", "ide", "rate", "mod", "de", "format", "def", "ode", "act"], "r": ["rs", "vr", "q", "b", "ar", "it", "lr", "sr", "c", "u", "h", "nr", "i", "mr", "er", "p", "d", "rect", "g", "or", "o", "t", "range", "err", "str", "w", "rc", "dr", "rr", "rf", "pr", "attr", "ir", "rb", "cr", "v", "rar", "rt", "m", "R", "rate", "f", "rd", "e", "arr", "l"]}}
{"project": "qemu", "commit_id": "4c4f0e4801ac79632d03867c88aafc90b4ce503c", "target": 1, "func": "static uint64_t openpic_tmr_read(void *opaque, hwaddr addr, unsigned len)\n\n{\n\n    OpenPICState *opp = opaque;\n\n    uint32_t retval = -1;\n\n    int idx;\n\n\n\n    DPRINTF(\"%s: addr %08x\\n\", __func__, addr);\n\n    if (addr & 0xF) {\n\n        goto out;\n\n    }\n\n    idx = (addr >> 6) & 0x3;\n\n    if (addr == 0x0) {\n\n        /* TIFR (TFRR) */\n\n        retval = opp->tifr;\n\n        goto out;\n\n    }\n\n    switch (addr & 0x30) {\n\n    case 0x00: /* TICC (GTCCR) */\n\n        retval = opp->timers[idx].ticc;\n\n        break;\n\n    case 0x10: /* TIBC (GTBCR) */\n\n        retval = opp->timers[idx].tibc;\n\n        break;\n\n    case 0x20: /* TIPV (TIPV) */\n\n        retval = read_IRQreg_ipvp(opp, opp->irq_tim0 + idx);\n\n        break;\n\n    case 0x30: /* TIDE (TIDR) */\n\n        retval = read_IRQreg_ide(opp, opp->irq_tim0 + idx);\n\n        break;\n\n    }\n\n\n\nout:\n\n    DPRINTF(\"%s: => %08x\\n\", __func__, retval);\n\n\n\n    return retval;\n\n}\n", "idx": 5797, "substitutes": {"opaque": ["ogatile", " oposter", "paque", "ogacity", "oposter", "oplay", "poster", " opacity", "opus", "patile", "OPatile", " opatile", "Oplay", "OPus", "opacity", "OPaque", "Opaque", "pacity", "ogoster", "opatile", " oplay", "OPlay", "Opatile", "Opus", " opus", "ogaque"], "addr": ["gt", "rs", "sp", "grad", "trans", "src", "mem", "lr", "asm", "offset", "pad", " address", "arch", "rn", "ip", "map", "cmd", "add", "arp", "on", "url", "data", "hw", "alt", "r", "dr", "rc", "id", "pos", "inter", "pkg", "attr", "align", "gate", "ad", "host", "Address", "ix", "rt", "dd", "ack", "off", "tx", "ptr", "gz", "alias", "address", "ord", "np", "obj", "hash", "hl", "adr", "res", "work", "arr", "coord", "x", "loc", "act"], "len": ["ln", "mem", "type", "Len", "cmp", "field", "seq", "n", "lib", "val", "data", "lan", "Length", "id", "ref", "ls", "lp", "en", "num", " length", "al", "size", "ize", "length", "l", "bin"], "opp": ["agg", "sie", "ij", "form", "roth", "app", "bj", "obb", "upp", "eff", "pread", "offensive", "oit", "prof", "pps", "join", "hom", "hess", "comm", "ik", "ijk", "ip", "impl", "plug", "op", "Lev", "perm", "ott", "ppo", "Opp", "emp", "pkg", "ogg", "obl", "oppers", "animate", "oph", "odd", "ipp", "oc", "fac", "evil", "company", "adj", "omp", "school", "supp", "jp", "kick", "jump", "rog", "obj", " Opp", "sim", "operator", "oise", "pp", "itz", "stick", "makers", "hog", "ost", "cho", "xff"], "idx": ["idv", "idxf", "identxe", "idxes", "identxb", "idg", "dbxs", " idxf", "indix", " idex", "indxs", "dbval", "indindex", "ridxs", "Idv", " idix", " idg", " idv", "identxes", "indx", "identix", "indct", "dbv", "indv", "identx", "index", "sidxf", "indg", " idindex", "ridv", " idxs", "indxb", "ridval", "identindex", " idxe", "identxs", " idct", "sidxes", "identg", "idval", "ridx", "idix", "idct", "idxb", "idxe", "sidxe", "sidx", "dbx", "idindex", " idxb", "Idxs", " idxes", "identv", "Idx", " idval", "idex", "Idex", "identxf", "identex", "idxs", "identct", "ridex"]}}
{"project": "qemu", "commit_id": "40f860cd6c1aa0d3399e3f8158f20bdc5b2bfbfe", "target": 0, "func": "static void gen_exception_insn(DisasContext *s, int offset, int excp)\n\n{\n\n    gen_a64_set_pc_im(s->pc - offset);\n\n    gen_exception(excp);\n\n    s->is_jmp = DISAS_JUMP;\n\n}\n", "idx": 5810, "substitutes": {"s": ["as", "rs", "so", "gs", "q", "b", "sw", "ns", "c", "ctx", "h", "qs", "set", "state", "cs", "sys", "os", "ps", "p", "d", "g", "n", "is", "ts", "ds", "sync", "es", "se", "js", "w", "sv", "ls", "sb", "sl", "hs", "ss", "bs", "south", "sn", "serv", "y", "sq", "S", "sts", "a"], "offset": ["original", "et", "sp", "error", "padding", "pc", "shift", "i", "set", "pad", "p", "addr", "mt", "location", "seek", "len", "row", "index", "pointer", "fp", "o", "bound", "position", "ref", "pos", "to", "inter", "top", "start", "slot", "oid", "offs", "part", "off", "ptr", "address", "amp", "point", "Offset", "length", "coord", "loc"], "excp": ["Exp", "descp", "nexCP", "pexCP", "pexcp", "desfp", "exceptcp", "exwp", "pexvp", "exceptwp", "exceptCP", "desvp", "Excp", "exCP", "ExCP", "exceptp", "Exwp", "desCP", "nexcp", "nexfp", " exwp", "exfp", " exCP", "exvp", "pexfp", "nexvp"]}}
{"project": "qemu", "commit_id": "ca6b6e1e68ac44b2e8895da10dd1c80dc03d08b7", "target": 0, "func": "static QDict *qmp_dispatch_check_obj(const QObject *request, Error **errp)\n\n{\n\n    const QDictEntry *ent;\n\n    const char *arg_name;\n\n    const QObject *arg_obj;\n\n    bool has_exec_key = false;\n\n    QDict *dict = NULL;\n\n\n\n    if (qobject_type(request) != QTYPE_QDICT) {\n\n        error_setg(errp, QERR_QMP_BAD_INPUT_OBJECT,\n\n                   \"request is not a dictionary\");\n\n        return NULL;\n\n    }\n\n\n\n    dict = qobject_to_qdict(request);\n\n\n\n    for (ent = qdict_first(dict); ent;\n\n         ent = qdict_next(dict, ent)) {\n\n        arg_name = qdict_entry_key(ent);\n\n        arg_obj = qdict_entry_value(ent);\n\n\n\n        if (!strcmp(arg_name, \"execute\")) {\n\n            if (qobject_type(arg_obj) != QTYPE_QSTRING) {\n\n                error_setg(errp, QERR_QMP_BAD_INPUT_OBJECT_MEMBER, \"execute\",\n\n                           \"string\");\n\n                return NULL;\n\n            }\n\n            has_exec_key = true;\n\n        } else if (strcmp(arg_name, \"arguments\")) {\n\n            error_setg(errp, QERR_QMP_EXTRA_MEMBER, arg_name);\n\n            return NULL;\n\n        }\n\n    }\n\n\n\n    if (!has_exec_key) {\n\n        error_setg(errp, QERR_QMP_BAD_INPUT_OBJECT, \"execute\");\n\n        return NULL;\n\n    }\n\n\n\n    return dict;\n\n}\n", "idx": 5820, "substitutes": {"request": ["package", "update", "open", "q", "call", "reply", "get", "argument", "path", "raw", "p", "insert", "enter", "document", "context", "pair", "first", "import", "input", "from", "query", "question", "initial", "forward", "start", "transform", "req", "complete", "reset", "requ", "frame", "xml", "art", "new", "project", "response", "config", "current", "message", "quest", "Request", "QUEST", "express", "public", "create", "reference", "object", "python"], "errp": [" erps", " errP", " erp", "derp", "derpb", " errps", "errwp", "iterpa", "rerpt", " erpat", "rerpc", "rerpb", "errorpa", "iterpre", "derping", "errcp", "derpc", "derpa", "rerwp", "erp", "iterpt", "erpat", "errps", "errpc", " errpat", "iterP", "errpre", "errorping", "rrpb", "errorpc", "erping", "errorpre", "errpt", "errpa", "errpb", "rrp", "errorP", "erps", "errorwp", "errorp", "rerpa", "rrcp", "rerping", "rerp", "iterping", "derwp", "dercp", "errP", "derpt", "iterp", "errpat", "rrping", "rercp", " erP", "errping", "erP", "erpre"], "ent": ["ev", "et", " Ent", "event", "ct", "quant", "att", "it", "ENT", "md", "gr", "kt", "cont", "anc", "det", "met", "nd", "Ent", "comm", "nt", "pent", "ant", "inst", "mut", "add", "ec", "ew", "n", "or", "ind", "gent", "eng", "pl", "sent", "mont", "el", "entity", "k", "eq", "en", "ow", "ents", "oc", "out", "sec", "inf", "st", "art", "ac", "entry", "ict", "ient", "rent", "ident", "cur", "obj", "rec", "e", "net", "imp", "enc", "conn", "def", "inc"], "arg_name": ["argacame", "app_local", "arg_type", " argacnames", "ar_num", "arg_nam", "arg8time", "arg7obj", " argacame", "arg8nam", "arg8local", " argacname", "tag_obj", "argacnames", " arg_type", "argNametype", "arg8name", "argacname", " arg_NAME", "argNameattr", "arg_ame", "arg_names", "argNamenames", "arg_attr", "arg_NAME", " arg_names", "argtnum", "tag_info", "ar_name", "arg___name", "arg_path", "ar___path", "argtname", "arg___local", "arg___num", "ar___name", "ar_path", "ar___local", "ar_local", "app_nam", "argtlocal", "argNamename", "argacNAME", "arg7name", "tag_type", "arg_num", "argtpath", "arg___path", " arg_attr", "arg_info", "arg7info", "app_name", "app_time", " argacNAME", " arg_ame", "arg_local", "tag_name", "arg7type", "arg_time", "ar___num"], "arg_obj": [" arg_object", "cmd_val", "arg_bj", "arg_val", "arg_object", "arg_o", " arg_val", "arg___val", "arg___obj", "cmd64bj", "arg___addr", "cmd_bj", " arg_addr", "arg64bj", "arg64name", "arg64obj", "arg_value", "cmd_obj", "cmd64obj", "cmd_name", " arg_o", " arg_value", "arg64val", "cmd64name", "cmd64val", "arg___object", "arg_addr"], "dict": ["draw", "tree", "dat", "conf", "nd", "state", "d", "ict", "cur", "sum", "output", "upper", "null", "compl", "nt", "bd", "context", "pl", "str", "out", "load", "dir", "local", "cd", "pp", "subject", "td", "json", "cert", "collect", "db", "ct", "msg", "map", "vol", "del", "dr", "pkg", "container", "dd", "found", "response", "build", "session", "hash", "ld", "all", "result", "get", "sys", "con", "table", "cmd", "bind", "document", "ds", "full", "input", "list", "inf", "df", "new", "doc", "print", "cache", "obj", "rd", "pd", "hd", "database", "arr", "wd", "def"]}}
{"project": "FFmpeg", "commit_id": "7e4fe5162ab94a413e04caae19193c5e7a4c6478", "target": 0, "func": "static void sha1_transform(uint32_t state[5], const uint8_t buffer[64])\n\n{\n\n    uint32_t block[80];\n\n    unsigned int i, a, b, c, d, e;\n\n\n\n    a = state[0];\n\n    b = state[1];\n\n    c = state[2];\n\n    d = state[3];\n\n    e = state[4];\n\n#if CONFIG_SMALL\n\n    for (i = 0; i < 80; i++) {\n\n        int t;\n\n        if (i < 16)\n\n            t = AV_RB32(buffer + 4 * i);\n\n        else\n\n            t = rol(block[i-3] ^ block[i-8] ^ block[i-14] ^ block[i-16], 1);\n\n        block[i] = t;\n\n        t += e + rol(a, 5);\n\n        if (i < 40) {\n\n            if (i < 20)\n\n                t += ((b&(c^d))^d)     + 0x5A827999;\n\n            else\n\n                t += ( b^c     ^d)     + 0x6ED9EBA1;\n\n        } else {\n\n            if (i < 60)\n\n                t += (((b|c)&d)|(b&c)) + 0x8F1BBCDC;\n\n            else\n\n                t += ( b^c     ^d)     + 0xCA62C1D6;\n\n        }\n\n        e = d;\n\n        d = c;\n\n        c = rol(b, 30);\n\n        b = a;\n\n        a = t;\n\n    }\n\n#else\n\n    for (i = 0; i < 15; i += 5) {\n\n        R0(a, b, c, d, e, 0 + i);\n\n        R0(e, a, b, c, d, 1 + i);\n\n        R0(d, e, a, b, c, 2 + i);\n\n        R0(c, d, e, a, b, 3 + i);\n\n        R0(b, c, d, e, a, 4 + i);\n\n    }\n\n    R0(a, b, c, d, e, 15);\n\n    R1(e, a, b, c, d, 16);\n\n    R1(d, e, a, b, c, 17);\n\n    R1(c, d, e, a, b, 18);\n\n    R1(b, c, d, e, a, 19);\n\n    for (i = 20; i < 40; i += 5) {\n\n        R2(a, b, c, d, e, 0 + i);\n\n        R2(e, a, b, c, d, 1 + i);\n\n        R2(d, e, a, b, c, 2 + i);\n\n        R2(c, d, e, a, b, 3 + i);\n\n        R2(b, c, d, e, a, 4 + i);\n\n    }\n\n    for (; i < 60; i += 5) {\n\n        R3(a, b, c, d, e, 0 + i);\n\n        R3(e, a, b, c, d, 1 + i);\n\n        R3(d, e, a, b, c, 2 + i);\n\n        R3(c, d, e, a, b, 3 + i);\n\n        R3(b, c, d, e, a, 4 + i);\n\n    }\n\n    for (; i < 80; i += 5) {\n\n        R4(a, b, c, d, e, 0 + i);\n\n        R4(e, a, b, c, d, 1 + i);\n\n        R4(d, e, a, b, c, 2 + i);\n\n        R4(c, d, e, a, b, 3 + i);\n\n        R4(b, c, d, e, a, 4 + i);\n\n    }\n\n#endif\n\n    state[0] += a;\n\n    state[1] += b;\n\n    state[2] += c;\n\n    state[3] += d;\n\n    state[4] += e;\n\n}\n", "idx": 5826, "substitutes": {"state": ["init", "user", "open", "STATE", "event", "error", "call", "it", "step", "type", "store", "map", "base", "dict", "seed", "monitor", "index", "range", "State", "key", "r", "trace", "tag", "list", "bar", "unit", "resource", "space", "start", "iter", "port", "config", "spec", "status", "states", "local", "print", "rule", "cache", "area", "f", "loop", "core", "test", "size", "info", "hash", "check", "lock", "trans"], "buffer": ["output", "q", "buff", "padding", "empty", "window", "type", "offset", "binary", "page", "buf", "Buffer", "base", "screen", "p", "n", "seed", "index", "data", "total", "input", "limit", "byte", "word", "board", "code", "out", "bin", "v", "memory", "max", "command", "batch", "xff", "cache", "capacity", "f", "message", "size", "length", "text", "sequence"], "block": ["chain", "q", "node", "prefix", "window", "it", "channel", "type", "pack", "view", "box", "model", "set", "field", "join", "ip", "map", "base", "table", "link", "group", "no", "row", "sync", "line", "range", "bit", "byte", "unit", "tag", "list", "proc", "ref", "board", "blocks", "control", "config", "frame", "load", "part", "batch", "pool", "bl", "mask", "cache", "filter", "point", "hash", "check", "lock", "Block", "object", "bin"], "i": ["depth", "asi", "chain", "ei", " ii", "im", "h", "gi", "zi", "ind", "hi", "pi", "iter", " j", "I", "io", "in", "j", "x", "di", "ic", "q", "um", "mi", "g", "xi", "index", "ri", "bi", "ki", "ti", "v", "ai", "m", "info", "json", "l", "ci", "it", "ity", "u", "ip", "li", "p", "ami", "is", "o", "s", "try", "iy", "y", "sql", "ii", "name", "init", "ij", "ini", " bi", "cli", "client", "oi", "qi", "si", "ie", "n", "multi", "err", "me", "ui", "id", "ji", "phi", "ims", "ix", "status", "f", "sim", "iu", "ite"], "a": ["h", "ma", "aaa", "aa", "w", "en", "j", "x", "da", "this", "as", "ta", "er", "g", "ak", "es", "va", "ach", "go", "el", "an", "ap", "au", "v", "ai", "m", "sa", "ac", "action", "ca", "am", "ia", "l", "ar", "u", "at", "ami", "p", "pa", "ae", "ed", "o", "r", "to", "s", "al", "la", "y", "ga", "oa", "ao", "ba", "all", "ate", "app", "ab", "A", "n", "ad", "ea", "fa", "area", "ee", "f", "z"], "b": ["db", "as", "gb", "ab", "it", "ar", "eb", "u", "ib", "h", "bg", "back", "bc", "br", "ob", "g", "p", "base", "body", "n", "bp", "bd", "lib", "ed", "cb", "bo", "o", "bt", "wb", "bi", "bu", "r", "w", "erb", "es", "bb", "to", "bar", "sb", "rb", "bf", "v", "be", "ad", "mb", "m", "ch", "B", "nb", "bs", "fb", "abb", "y", "bl", "f", "by", "j", "z", "l", "ba"], "c": ["cf", "ic", "dc", "chain", "gc", "ct", "ci", "ar", "cp", "conf", "u", "pc", "h", "cl", "bc", "cont", "con", "cs", "sc", "cor", "fc", "g", "co", "cm", "p", "n", "unc", "ec", "cb", "lc", "ce", "o", "r", "cc", "col", "w", "rc", "arc", "cr", "v", "ad", "m", "ch", "ac", "vc", "cv", "cd", "y", "cat", "cache", "ca", "f", "can", "cur", "C", "z", "enc", "com", "cu", "x", "l", "tc"], "d": ["db", "as", "fd", "dc", "q", "dat", "it", "u", "h", "md", "nd", "at", "du", "er", "dt", "g", "p", "n", "dev", "sd", "bd", "ds", "ed", "del", "ind", "o", "and", "r", "D", "w", "dr", "dh", "str", "id", "dm", "dx", "ud", "s", "ad", "v", "dd", "m", "dir", "dn", "done", "der", "cd", "y", "f", "dp", "de", "td", "ld", "j", "z", "di", "dom", "l", "da"], "e": ["et", "ei", "ate", "it", "end", "est", "eb", "u", "h", "em", "ek", "at", "er", "te", "g", "p", "ie", "n", "ec", "ed", "ae", "o", "ce", "se", "es", "r", "err", "w", "and", "el", "entity", "an", "ue", "s", "en", "v", "be", "eu", "ea", "m", "re", "y", "ee", "f", "de", "oe", "E", "x", "ne", "l", "le"], "t": ["ty", "tree", "et", "ert", "it", "att", "term", "type", "u", "h", " T", "tar", "T", "pt", "set", "ta", "at", "te", "er", "p", "g", "dt", "mt", "n", "ent", "tg", "ts", "ant", "tr", "o", "total", "wt", "temp", "r", "trace", "w", "to", "ti", "out", "v", "ot", "tu", "rt", "status", "m", "st", "ret", "y", " ot", "vt", "qt", "td", "j", "x", "tp", "title", "text", "l", "tt", "tc"]}}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "static int get_int64(QEMUFile *f, void *pv, size_t size)\n\n{\n\n    int64_t *v = pv;\n\n    qemu_get_sbe64s(f, v);\n\n    return 0;\n\n}\n", "idx": 5834, "substitutes": {"f": ["fd", "cf", "form", "uf", "q", "b", "fm", "af", "c", "h", "i", "fx", "lf", "file", "fc", "p", "d", "g", "F", "fp", "t", "r", "w", "bf", "fac", "inf", "df", "m", "fb", "tf", "sf", "fs", "fi", "fo", "e", "fr", "ile", "l", "fw"], "pv": [" pj", "Pvt", "ppV", "pvi", " pvt", "prvi", "pV", "Pv", "pj", "Pvi", "Pj", "prV", "ppvt", "pvt", " pvi", "ppj", "prv", " pV", "PV", "ppv"], "size": ["sp", "SIZE", " sp", "Size", " ignored", " unused", "p", "len", " Size", " st", "pe", " sized", " sum", " scale", "s", " notice", " sh", " shr", "ize", "e", " len", "length", " count", " enc"], "v": ["ev", "uv", "q", "b", "ov", "c", "u", "h", "av", "i", "vi", "p", "g", "n", "vp", "tv", "o", "t", "r", "va", "w", "value", "sv", "k", "s", "out", "nv", "m", "V", "cv", "vt", "vm", "j", "x", "a", "l"]}}
{"project": "qemu", "commit_id": "ad5b88b1f198182642b6cbf3dacb4cade0c80fb9", "target": 1, "func": "static void acpi_build_update(void *build_opaque, uint32_t offset)\n\n{\n\n    AcpiBuildState *build_state = build_opaque;\n\n    AcpiBuildTables tables;\n\n\n\n    /* No state to update or already patched? Nothing to do. */\n\n    if (!build_state || build_state->patched) {\n\n        return;\n\n    }\n\n    build_state->patched = 1;\n\n\n\n    acpi_build_tables_init(&tables);\n\n\n\n    acpi_build(build_state->guest_info, &tables);\n\n\n\n    assert(acpi_data_len(tables.table_data) == build_state->table_size);\n\n    memcpy(build_state->table_ram, tables.table_data->data,\n\n           build_state->table_size);\n\n\n\n    acpi_build_tables_cleanup(&tables, true);\n\n}\n", "idx": 5837, "substitutes": {"build_opaque": ["build_iopaque", "build_iopanse", "build_operaque", "build_opsatile", "build_operatile", "build_opsosit", "build_oposit", "build_operosit", "build_popatile", "build_opsaques", "build_popque", "build_obatile", "build_opaques", "build_operanse", "build_opque", "build_obosit", "build_obaques", "build_popaque", "build_obaque", "build_opanse", "build_operque", "build_opsaque", "build_popanse", "build_operaques", "build_iopque", "build_opatile", "build_iopatile"], "offset": ["bytes", "abled", "ian", "os", "itness", "body", "oo", "ogo", "ae", "oes", "ips", "unk", "ids", "foot", "abytes", "code", "ending", "ah", "oby", "alloc", "load", " offsets", "address", "rend", "size", "oot", "acl", "ops"], "build_state": ["build_resource", " build_request", " build_State", "buildptrequest", " build_role", "build2stats", "build_stats", "buildedstate", "build2pointer", "buildptoperator", "buildingsize", "build_estate", " build_estate", " build_size", "buildingstates", "build_State", " build_count", " build_init", "build_role", " build_states", "buildinginit", "buildedpointer", "buildedSTATE", " build2count", " build_STATE", "buildtimestate", "build2State", "buildipresource", "build_pointer", "build_request", "build2states", "buildipstate", "buildedorder", "buildedstates", " build2stats", "build_operator", "build_count", "buildingstats", "build_STATE", "buildipcontext", "build_style", "uild_resource", "build_order", "build_control", "build2state", " build_order", "buildtimerequest", "buildipcontrol", "build_size", "buildptrole", "buildptstate", "buildptState", "build_states", "buildedState", "buildtimeState", " build2state", "buildptstates", "uild_state", "build2count", " build_style", "uild_context", " build_pointer", " build_stats", " build_operator", "buildtimerole", "build_context", "uild_control", "buildingcount", "buildingstate", "build_init"], "tables": ["tracerees", "trees", "traceabled", "nates", " tests", "tenables", " tabases", "tabled", " tators", "traceources", "vtases", "pables", "Tources", "tenresses", "Tables", "portables", "Tiffs", "tests", "Tests", " tians", " tiffs", "tamps", "tickets", "pamps", "vtests", "turtles", "tians", "vtamps", "Tates", "Tickets", " turtles", "pources", "Trees", "vtables", "nests", "rotresses", "Tabled", "pickets", "Tases", "detables", "Tabases", "nases", "tenorders", "pabled", "portians", " trees", "portests", "traceables", "tases", "tresses", "detians", "contables", "contrees", "tenurtles", "detators", "tators", "vtrees", " torders", "torders", "prees", "contabases", "rotables", "vtickets", "tiffs", "Tamps", "nables", "contiffs", "roturtles", "portators", "tates", "vtates", " tresses", "tources", "rotorders", "tabases", "detests"]}}
{"project": "FFmpeg", "commit_id": "a8bdf2405c6027f45a899eaaa6ba74e97c1c2701", "target": 1, "func": "static av_cold int amr_nb_encode_init(AVCodecContext *avctx)\n\n{\n\n    AMRContext *s = avctx->priv_data;\n\n\n\n    if (avctx->sample_rate != 8000) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Only 8000Hz sample rate supported\\n\");\n\n        return AVERROR(ENOSYS);\n\n    }\n\n\n\n    if (avctx->channels != 1) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Only mono supported\\n\");\n\n        return AVERROR(ENOSYS);\n\n    }\n\n\n\n    avctx->frame_size  = 160;\n\n    avctx->coded_frame = avcodec_alloc_frame();\n\n\n\n\n\n    s->enc_state = Encoder_Interface_init(s->enc_dtx);\n\n    if (!s->enc_state) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Encoder_Interface_init error\\n\");\n\n\n        return -1;\n\n    }\n\n\n\n    s->enc_mode    = get_bitrate_mode(avctx->bit_rate, avctx);\n\n    s->enc_bitrate = avctx->bit_rate;\n\n\n\n    return 0;\n\n}", "idx": 5845, "substitutes": {"avctx": ["cvctx", "AVctx", "wavcmp", " avcmp", " avproc", "avtmp", "afconf", "ajctx", "avertmp", "avetimeout", "avcontext", "aveconn", "ivertmp", "avjac", "afwd", "avecf", "avproc", "navreq", "avcfg", "vercmp", "devtx", "avkt", " avobj", "avercli", "averctx", "aftmp", "AVcontext", "averobj", "averpkg", "AVconn", "afctx", "ivercontext", "aveconf", "cvcontext", "ajcontext", "avewd", "avconn", "avecontext", "navkl", "navctx", "averconfig", "avectx", "avwd", "verctx", "ajcli", "wavctx", "ajconf", "avcf", "cvtx", "avertimeout", "avcb", "averproc", "ajtmp", "avertx", "avconf", "wavcontext", " avkw", "verpkg", "averkw", "avtimeout", " avconn", "avpkg", "afproc", "avecm", "devobj", "wavcb", " avcm", "vertx", "avtx", "aveconfig", "devcmp", "avercfg", "cvcm", " avkt", "avefx", "navcf", " avcontext", "avercontext", "avekw", "iverwd", " avtx", "iverctx", " avpkg", "ajfx", "avetmp", "aveproc", " avcfg", "avfx", " avjac", "ajtimeout", " avtmp", "averfx", "avercmp", "averjac", "ajproc", "avereq", "avreq", " avcb", "avetx", "avobj", "avekl", "ajconfig", "avcli", "AVtx", "avkl", "ajjac", "wavkl", "wavcf", "avconfig", "ajcmp", " avcli", "avcmp", "ajcfg", "averkt", "ajcb", "avcm", "avekt", "afcontext", "wavreq", "devctx", "avkw"], "s": ["rs", "gs", "b", "less", "ns", "c", "its", "ats", "h", "i", "set", "sys", "qs", "cs", "self", "os", "ps", "g", "ms", "details", "p", "als", "is", "ts", "ports", "ds", "t", "se", "es", "js", "w", "sv", "ls", "gets", "sb", "ess", "v", "ims", "stats", "spec", "hs", "vs", "a", "bs", "ss", "sq", "f", "fs", "S", "sts", "j", "sports", "aws", "l"]}}
{"project": "FFmpeg", "commit_id": "c6bdc90890250ce351b260eff69ce3c0d0745a62", "target": 1, "func": "void help(void)\n\n{\n\n    printf(\"dct-test [-i] [<test-number>]\\n\"\n\n           \"test-number 0 -> test with random matrixes\\n\"\n\n           \"            1 -> test with random sparse matrixes\\n\"\n\n           \"            2 -> do 3. test from mpeg4 std\\n\"\n\n           \"-i          test IDCT implementations\\n\"\n\n           \"-4          test IDCT248 implementations\\n\");\n\n    exit(1);\n\n}\n", "idx": 5846, "substitutes": {}}
{"project": "qemu", "commit_id": "d9bce9d99f4656ae0b0127f7472db9067b8f84ab", "target": 1, "func": "PPC_OP(slw)\n\n{\n\n    if (T1 & 0x20) {\n\n        T0 = 0;\n\n    } else {\n\n        T0 = T0 << T1;\n\n    }\n\n    RETURN();\n\n}\n", "idx": 5855, "substitutes": {}}
{"project": "FFmpeg", "commit_id": "e3052ce7b177164da8aecfec065650fa5733e2d1", "target": 1, "func": "static int get_num(ByteIOContext *pb, int *len)\n\n{\n\n    int n, n1;\n\n\n\n    n = get_be16(pb);\n\n    (*len)-=2;\n\n//    n &= 0x7FFF;\n\n    if (n >= 0x4000) {\n\n        return n - 0x4000;\n\n    } else {\n\n        n1 = get_be16(pb);\n\n        (*len)-=2;\n\n        return (n << 16) | n1;\n\n    }\n\n}\n", "idx": 5864, "substitutes": {"pb": ["ph", "stab", "uf", "b", "bj", "ab", "wp", "cp", "pc", "ctx", "buf", "pt", "buffer", "ip", "px", "bh", "p", "pa", "cmd", "bp", "ker", "vp", "arp", "cb", "pl", "wb", "aus", "lb", "pm", "ub", "bb", "pkg", "proc", "pg", "ap", "lp", "resp", "fb", "jp", "np", "amp", "PB", "pp", "tk", "tp", "tc", "mp"], "len": ["ln", "wid", "lis", "gl", "Len", "den", "mat", "lf", "compl", "nt", "lib", "del", "un", "fl", "pl", "kl", "vel", "limit", "el", "syn", "coll", "pos", "fil", "ls", "lp", "lim", "en", "v", "fun", "fin", "sl", "lvl", "cond", "lit", "size", "hl", "length", "ld", "ll", "nl", "il", "l", "le", "elt", "vec"], "n": ["all", "b", "mn", "ns", "c", "note", "h", "nr", "i", "none", "nor", "nt", "nn", "d", "g", "norm", "p", "gn", "nc", "tn", "on", "un", "na", "name", "t", "nu", "N", "number", "r", "an", "ng", "nm", "out", "en", "num", "v", "cn", "m", "fn", "dn", "nb", "sn", "nan", "ul", "y", "np", "pn", "j", "nl", "z", "ne", "x", "ni", "ll", "l", " fn"], "n1": ["sn1", "n11", "gn11", "ngone", "k1", "k9", "gnfirst", "none", "sn11", "ng6", "nn", "sn6", "ng11", "nat1", " n2", "gnn", "snn", "nfirst", "Nfirst", "N1", "sn9", "ng1", "kn", "nat2", "N2", "gnone", "kfirst", "snone", "snfirst", "n2", "gn9", "gn1", "n9", "natfirst", "gn6", " nfirst", "n6"]}}
{"project": "qemu", "commit_id": "e5ba83c53add51796e8ea787d2b7cb1f9c3cb72d", "target": 0, "func": "CPUState *ppc440ep_init(MemoryRegion *address_space_mem, ram_addr_t *ram_size,\n\n                        PCIBus **pcip, const unsigned int pci_irq_nrs[4],\n\n                        int do_init, const char *cpu_model)\n\n{\n\n    MemoryRegion *ram_memories\n\n        = g_malloc(PPC440EP_SDRAM_NR_BANKS * sizeof(*ram_memories));\n\n    target_phys_addr_t ram_bases[PPC440EP_SDRAM_NR_BANKS];\n\n    target_phys_addr_t ram_sizes[PPC440EP_SDRAM_NR_BANKS];\n\n    CPUState *env;\n\n    qemu_irq *pic;\n\n    qemu_irq *irqs;\n\n    qemu_irq *pci_irqs;\n\n\n\n    if (cpu_model == NULL) {\n\n        cpu_model = \"440-Xilinx\"; // XXX: should be 440EP\n\n    }\n\n    env = cpu_init(cpu_model);\n\n    if (!env) {\n\n        fprintf(stderr, \"Unable to initialize CPU!\\n\");\n\n        exit(1);\n\n    }\n\n\n\n    ppc_booke_timers_init(env, 400000000, 0);\n\n    ppc_dcr_init(env, NULL, NULL);\n\n\n\n    /* interrupt controller */\n\n    irqs = g_malloc0(sizeof(qemu_irq) * PPCUIC_OUTPUT_NB);\n\n    irqs[PPCUIC_OUTPUT_INT] = ((qemu_irq *)env->irq_inputs)[PPC40x_INPUT_INT];\n\n    irqs[PPCUIC_OUTPUT_CINT] = ((qemu_irq *)env->irq_inputs)[PPC40x_INPUT_CINT];\n\n    pic = ppcuic_init(env, irqs, 0x0C0, 0, 1);\n\n\n\n    /* SDRAM controller */\n\n    memset(ram_bases, 0, sizeof(ram_bases));\n\n    memset(ram_sizes, 0, sizeof(ram_sizes));\n\n    *ram_size = ppc4xx_sdram_adjust(*ram_size, PPC440EP_SDRAM_NR_BANKS,\n\n                                    ram_memories,\n\n                                    ram_bases, ram_sizes,\n\n                                    ppc440ep_sdram_bank_sizes);\n\n    /* XXX 440EP's ECC interrupts are on UIC1, but we've only created UIC0. */\n\n    ppc4xx_sdram_init(env, pic[14], PPC440EP_SDRAM_NR_BANKS, ram_memories,\n\n                      ram_bases, ram_sizes, do_init);\n\n\n\n    /* PCI */\n\n    pci_irqs = g_malloc(sizeof(qemu_irq) * 4);\n\n    pci_irqs[0] = pic[pci_irq_nrs[0]];\n\n    pci_irqs[1] = pic[pci_irq_nrs[1]];\n\n    pci_irqs[2] = pic[pci_irq_nrs[2]];\n\n    pci_irqs[3] = pic[pci_irq_nrs[3]];\n\n    *pcip = ppc4xx_pci_init(env, pci_irqs,\n\n                            PPC440EP_PCI_CONFIG,\n\n                            PPC440EP_PCI_INTACK,\n\n                            PPC440EP_PCI_SPECIAL,\n\n                            PPC440EP_PCI_REGS);\n\n    if (!*pcip)\n\n        printf(\"couldn't create PCI controller!\\n\");\n\n\n\n    isa_mmio_init(PPC440EP_PCI_IO, PPC440EP_PCI_IOLEN);\n\n\n\n    if (serial_hds[0] != NULL) {\n\n        serial_mm_init(address_space_mem, 0xef600300, 0, pic[0],\n\n                       PPC_SERIAL_MM_BAUDBASE, serial_hds[0],\n\n                       DEVICE_BIG_ENDIAN);\n\n    }\n\n    if (serial_hds[1] != NULL) {\n\n        serial_mm_init(address_space_mem, 0xef600400, 0, pic[1],\n\n                       PPC_SERIAL_MM_BAUDBASE, serial_hds[1],\n\n                       DEVICE_BIG_ENDIAN);\n\n    }\n\n\n\n    return env;\n\n}\n", "idx": 5875, "substitutes": {"address_space_mem": ["address_space_ram", "address_space_addr", "address_area_ram", "address_area_memory", "address_area_mem", "address_area_addr", "address_space_memory"], "ram_size": ["ram_space", "gram_size", "gram_space", "ram2size", "ram_SIZE", "gram_time", "ram_Size", "gram_dim", "gram_SIZE", "gram_ize", "gram_Size", "ram_dim", "ram2space", "ram_time", "ram_ize", "ram2Size", "ram2dim"], "pcip": ["cipes", "PCip", "bcipes", "pcio", "bcio", "PCio", "bcip", "cip", "pcips", "bcips", "PCips", "PCipes", "pcipes", "cio", "cips"], "pci_irq_nrs": ["pci_irq_srs", "pci_irq_nbrs", "pci_irq_nris", "pci_irq_drs", "pci_irq_drc", "pci_irq_sris", "pci_irq_nbris", "pci_irq_nls", "pci_irq_sls", "pci_irq_nbrc", "pci_irq_nbls", "pci_irq_src", "pci_irq_dls", "pci_irq_nrc", "pci_irq_dris"], "do_init": ["proc_init", "do2init", "proc_Init", "do_start", "do2start", "do2Init", "proc_start", "do_Init"], "cpu_model": ["cpu_controller", "processor_mode", "CPU_type", "cpu_Model", "CPU_model", "chip_controller", "hog_machine", "cpu_state", "hog_model", "chip_config", "processor_model", "CPU_state", "CPU_Model", "chip_Model", "hog_models", "processor_models", "cpu_type", "chip_model", "cpu_models", "cpu_machine", "cpu_config", "hog_controller", "cpu_mode"], "ram_memories": ["ram_manaries", "ram_tempory", "ram_temors", "ram_manograms", "ram_tempograms", "ram_histaries", "ram_temaries", "ram_histors", "ram_temory", "ram_history", "ram_medories", "ram_manories", "ram_temparies", "ram_memaries", "ram_memors", "ram_temories", "ram_histories", "ram_temograms", "ram_memograms", "ram_medograms", "ram_medors", "ram_tempors", "ram_tempories", "ram_histograms", "ram_memory", "ram_manors", "ram_medaries"], "ram_bases": ["ram_abases", "ram_bodes", "ram5stase", "ram_abains", "ram_blases", "ram_basales", "ram_bins", "ram_pains", "ram_stids", "ram_abase", "ram_nbaves", "ram_basodes", "ram5base", "ram_beodes", "ram_chones", "ram_stases", "ram_nbins", "ram_blins", "ram_nbores", "ram_baves", "ram_pids", "ram_beases", "ram_basases", "ram_stains", "ram5stases", "ram5bids", "ram_baores", "ram5bains", "ram_blores", "exec", "ram_beones", "ram_chases", "ram_bales", "ram_bones", "ram_nbases", "ram_chodes", "ram_bores", "ram5bases", "ram_abids", "ram_base", "ram5stains", "ram_blaves", "ram_beales", "ram_pases", "ram_bains", "ram_basones", "ram_pase", "ram_chales", "ram_baases", "func", "ram_stase", "ram_bids", "new", "ram_baaves", "ram5stids", "def"], "ram_sizes": ["ram_mizes", "ram_sinks", "ram_lizes", "ram2bists", "ram_hists", "ram_hizes", "ram_lamples", "ram_howers", "ram_minks", "ram_lides", "ram_samples", "ram_sockets", "ram_seinks", "ram_masists", "ram_Sists", "ram2sowers", "ram_Sets", "ram_sists", "ram_mamples", "ram_nsists", "ram_hets", "ram2sets", "ram2bizes", "ram_links", "ram_bists", "ram_bets", "ram_masockets", "ram_lapes", "ram_nsizes", "ram2sizes", "ram_Sizes", "ram2bets", "ram_sowers", "ram_Sowers", "ram_nsapes", "ram_bizes", "ram_lists", "ram_mides", "ram2bowers", "ram_seizes", "ram_sides", "ram_seides", "ram2sists", "ram_seamples", "ram_lockets", "ram_sets", "ram_nsockets", "ram_masapes", "ram_bowers", "ram_sapes", "ram_masizes"], "env": ["iv", "uv", "event", "ei", "esc", "po", "conf", "ped", "buf", "vid", "eg", "ec", "dev", "network", "cb", "environment", "pe", "js", "en", "ah", "worker", "tmp", "cur", "enc", "esm", "forge", "stage", "cam", "er", "context", "eh", "server", "esp", "v", "vs", "priv", "np", "pres", "tk", "shell", "ev", "end", "ctx", "anc", "era", "ent", "timer", "viron", "usr", "hw", "sv", "org", "nv", "cv", "eve", "door", "init", "chart", "app", "window", "ov", "here", "eas", "erd", "etc", "vp", "ew", "eng", "Environment", "him", "proc", "eu", "tx", "equ", "doc", "ee", "vt", "obj", "qt", "e", "conn"], "pic": ["ic", "gc", "feat", "Pic", "ics", "bot", "pc", "eric", "cam", "bc", "anc", "pict", "fc", "p", "pa", "pick", "pol", "picture", "wic", "mic", "sync", "aci", "pi", "peg", "py", "icc", "png", "nic", "txt", "ac", "ig", "pac", "jp", "mc", " Pic", "Picture", "iac", "pin", "icon", "fg", "capt"], "irqs": ["irtcs", "pirces", "ierqi", "irics", "mirqi", "rq", " irques", "rirques", "irqi", "mirqs", "pirqs", "pirques", " ircs", "irbacks", " irbacks", " irews", "ircs", "pirxes", "irtqi", "mirq", "pirongs", "rirqs", "ireews", "irjs", "mircs", "irq", "iriques", "irtq", " irces", "irtqs", "irques", "pirq", "pirqi", "rirjs", "irxes", "ierews", "ierbacks", "rirq", "irongs", "irces", " irxes", " irqi", "rques", "ierqs", "rerq", "iriqs", "rerjs", "ireqs", "irtongs", "rerqs", "ireqi", " irongs", "rqs", "irews", "irtces", "rjs", "rerques", "irebacks", "irixes", "pircs"], "pci_irqs": ["pci_nirks", "pci_virq", "pci_mirqs", "pci_irq", "pci_ircs", "pci_irks", "pci_nirq", "pci_virks", "pci_vircs", "pci_mircs", "pci_mirks", "pci_nirqs", "pci_mirq", "pci_nircs", "pci_virqs"]}}
{"project": "qemu", "commit_id": "146beee5d9f94d96ab3bf54ac355a263290b75ac", "target": 0, "func": "static int piix4_initfn(PCIDevice *dev)\n\n{\n\n    PIIX4State *d = DO_UPCAST(PIIX4State, dev, dev);\n\n    uint8_t *pci_conf;\n\n\n\n    isa_bus_new(&d->dev.qdev);\n\n\n\n    pci_conf = d->dev.config;\n\n    pci_config_set_vendor_id(pci_conf, PCI_VENDOR_ID_INTEL);\n\n    pci_config_set_device_id(pci_conf, PCI_DEVICE_ID_INTEL_82371AB_0); // 82371AB/EB/MB PIIX4 PCI-to-ISA bridge\n\n    pci_config_set_class(pci_conf, PCI_CLASS_BRIDGE_ISA);\n\n\n\n    piix4_dev = &d->dev;\n\n    qemu_register_reset(piix4_reset, d);\n\n    return 0;\n\n}\n", "idx": 5899, "substitutes": {"dev": ["db", "ev", "des", "app", "mem", "devices", "end", "conf", "md", "av", "cam", "pad", "DEV", "dem", "buf", "pro", "den", "nt", "ve", "store", "sys", "die", "raw", "cmd", "sd", "data", "hw", "w", "go", "adv", "debug", "device", "out", "env", "v", "ad", "vo", "dist", "bus", "dd", "port", "new", "ch", "block", "spec", "config", "off", "serv", "build", "home", "doc", "desc", "priv", "pub", "disk", "obj", "de", "gu", "info", "boot", "ver", "Dev", "conn", "def", "develop", "da"], "d": ["db", "dj", "fd", "dc", "b", "dat", "end", "c", "h", "nd", "p", "g", "dl", "dt", "n", "dict", "bd", "sd", "ds", "ind", "o", "t", "r", "dh", "D", "dr", "w", "debug", "dm", "dx", "device", "out", "ad", "v", "dd", "dos", "m", "dn", "done", "pd", "did", "e", "ld", "j", "z", "di", "l", "da"], "pci_conf": ["pcietconf", "pci_dev", "pci2con", "pcietrc", "pdi_state", "pci00config", "pci_ref", "pci00conf", "pdi_info", "pci2state", "pdi_con", "pcietcfg", "ppi_cfg", "pci_con", "pci_def", "ppi_config", "ppi_dev", "pci_config", "pcietconfig", "pci_info", "pci2conf", "pci00dev", "pdi_conf", "pci2config", "pci_rc", "ppi_rc", "pci00cfg", "ppi_conf", "pdi_config", "ppi_ref", "ppi_def", "pci_cfg", "pci_state"]}}
{"project": "FFmpeg", "commit_id": "d6945aeee419a8417b8019c7c92227e12e45b7ad", "target": 1, "func": "static void FUNCC(ff_h264_add_pixels8)(uint8_t *_dst, int16_t *_src, int stride)\n\n{\n\n    int i;\n\n    pixel *dst = (pixel *) _dst;\n\n    dctcoef *src = (dctcoef *) _src;\n\n    stride /= sizeof(pixel);\n\n\n\n    for (i = 0; i < 8; i++) {\n\n        dst[0] += src[0];\n\n        dst[1] += src[1];\n\n        dst[2] += src[2];\n\n        dst[3] += src[3];\n\n        dst[4] += src[4];\n\n        dst[5] += src[5];\n\n        dst[6] += src[6];\n\n        dst[7] += src[7];\n\n\n\n        dst += stride;\n\n        src += 8;\n\n    }\n\n\n\n    memset(_src, 0, sizeof(dctcoef) * 64);\n\n}\n", "idx": 5905, "substitutes": {"_dst": ["_newrc", "___disdest", "_dest", "_wrc", "_lest", "_wut", "_dsst", "_wst", "_sot", "_dsest", "_disdest", "___disst", "_disrc", "_dut", "_lrc", "_ddest", "___drc", "_newut", "_dsrc", "_drc", "_newdest", "_wdest", "___dut", "_disst", "_disut", "_lot", "___ddest", "_newst", "___dst", "_dsot", "_sst", "___disrc", "___disut", "_dot", "_lst", "_sest"], "_src": ["__sc", "___rc", " _sr", "___src", "_rc", "__rc", "_sc", "_sr", "__src", "_source", " _source", "__source", "_sys", " _sys", " _rc", "__sys", "___sc", "___source"], "stride": ["zice", "Strope", "arrice", "zide", "collue", "strice", "STRope", "stue", "stide", "arrride", "collride", "zope", "zride", " strue", " strope", "Stride", "stade", "strope", "stope", "Strade", " strade", "collide", "arride", " strides", "arrope", "STRice", "collope", "strue", "strride", "STRride", "Strides", "stides", "strade", "STRide", "strides", " strride"], "i": ["init", "ic", "ini", "asi", "ij", " bi", " multi", "ci", "ei", " ii", "it", " m", "im", "c", " x", " v", "mi", "qi", "ip", "li", "p", "si", "g", "ie", "zi", "n", "d", "xi", "ind", "index", " ti", "t", "pi", "multi", "bi", "me", "ui", "id", "ki", "phi", "ti", "v", "ix", "ai", "m", "PI", "I", "batch", "y", "print", "\u0438", "sim", "iu", "e", "j", "x", "di", "ii"], "dst": ["pdST", "fdst", "dradest", "dcut", " dru", "donebr", "fddest", "dralas", "drasts", "draword", "delst", "idstore", "dgest", "dsts", "discheck", "delsts", " dbsp", " dsts", "cdbr", "disput", "cdsts", "modbsp", "dport", " dsrc", " dcheck", " dx", "dest", "dput", "drast", "modsts", "idst", "DST", "cdcut", "dct", "dbr", "disru", "adst", "idport", "disdest", "dx", "dbsp", "adport", "dend", "delend", "fdstore", "pdsrc", "pdest", "adend", "dsrc", " dport", " dct", "dru", " dend", "drgest", " dstore", "idput", "drsts", "dddest", " dST", "draru", "modgest", "modst", "cdcheck", " dcut", "drabr", "drst", "idx", "pdst", "pddest", "disst", "ddst", "fdput", "ddsts", "idct", "Dst", "drbsp", " dword", "dstore", "dword", " ddest", " dput", "delbsp", "adbr", "disbsp", "dcheck", "pdsts", "cdst", "cdbsp", "dST", "iddest", "ddest", "ddST", "cdput", "dracut", "adct", "donest", "adsts", "adx", "Dest", "donelas", "Dsrc", " dlas", "delbr", " dest", " dbr", "discut", "doneword", "delgest", "dlas"], "src": ["iv", "stab", "uv", "rel", "sc", "sup", "inst", "impl", "cb", "fp", "sb", "iter", "txt", "req", "cur", "dest", "ctrl", "loc", "source", "rs", "sort", "lib", "sel", "nil", "rb", "lp", "load", "scan", "supp", "np", "pp", "comp", "via", "ctr", "stock", "sr", "seq", "std", "usr", "r", "rc", "pkg", "attr", "sec", "sur", "rt", "ripp", "st", "usc", "bs", "uint", "sq", "hl", "filename", "warn", "ser", "pack", "sys", "fc", "stat", "sync", "func", "ins", "syn", "proc", "dist", "sl", "rl", "sn", "ul", "ptr", "ist", "ipl", "tp"]}}
{"project": "FFmpeg", "commit_id": "fbaf75b166cd067cf383a75ffcccb1e2b370bf6d", "target": 1, "func": "static int output_frame(H264Context *h, AVFrame *dst, AVFrame *src)\n\n{\n\n    int i;\n\n    int ret = av_frame_ref(dst, src);\n\n    if (ret < 0)\n\n        return ret;\n\n\n\n    if (!h->sps.crop)\n\n        return 0;\n\n\n\n    for (i = 0; i < 3; i++) {\n\n        int hshift = (i > 0) ? h->chroma_x_shift : 0;\n\n        int vshift = (i > 0) ? h->chroma_y_shift : 0;\n\n        int off    = ((h->sps.crop_left >> hshift) << h->pixel_shift) +\n\n            (h->sps.crop_top  >> vshift) * dst->linesize[i];\n\n        dst->data[i] += off;\n\n    }\n\n    return 0;\n\n}\n", "idx": 5908, "substitutes": {"h": ["ph", "header", "q", "b", "window", "c", "http", "kh", "comm", "self", "oh", "ht", "bh", "d", "p", "g", "ec", "hz", "o", "t", "history", "hw", "r", "dh", "th", "rh", "k", "v", "host", "ah", "sh", "m", "ch", "hs", "he", "ih", "cache", "f", "hm", "hd", "pp", "hl", "hash", "rec", "j", "H", "info", "hh", "x", "l", "hp"], "dst": ["hst", "Dbl", "dct", "sddest", " dend", "stdest", "Dend", "dST", "sdend", "Dct", "ddest", "sdst", "dot", " dST", "desot", "dsdest", "dsst", "desST", "desst", "sdest", "stst", "Dv", "stest", "dsend", "hdest", "dend", "Dest", "desct", " dot", " dest", "Dst", "Ddest", "dsest", "hv", " dv", "Dot", "dv", "hbl", "dest", " ddest", "dbl", " dbl", "DST", " dct", "stend"], "src": ["iv", "rs", "vr", "b", "ser", "it", "sr", "rel", "sys", "sc", "inst", "usr", "r", "sel", "input", "th", "rc", "syn", "start", "s", "v", "sec", "sh", "sur", "rt", "inner", "stream", "st", "bs", "sn", "img", "sq", "ur", "f", "dest", "conv", "in", "hl", "fr", "source"], "i": ["asi", "chain", "ei", "im", "c", "ik", "gi", "zi", "ind", "t", "key", "pi", "hi", "I", "batch", "jp", "io", "j", "di", "\u0438", "x", "ic", "mi", "g", "xi", "index", "ri", "bi", "ki", "span", "ti", "v", "ai", "m", "us", "info", "l", "ci", "it", "u", "gl", "ip", "li", "p", "ami", "is", "o", "r", "to", "s", "y", "sql", "ii", "name", "init", "ini", "ij", "b", "cli", "oi", "qi", "si", "n", "iq", "multi", "me", "id", "ui", "ji", "phi", "ir", "ix", "status", "f", "sim", "ex", "iu", "gu", "e", "sequence"]}}
{"project": "qemu", "commit_id": "100f8f26086ad85a9361f2883edd55bc337ce594", "target": 1, "func": "void throttle_account(ThrottleState *ts, bool is_write, uint64_t size)\n\n{\n\n    double units = 1.0;\n\n\n\n    /* if cfg.op_size is defined and smaller than size we compute unit count */\n\n    if (ts->cfg.op_size && size > ts->cfg.op_size) {\n\n        units = (double) size / ts->cfg.op_size;\n\n    }\n\n\n\n    ts->cfg.buckets[THROTTLE_BPS_TOTAL].level += size;\n\n    ts->cfg.buckets[THROTTLE_OPS_TOTAL].level += units;\n\n\n\n    if (is_write) {\n\n        ts->cfg.buckets[THROTTLE_BPS_WRITE].level += size;\n\n        ts->cfg.buckets[THROTTLE_OPS_WRITE].level += units;\n\n    } else {\n\n        ts->cfg.buckets[THROTTLE_BPS_READ].level += size;\n\n        ts->cfg.buckets[THROTTLE_OPS_READ].level += units;\n\n    }\n\n}\n", "idx": 5920, "substitutes": {"ts": ["rs", "testers", "gs", "times", "tes", "ns", "fts", "ics", "modules", "eps", "its", "wcs", "ats", "amps", "steps", "acs", "qs", "nuts", "cs", "Ts", "tl", "aps", "terms", "actions", "TS", "ps", "als", "arts", "mt", "ms", "tm", "tn", "mint", "uts", "ds", "ports", "lets", "tr", "inters", "pots", "t", "vals", "types", "wt", "js", "ins", "ths", "atts", "ls", "tis", "ents", "ims", "tz", "ties", "outs", "txt", "hs", "vs", "asts", "ss", "bs", "parts", "fs", "heads", "posts", "ks", "sts", "tp", "tt", "tc", "lbs", "lists"], "is_write": [" is_writing", "is_writing", "is_written", "isDwrite", "isDwrote", " is_written", "is_writer", " is_writer", " is_wrote", " is_writ", "isDwriter", "is_writ", "isDwritten", "is_wrote"], "size": ["members", "large", "bytes", "export", "chain", "padding", "empty", "SIZE", " sizes", "weight", "fee", "any", "values", "Size", "scope", "set", "assets", "buffer", "amount", "g", "see", "body", "words", "use", "settings", "len", "zero", "index", "data", "total", "sent", "height", "scale", "number", "unit", "ui", "space", "options", "style", "password", "send", "code", "dim", "memory", "units", "args", "small", "status", "city", "storage", "member", "capacity", "address", "count", "message", "cache", "shape", "sum", "ize", "time", "length", "format", "news", "params", "sized", "speed"]}}
{"project": "qemu", "commit_id": "e8a095dadb70e2ea6d5169d261920db3747bfa45", "target": 1, "func": "void bdrv_remove_aio_context_notifier(BlockDriverState *bs,\n\n                                      void (*attached_aio_context)(AioContext *,\n\n                                                                   void *),\n\n                                      void (*detach_aio_context)(void *),\n\n                                      void *opaque)\n\n{\n\n    BdrvAioNotifier *ban, *ban_next;\n\n\n\n    QLIST_FOREACH_SAFE(ban, &bs->aio_notifiers, list, ban_next) {\n\n        if (ban->attached_aio_context == attached_aio_context &&\n\n            ban->detach_aio_context   == detach_aio_context   &&\n\n            ban->opaque               == opaque)\n\n        {\n\n            QLIST_REMOVE(ban, list);\n\n            g_free(ban);\n\n\n\n            return;\n\n        }\n\n    }\n\n\n\n    abort();\n\n}\n", "idx": 5931, "substitutes": {"bs": ["bytes", "gs", "bis", "b", "bn", "blog", "ns", "pb", "bos", "its", "acs", "ats", "bc", "cs", "os", "bh", "base", "ms", "bp", "bd", "ts", "bles", "ds", "BS", "bi", "aus", "bb", "ls", "sb", "s", "bf", "bps", "bits", "vs", "ss", "bl", "fs", "bm", "bas", "lbs"], "attached_aio_context": ["attached_aive_config", "attached_ai_context", "attached_aio_case", "attached_aio_config", "attached_aive_text", "attached_ai_text", "attached_ai_path", "attached_aio_data", "attached_aio_path", "attached_aio_name", "attached_ai_case", "attached_aive_content", "attached_aive_context", "attached_aio_text", "attached_aio_content"], "detach_aio_context": ["detach_aive_text", "detach_aios_config", "detach_aio_history", "detach_aios_context", "detach_aio_Context", "detach_aio_config", "detach_aios_Context", "detach_aive_config", "detach_aio_system", "detach_aive_context", "detach_aive_system", "detach_aive_connection", "detach_aio_connection", "detach_aio_text", "detach_aive_history", "detach_aios_text"], "opaque": ["ipaques", "paque", "pience", "operatile", "operaque", "ipaque", "opience", "punct", " opacity", "opaques", "opsacity", "opsaques", "operaques", "paques", "ipacity", "ipatile", "operacity", "opacity", "opsaque", " opaques", "ompaque", "ompacity", "ipunct", "ipience", "ompience", "pacity", "opatile", "opunct", "ompaques", " opunct", "opsatile"], "ban": ["rain", "cast", "anned", "ain", "avan", "raf", "bn", "wid", "pan", "istan", "iban", "bank", "cam", "ang", "ram", "ann", "wan", "annot", "anan", "Ban", "dan", "gan", " Ban", "card", "brush", "var", "ran", "isen", "kan", "uan", "stan", "san", "tag", "an", "AN", "irm", "broad", "span", "awan", "van", "gate", "plain", "pai", "man", "forth", "fan", "bean", "scan", "batch", "alias", "pas", "bang", "bug", "can", "iron", "plan", "pin", "gray", "icon", "ank", "warn", "news", "auth", "vote", "bin"], "ban_next": ["ban_first", "ban_prev", "fan__next", "fan_ne", "fan_next", "ban__prev", "ban_data", "fan_first", "ban__ne", "fan_prev", "ban_ne", "iban_prev", "iban_next", "fan__prev", "fan__first", "ban__next", "ban__first", "iban_data", "fan__ne"]}}
{"project": "qemu", "commit_id": "7d1b0095bff7157e856d1d0e6c4295641ced2752", "target": 1, "func": "static void gen_addq_lo(DisasContext *s, TCGv_i64 val, int rlow)\n\n{\n\n    TCGv_i64 tmp;\n\n    TCGv tmp2;\n\n\n\n    /* Load value and extend to 64 bits.  */\n\n    tmp = tcg_temp_new_i64();\n\n    tmp2 = load_reg(s, rlow);\n\n    tcg_gen_extu_i32_i64(tmp, tmp2);\n\n    dead_tmp(tmp2);\n\n    tcg_gen_add_i64(val, val, tmp);\n\n    tcg_temp_free_i64(tmp);\n\n}\n", "idx": 5962, "substitutes": {"s": ["as", "rs", "gs", "ses", "b", "sg", "less", "ns", "c", "ctx", "h", "sys", "sc", "os", "p", "g", "ps", "is", "ts", "ds", "t", "es", "r", "js", "ls", "sb", "xs", "ess", "scl", "v", "spec", "hs", "ss", "sq", "fs", "S", "a", "ysis"], "val": ["b", "mem", "it", "sol", "u", "ctx", "Val", " v", "pt", "alpha", "valid", "p", "vol", "pol", "ind", "pl", "data", " value", "vals", "key", "ival", "value", "err", "bal", "el", "ref", "pr", "v", "cal", "aval", "m", " aval", "reg", "al", "ret", "tx", "item", "eval", "serv", "vt", "VAL", "test", "z", " eval", "x", "l", "vec"], "rlow": ["rxlow", "RLow", " rlight", "mrlow", "rlower", "rorlow", "rxlev", "rlev", " rLow", "Rhard", "rorhard", "rLow", "rhard", "rorlower", "rlight", "rtlow", "mrlight", "rtLow", "rtlower", " rlev", "Rlow", "rxLow", "rorLow", "mrLow", "mrlev", "rthard", "rxlight", "Rlower"], "tmp": [" ind", "uv", "gb", "sp", " ptr", "buff", "xy", "copy", "uf", "Temp", "gm", "cp", " sp", "ctx", "cmp", "tar", "pro", "buf", "nt", "aaa", "mk", " td", "p", "tm", "tn", "mint", " pts", "etc", "zero", " t", " junk", "pl", "perm", "cb", "t", "emp", "temp", "tv", "zip", " mp", "pkg", "Buff", "py", " mut", "v", "txt", "tu", " np", "orig", "rt", " prob", "mb", "resp", "cv", "mm", "gz", "img", "ptr", "jp", "np", "cur", "obj", "test", " temp", "nom", "snap", "appy", "tt", "mp"], "tmp2": ["cache3", "jp02", " tmp4", "tmp4", "obj2", "obj02", "temp4", "mp2", "jptwo", " tmp02", "cache02", "stagetwo", " tmp1", "pb3", "mp02", "mp1", "mp3", "pb02", " tmptwo", "pb2", "tmp02", "obj3", "cache2", " tmp3", "temp2", "tmp3", "pbtwo", "tmptwo", "jp2", "stage2", "obj1", "tmp1", "mptwo", "stage1", "temp3", "cachetwo", "jp1", "stage02", "temp1", "mp4"]}}
{"project": "qemu", "commit_id": "b4ba67d9a702507793c2724e56f98e9b0f7be02b", "target": 1, "func": "static void test_bmdma_simple_rw(void)\n\n{\n\n    QPCIDevice *dev;\n\n    void *bmdma_base, *ide_base;\n\n    uint8_t status;\n\n    uint8_t *buf;\n\n    uint8_t *cmpbuf;\n\n    size_t len = 512;\n\n    uintptr_t guest_buf = guest_alloc(guest_malloc, len);\n\n\n\n    PrdtEntry prdt[] = {\n\n        {\n\n            .addr = cpu_to_le32(guest_buf),\n\n            .size = cpu_to_le32(len | PRDT_EOT),\n\n        },\n\n    };\n\n\n\n    dev = get_pci_device(&bmdma_base, &ide_base);\n\n\n\n    buf = g_malloc(len);\n\n    cmpbuf = g_malloc(len);\n\n\n\n    /* Write 0x55 pattern to sector 0 */\n\n    memset(buf, 0x55, len);\n\n    memwrite(guest_buf, buf, len);\n\n\n\n    status = send_dma_request(CMD_WRITE_DMA, 0, 1, prdt,\n\n                              ARRAY_SIZE(prdt), NULL);\n\n    g_assert_cmphex(status, ==, BM_STS_INTR);\n\n    assert_bit_clear(qpci_io_readb(dev, ide_base + reg_status), DF | ERR);\n\n\n\n    /* Write 0xaa pattern to sector 1 */\n\n    memset(buf, 0xaa, len);\n\n    memwrite(guest_buf, buf, len);\n\n\n\n    status = send_dma_request(CMD_WRITE_DMA, 1, 1, prdt,\n\n                              ARRAY_SIZE(prdt), NULL);\n\n    g_assert_cmphex(status, ==, BM_STS_INTR);\n\n    assert_bit_clear(qpci_io_readb(dev, ide_base + reg_status), DF | ERR);\n\n\n\n    /* Read and verify 0x55 pattern in sector 0 */\n\n    memset(cmpbuf, 0x55, len);\n\n\n\n    status = send_dma_request(CMD_READ_DMA, 0, 1, prdt, ARRAY_SIZE(prdt), NULL);\n\n    g_assert_cmphex(status, ==, BM_STS_INTR);\n\n    assert_bit_clear(qpci_io_readb(dev, ide_base + reg_status), DF | ERR);\n\n\n\n    memread(guest_buf, buf, len);\n\n    g_assert(memcmp(buf, cmpbuf, len) == 0);\n\n\n\n    /* Read and verify 0xaa pattern in sector 1 */\n\n    memset(cmpbuf, 0xaa, len);\n\n\n\n    status = send_dma_request(CMD_READ_DMA, 1, 1, prdt, ARRAY_SIZE(prdt), NULL);\n\n    g_assert_cmphex(status, ==, BM_STS_INTR);\n\n    assert_bit_clear(qpci_io_readb(dev, ide_base + reg_status), DF | ERR);\n\n\n\n    memread(guest_buf, buf, len);\n\n    g_assert(memcmp(buf, cmpbuf, len) == 0);\n\n\n\n\n\n    g_free(buf);\n\n    g_free(cmpbuf);\n\n}\n", "idx": 5963, "substitutes": {"dev": ["ev", "des", "app", "mem", "end", "conf", "md", "av", "cam", "DEV", "dem", "den", "sys", "nt", "ve", "d", "cmd", "vol", "link", "sd", "eng", "tr", "data", "hw", "server", "w", "go", "adv", "board", "device", "van", "en", "env", "ad", "v", "sh", "Device", "dd", "spec", "serv", "scan", "doc", "disk", "priv", "serial", "obj", "hid", "de", "gu", "tech", "dis", "stick", "di", "ver", "Dev", "conn", "def", "develop"], "bmdma_base": ["bmdma__id", "bmdma_name", "bmdra_id", "bmdra__base", "bmdl_ref", "bmdma_Base", "bmdma_file", "bmdma_type", "bmdl_name", "bmdl_base", "bmdma_ref", "bmdl_type", "bmdra_Base", "bmdma__file", "bmdma__Base", "bmdma_id", "bmdra__file", "bmdra_base", "bmdra__id", "bmdra_file", "bmdra__Base", "bmdma__base"], "ide_base": ["ideacbound", "idi_no", "iden_area", "ide_bound", "ide_area", "ide_prefix", "idi_part", "ideApart", "iden_bound", "ide_ase", "idi_balance", "ide_part", "idi___base", "ide_last", "idi_force", "idi_base", "idi___part", "ided_max", "idi_last", "ideaclast", "ide___no", "iden_base", "ideAbase", "idevalforce", "ide_bu", "idevalbound", "ide___balance", "idevallast", "ide_no", "ided_origin", "ideAbalance", "idi___no", "ideacforce", "ide_origin", "ided_base", "ine_ase", "idi___balance", "ideNamefile", "ine_base", "idi_bound", "ide_force", "ideacbase", "ideNamebase", "ide_label", "ide___base", "ine_label", "idevalbase", "ide___part", "ide_max", "ideNamelabel", "iden_prefix", "ide_balance", "ided_bu", "ine_file", "ideNamease", "ideAno", "ide_file"], "status": ["act", "success", "service", "result", "error", "sw", "ssl", "ser", "wait", "prefix", "access", "ping", "git", "type", "cli", "state", "compl", "login", "enabled", "msg", "valid", "progress", "stat", "details", "notice", "score", "uses", "sync", "used", "scale", "err", "str", "dr", "admin", "id", "syn", "currently", "reason", "confirmed", "wrapper", "summary", "Status", "stats", "speed", "resp", "spec", "sex", "vis", "serv", "version", "atus", "diff", "sim", "size", "flags", "info", "check", "pres", "STAT", "format", "res", "html", " Status", "since", "name", "flag"], "buf": ["rain", "db", "bytes", "uf", "buff", "b", "mem", "window", "cp", "ctx", "br", "cam", "bc", "box", "Buffer", "buffer", "msg", "seq", "norm", "cmd", "stat", "len", "var", "vp", "cb", "tr", "queue", "data", "wb", "func", "str", "vec", "pkg", "Buff", "rb", "lim", "fac", "txt", "cap", "block", "bridge", "tmp", "img", "cv", "gz", "doc", "desc", "bl", "batch", "cache", "aka", "obj", "cur", "size", "ctr", "broad", "loc", "urg", "bin"], "cmpbuf": ["testmsg", "mpbuffer", "permbuffer", "mpmsg", "cmpmsg", "cmpdata", "permbuff", "compbuff", "cmpbuffer", "mpbuff", "mpbuf", "cmpuf", "mpdata", "compdata", "testbuffer", "cmpbuff", "reluf", "testbuf", "respbuff", "respdata", "testbuff", "compbuffer", "compmsg", "permdata", "compbuf", "compuf", "respbuf", "respuf", "relbuf", "relbuff", "permbuf", "reldata"], "prdt": ["prtg", "polmt", "hrds", "prdet", "Prdm", "erds", "pretp", "chtp", " prde", "sprds", "chdt", "krDT", "PRds", "erdm", "poldm", "prde", "sprtz", "poldet", "pretk", "Prds", "hrdt", "polds", "chtk", "prdim", "prtp", "PRtg", "poldim", "prds", "sprdt", "Prdt", "sprdm", "prtk", "chtif", "prtif", "krdt", " prmt", "prtd", "hrdm", " prtp", "erdt", "Prdet", "ertd", "PRdt", "sprde", "prdat", "polde", " prDT", " prdim", " prdat", "PRdm", "prmt", "sprdim", " prtif", "hrtd", "prDT", "poldt", "krdat", "sprtg", " prtd", "sprdet", "prdm", "PRtz", "prtz", " prdm", "PRDT", "PRdat", "sprmt", " prtz", "pretif", "krdm", "predt", " prtg", " prds", " prtk"]}}
{"project": "FFmpeg", "commit_id": "33f58c3616d2870d3861da68217ef9d05cc5047a", "target": 1, "func": "static int idcin_read_packet(AVFormatContext *s,\n\n                             AVPacket *pkt)\n\n{\n\n    int ret;\n\n    unsigned int command;\n\n    unsigned int chunk_size;\n\n    IdcinDemuxContext *idcin = s->priv_data;\n\n    AVIOContext *pb = s->pb;\n\n    int i;\n\n    int palette_scale;\n\n    unsigned char r, g, b;\n\n    unsigned char palette_buffer[768];\n\n    uint32_t palette[256];\n\n\n\n    if (s->pb->eof_reached)\n\n        return AVERROR(EIO);\n\n\n\n    if (idcin->next_chunk_is_video) {\n\n        command = avio_rl32(pb);\n\n        if (command == 2) {\n\n            return AVERROR(EIO);\n\n        } else if (command == 1) {\n\n            /* trigger a palette change */\n\n            if (avio_read(pb, palette_buffer, 768) != 768)\n\n                return AVERROR(EIO);\n\n            /* scale the palette as necessary */\n\n            palette_scale = 2;\n\n            for (i = 0; i < 768; i++)\n\n                if (palette_buffer[i] > 63) {\n\n                    palette_scale = 0;\n\n                    break;\n\n\n\n\n            for (i = 0; i < 256; i++) {\n\n                r = palette_buffer[i * 3    ] << palette_scale;\n\n                g = palette_buffer[i * 3 + 1] << palette_scale;\n\n                b = palette_buffer[i * 3 + 2] << palette_scale;\n\n                palette[i] = (r << 16) | (g << 8) | (b);\n\n\n\n\n\n        chunk_size = avio_rl32(pb);\n\n\n\n\n\n        /* skip the number of decoded bytes (always equal to width * height) */\n\n        avio_skip(pb, 4);\n\n        chunk_size -= 4;\n\n        ret= av_get_packet(pb, pkt, chunk_size);\n\n        if (ret < 0)\n\n            return ret;\n\n        if (command == 1) {\n\n            uint8_t *pal;\n\n\n\n            pal = av_packet_new_side_data(pkt, AV_PKT_DATA_PALETTE,\n\n                                          AVPALETTE_SIZE);\n\n            if (ret < 0)\n\n                return ret;\n\n            memcpy(pal, palette, AVPALETTE_SIZE);\n\n            pkt->flags |= AV_PKT_FLAG_KEY;\n\n\n        pkt->stream_index = idcin->video_stream_index;\n\n        pkt->duration     = 1;\n\n    } else {\n\n        /* send out the audio chunk */\n\n        if (idcin->current_audio_chunk)\n\n            chunk_size = idcin->audio_chunk_size2;\n\n        else\n\n            chunk_size = idcin->audio_chunk_size1;\n\n        ret= av_get_packet(pb, pkt, chunk_size);\n\n        if (ret < 0)\n\n            return ret;\n\n        pkt->stream_index = idcin->audio_stream_index;\n\n        pkt->duration     = chunk_size / idcin->block_align;\n\n\n\n        idcin->current_audio_chunk ^= 1;\n\n\n\n\n    if (idcin->audio_present)\n\n        idcin->next_chunk_is_video ^= 1;\n\n\n\n    return ret;\n", "idx": 5965, "substitutes": {"s": ["gs", "ses", "sw", "sg", "less", "ns", "conf", "c", "its", "ats", "aws", "set", "sys", "qs", "cs", "os", "p", "ps", "n", "ts", "ds", "t", "js", "w", "ins", "sv", "ls", "sb", "v", "stats", "m", "spec", "hs", "vs", "ss", "bs", "local", "sq", "f", "parts", "fs", "ex", "e", "S", "sts", "sports", "a"], "pkt": [" pkg", "pmsg", "ppnt", "pcacket", " pwd", "pckt", "npqt", "tnt", "tmsg", "cpmsg", "npkt", "pnt", "compnt", "facket", "npacket", "npnt", " pvt", "tacket", "promsg", "compacket", "cpkt", "proacket", "wkt", "cpnt", "prokg", "pcvt", "wet", "compkg", "pwd", "pet", "packet", "ppkt", "pkg", "fkt", "ppqt", " pqt", "tkt", "cpacket", "fkg", "cpwd", "cpvt", "compkt", " pnt", "ppacket", "wwd", "pvt", "tkg", "cpet", "fmsg", " pmsg", "prokt", "pqt", "pcnt", " pet", "wacket", " packet"], "ret": ["gt", "result", "error", "cert", "pret", "magic", "it", "mem", "att", "conf", "Return", "run", "ber", "reply", "back", "ter", "det", "nt", "ry", "rect", "mt", "rets", "len", "val", "over", "tr", "t", "alt", "value", "err", "after", "ref", "inter", "rev", "rem", "out", "iter", "v", "summary", "try", "complete", "not", "rt", "reset", "status", "resp", "re", "reg", "response", "report", "print", "RET", "cat", "lag", "fail", "Ret", "ft", "net", "res", "def", "elt", "flag"], "command": ["which", "method", "example", "event", "function", "magic", "call", "power", "Command", "channel", "type", "communication", "direction", "category", "operation", "argument", "shift", "description", "comm", "execute", "buffer", "cmd", "rank", "duration", "context", "option", "process", "button", "key", "history", "slave", "height", "definition", "position", "requisite", "attribute", "confirmed", "distance", "minute", "password", "timeout", "mode", "code", "commit", "component", "request", "volume", "comment", "controller", "frequency", "action", "version", "handler", "capacity", "count", "message", "directory", "format", "menu", "name", "condition", "sequence"], "chunk_size": ["chunkityshare", "chunk_share", "chunk_count", "chunk_Size", "chunktshare", "chrawitySize", "chunkingscale", "chraw_share", "chunkedsize", "chunkingSIZE", "chunk_speed", "chrawitysize", "chunkingsize", "chunklenindex", "chunk_index", "chunktSize", "chunk_SIZE", "chunk_member", "chrawitymember", "chunk_scale", "chunkitysize", "chunktmember", "chraw_Size", "chrawityshare", "chraw_size", "chunkitySize", "chunkedscale", "chunklensize", "chunklenSize", "chraw_member", "chunkedSIZE", "chunklenspeed", "chunktsize", "chunkitymember"], "idcin": [" idvin", "kindcin", " idsin", "adcin", "kindcoin", "midvin", "kindci", "idci", " idgin", "Idvin", "Idci", "adtin", "adci", "Idtin", " idtin", "midsin", "Idsin", " idci", "midcin", "idgin", "midci", "adgin", "idvin", "idsin", "idcoin", "Idcin", "Idgin", "kindvin", "idtin", "Idcoin", " idcoin"], "pb": ["db", "uv", "uf", "um", "bj", "ab", "wp", "cp", "eb", "ping", "pc", "ctx", "pan", "sys", "pt", "buf", "iov", "sc", "ob", "prot", "buffer", "px", "p", "tg", "pa", "bp", "typ", "vp", "cb", "pl", "wb", "fp", "pm", "bb", "ub", "pg", "pkg", "proc", "py", "sb", "lp", "rb", "emb", "mb", "resp", "nb", "bs", "fb", "cv", "tx", "pool", "jp", "np", "tap", "dp", "obj", "pp", "PB", "td", "snap", "tk", "oa", "tp", "tc", "mp"], "i": ["chain", "ei", " ii", "gi", "zi", "ind", "key", "pi", "I", "batch", "io", "in", "j", "x", "\u0438", "di", "this", "ic", "um", "mi", "xi", "index", "ri", "bi", "ki", "span", "ti", "v", "ai", "m", "ia", "info", "l", "ci", "it", "ip", "li", "p", "ami", "progress", "is", "dr", "k", "try", "y", "ii", "name", "init", "ini", "ij", "uri", "cli", "set", "oi", "client", "qi", "si", "n", "iq", "multi", "me", "id", "ui", "ji", "slice", "phi", "ims", "ix", "status", "print", "f", "sim", "ex", "iu", "point", "z"], "palette_scale": ["paletteingsync", "palettePscale", "palettePfail", "paletteingsize", "palette13scale", "palette_fail", "palette_shape", "palettePsort", "palettePspec", "palette13stroke", "palettes_size", "palalo_fail", "palette_Scale", "palant_scale", "palaxy_radius", "palette_color", "palendix____scale", "palette_radius", "paletteingsort", "palant_shift", "palette____scale", "palettes_store", "palalo_scale", "palette____color", "paletteingtile", "palette_stroke", "palendix____step", "paletteingspec", "palettes_scale", "palant_Scale", "palaloPspec", "palette____stroke", "palette13step", "palette____step", "palaxy_scan", "palendix____stroke", "palendix_stroke", "palette_shift", "palette_size", "palette_sort", "palette_scan", "palant_shape", "palendix_color", "palaxy_scale", "palette_spec", "palette13color", "palette_store", "palaloPfail", "palendix_step", "paletteingscale", "palaxy_pad", "palendix____color", "palette_pad", "palalo_sort", "palaloPsort", "paletteingfail", "palette_step", "palette_tile", "palette_sync", "palendix_scale", "palaloPscale", "palalo_spec"], "r": ["\u0440", "vr", "rs", "ar", "lr", "sr", "c", "u", "gr", "rx", "mr", "d", "p", "n", "tr", "t", "ri", "dr", "rc", "rf", "rr", "rb", "cr", "rar", "rt", "rl", "m", "re", "a", "R", "rg", "rate", "f", "rd", "e", "ro", "x", "l"], "g": ["gt", "gb", "gc", "gs", "gre", "gp", "gm", "c", "u", "bg", "gr", "ger", "gold", "gi", "gy", "fg", "tg", "green", "d", "group", "ge", "gd", "go", "pg", "gio", "v", "m", "a", "rg", "gin", "gam", "gu", "gen", "ga", "groups", "j", "gray", "gg", "G", "l"], "b": ["db", "gb", "c", "u", "bg", "ib", "h", "br", "bc", "ba", "beta", "p", "base", "d", "n", "cb", "o", "t", "bi", "bb", "sb", "rb", "v", "be", "m", "B", "bs", "nb", "fb", "y", "f", "j", "bas", "z", "a", "l", "bin"], "palette_buffer": ["palette67server", "palette_server", "palette_width", "palette_buf", "palet_buf", "palet_width", "palellow_iter", "palellow_buffer", "palette_Buffer", "palette5iter", "palette67Buffer", "palette_match", "palette5buffer", "palellow_match", "palette_buff", "pallete_database", "palet_iter", "pallete_buff", "palette0store", "palette67match", "palellow_database", "pallete_buf", "palette_iter", "palette0server", "palette5width", "palellow_store", "palette_store", "palellow_Buffer", "palette0Buffer", "palellow_server", "palette_index", "palette_database", "palette67database", "palette67buffer", "palet_buffer", "palette67store", "palette5buf", "pallete_buffer", "palette67iter", "palette0buffer"], "palette": ["lue", "palgon", "polgon", "colette", "pallette", "polette", " pallette", "aliettes", "Palettes", " palue", "polett", "chte", "palue", "palet", "Palue", "alilette", "Palet", "chgon", "colte", "aliette", "lette", "Pallette", "palettes", "aliet", "lettes", "colgon", "chett", "chette", "colett", "llette", "palett", " palet", " palettes", "palte", "Palette", "polte"], "pal": ["Pal", "ph", "ass", "buff", "quant", "dat", "mem", "att", "ell", "flat", "gr", "sam", "mel", "pod", "cel", "pro", "buffer", "pat", "p", "table", "font", "ele", "pol", "vol", "val", "pl", "sel", "col", "bat", "bal", "el", "fac", "cal", "apple", "pixel", "cell", "phil", "al", "ul", "isal", "batch", "local", "pac", "cache", "bl", " Pal", "pp", "nl", "arr", "sal", "bin"]}}
{"project": "FFmpeg", "commit_id": "009f829dde811af654af7110326aea3a72c05d5e", "target": 1, "func": "static inline void RENAME(yuv2rgb555_2)(SwsContext *c, const uint16_t *buf0,\n\n                                        const uint16_t *buf1, const uint16_t *ubuf0,\n\n                                        const uint16_t *ubuf1, const uint16_t *vbuf0,\n\n                                        const uint16_t *vbuf1, const uint16_t *abuf0,\n\n                                        const uint16_t *abuf1, uint8_t *dest,\n\n                                        int dstW, int yalpha, int uvalpha, int y)\n\n{\n\n    x86_reg uv_off = c->uv_off << 1;\n\n\n\n    //Note 8280 == DSTW_OFFSET but the preprocessor can't handle that there :(\n\n    __asm__ volatile(\n\n        \"mov %%\"REG_b\", \"ESP_OFFSET\"(%5)        \\n\\t\"\n\n        \"mov        %4, %%\"REG_b\"               \\n\\t\"\n\n        \"push %%\"REG_BP\"                        \\n\\t\"\n\n        YSCALEYUV2RGB(%%REGBP, %5, %6)\n\n        \"pxor    %%mm7, %%mm7                   \\n\\t\"\n\n        /* mm2=B, %%mm4=G, %%mm5=R, %%mm7=0 */\n\n#ifdef DITHER1XBPP\n\n        \"paddusb \"BLUE_DITHER\"(%5), %%mm2      \\n\\t\"\n\n        \"paddusb \"GREEN_DITHER\"(%5), %%mm4      \\n\\t\"\n\n        \"paddusb \"RED_DITHER\"(%5), %%mm5      \\n\\t\"\n\n#endif\n\n        WRITERGB15(%%REGb, 8280(%5), %%REGBP)\n\n        \"pop %%\"REG_BP\"                         \\n\\t\"\n\n        \"mov \"ESP_OFFSET\"(%5), %%\"REG_b\"        \\n\\t\"\n\n        :: \"c\" (buf0), \"d\" (buf1), \"S\" (ubuf0), \"D\" (ubuf1), \"m\" (dest),\n\n           \"a\" (&c->redDither), \"m\"(uv_off)\n\n    );\n\n}\n", "idx": 5981, "substitutes": {"c": ["cf", "dc", "b", "ct", "ci", "cp", "conf", "ctx", "h", "bc", "cont", "con", "cs", "fc", "p", "d", "g", "co", "cm", "n", "ec", "cb", "lc", "ce", "t", "cc", "rc", "s", "v", "ch", "ac", "cv", "ca", "f", "C", "e", "l", "tc"], "buf0": ["batch1", "buf00", "ufzero", "uf00", "batch000", "queue1", "buffer000", "bu0", "buf000", "uf2", "uf1", "buf2", "buffer0", "bu00", "queuezero", "queue0", "batch2", "buzero", "uf0", "buffer2", "bufzero", "buffer1", "batch0", "queue00", "uf000", "bu1"], "buf1": ["uf10", "vec2", "vec01", "buff1", "buffer01", "buff0", "uf01", "buffer10", "buf01", "buff10", "uf2", "uf1", "buf2", "buf10", "uf0", "buffer2", "vec1", "buff2", "vec0", "buffer1", "buffer0"], "ubuf0": ["ubf1", "ublim8", "abuf00", "ubbuf2", "ubf00", "umuf000", "ubimg2", "ubuf000", "ubbuf1", "ubf0", "ubbuf00", "abuf2", "ubuffer000", "ubuffer0", "umbuf1", "ublim0", "umuf0", "ubbuf8", "ubbuf0", "ubbuf000", "umuf1", "ubuf8", "ubimg1", "abbuf0", "ubf2", "umuf8", "ubuffer8", "ubuf2", "abbuf1", "ublim1", "umbuf8", "ubuffer1", "abbuf00", "ubuf00", "umbuf0", "ublim000", "umbuf000", "abbuf2", "ubimg00", "ubimg0"], "ubuf1": ["ubuff1", "ubuff0", "ubufOne", "ubbuf2", "ublf0", "ubbuf1", "ubuff8", "ubbuff1", "abuf2", "umbuf1", "umuf0", "umbufOne", "ubbuf8", "ubbuf0", "ubtxt8", "umuf1", "ubtxt0", "ubtxtOne", "ubuf8", "ubbuff0", "umufOne", "ubtxt1", "abbuf0", "umuf8", "abuf8", "ubbuff8", "ubuf2", "ublf1", "ubbuffOne", "abbuf1", "ublf2", "abbuf8", "umbuf8", "ubuff2", "umbuf0", "ubbufOne", "abbuf2", "ublf8"], "vbuf0": ["vbuf2", "fuf0", "fuf2", "vbuff2", "fbuf1", "vuf0", "vbuffer0", "fbuf0", "fuf1", "vbuffer1", "vuf2", "fbuf2", "vbuffer2", "vuf1", "vbuff0", "vbuff1"], "vbuf1": ["vbuf2", "fuf0", "fbuf8", "fuf2", "vbuffer8", "vbuff2", "fbuf1", "vuf0", "vbuffer0", "fbuf0", "fuf1", "vuf8", "vbuffer1", "vuf2", "fbuf2", "vbuf8", "vbuffer2", "fuf8", "vuf1", "vbuff8", "vbuff0", "vbuff1"], "abuf0": ["abff1", "ubbuf2", "abbuf5", "abuf5", "ubbuf1", "abimg0", "abff5", "abff2", "abuf2", "abimg2", "ubbuf5", "abff0", "ubbuf0", "ubuf5", "abbuf0", "ubuf2", "abbuf1", "abimg1", "abbuf2", "abimg5"], "abuf1": ["ubbuf2", "abbuff0", "ubbuf1", "abuf2", "ubbuf8", "ubbuf0", "abuff0", "abuff8", "ubuf8", "abbuff2", "abbuf0", "abuf8", "abuff2", "ubuf2", "abbuf1", "abbuf8", "abbuff1", "abbuff8", "abbuf2", "abuff1"], "dest": ["output", "dc", "result", "loc", "sp", "mem", "src", "window", "end", "target", "est", "self", "path", "usr", "tr", "temp", "slave", "w", "ref", "master", "rest", "Dest", "out", "iter", "tip", "dist", "orig", "port", "spec", "st", "tmp", "ptr", "desc", "obj", "origin", "trans", "source"], "dstW": ["ddestW", "destU", "dostA", "DestW", "destN", "dstA", "dostW", "DstU", "DstA", "dostU", "destW", "dstN", "DstW", "destA", "ddestA", "DestA", "ddestN", "DestU", "dstU", "DestN", "DstN", "ddestU", "dostN"], "yalpha": ["Yalpha", "Ybeta", "yyma", "yma", "xbeta", "yyalpha", "yybeta", "yyrc", "Yma", "Yrc", "xalpha", "xrc", "yrc", "ybeta", "xma"], "uvalpha": ["upllambda", "uvallambda", "uplpha", "uwlpi", "uplpi", "uwllambda", "uivalpi", "uivalho", "uvalpi", "uirelho", "uirelpi", "uwlpha", "urellambda", "urelpha", "urelho", "uivallambda", "urelpi", "uirelpha", "uvalho", "uivalpha", "uplho", "uwlho", "uirellambda"], "y": ["vy", "ty", "xy", "b", "dy", "cy", "i", "yi", "Y", "ry", "gy", "p", "sy", "yd", "ay", "t", "ny", "ly", "py", "yy", "iy", "ch", "iny", "yp", "ys", "x", "ym", "oy"]}}
{"project": "qemu", "commit_id": "51b19ebe4320f3dcd93cea71235c1219318ddfd2", "target": 0, "func": "static VirtIOBlockReq *virtio_blk_get_request(VirtIOBlock *s)\n\n{\n\n    VirtIOBlockReq *req = virtio_blk_alloc_request(s);\n\n\n\n    if (!virtqueue_pop(s->vq, &req->elem)) {\n\n        virtio_blk_free_request(req);\n\n        return NULL;\n\n    }\n\n\n\n    return req;\n\n}\n", "idx": 6007, "substitutes": {"s": ["rs", "gs", "ses", "bis", "b", "less", "ns", "sol", "c", "its", "h", "ies", "sys", "set", "qs", "cs", "os", "als", "ps", "p", "is", "ts", "ds", "es", "js", "ins", "ls", "v", "ims", "sl", "spec", "hs", "ss", "bs", "y", "sq", "fs", "ares", "S", "sts", "j", "z"], "req": ["ev", "q", " res", "low", " requ", "buf", " requisite", "rx", " q", "msg", "seq", "ext", "ps", "p", "cmd", "good", "required", "circ", "iq", "ind", " resp", "r", "err", "ref", "crit", "pkg", "rr", "rem", "qa", "out", "txt", "grab", "qq", "dq", "requ", "resp", "request", "reg", "alloc", "ack", "tx", "tek", "sq", "jp", "require", "desc", "obj", "quest", "qt", "comp", "fr", "j", " rap", " reg", "res", "needed", "urg"]}}
{"project": "FFmpeg", "commit_id": "f7a02d5d694bcef993b0229c9e57f22421fed637", "target": 0, "func": "static int output_packet(InputStream *ist, const AVPacket *pkt)\n\n{\n\n    int ret = 0, i;\n\n    int got_output;\n\n\n\n    AVPacket avpkt;\n\n    if (!ist->saw_first_ts) {\n\n        ist->dts = ist->st->avg_frame_rate.num ? - ist->st->codec->has_b_frames * AV_TIME_BASE / av_q2d(ist->st->avg_frame_rate) : 0;\n\n        ist->pts = 0;\n\n        if (pkt != NULL && pkt->pts != AV_NOPTS_VALUE && !ist->decoding_needed) {\n\n            ist->dts += av_rescale_q(pkt->pts, ist->st->time_base, AV_TIME_BASE_Q);\n\n            ist->pts = ist->dts; //unused but better to set it to a value thats not totally wrong\n\n        }\n\n        ist->saw_first_ts = 1;\n\n    }\n\n\n\n    if (ist->next_dts == AV_NOPTS_VALUE)\n\n        ist->next_dts = ist->dts;\n\n    if (ist->next_pts == AV_NOPTS_VALUE)\n\n        ist->next_pts = ist->pts;\n\n\n\n    if (pkt == NULL) {\n\n        /* EOF handling */\n\n        av_init_packet(&avpkt);\n\n        avpkt.data = NULL;\n\n        avpkt.size = 0;\n\n        goto handle_eof;\n\n    } else {\n\n        avpkt = *pkt;\n\n    }\n\n\n\n    if (pkt->dts != AV_NOPTS_VALUE) {\n\n        ist->next_dts = ist->dts = av_rescale_q(pkt->dts, ist->st->time_base, AV_TIME_BASE_Q);\n\n        if (ist->st->codec->codec_type != AVMEDIA_TYPE_VIDEO || !ist->decoding_needed)\n\n            ist->next_pts = ist->pts = ist->dts;\n\n    }\n\n\n\n    // while we have more to decode or while the decoder did output something on EOF\n\n    while (ist->decoding_needed && (avpkt.size > 0 || (!pkt && got_output))) {\n\n        int duration;\n\n    handle_eof:\n\n\n\n        ist->pts = ist->next_pts;\n\n        ist->dts = ist->next_dts;\n\n\n\n        if (avpkt.size && avpkt.size != pkt->size) {\n\n            av_log(NULL, ist->showed_multi_packet_warning ? AV_LOG_VERBOSE : AV_LOG_WARNING,\n\n                   \"Multiple frames in a packet from stream %d\\n\", pkt->stream_index);\n\n            ist->showed_multi_packet_warning = 1;\n\n        }\n\n\n\n        switch (ist->st->codec->codec_type) {\n\n        case AVMEDIA_TYPE_AUDIO:\n\n            ret = decode_audio    (ist, &avpkt, &got_output);\n\n            break;\n\n        case AVMEDIA_TYPE_VIDEO:\n\n            ret = decode_video    (ist, &avpkt, &got_output);\n\n            if (avpkt.duration) {\n\n                duration = av_rescale_q(avpkt.duration, ist->st->time_base, AV_TIME_BASE_Q);\n\n            } else if(ist->st->codec->time_base.num != 0 && ist->st->codec->time_base.den != 0) {\n\n                int ticks= ist->st->parser ? ist->st->parser->repeat_pict+1 : ist->st->codec->ticks_per_frame;\n\n                duration = ((int64_t)AV_TIME_BASE *\n\n                                ist->st->codec->time_base.num * ticks) /\n\n                                ist->st->codec->time_base.den;\n\n            } else\n\n                duration = 0;\n\n\n\n            if(ist->dts != AV_NOPTS_VALUE && duration) {\n\n                ist->next_dts += duration;\n\n            }else\n\n                ist->next_dts = AV_NOPTS_VALUE;\n\n\n\n            if (got_output)\n\n                ist->next_pts += duration; //FIXME the duration is not correct in some cases\n\n            break;\n\n        case AVMEDIA_TYPE_SUBTITLE:\n\n            ret = transcode_subtitles(ist, &avpkt, &got_output);\n\n            break;\n\n        default:\n\n            return -1;\n\n        }\n\n\n\n        if (ret < 0)\n\n            return ret;\n\n\n\n        avpkt.dts=\n\n        avpkt.pts= AV_NOPTS_VALUE;\n\n\n\n        // touch data and size only if not EOF\n\n        if (pkt) {\n\n            if(ist->st->codec->codec_type != AVMEDIA_TYPE_AUDIO)\n\n                ret = avpkt.size;\n\n            avpkt.data += ret;\n\n            avpkt.size -= ret;\n\n        }\n\n        if (!got_output) {\n\n            continue;\n\n        }\n\n    }\n\n\n\n    /* handle stream copy */\n\n    if (!ist->decoding_needed) {\n\n        rate_emu_sleep(ist);\n\n        ist->dts = ist->next_dts;\n\n        switch (ist->st->codec->codec_type) {\n\n        case AVMEDIA_TYPE_AUDIO:\n\n            ist->next_dts += ((int64_t)AV_TIME_BASE * ist->st->codec->frame_size) /\n\n                             ist->st->codec->sample_rate;\n\n            break;\n\n        case AVMEDIA_TYPE_VIDEO:\n\n            if (pkt->duration) {\n\n                ist->next_dts += av_rescale_q(pkt->duration, ist->st->time_base, AV_TIME_BASE_Q);\n\n            } else if(ist->st->codec->time_base.num != 0) {\n\n                int ticks= ist->st->parser ? ist->st->parser->repeat_pict + 1 : ist->st->codec->ticks_per_frame;\n\n                ist->next_dts += ((int64_t)AV_TIME_BASE *\n\n                                  ist->st->codec->time_base.num * ticks) /\n\n                                  ist->st->codec->time_base.den;\n\n            }\n\n            break;\n\n        }\n\n        ist->pts = ist->dts;\n\n        ist->next_pts = ist->next_dts;\n\n    }\n\n    for (i = 0; pkt && i < nb_output_streams; i++) {\n\n        OutputStream *ost = output_streams[i];\n\n\n\n        if (!check_output_constraints(ist, ost) || ost->encoding_needed)\n\n            continue;\n\n\n\n        do_streamcopy(ist, ost, pkt);\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 6008, "substitutes": {"ist": ["isting", "ists", "htt", "elist", "ik", "ht", "reat", "inst", "oad", "ind", "irm", "ast", "ird", "artist", "istant", "art", "ict", "isted", "iat", "pas", "gest", "pect", "xp", "iz", "work", "ust", "tml", "ift", "feat", "wp", "edit", "alist", "ire", "iana", "rank", "tif", "ick", "eh", "esp", "ista", "port", "iste", "IST", "rit", "supp", "empt", "ace", "ort", "et", "ert", "ive", "ilst", "ief", "pt", "dit", "is", "pir", "usr", "meet", "ister", "ont", "iop", "st", "express", "lect", "hl", "ld", "il", "ij", "istor", "est", "its", "sys", "xt", "ous", "erd", "assert", "pop", "irst", "spect", "ush", "iest", "each", "list", "ess", "tip", "dist", "exist", "hist", "wikipedia", "istar", "sts", "isi", "wd", "ism", "istically"], "pkt": [" pkg", "cpqt", "cnt", "patchkt", "pbto", "ppwk", "Pkg", "tacket", "apkt", "patchkg", "cacket", "ckt", "twk", "compvc", "prkt", "pp_", "pwt", "dqt", "pakt", "pct", " pvc", "Pwk", "pdu", "patchwt", " pwt", "dnt", "apmt", "compnt", "pcht", "cpkt", "apacket", "pracket", "cpnt", "pmt", "cvc", "tkt", "cpacket", "compkt", "ppto", "ppacket", "pant", "pb_", "patchacket", " p_", " punct", "pqt", "npmt", "pvc", "apkg", "ppnt", " pwk", " pct", "Pct", "p_", "pacht", "paykt", "paacket", "Packet", "npwk", "paynt", "dkt", "ppkt", "pwk", "pkg", "npunct", " pnt", "pett", "apwt", " pto", "Pkt", "dacket", " pcht", "cpct", "tnt", "postkt", "Punct", "npkt", "pnt", "cpwk", "npacket", "punct", "npett", "compacket", "paycht", " pdu", "packet", "apett", "postkg", " pqt", "prmt", "pto", "prett", "payacket", "postwk", "Pdu", " packet", "postdu"], "i": ["ij", "b", "im", "c", "mi", "li", "p", "si", "g", "n", "index", "t", "bi", "pi", "ti", "v", "ix", "m", "I", "f", "ia", "fi", "iu", "j", "x", "il", "ii"], "got_output": ["got___console", " got_exit", "gotfulconsole", "need_console", "got___data", "got_message", "got_exit", "gotfuldata", " got_wrong", "need_output", "need_message", "got___message", "got_wrong", "got_data", "got_Output", "gotfulmessage", "got___output", "gotfuloutput", "got_console", "need_data", " got_Output"], "avpkt": ["avgwk", "avPwk", "avopvt", "avoptx", "rootpkat", "avpeet", "avpardt", "ovpet", "avewpkt", "avpaacket", "avapkt", "avewpacket", "avnpdt", "avpaelt", "vrpkt", "avenpet", "avpacmd", "avnpkt", "avenpkt", "vrpardt", " avnpdt", "avepkt", "avlikedat", "avlikekt", "ovpeet", "vrpdt", "vrparkt", "avnpvt", "avnpcmd", "ovpeett", "vrpacket", "aveopkw", "rootpkt", "avepgt", "avaptt", "avpect", "aveopmsg", "rootlikekat", "avpett", "avapgt", "ovpkt", "avipacket", "avpakt", "avnpelt", "avwpkg", "avipdt", "avgdt", "avpagt", "avewptt", "avepelt", "avewpgt", " avnpkg", "avwpgt", "AVnpvt", " avpdt", "avtpacket", "avepcmd", "avwpkt", "avphpkt", "avepkw", "avopkat", "avphptx", "AVpvt", "avpet", " avpwk", "avptt", "aveoptx", "rootlikecmd", "avepmsg", "avjptx", "avlikekat", "avtpkt", "avpkg", "rootlikedat", "avmcmd", "avpcmd", "aveptt", "avopcmd", "avwptt", "avopkw", "AVnpwk", "aveptx", "rootpdat", "avnpet", "AVpkt", "avpdat", "avopwk", "avwpacket", "AVnpkt", "vrparacket", "ovpekt", "avpakat", "avphpkw", "avpkat", " avpkg", "aveopkt", "avmet", "avpgt", "avapacket", "avopdat", "avpmsg", "avepacket", "avjpkt", "avnpkg", "avPett", "avpwk", "vrparwk", "ovpct", "avenpcmd", "avopmsg", "avpvt", "rootpcmd", "avopkt", "avpadat", "avopett", "avepet", "AVpwk", "avipwk", "avpaet", "avpeett", "avpelt", "avpdt", "avgkt", "avopet", "ovpett", "avPct", "avPkt", "avPet", "avpacket", " avnpwk", "avjpkw", "avtpwk", "avmelt", "avphpmsg", "avmkt", "avlikecmd", "avpkw", "avenpelt", "avtpdt", "AVpct", "avwpdt", "avnpwk", "AVnpct", "avparkt", "avpct", "avgkg", "vrpwk", "avipkt", "avpekt", "avnpct", "ovpect", "avparwk", "rootlikekt", "avptx", "avpatt", "avPvt", "avopct", " avnpkt", "avjpmsg", "avparacket", "avwpwk"], "duration": ["result", "wait", "d", " timeout", "no", "len", "total", "alt", "r", "err", "repeat", "str", " fut", "span", "rest", "timeout", "v", "resp", "m", " wait", "f", "loop", "Duration", "time", "length", " dur"]}}
{"project": "qemu", "commit_id": "ea375f9ab8c76686dca0af8cb4f87a4eb569cad3", "target": 1, "func": "void qemu_system_reset(void)\n\n{\n\n    QEMUResetEntry *re, *nre;\n\n\n\n    /* reset all devices */\n\n    QTAILQ_FOREACH_SAFE(re, &reset_handlers, entry, nre) {\n\n        re->func(re->opaque);\n\n    }\n\n\n}", "idx": 6025, "substitutes": {"re": ["rs", "ar", "mem", "gre", "rep", "real", "set", "con", "ry", "ire", "ent", "co", "n", "ge", "rew", "pair", "red", "se", "ri", "ere", "vre", "r", "range", "ce", "ref", "RE", "pre", "rem", "ue", "ren", "cre", "be", "reset", "m", "resp", "reg", "al", "ret", "entry", "le", "report", "he", "ru", "rate", "Re", "de", "rec", "e", "ree", "res", "ro", "rez", "ne", "rer", "com", "rm"], "nre": ["nres", "nmcre", " nres", "nmre", "Nry", "nry", "nnre", "nncre", "nRE", "Ncre", "Nres", "nmRE", " nRE", "nnres", "nnry", "ncre", "nmres", " nry", "Nre", "nnRE", " ncre"]}}
{"project": "qemu", "commit_id": "a9c0183059d6a4e4d940cd86ac0f9402b0655d24", "target": 0, "func": "static void sd_reset(SDState *sd, BlockDriverState *bdrv)\n\n{\n\n    uint64_t size;\n\n    uint64_t sect;\n\n\n\n    if (bdrv) {\n\n        bdrv_get_geometry(bdrv, &sect);\n\n    } else {\n\n        sect = 0;\n\n    }\n\n    size = sect << 9;\n\n\n\n    sect = (size >> (HWBLOCK_SHIFT + SECTOR_SHIFT + WPGROUP_SHIFT)) + 1;\n\n\n\n    sd->state = sd_idle_state;\n\n    sd->rca = 0x0000;\n\n    sd_set_ocr(sd);\n\n    sd_set_scr(sd);\n\n    sd_set_cid(sd);\n\n    sd_set_csd(sd, size);\n\n    sd_set_cardstatus(sd);\n\n    sd_set_sdstatus(sd);\n\n\n\n    sd->bdrv = bdrv;\n\n\n\n    if (sd->wp_groups)\n\n        g_free(sd->wp_groups);\n\n    sd->wp_switch = bdrv ? bdrv_is_read_only(bdrv) : 0;\n\n    sd->wp_groups = (int *) g_malloc0(sizeof(int) * sect);\n\n    memset(sd->function_group, 0, sizeof(int) * 6);\n\n    sd->erase_start = 0;\n\n    sd->erase_end = 0;\n\n    sd->size = size;\n\n    sd->blk_len = 0x200;\n\n    sd->pwd_len = 0;\n\n    sd->expecting_acmd = 0;\n\n}\n", "idx": 6032, "substitutes": {"sd": ["draw", "des", "dat", "nd", "sc", "reci", "d", "sy", "add", "dev", "ind", "se", "ud", "sb", "ss", "south", "disc", "mod", "sta", "di", "od", "so", "SD", "ell", "sam", "bd", "san", "send", "sa", "dk", "cd", "desc", "sch", "td", "db", "ci", "sg", "ond", "md", "score", "ed", "and", "th", "sv", "sm", "s", "sec", "vd", "sk", "dd", "st", "ord", "ld", "dis", "fd", "cod", "form", "si", "dl", "gd", "ds", "ard", "ad", "dist", "sh", "sl", "df", "sn", "storage", "sky", "pd", "sim", "hd", "sing"], "bdrv": ["bsrcv", " bderv", "bdrvc", "bdercv", "btrh", "bvrch", "bdrh", "bdrf", "bDRw", " bDRp", "hdrl", "bDrvr", "wdrvr", "bdrov", "htrr", "ibvrf", "wdrv", "wderv", "bdrch", "ibvrv", "ibvrch", "wdervr", "btrp", " bdercv", "bsrov", " bdrh", "bricv", " bdervr", "bdrm", "bdervr", "wdervd", "bdervc", "bvrm", "hdrv", "bdril", " bdrvd", "hsrv", "bDRp", "ibdrw", "bderver", "bvrv", "bdrcer", "bDrvd", "bsrf", "bdrivd", " bdrw", "blervr", "bvrvr", "htrv", "wdrvd", "briv", "bsrw", "hsrvd", "bdervd", "bdarm", "bdrcv", "bDRh", "bdarv", "btrv", "bvrf", " bdrvc", "brivd", "bvrov", "bdriv", "blerver", "bderf", "bDRv", "ibvrw", "bsrvr", "bdr", "blervc", "wdercer", " bdervd", "bdrvr", " bdrver", "btrw", "bridvr", " bdrcv", "bdrvd", " bvrver", "bsrvd", " bDRh", "bdarvd", "bridcer", "btrvd", "hdrvd", "bvrvc", "bridv", " bdrvr", "bvrp", "btrr", " bvrvr", "bderw", "hdrm", "bdrw", "bderch", "bDrv", " bdrp", "bvrw", "ibdrch", "hsrm", "bdrr", "bdrl", "bsrch", "bdercer", "blerv", " bDRw", "bsrv", "bdv", "bdrir", "bderv", "wdrcer", "bdrp", "ibdrf", "btrl", "bridvd", " bvrvc", "bDrcer", " bDRv", "hdrr", "bdrver", " bvrv", "bsrm", "htrl", "htrvd", "bdl", "bvrh", "brivr", "bdvd", "bdarov", "hsrov", "bvrver", "hdrov", "ibdrv", "bvrvd"], "size": ["sw", "empty", "SIZE", "c", "h", "sc", "t", "se", "section", "pos", "num", "memory", "south", "sum", "iz", "x", "loc", "mem", "g", "index", "max", "v", "dim", "address", "length", "l", "shift", "offset", "p", "len", "total", "limit", "to", "sv", "align", "s", "sec", "small", "st", "capacity", "shape", "ize", "news", "name", "sp", "Size", "set", "buffer", "n", "ew", "row", "data", "sent", "height", "scale", "space", "sh", "status", "sn", "storage", "area", "count", "z"], "sect": ["mult", "put", "ECT", "ct", "rupt", "sw", "ctl", "access", "step", "issue", "ect", "ctx", "shift", "set", "con", "touch", "client", "sections", "aj", "seq", "round", "n", "ec", "len", "zero", "row", "index", "se", "cc", "col", "rc", "section", "crit", "connect", "pos", "control", "ess", "eq", "sector", "change", "sec", "sh", "scroll", "resp", "port", "st", "tab", "adj", "config", "ch", "gz", "cond", "sq", "count", "diff", "mod", "test", "ex", "length", "z", "j", "x", "loc", "act"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void phys_page_set(AddressSpaceDispatch *d,\n\n                          target_phys_addr_t index, target_phys_addr_t nb,\n\n                          uint16_t leaf)\n\n{\n\n    /* Wildly overreserve - it doesn't matter much. */\n\n    phys_map_node_reserve(3 * P_L2_LEVELS);\n\n\n\n    phys_page_set_level(&d->phys_map, &index, &nb, leaf, P_L2_LEVELS - 1);\n\n}\n", "idx": 6033, "substitutes": {"d": ["dc", "b", "dat", "md", "c", "du", "dt", "p", "bd", "sd", "ds", "t", "r", "D", "dh", "dr", "dm", "dx", "dll", "v", "ad", "dd", "dq", "m", "dn", "cd", "f", "dp", "pd", "de", "e", "did", "di", "a", "fd", "da"], "index": ["node", "type", "ctx", "offset", "i", "set", "find", "active", "primary", "nn", "base", "si", "val", "ind", "row", "label", "key", "value", "position", "slice", "ref", "pos", "id", "level", "iter", "num", "ix", "iso", "block", "Index", "tx", "local", "address", "count", "size", "x", "inc", "loc"], "nb": ["db", "gb", "b", "bn", "bj", "obb", "pb", "note", "ib", "gov", "nr", "nd", "nt", "nn", "n", "tn", "bd", "iq", "cb", "wb", "lb", "nu", "bb", "nob", "ub", "sb", "nm", "rb", "bf", "num", "cn", "mb", "xb", "abb", "batch", "NB", "np", "nz", "kb", "bm"], "leaf": ["gt", "depth", "aw", "tree", "root", "empty", "node", "deep", "af", "fee", "lf", "Le", "nt", "valid", "table", "aux", "locked", "label", " Leaf", "alt", "stack", "slave", "lang", "let", "bool", "level", "child", "bf", "lvl", "ul", "stable", "local", "parent", "batch", "conv", "de", "ld", "oot", "flag"]}}
{"project": "qemu", "commit_id": "425532d71d5d295cc9c649500e4969ac621ce51d", "target": 0, "func": "static inline void tcg_out_op(TCGContext *s, TCGOpcode opc, const TCGArg *args,\n\n                              const int *const_args)\n\n{\n\n    int c;\n\n\n\n    switch (opc) {\n\n    case INDEX_op_exit_tb:\n\n        if (check_fit_tl(args[0], 13)) {\n\n            tcg_out_arithi(s, TCG_REG_G0, TCG_REG_I7, 8, RETURN);\n\n            tcg_out_movi_imm13(s, TCG_REG_O0, args[0]);\n\n        } else {\n\n            tcg_out_movi(s, TCG_TYPE_PTR, TCG_REG_I0, args[0] & ~0x3ff);\n\n            tcg_out_arithi(s, TCG_REG_G0, TCG_REG_I7, 8, RETURN);\n\n            tcg_out_arithi(s, TCG_REG_O0, TCG_REG_O0,\n\n                           args[0] & 0x3ff, ARITH_OR);\n\n        }\n\n        break;\n\n    case INDEX_op_goto_tb:\n\n        if (s->tb_jmp_offset) {\n\n            /* direct jump method */\n\n            uint32_t old_insn = *(uint32_t *)s->code_ptr;\n\n            s->tb_jmp_offset[args[0]] = s->code_ptr - s->code_buf;\n\n            /* Make sure to preserve links during retranslation.  */\n\n            tcg_out32(s, CALL | (old_insn & ~INSN_OP(-1)));\n\n        } else {\n\n            /* indirect jump method */\n\n            tcg_out_ld_ptr(s, TCG_REG_T1, (uintptr_t)(s->tb_next + args[0]));\n\n            tcg_out_arithi(s, TCG_REG_G0, TCG_REG_T1, 0, JMPL);\n\n        }\n\n        tcg_out_nop(s);\n\n        s->tb_next_offset[args[0]] = s->code_ptr - s->code_buf;\n\n        break;\n\n    case INDEX_op_call:\n\n        if (const_args[0]) {\n\n            tcg_out_calli(s, args[0]);\n\n        } else {\n\n            tcg_out_arithi(s, TCG_REG_O7, args[0], 0, JMPL);\n\n        }\n\n        /* delay slot */\n\n        tcg_out_nop(s);\n\n        break;\n\n    case INDEX_op_br:\n\n        tcg_out_bpcc(s, COND_A, BPCC_PT, args[0]);\n\n        tcg_out_nop(s);\n\n        break;\n\n    case INDEX_op_movi_i32:\n\n        tcg_out_movi(s, TCG_TYPE_I32, args[0], (uint32_t)args[1]);\n\n        break;\n\n\n\n#define OP_32_64(x)                             \\\n\n        glue(glue(case INDEX_op_, x), _i32):    \\\n\n        glue(glue(case INDEX_op_, x), _i64)\n\n\n\n    OP_32_64(ld8u):\n\n        tcg_out_ldst(s, args[0], args[1], args[2], LDUB);\n\n        break;\n\n    OP_32_64(ld8s):\n\n        tcg_out_ldst(s, args[0], args[1], args[2], LDSB);\n\n        break;\n\n    OP_32_64(ld16u):\n\n        tcg_out_ldst(s, args[0], args[1], args[2], LDUH);\n\n        break;\n\n    OP_32_64(ld16s):\n\n        tcg_out_ldst(s, args[0], args[1], args[2], LDSH);\n\n        break;\n\n    case INDEX_op_ld_i32:\n\n    case INDEX_op_ld32u_i64:\n\n        tcg_out_ldst(s, args[0], args[1], args[2], LDUW);\n\n        break;\n\n    OP_32_64(st8):\n\n        tcg_out_ldst(s, args[0], args[1], args[2], STB);\n\n        break;\n\n    OP_32_64(st16):\n\n        tcg_out_ldst(s, args[0], args[1], args[2], STH);\n\n        break;\n\n    case INDEX_op_st_i32:\n\n    case INDEX_op_st32_i64:\n\n        tcg_out_ldst(s, args[0], args[1], args[2], STW);\n\n        break;\n\n    OP_32_64(add):\n\n        c = ARITH_ADD;\n\n        goto gen_arith;\n\n    OP_32_64(sub):\n\n        c = ARITH_SUB;\n\n        goto gen_arith;\n\n    OP_32_64(and):\n\n        c = ARITH_AND;\n\n        goto gen_arith;\n\n    OP_32_64(andc):\n\n        c = ARITH_ANDN;\n\n        goto gen_arith;\n\n    OP_32_64(or):\n\n        c = ARITH_OR;\n\n        goto gen_arith;\n\n    OP_32_64(orc):\n\n        c = ARITH_ORN;\n\n        goto gen_arith;\n\n    OP_32_64(xor):\n\n        c = ARITH_XOR;\n\n        goto gen_arith;\n\n    case INDEX_op_shl_i32:\n\n        c = SHIFT_SLL;\n\n    do_shift32:\n\n        /* Limit immediate shift count lest we create an illegal insn.  */\n\n        tcg_out_arithc(s, args[0], args[1], args[2] & 31, const_args[2], c);\n\n        break;\n\n    case INDEX_op_shr_i32:\n\n        c = SHIFT_SRL;\n\n        goto do_shift32;\n\n    case INDEX_op_sar_i32:\n\n        c = SHIFT_SRA;\n\n        goto do_shift32;\n\n    case INDEX_op_mul_i32:\n\n        c = ARITH_UMUL;\n\n        goto gen_arith;\n\n\n\n    OP_32_64(neg):\n\n\tc = ARITH_SUB;\n\n\tgoto gen_arith1;\n\n    OP_32_64(not):\n\n\tc = ARITH_ORN;\n\n\tgoto gen_arith1;\n\n\n\n    case INDEX_op_div_i32:\n\n        tcg_out_div32(s, args[0], args[1], args[2], const_args[2], 0);\n\n        break;\n\n    case INDEX_op_divu_i32:\n\n        tcg_out_div32(s, args[0], args[1], args[2], const_args[2], 1);\n\n        break;\n\n\n\n    case INDEX_op_brcond_i32:\n\n        tcg_out_brcond_i32(s, args[2], args[0], args[1], const_args[1],\n\n                           args[3]);\n\n        break;\n\n    case INDEX_op_setcond_i32:\n\n        tcg_out_setcond_i32(s, args[3], args[0], args[1],\n\n                            args[2], const_args[2]);\n\n        break;\n\n    case INDEX_op_movcond_i32:\n\n        tcg_out_movcond_i32(s, args[5], args[0], args[1],\n\n                            args[2], const_args[2], args[3], const_args[3]);\n\n        break;\n\n\n\n    case INDEX_op_add2_i32:\n\n        tcg_out_addsub2(s, args[0], args[1], args[2], args[3],\n\n                        args[4], const_args[4], args[5], const_args[5],\n\n                        ARITH_ADDCC, ARITH_ADDX);\n\n        break;\n\n    case INDEX_op_sub2_i32:\n\n        tcg_out_addsub2(s, args[0], args[1], args[2], args[3],\n\n                        args[4], const_args[4], args[5], const_args[5],\n\n                        ARITH_SUBCC, ARITH_SUBX);\n\n        break;\n\n    case INDEX_op_mulu2_i32:\n\n        c = ARITH_UMUL;\n\n        goto do_mul2;\n\n    case INDEX_op_muls2_i32:\n\n        c = ARITH_SMUL;\n\n    do_mul2:\n\n        /* The 32-bit multiply insns produce a full 64-bit result.  If the\n\n           destination register can hold it, we can avoid the slower RDY.  */\n\n        tcg_out_arithc(s, args[0], args[2], args[3], const_args[3], c);\n\n        if (SPARC64 || args[0] <= TCG_REG_O7) {\n\n            tcg_out_arithi(s, args[1], args[0], 32, SHIFT_SRLX);\n\n        } else {\n\n            tcg_out_rdy(s, args[1]);\n\n        }\n\n        break;\n\n\n\n    case INDEX_op_qemu_ld_i32:\n\n        tcg_out_qemu_ld(s, args[0], args[1], args[2], args[3], false);\n\n        break;\n\n    case INDEX_op_qemu_ld_i64:\n\n        tcg_out_qemu_ld(s, args[0], args[1], args[2], args[3], true);\n\n        break;\n\n    case INDEX_op_qemu_st_i32:\n\n        tcg_out_qemu_st(s, args[0], args[1], args[2], args[3]);\n\n        break;\n\n    case INDEX_op_qemu_st_i64:\n\n        tcg_out_qemu_st(s, args[0], args[1], args[2], args[3]);\n\n        break;\n\n\n\n    case INDEX_op_movi_i64:\n\n        tcg_out_movi(s, TCG_TYPE_I64, args[0], args[1]);\n\n        break;\n\n    case INDEX_op_ld32s_i64:\n\n        tcg_out_ldst(s, args[0], args[1], args[2], LDSW);\n\n        break;\n\n    case INDEX_op_ld_i64:\n\n        tcg_out_ldst(s, args[0], args[1], args[2], LDX);\n\n        break;\n\n    case INDEX_op_st_i64:\n\n        tcg_out_ldst(s, args[0], args[1], args[2], STX);\n\n        break;\n\n    case INDEX_op_shl_i64:\n\n        c = SHIFT_SLLX;\n\n    do_shift64:\n\n        /* Limit immediate shift count lest we create an illegal insn.  */\n\n        tcg_out_arithc(s, args[0], args[1], args[2] & 63, const_args[2], c);\n\n        break;\n\n    case INDEX_op_shr_i64:\n\n        c = SHIFT_SRLX;\n\n        goto do_shift64;\n\n    case INDEX_op_sar_i64:\n\n        c = SHIFT_SRAX;\n\n        goto do_shift64;\n\n    case INDEX_op_mul_i64:\n\n        c = ARITH_MULX;\n\n        goto gen_arith;\n\n    case INDEX_op_div_i64:\n\n        c = ARITH_SDIVX;\n\n        goto gen_arith;\n\n    case INDEX_op_divu_i64:\n\n        c = ARITH_UDIVX;\n\n        goto gen_arith;\n\n    case INDEX_op_ext32s_i64:\n\n        tcg_out_arithi(s, args[0], args[1], 0, SHIFT_SRA);\n\n        break;\n\n    case INDEX_op_ext32u_i64:\n\n        tcg_out_arithi(s, args[0], args[1], 0, SHIFT_SRL);\n\n        break;\n\n    case INDEX_op_trunc_shr_i32:\n\n        if (args[2] == 0) {\n\n            tcg_out_mov(s, TCG_TYPE_I32, args[0], args[1]);\n\n        } else {\n\n            tcg_out_arithi(s, args[0], args[1], args[2], SHIFT_SRLX);\n\n        }\n\n        break;\n\n\n\n    case INDEX_op_brcond_i64:\n\n        tcg_out_brcond_i64(s, args[2], args[0], args[1], const_args[1],\n\n                           args[3]);\n\n        break;\n\n    case INDEX_op_setcond_i64:\n\n        tcg_out_setcond_i64(s, args[3], args[0], args[1],\n\n                            args[2], const_args[2]);\n\n        break;\n\n    case INDEX_op_movcond_i64:\n\n        tcg_out_movcond_i64(s, args[5], args[0], args[1],\n\n                            args[2], const_args[2], args[3], const_args[3]);\n\n        break;\n\n\n\n    gen_arith:\n\n        tcg_out_arithc(s, args[0], args[1], args[2], const_args[2], c);\n\n        break;\n\n\n\n    gen_arith1:\n\n\ttcg_out_arithc(s, args[0], TCG_REG_G0, args[1], const_args[1], c);\n\n\tbreak;\n\n\n\n    default:\n\n        fprintf(stderr, \"unknown opcode 0x%x\\n\", opc);\n\n        tcg_abort();\n\n    }\n\n}\n", "idx": 6043, "substitutes": {"s": ["sw", "less", "tes", "conf", "http", "h", "self", "ps", "dev", "ts", "t", "se", "js", "w", "sb", "services", "ss", "south", "socket", "in", "changes", "x", "sports", "source", "as", "rs", "q", "ses", "setup", "results", "store", "os", "er", "g", "tests", "ms", "es", "simple", "an", "v", "stats", "bits", "m", "vs", "us", "aws", "gs", "bis", "ssl", "ns", "ctx", "ats", "ies", "comm", "p", "aunts", "is", "r", "sv", "sm", "hs", "bs", "y", "sq", "sql", "S", "b", "eps", "its", "cli", "i", "sys", "qs", "set", "als", "stat", "details", "n", "ds", "sync", "ls", "ims", "ties", "sym", "status", "states", "storage", "obj", "sts", "z"], "opc": [" opcs", "opn", "iopc", "opplc", "iopn", "opC", " opC", "opcs", "oppC", "iopC", "OPcs", " oplc", " opn", "opcode", "ioplc", "epcs", "OPcode", "oplc", "epc", "OPc", " opcode", "oppn", "oppc", "epcode", "eplc", "OPlc"], "args": ["members", "rs", "fields", "gs", "names", "points", "weights", "ants", "ns", "orders", "amps", "ags", "values", "related", "aws", "locks", "qs", "objects", "cs", "terms", "ads", "actions", "ians", "ms", "tests", "words", "bugs", "ts", "rows", "aux", "workers", "settings", "arms", "vals", "range", "issues", "seconds", "headers", "js", "errors", "ins", "atts", "ids", "blocks", "xs", "Args", "grades", "units", "ims", "tags", "ras", "users", "properties", "ties", "ams", "els", "resp", "bits", "vs", "limits", "axis", "parts", "fs", "arg", "flags", "ks", "changes", "roots", "arr", "features", "params"], "const_args": [" const_arg", "const2arg", "static_ms", " const2vals", "const_ms", " const2args", "const___params", "const_flags", "const_vals", "const2flags", "const___args", " const2flags", "const2args", "const___ms", "const2vals", "const_keys", " const2arg", "static_keys", " const_flags", " const_vals", "const___keys", "static_params", "const_params", "static_args", "const_arg"], "c": ["b", "call", "cp", " C", "cs", "fc", "p", "n", "ec", "Count", "or", "cb", "lc", " e", "w", " ec", "code", "ac", "count", "f", "C", "e", " count", "a", "l"]}}
{"project": "FFmpeg", "commit_id": "df824548d031dbfc5fa86ea9e0c652bd086b55c4", "target": 0, "func": "static int eightsvx_decode_frame(AVCodecContext *avctx, void *data,\n\n                                 int *got_frame_ptr, AVPacket *avpkt)\n\n{\n\n    EightSvxContext *esc = avctx->priv_data;\n\n    int n, out_data_size;\n\n    int ch, ret;\n\n    uint8_t *src;\n\n\n\n    /* decode and interleave the first packet */\n\n    if (!esc->samples && avpkt) {\n\n        int packet_size = avpkt->size;\n\n\n\n        if (packet_size % avctx->channels) {\n\n            av_log(avctx, AV_LOG_WARNING, \"Packet with odd size, ignoring last byte\\n\");\n\n            if (packet_size < avctx->channels)\n\n                return packet_size;\n\n            packet_size -= packet_size % avctx->channels;\n\n        }\n\n        esc->samples_size = !esc->table ?\n\n            packet_size : avctx->channels + (packet_size-avctx->channels) * 2;\n\n        if (!(esc->samples = av_malloc(esc->samples_size)))\n\n            return AVERROR(ENOMEM);\n\n\n\n        /* decompress */\n\n        if (esc->table) {\n\n            const uint8_t *buf = avpkt->data;\n\n            uint8_t *dst;\n\n            int buf_size = avpkt->size;\n\n            int i, n = esc->samples_size;\n\n\n\n            if (buf_size < 2) {\n\n                av_log(avctx, AV_LOG_ERROR, \"packet size is too small\\n\");\n\n                return AVERROR(EINVAL);\n\n            }\n\n\n\n            /* the uncompressed starting value is contained in the first byte */\n\n            dst = esc->samples;\n\n            for (i = 0; i < avctx->channels; i++) {\n\n                *(dst++) = buf[0]+128;\n\n                delta_decode(dst, buf + 1, buf_size / avctx->channels - 1, (buf[0]+128)&0xFF, esc->table);\n\n                buf += buf_size / avctx->channels;\n\n                dst += n / avctx->channels - 1;\n\n            }\n\n        } else {\n\n            raw_decode(esc->samples, avpkt->data, esc->samples_size);\n\n        }\n\n    }\n\n\n\n    /* get output buffer */\n\n    av_assert1(!(esc->samples_size % avctx->channels || esc->samples_idx % avctx->channels));\n\n    esc->frame.nb_samples = FFMIN(MAX_FRAME_SIZE, esc->samples_size - esc->samples_idx)  / avctx->channels;\n\n    if ((ret = avctx->get_buffer(avctx, &esc->frame)) < 0) {\n\n        av_log(avctx, AV_LOG_ERROR, \"get_buffer() failed\\n\");\n\n        return ret;\n\n    }\n\n\n\n    *got_frame_ptr   = 1;\n\n    *(AVFrame *)data = esc->frame;\n\n\n\n    out_data_size = esc->frame.nb_samples;\n\n    for (ch = 0; ch<avctx->channels; ch++) {\n\n        src = esc->samples + esc->samples_idx / avctx->channels + ch * esc->samples_size / avctx->channels;\n\n        memcpy(esc->frame.data[ch], src, out_data_size);\n\n    }\n\n    out_data_size *= avctx->channels;\n\n    esc->samples_idx += out_data_size;\n\n\n\n    return esc->table ?\n\n        (avctx->frame_number == 0)*2 + out_data_size / 2 :\n\n        out_data_size;\n\n}\n", "idx": 6063, "substitutes": {"avctx": ["AVctx", "wavcmp", " avcmp", "avcp", "navjac", "ajctx", "ravcu", "ivercmd", "ravctx", "avcontext", "aveconn", "afcmd", "avjac", "averctl", "abcu", "ajjp", "iverkw", "avecp", "avcfg", "avcu", " avobj", "afctl", "averctx", "AVcontext", "avcmd", "ajctl", "afctx", "ajkw", " avjp", "avejac", "ajcontext", "avconn", "avecontext", "navctx", "afconn", "averconfig", "avectx", "wavctx", "afconfig", "avctl", "navcmd", "wavcontext", "avecmd", "afjp", "afcu", " avconn", "avpkg", "avtx", "aveconfig", "avercfg", "abcontext", "abcmd", "avecu", "averconn", " avcontext", "aftx", "avercu", "avercontext", "abjac", "aveobj", " avtx", "iverctx", "ajobj", " avcfg", "ajcmd", " avctl", "ajpkg", "wavtx", "wavpkg", "ajconn", "averjac", "afpkg", "AVctl", "abctx", "navkw", "afcmp", "avecmp", "avercmd", "ajtx", "abcp", "avjp", "avetx", "avecfg", " avcmd", "iverjac", "ajconfig", "avobj", "AVtx", "ajjac", "abcmp", "ajcmp", "abconn", "abtx", "avconfig", "ajcp", "avcmp", "ravcontext", "ajcfg", "abpkg", "avepkg", "afcontext", "ravtx", "avkw", "wavobj"], "data": ["read", "bytes", "padding", "dat", "window", "type", "offset", "feed", "multiple", "pad", "buffer", "raw", "actions", "map", "d", "p", "table", "base", "len", "name", "ata", "o", "t", "input", "Data", "w", "r", "value", "id", "mu", "start", "out", "mode", "video", "stream", "frame", "m", "load", "response", "batch", "cache", "f", "DATA", "message", "size", "length", "format", "text", "a", "def", "image", "bin"], "got_frame_ptr": ["got_frame_pointer", "got_frame2addr", "got_frame_addr", "got_frame2pointers", "got_frame_pointers", "got_frame2ptr", "got_data_pointers", "got_data_ptr", "got_frame2pointer", "got_data_addr", "got_data_pointer"], "avpkt": ["avjpcmd", "avdkt", "avcpacket", "avpaft", "ajppkt", " avpnt", "avepakt", "avvpft", " avpdu", "avvpmt", "avmct", "avpacmd", "avepaft", "avepkt", "afmkt", "avpnt", "avdth", "avpth", "avppacket", " avPnt", "afmk", "avpackcmd", "avppkt", "avpft", " avPct", "afpk", "avpakt", "avmk", "ajppct", "avvk", "afPcmd", " avPdu", "avdcmd", "ajpct", "avepcmd", "avjpft", "afPth", "avppct", "ajpkt", "avepamt", "avcpkt", "afPacket", "avpackkt", "avPdu", "avppcmd", "avcpk", "avcpnt", "avvct", "avcpcmd", "avpdu", "avmcmd", "avepacmd", "avpcmd", "avppk", "avmacket", "afpct", "avdacket", "avPth", "afPkt", "avpackth", "avpmt", "avPcmd", "avppnt", "ajppacket", "avpk", "afpacket", "avjpkt", "afcpkt", "avvacket", "afpdu", "afmacket", "avpamt", "afmct", "avjpmt", "avopkt", "ajpacket", "avopacket", "avmdu", "afpkt", " avPkt", "afpth", "afcpdu", "avPct", "avPkt", "avpacket", " avpct", "avpackacket", "avPnt", "avcpct", "avmkt", "avvpcmd", "avvkt", "avepmt", "afpcmd", "afcpacket", "avopk", "ajppk", "avpct", "avvpkt", "avepft", "avPacket", "afcpcmd", "avopct", "avcpdu", "avppdu", "ajpk"], "esc": ["ecd", "ev", "bec", "eb", "ctx", "sc", "ek", "comm", "except", "Esc", "exc", "escape", "eg", "https", "esi", "chest", "psc", "established", "ech", "ec", "ew", "ocr", "ebook", "ez", "eng", "eh", "osc", "lc", "es", "ep", "eca", "rez", "sel", "xc", "asc", "rc", "pg", "esp", "egal", "eur", " ec", "ess", "eq", "oc", "ah", "sec", "ef", "sh", "secure", "phrase", "isc", "equ", "disc", "exec", "desc", "eval", "eco", "abc", "eth", "ex", "imp", "irc", "ssh", "esm", "env", "ape", "loc", "ect"], "n": ["b", "mn", "ns", "c", "h", "nt", "nn", "p", "d", "g", " N", "nc", "len", "na", "o", "t", "r", "N", "w", "id", "nm", "k", "cn", "en", "num", "v", "out", "s", "m", "nb", "sn", "nan", "count", "np", "size", "z", "j", "names", "ni", "l"], "out_data_size": ["out_window_num", "out_window_size", "out_data_num", "out_data_length", "out_window_len", "out_window_length", "out_data_len"], "ch": ["q", "chain", "CH", "channel", "conf", "c", "h", "cs", "sc", "cor", "Ch", "ip", "cb", "bi", "cht", "ach", "col", "th", "k", "och", "y", "ih", "count", "chan", "z", "cho"], "ret": ["rs", "result", "match", "mem", "rel", "sys", "nt", "ry", "mt", "val", "alt", "rc", "ref", "rem", "reset", "fin", "rt", "status", "re", "new", "fi", "conv", "Ret", "net", "ll", "res", "elt"], "src": ["iv", "rs", "loc", "sys", "sc", "bh", "addr", "inst", "cb", "usr", "input", "rc", "attr", "sb", "txt", "dist", "st", "sub", "sn", "scan", "ptr", "img", "tmp", "dest", "ctr", "trans", "source", "bin"], "buf": ["init", "db", "uf", "buff", "b", "ff", "mem", "end", "cp", "pb", "ctx", "br", "pack", "cam", "bc", "box", "h", "late", "Buffer", "buffer", "ux", "msg", "raw", "map", "seq", "norm", "cmd", "var", "cb", "queue", "err", "rc", "pos", "pkg", "mu", "Buff", "rb", "lim", "max", "txt", "iter", "cap", "emb", "foo", "nb", "off", "tmp", "cv", "batch", "img", "doc", "tx", "bl", "np", "desc", "xff", "conv", "arr", "coord", "vec"], "dst": ["bend", "sddest", "sst", " dend", "sest", "idost", "idput", "wst", "dST", "iddest", "idnd", "wST", "idest", "Dnet", "sdst", " dST", "ddest", "jost", "jst", "sdest", "wrest", "dend", "brest", "idnet", "Dest", "jnd", "dost", "Dnd", " dest", "Dst", "sdput", "dnet", "dnd", "Ddest", "sST", "bST", "Dput", " drest", "drest", "Dost", "dest", " dnet", "jest", "dput", "wend", " dost", "bst", "idst", " ddest", "DST"], "i": ["init", "ic", "ini", "ci", "b", "it", "im", "c", "u", "cli", "h", "gi", "mi", "qi", "ip", "li", "p", "si", "g", "d", "zi", "is", "xi", "index", "t", "bi", "pi", "multi", "id", "ui", "ki", "k", "phi", "ti", "v", "ix", "ai", "m", "status", "I", "y", "io", "sim", "iu", "e", "j", "z", "di", "x", "ii", "l"]}}
{"project": "qemu", "commit_id": "80dcfb8532ae76343109a48f12ba8ca1c505c179", "target": 0, "func": "static int virtio_serial_load(QEMUFile *f, void *opaque, int version_id)\n\n{\n\n    VirtIOSerial *s = opaque;\n\n    VirtIOSerialPort *port;\n\n    uint32_t max_nr_ports, nr_active_ports, ports_map;\n\n    unsigned int i;\n\n    int ret;\n\n\n\n    if (version_id > 3) {\n\n        return -EINVAL;\n\n    }\n\n\n\n    /* The virtio device */\n\n    ret = virtio_load(&s->vdev, f);\n\n    if (ret) {\n\n        return ret;\n\n    }\n\n\n\n    if (version_id < 2) {\n\n        return 0;\n\n    }\n\n\n\n    /* The config space */\n\n    qemu_get_be16s(f, &s->config.cols);\n\n    qemu_get_be16s(f, &s->config.rows);\n\n\n\n    qemu_get_be32s(f, &max_nr_ports);\n\n    tswap32s(&max_nr_ports);\n\n    if (max_nr_ports > tswap32(s->config.max_nr_ports)) {\n\n        /* Source could have had more ports than us. Fail migration. */\n\n        return -EINVAL;\n\n    }\n\n\n\n    for (i = 0; i < (max_nr_ports + 31) / 32; i++) {\n\n        qemu_get_be32s(f, &ports_map);\n\n\n\n        if (ports_map != s->ports_map[i]) {\n\n            /*\n\n             * Ports active on source and destination don't\n\n             * match. Fail migration.\n\n             */\n\n            return -EINVAL;\n\n        }\n\n    }\n\n\n\n    qemu_get_be32s(f, &nr_active_ports);\n\n\n\n    /* Items in struct VirtIOSerialPort */\n\n    for (i = 0; i < nr_active_ports; i++) {\n\n        uint32_t id;\n\n        bool host_connected;\n\n\n\n        id = qemu_get_be32(f);\n\n        port = find_port_by_id(s, id);\n\n        if (!port) {\n\n            return -EINVAL;\n\n        }\n\n\n\n        port->guest_connected = qemu_get_byte(f);\n\n        host_connected = qemu_get_byte(f);\n\n        if (host_connected != port->host_connected) {\n\n            /*\n\n             * We have to let the guest know of the host connection\n\n             * status change\n\n             */\n\n            send_control_event(port, VIRTIO_CONSOLE_PORT_OPEN,\n\n                               port->host_connected);\n\n        }\n\n\n\n        if (version_id > 2) {\n\n            uint32_t elem_popped;\n\n\n\n            qemu_get_be32s(f, &elem_popped);\n\n            if (elem_popped) {\n\n                qemu_get_be32s(f, &port->iov_idx);\n\n                qemu_get_be64s(f, &port->iov_offset);\n\n\n\n                qemu_get_buffer(f, (unsigned char *)&port->elem,\n\n                                sizeof(port->elem));\n\n                virtqueue_map_sg(port->elem.in_sg, port->elem.in_addr,\n\n                                 port->elem.in_num, 1);\n\n                virtqueue_map_sg(port->elem.out_sg, port->elem.out_addr,\n\n                                 port->elem.out_num, 1);\n\n\n\n                /*\n\n                 *  Port was throttled on source machine.  Let's\n\n                 *  unthrottle it here so data starts flowing again.\n\n                 */\n\n                virtio_serial_throttle_port(port, false);\n\n            }\n\n        }\n\n    }\n\n    return 0;\n\n}\n", "idx": 6069, "substitutes": {"f": ["cf", "form", "uf", "q", "buff", "b", "um", "xf", "fm", "ff", "it", "conf", "af", "c", "h", "fx", "safe", "lf", "file", "fc", "p", "d", "g", "F", "fl", "o", "fp", "t", "full", "r", "w", "ref", "of", "rf", "bf", "out", "v", "fac", "far", "ef", "fed", "fa", "ac", "fb", "tf", "sf", "fs", "fi", "fo", "ft", "ex", "e", "l", "fr", "z", "j", "a", "fd", "fw"], "opaque": ["ogacity", "oplque", "opssolete", " opene", "opene", "ogaco", "ogque", "opque", "popaco", "oplaco", "opaco", "opsolete", "Opque", "opacity", "opsaque", "popacity", "popaque", "Opaque", "oplacity", " opque", "Opsolete", "opsene", "opsque", " opsolete", "popque", "Opene", "oplaque", "ogaque"], "version_id": ["versionofid", "version_number", "versionTypeid", "version2type", "version_Id", "sectionityId", "versionTypedb", "version_is", "versionofnumber", " version_type", "version2no", "messageewid", "versionalitynumber", "section_Id", "version_db", "version__id", "versionalitybug", "message_ip", "version_ip", "ver_number", "version2time", "message_id", "section_id", "versionewlink", "messageewlink", "sectionityid", "ver_type", "versionityis", "messageewip", "versionoftype", "version_type", "version_bug", "version__time", "version2id", "version_link", "version_no", "versionitydb", "sectionityis", " version_no", "ver_bug", "versionTypeis", "sectionitydb", "versionationid", "versionewid", "versionalitytype", "versionalityid", "version_time", "versionofbug", "versionTypeId", "versionityId", "section_is", "version__no", "version__type", " version_time", "ver_id", "versionationip", "section_db", "message_link", "versionewip", "versionationlink", "versionityid"], "s": ["single", "rs", "service", "gs", "ses", "sp", "ssl", "b", "sw", "ns", "conf", "c", "its", "h", "sam", "sys", "store", "set", "comm", "qs", "state", "os", "p", "ps", "n", "is", "ts", "settings", "ds", "se", "t", "es", "r", "js", "sv", "ls", "params", "sb", "services", "ess", "v", "stats", "sl", "spec", "a", "hs", "ss", "serv", "su", "sq", "session", "socket", "fs", "S", "sts", "series", "sis", "source", "sports", "aws", "ops"], "port": ["policy", "present", "eport", "h", "pro", "state", "file", "Port", "link", "ports", "queue", "t", "key", "pe", "PORT", "tag", "device", "bridge", "comment", "entry", "parent", "socket", "test", "j", "player", "pport", "service", "page", "ve", "seat", "ported", "server", "position", "pipe", "proxy", "timeout", "v", " sport", "project", "mit", "m", "part", "report", "remote", "version", "pool", "address", "info", "pp", "export", "peer", "ort", "gp", "channel", "type", "pc", "pt", "plugin", "p", "connection", " transport", "import", "try", "host", "cp", "ping", "pod", "client", "profile", "table", "group", "row", "slave", "handle", "component", "slot", "driver", "member", "point", "public", "interface"], "max_nr_ports": ["max_nr_ps", "max_nr67ports", "max_num_devices", "max_nrdusers", "max_nr_users", "max_nir_planes", "max_nrptports", "max_nrddevices", "max_nr_points", "max_nr_values", "max_NR_values", "max_nir_ports", "max_NR_users", "max_num_ports", "max_NR_points", "max_NR_jobs", "max_num_players", "max_NR_rows", "max_nrntports", "max_nr67planes", "max_nrptrows", "max_nir67planes", "max_nr_rows", "max_NR_planes", "max_nr_devices", "max_nrdjobs", "max_nr_pointers", "max_NR_ps", "max_nr_orts", "max_nrntpointers", "max_nrptplanes", "max_nrntplanes", "max_nir_orts", "max_nrptps", "max_nir67orts", "max_NR_ports", "max_NR_devices", "max_nr_players", "max_nrntvalues", "max_nr_jobs", "max_nrdports", "max_NR_pointers", "max_num_planes", "max_nr_planes", "max_nr67orts", "max_nir67ports"], "nr_active_ports": ["nr_nr_workers", "nr_activeedports", "nr_active2ports", "nr_active2players", "nr_active__ports", "nr_activedports", "nr_active_cells", "nr_active_pages", "nr_activ_ports", "nr_activ_cells", "nr_active__port", "nr_activeedcells", "nr_activeableoptions", "nr_activ_players", "nr_activedcells", "nr_active___workers", "nr_activedoptions", "nr_active_hops", "nr_active__hops", "nr_active_port", "nr_active_planes", "nr_active2pages", "nr_activeedoptions", "nr_active__planes", "nr_active___pages", "nr_active___players", "nr_activeedplayers", "nr_activ_options", "nr_nr_ports", "nr_active___ports", "nr_nr_players", "nr_active_workers", "nr_activeablecells", "nr_activedplayers", "nr_activeableports", "nr_active2workers", "nr_active_options", "nr_activeableplayers", "nr_active_players", "nr_nr_pages"], "ports_map": ["portsermap", "orts_map", "ports__reg", "orts_ap", "ports_reg", "portserMAP", "planes_cap", "planes_dict", "ports_cap", "ports_list", "services_map", "ports_dict", "types_map", "types_reg", "orts_table", "types_list", "planes_list", "ports_table", "types_maps", "ports_maps", "ports_ap", "services_Map", "ports_MAP", "ports__list", "portserMap", "portserload", "services_MAP", "ports_load", "ports__map", "ports__maps", "planes_map", "services_load", "ports_Map", "orts_list"], "i": ["init", "ini", "ij", "q", "ei", " multi", "ci", "chain", " ii", " di", "it", "uri", " m", "im", "u", "cli", " v", " ni", "oi", "gi", "mi", "qi", "li", "p", "si", "g", " si", "zi", "n", "iq", "xi", "ind", "index", " ti", "t", "pi", " err", "multi", "bi", "dr", "me", "ui", "ki", "ji", "hi", " I", "phi", "ti", " pi", "ims", "ix", " j", "ai", "m", "ri", " mi", "I", "batch", "y", " index", "us", "sim", "iu", "in", "point", "info", "j", "di", "\u0438", "ii"], "ret": ["gt", "result", "pret", "mem", "verified", "Return", "cont", "gov", "ter", "det", "nt", "ry", "valid", "backed", "mt", " Ret", "rets", "len", "val", "over", "cb", "tr", "usr", "t", "alt", "r", "ref", "bool", "rev", "nil", "out", "try", "v", "txt", "rt", "reset", "final", "resp", "re", "erey", "reg", "new", "tmp", "lit", "print", "RET", "pas", "jp", "Ret", "ll", "res", "got", "def", "cert", "flag"], "id": ["pid", "it", "window", "wid", "h", "kid", "vid", "mid", "ip", "d", "order", "is", "name", "url", "aid", "index", "uid", "key", "t", " fid", "str", "dr", "ref", "tag", "ids", "code", "bid", "ad", "ID", "sid", "oid", " tid", "m", "rid", "part", "ptr", "ide", "ident", "info", "time", "hash", "Id", "fd"], "host_connected": ["host_loaded", "ghostrettyupdated", "hosterconnected", "human_connected", "hostedupdated", "ghost_connected", "hostenpressed", "hostfulpressed", "hostrettyconnected", "host_visible", "host_updated", "host_created", "hostingcolored", "host_accessible", "hostedopened", "hostenconn", "host_colored", "hostrettyopened", "host__established", "hostfulconn", "hostingconnected", "host_active", " host_created", "human_established", "host_connection", "human_visible", "hostrettyupdated", "host__connected", "hostenactive", "host__accessible", "ghostrettyconnection", "hostfulactive", "cert_active", "hostedconnection", "certfulconn", "certfulactive", "host__visible", "hostingclosed", "host_established", " host_loaded", "ghostrettyopened", "hosterpressed", "host_opened", "host_closed", "hosteractive", "server_closed", "cert_conn", "hostenconnected", "host_conn", "host_pressed", " host_connection", "ghost_opened", "server_connected", "hostedconnected", "cert_pressed", "server_connection", "server_colored", "cert_connected", "certfulconnected", "hostfulconnected", "hosterconn", "certfulpressed", "ghost_updated", "ghostrettyconnected", "hostingconnection", "hostrettyconnection", "human_accessible", "ghost_connection"], "elem_popped": ["elem_droplet", "elem_POpp", "elem_popled", "elem_copled", "cont", "elem_dropled", "elem_POps", "elem_POpped", "elem_popping", "elem_POpping", "elem_cops", "elem_poplet", "elem_dropp", "elem_copp", "_", "elem_dropped", "elem_popp", "elem_drops", "elem_croplet", "elem_crops", "elem_copped", "elem_POpled", "elem_POplet", "elem_pops", "ii", "elem_dropping", "elem_cropping", "elem_cropped"]}}
{"project": "qemu", "commit_id": "130257dc443574a9da91dc293665be2cfc40245a", "target": 0, "func": "static CharDriverState *qemu_chr_open_spice_port(const char *id,\n\n                                                 ChardevBackend *backend,\n\n                                                 ChardevReturn *ret,\n\n                                                 Error **errp)\n\n{\n\n    const char *name = backend->spiceport->fqdn;\n\n    CharDriverState *chr;\n\n    SpiceCharDriver *s;\n\n\n\n    if (name == NULL) {\n\n        fprintf(stderr, \"spice-qemu-char: missing name parameter\\n\");\n\n        return NULL;\n\n    }\n\n\n\n    chr = chr_open(\"port\", spice_port_set_fe_open);\n\n    s = chr->opaque;\n\n    s->sin.portname = g_strdup(name);\n\n\n\n    return chr;\n\n}\n", "idx": 6092, "substitutes": {"id": ["init", "db", "pid", "end", "kid", "kind", "vid", "mid", "ip", "bind", "iden", "uid", "key", "rc", "tag", "ref", "ids", "code", "bid", "ad", "ID", "sid", "oid", "rid", "ident", "hid", "hash", "Id"], "backend": ["Backide", "backind", "backide", "bend", "bide", "guest", "backest", "BACKenter", "guend", "BACKender", "guind", "best", "bind", "Backind", "bbend", "Backended", "guide", "Backenter", "BACKended", "bbender", "Backend", "bbended", "bbenter", "Backender", "BACKend", "backenter", "Backest", "backended", "backender"], "ret": ["gt", "et", "des", "mem", "reply", "det", "sys", "nt", "mt", "rets", "val", "std", "sel", "ref", "txt", "rt", "resp", "re", "reg", "lit", "RET", "desc", "Ret", "res", "def", "rm"], "errp": ["erpp", "Erpp", "errpp", "erpar", "Erp", "nrps", "Erpar", "Erps", "errpar", "nrpp", "erp", "nrp", "nrpar", "errps", "erps"], "name": ["open", "aw", "error", "b", "prefix", "mem", "type", "c", "def", "up", "ma", "create", "path", "nam", "base", "zone", "order", "ame", "n", "no", "len", "na", "label", "data", "o", "key", "r", "str", "w", "word", "ref", "nm", "normal", "spec", "NAME", "a", "part", "close", "version", "local", "alias", "ident", "f", "size", "info", "l", "net", "j", "nl", "ne", "names", "x", "title", "Name", "source", "admin"], "chr": ["ochr", "Chr", "echR", "Chdr", " chrb", "echdr", "thru", "chsr", "ichru", "CHsr", "chru", "chedr", "CHr", "thsr", "cheR", "cherar", " chR", "echr", "ichr", "cherru", "thr", " chdr", "chcr", "Char", "Chsr", "ichsr", "ochsr", "echcr", "CHrb", "chersr", "CHar", "checr", "cherr", "ochdr", " chcr", "thar", "Chrs", "Chrb", "cher", "chdr", "chrs", " chrs", "ochrs", "chR", "ichar", " chsr", "chrb"], "s": ["rs", "gs", "ses", "ssl", "sp", "bis", "ns", "c", "its", "ats", "sys", "qs", "cs", "self", "os", "p", "g", "ps", "n", "is", "ts", "ds", "o", "es", "r", "w", "js", "ins", "sv", "ls", "sb", "hs", "ss", "bs", "y", "socket", "session", "sq", "fs", "S", "sts", "sis", "sports", "source"]}}
{"project": "qemu", "commit_id": "ec53b45bcd1f74f7a4c31331fa6d50b402cd6d26", "target": 0, "func": "void cpu_breakpoint_remove_by_ref(CPUState *cpu, CPUBreakpoint *breakpoint)\n\n{\n\n#if defined(TARGET_HAS_ICE)\n\n    QTAILQ_REMOVE(&cpu->breakpoints, breakpoint, entry);\n\n\n\n    breakpoint_invalidate(cpu, breakpoint->pc);\n\n\n\n    g_free(breakpoint);\n\n#endif\n\n}\n", "idx": 6098, "substitutes": {"cpu": ["ck", "CPU", "gc", "ct", "cum", "cp", "target", "pu", "pc", "ctx", "prof", "sys", " CPU", "clock", "physical", "os", "arch", "cpp", "util", "clus", "nc", "aux", "process", "hw", "phys", "linux", "proc", "bench", "mu", "nic", "ork", "bits", "gpu", "processor", "percent", "alloc", "cv", "socket", "np", "aco", "core", "boot", "comp", "cu", "tp"], "breakpoint": [" breakPoint", "breakingpoint", "blockPoint", "workscope", "breakoint", " breakp", "BreakPoint", "Breakoint", "windowoint", "breakline", "breakpage", "breakingzone", "breakingoint", "Breakp", "Breakpoint", "breakingtag", " breakline", " breakoint", "Breakpointer", "breaktag", " breakpointer", "breakPoint", "Breakzone", "workpoint", "windowpointer", "Breakpage", " breakzone", "breakscope", "Breakline", "breakingscope", " breakscope", "blockline", "breakpointer", "windowpoint", "blockp", "windowpage", "blockpoint", " breaktag", "breakingpage", "breakp", "breakingPoint", "breakzone", "workoint", "worktag", " breakpage"]}}
{"project": "FFmpeg", "commit_id": "1eaff98c8320d9ba48fbaec2a558f31f4104de98", "target": 1, "func": "static int flv_write_trailer(AVFormatContext *s)\n\n{\n\n    int64_t file_size;\n\n\n\n    AVIOContext *pb = s->pb;\n\n    FLVContext *flv = s->priv_data;\n\n    int i;\n\n\n\n    /* Add EOS tag */\n\n    for (i = 0; i < s->nb_streams; i++) {\n\n        AVCodecContext *enc = s->streams[i]->codec;\n\n        FLVStreamContext *sc = s->streams[i]->priv_data;\n\n        if (enc->codec_type == AVMEDIA_TYPE_VIDEO &&\n\n            enc->codec_id == AV_CODEC_ID_H264)\n\n            put_avc_eos_tag(pb, sc->last_ts);\n\n    }\n\n\n\n    file_size = avio_tell(pb);\n\n\n\n    /* update information */\n\n    avio_seek(pb, flv->duration_offset, SEEK_SET);\n\n    put_amf_double(pb, flv->duration / (double)1000);\n\n    avio_seek(pb, flv->filesize_offset, SEEK_SET);\n\n    put_amf_double(pb, file_size);\n\n\n\n    avio_seek(pb, file_size, SEEK_SET);\n\n    return 0;\n\n}\n", "idx": 6103, "substitutes": {"s": ["rs", "gs", "ses", "less", "ns", "conf", "c", "its", "http", "ats", "h", "eps", "qs", "sys", "cs", "comm", "https", "os", "p", "ps", "g", "ms", "n", "ts", "ds", "fps", "t", "es", "aus", "js", "w", "ins", "sv", "ls", "sb", "xs", "v", "ims", "stats", "args", "m", "spec", "hs", "vs", "bs", "ss", "sq", "f", "parts", "fs", "ex", "S", "sts", "aws"], "file_size": ["file2Size", "FILE_Size", "file_SIZE", "file2length", "FILE_size", " file_length", " file_offset", "file2data", "file_name", "file_offset", "file_length", " file_SIZE", "FILE_SIZE", "file_Size", " file_data", "file_data", "FILE_name", " file_Size", "file2size"], "pb": ["db", "gb", "stab", "uf", "pel", "b", "bj", "um", "wp", "cp", "eb", "pc", "ctx", "pt", "buf", "ob", "bh", "px", "p", "pa", "mt", "bp", "tm", "typ", "vp", "orp", "cb", "pl", "wb", "fp", "func", "erb", "lb", "pm", "ub", "bb", "pg", "pkg", "proc", "sb", "lp", "rb", "bps", "req", "emb", "mb", "resp", "tab", "nb", "xb", "fb", "cv", "zb", "jp", "np", "amp", "dp", "pp", "PB", "td", "patch", "tk", "tp", "tc", "mp"], "flv": [" flvt", "flov", " flvm", "fluv", "ilv", "filvc", " flf", "vlvm", "flof", "filuv", "flushvm", "ilf", "flovt", "flvm", "flvc", " flvc", "ilvt", "sluv", "flf", "llvc", " fluv", "vlf", "vlv", " flov", "flushf", "slov", "llv", "filf", "slv", "flvt", "llf", "filov", "flushv", "filv"], "i": ["chain", " multi", " ii", "im", "gi", "zi", "ind", " ti", "t", "pi", "hi", " pi", " j", "I", "batch", "in", "j", "series", "x", "di", "ic", "instance", " ni", "mi", "my", "g", " si", "ms", "xi", "index", "ri", "bi", "go", "ki", "ti", "ai", "m", "remote", "us", "info", " li", "ci", "it", "ip", "li", "ami", "is", "ski", "o", " I", " iter", "y", "ii", "name", "ini", "ij", " bi", "uri", " ki", " wi", "oi", "qi", "si", "multi", "me", "ui", "id", "list", "ji", "phi", "ims", "ix", " mi", "sim", "ex", "iu"], "enc": ["ck", "ev", "cod", "et", "c", "pc", "ctx", "eric", "cmp", "anc", "Enc", "fc", "ent", "oder", "ec", "nc", "iq", "eng", "xc", "cc", "ens", "coll", "code", "en", "oc", "acc", "ENC", "ack", "vc", "cv", "equ", "conv", "ENG", "auth", "conn", "env", "inc", "act"], "sc": [" subsc", "gc", "sp", "esc", "sw", "c", "pc", "ctx", "bc", "anc", "cs", "fc", "ec", "nc", "osc", "lc", "cc", "asc", "rc", "arc", "scl", "cr", "acc", "ch", "Sc", "uc", "SC", "ss", "isc", "sci", "cv", "mc", "sch", "tc"]}}
{"project": "qemu", "commit_id": "2d896b454a0e19ec4c1ddbb0e0b65b7e54fcedf3", "target": 1, "func": "static const void *boston_fdt_filter(void *opaque, const void *fdt_orig,\n\n                                     const void *match_data, hwaddr *load_addr)\n\n{\n\n    BostonState *s = BOSTON(opaque);\n\n    MachineState *machine = s->mach;\n\n    const char *cmdline;\n\n    int err;\n\n    void *fdt;\n\n    size_t fdt_sz, ram_low_sz, ram_high_sz;\n\n\n\n    fdt_sz = fdt_totalsize(fdt_orig) * 2;\n\n    fdt = g_malloc0(fdt_sz);\n\n\n\n    err = fdt_open_into(fdt_orig, fdt, fdt_sz);\n\n    if (err) {\n\n        fprintf(stderr, \"unable to open FDT\\n\");\n\n        return NULL;\n\n    }\n\n\n\n    cmdline = (machine->kernel_cmdline && machine->kernel_cmdline[0])\n\n            ? machine->kernel_cmdline : \" \";\n\n    err = qemu_fdt_setprop_string(fdt, \"/chosen\", \"bootargs\", cmdline);\n\n    if (err < 0) {\n\n        fprintf(stderr, \"couldn't set /chosen/bootargs\\n\");\n\n        return NULL;\n\n    }\n\n\n\n    ram_low_sz = MIN(256 * M_BYTE, machine->ram_size);\n\n    ram_high_sz = machine->ram_size - ram_low_sz;\n\n    qemu_fdt_setprop_sized_cells(fdt, \"/memory@0\", \"reg\",\n\n                                 1, 0x00000000, 1, ram_low_sz,\n\n                                 1, 0x90000000, 1, ram_high_sz);\n\n\n\n    fdt = g_realloc(fdt, fdt_totalsize(fdt));\n\n    qemu_fdt_dumpdtb(fdt, fdt_sz);\n\n\n\n    s->fdt_base = *load_addr;\n\n\n\n    return fdt;\n\n}\n", "idx": 6108, "substitutes": {"opaque": ["obaques", "OPsolete", "OPoch", "oppca", "obca", " Oplay", " Opaque", "oplay", "oppaques", "obacity", "opaques", "oppaque", "Opoch", " Opoch", "oplca", "opca", "Oplay", "opsolete", "opacity", "OPaque", "Opaque", "oplacity", "opoch", "Opsolete", " Opsolete", "OPlay", "oplaque", "oppacity", "oplaques", "obaque"], "fdt_orig": ["fdt_prop", "fdt__Orig", "fdt__orig", "fdt_original", "fdp_original", "fdt_Orig", "fdp_orig", "fdx_original", "fdx_orig", "fdt__original", "fdp_Orig", "fdp_origin", "fdt__prop", "fdp_raw", "fdx_Orig", "fdx_prop", "fdt_origin", "fdt_raw"], "match_data": ["matchmathash", "cachematbuffer", "matchmatbytes", "cache_hash", "cache_buffer", "match_buffer", "cache_bytes", "match_bytes", "cachemathash", "matchmatdata", "cachematdata", "matchmatbuffer", "cache_data", "match_hash", "cachematbytes"], "load_addr": ["loader_address", "loadADpad", "load_ref", "load_pad", "loadADaddr", "loadADaddress", "loader_addr", " load_hash", "loadaddrref", "loadaddraddress", "loaderhash", " load_address", "loaderref", "loadaddrhash", "loaderaddr", "loaderaddress", "loadaddraddr", "loader_pad", "load_hash", "load_address", " load_ref"], "s": ["rs", "so", "sp", "ses", "b", "sw", "less", "ns", "h", "sys", "state", "self", "os", "g", "ps", "p", "is", "ds", "se", "t", "sv", "ls", "sm", "sb", "services", "v", "sl", "m", "sa", "hs", "st", "ss", "bs", "south", "sac", "sq", "session", "fs", "S", "sts", "j", "sis", "sports", "a", "sand", "sing"], "machine": ["policy", "chain", "magic", "mob", "power", "node", "mem", "instance", "managed", "model", "leader", "template", "zone", "domain", "human", "link", "network", "monitor", " machines", "process", "movie", "server", "me", "money", "module", "proc", "dm", "sm", "device", "mode", "normal", "achine", "host", "memory", "container", "man", "iso", "mass", "m", "volume", "demon", "rule", "handler", "alias", "manager", "mc", "Machine", "message", "spin", "sim", "vm", "smart", "engine", "mouse", "series", "menu", "agent", "computer"], "cmdline": ["commnet", "cmdeline", "commandlog", "cmdnet", "commandnet", "cmdle", " cmdnet", "commandline", "commline", " cmdlog", "cmdLine", " cmdeline", "commandeline", "comml", " cmdLine", " cmdl", " cmdle", "mdline", "cmdlog", "mdle", "commandLine", "commLine", "commandl", "mdLine", "cmdl", "commlog", "commandle", "commeline"], "err": [" terr", " score", "ev", "eor", "error", "warn", " ptr", "Er", "fee", "conf", "kr", "c", "lr", "br", "here", "eas", "i", "nr", "only", " ni", "none", "aaa", "mr", "rn", "er", "die", "norm", "order", "timer", "n", "notice", "good", "score", "or", "cb", "usr", "ner", "css", "errors", "ere", "r", "dr", "rr", "attr", "pr", "level", "code", "iter", "cr", "rar", "yr", "rb", "req", "inner", "cfg", "resp", "gz", "count", "cer", "later", "test", " intr", " len", "e", "fr", "res", "spr", "arr", "Error", "elt", " cr"], "fdt": ["fcwt", "windt", "fredts", "FDl", "fedt", "dfit", "frwt", "fdl", "fdg", "FDt", " filts", "feedr", "fdpt", "fdte", "fdtt", "fdp", "feedT", "fcT", "fct", "fmT", "flt", "windta", "lnw", " filc", "FDT", "fnt", "fdts", "windl", "lnT", "dftd", "lntt", "dfd", "fints", "fta", "fdtd", "fedg", "fmr", "fedpt", "fdT", "fctt", "aftt", " fidc", "dfte", "fdtr", "finnt", "flw", "dfT", "fmtd", "fcc", "afttt", "fdc", "flte", "fg", "ftr", "ftd", "dft", "dfnt", "fdnt", "fcts", "fdit", "dfpt", "dfta", "fts", " fidw", "FDp", "aftte", "dfw", "dftt", " filt", "find", "fltd", "lnte", "fedtr", " filw", "fredt", " fidt", "lntd", "FDte", "FDtt", "frtt", "frT", "fdr", "fredtr", "fint", "lnwt", "frt", "fdw", "dfts", "fredta", "ft", "feedt", "windtd", "fd", "dfp", "aftta", "fcw", "FDit", "FDtd", "dftr", "dfr", "fdwt", "fl", "fcp", "fcit", " fidts", "feedtd", "fpt", "fdta", "fdd", "lnt", "FDta", "fmt", "dfg"], "fdt_sz": ["fdt_sdiz", "fdt_insiz", "fdt_asld", "fdt_asz", "fdt_ssz", "fdt_asgn", "fdt_cz", "fdt_szn", "fdt_spect", "fdt_Sz", "fdt_tszi", "fdt_ensiz", "fdt_tsz", "fdt_sv", "fdt_ssiz", "fdt_sce", "fdt_mld", "fdt_ciz", "fdt_getsiz", "fdt_ssst", "fdt_lsld", "fdt_cce", "fdt_ensz", "fdt_miz", "fdt_lszi", "fdt_insq", "fdt_getsce", "fdt_ensld", "fdt_lsgn", "fdt_sdst", "fdt_enspect", "fdt_rsq", "fdt_sst", "fdt_szi", "fdt_cv", "fdt_tsgn", "fdt_sq", "fdt_Sld", "fdt_Spect", "fdt_siz", "fdt_lsz", "fdt_sszn", "fdt_sld", "fdt_mz", "fdt_getsv", "fdt_tsld", "fdt_mpect", "fdt_Siz", "fdt_sgn", "fdt_insz", "fdt_sdz", "fdt_aszi", "fdt_Sq", "fdt_rsiz", "fdt_getsz", "fdt_sdzn", "fdt_rsz"], "ram_low_sz": ["ram_low_esiz", "ram_low_insj", "ram_low_rsiz", "ram_low_sZ", "ram_low_Sj", "ram_low_esz", "ram_low_sld", "ram_low_sx", "ram_low_insz", "ram_low_dsZ", "ram_low_siz", "ram_low_Sq", "ram_low_esgn", "ram_low_insiz", "ram_low_SZ", "ram_low_esze", "ram_low_sj", "ram_low_insld", "ram_low_dsq", "ram_low_insx", "ram_low_sq", "ram_low_rsgn", "ram_low_Sx", "ram_low_dsiz", "ram_low_sgn", "ram_low_rsz", "ram_low_Sz", "ram_low_dsz", "ram_low_sze", "ram_low_rsze", "ram_low_Siz", "ram_low_Sld", "ram_low_insZ"], "ram_high_sz": ["ram_high_dsz", "ram_high_Sl", "ram_high_Szi", "ram_high_ll", "ram_high_giz", "ram_high_lZ", "ram_high_siz", "ram_high_sZ", "ram_high_gz", "ram_high_Sz", "ram_high_Siz", "ram_high_liz", "ram_high_dsiz", "ram_high_dsZ", "ram_high_szi", "ram_high_dszi", "ram_high_gci", "ram_high_lz", "ram_high_lzi", "ram_high_sl", "ram_high_csz", "ram_high_sci", "ram_high_csiz", "ram_high_dsci", "ram_high_gzi", "ram_high_csl", "ram_high_cszi"]}}
{"project": "FFmpeg", "commit_id": "5c720657c23afd798ae0db7c7362eb859a89ab3d", "target": 1, "func": "static int mov_read_cmov(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n\n{\n\n#if CONFIG_ZLIB\n\n    AVIOContext ctx;\n\n    uint8_t *cmov_data;\n\n    uint8_t *moov_data; /* uncompressed data */\n\n    long cmov_len, moov_len;\n\n    int ret = -1;\n\n\n\n    avio_rb32(pb); /* dcom atom */\n\n    if (avio_rl32(pb) != MKTAG('d','c','o','m'))\n\n        return AVERROR_INVALIDDATA;\n\n    if (avio_rl32(pb) != MKTAG('z','l','i','b')) {\n\n        av_log(c->fc, AV_LOG_ERROR, \"unknown compression for cmov atom !\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    avio_rb32(pb); /* cmvd atom */\n\n    if (avio_rl32(pb) != MKTAG('c','m','v','d'))\n\n        return AVERROR_INVALIDDATA;\n\n    moov_len = avio_rb32(pb); /* uncompressed size */\n\n    cmov_len = atom.size - 6 * 4;\n\n\n\n    cmov_data = av_malloc(cmov_len);\n\n    if (!cmov_data)\n\n        return AVERROR(ENOMEM);\n\n    moov_data = av_malloc(moov_len);\n\n    if (!moov_data) {\n\n        av_free(cmov_data);\n\n        return AVERROR(ENOMEM);\n\n    }\n\n    avio_read(pb, cmov_data, cmov_len);\n\n    if (uncompress (moov_data, (uLongf *) &moov_len, (const Bytef *)cmov_data, cmov_len) != Z_OK)\n\n        goto free_and_return;\n\n    if (ffio_init_context(&ctx, moov_data, moov_len, 0, NULL, NULL, NULL, NULL) != 0)\n\n        goto free_and_return;\n\n    atom.type = MKTAG('m','o','o','v');\n\n    atom.size = moov_len;\n\n    ret = mov_read_default(c, &ctx, atom);\n\nfree_and_return:\n\n    av_free(moov_data);\n\n    av_free(cmov_data);\n\n    return ret;\n\n#else\n\n    av_log(c->fc, AV_LOG_ERROR, \"this file requires zlib support compiled in\\n\");\n\n    return AVERROR(ENOSYS);\n\n#endif\n\n}\n", "idx": 6112, "substitutes": {"c": ["cf", "ic", "dc", "cas", "ci", "ct", "b", "cp", "pc", "h", "cmp", "bc", "cam", "cont", "con", "cs", "sc", "fc", "p", "cm", "g", "co", "ec", "nc", "lc", "t", "xc", "w", "cc", "icc", "v", "m", "uc", "ac", "vc", "cv", "ca", "f", "mc", "C", "e", "abc", "tc"], "pb": ["stab", "peer", "uf", "sp", "bj", "ab", "wp", "cp", "eb", "pc", "pan", "pro", "sys", "pt", "buf", "ob", "px", "p", "ps", "pa", "bp", "typ", "vp", "cb", "pl", "apy", "erb", "wb", "pm", "ub", "bb", "pkg", "pg", "py", "proc", "sb", "lp", "rb", "bps", "txt", "emb", "bs", "fb", "tmp", "tx", "pool", "tf", "jp", "np", "dp", "PB", "pp", "td", "tk", "tp", "tc", "mp"], "atom": ["atomic", "orm", "b", "app", "um", "node", "ab", "att", "conf", "term", "type", "asm", "pair", "tar", "binary", "mat", "pt", "nt", "kat", "msg", "at", "prop", "p", "base", "cmd", "n", "typ", "tm", "op", "ata", "or", "index", "o", "data", "and", "phys", "orb", "element", "het", "key", "unit", "to", "attribute", "proc", "attr", "opt", "ap", "out", "num", "m", "article", "om", "tab", "xml", "part", "al", "tmp", "item", "adj", "pot", "y", "entry", "np", "obj", "x", "name"], "ctx": ["cf", "loc", "dc", "gc", "cas", "ct", " buf", "ctl", "cp", "conf", "ns", "cmp", "bc", "wx", "sys", "sc", "fc", "px", "p", " cx", "cmd", "nc", "context", "cb", "lc", "hw", "cc", "xc", "pkg", "xs", "kw", " ac", "txt", "tz", "cfg", "ac", " context", "tx", "cv", "tmp", "jp", "np", "cur", "obj", "conv", "tc", "j", "wd", "conn", "abc", " sc"], "cmov_data": ["cmov____bin", "cmnovpyata", "cmove_addr", "cmov7area", "cmova_len", "cmov2type", "cmov_no", "cmvo_mem", "cmvo_data", "cmove_area", "cmov____data", "cmvo____mem", "cmova_data", "cmovpyata", "cmov8addr", "cmov_addr", "cmov_Data", "cmov_bus", "cmov____mem", "cmov_mem", "cmvo____data", "cmvo_dat", "cmov7length", "cmovpyData", "cmov8type", "cmovpydat", "cmova_bus", "cmov_length", "cmove_length", "cmov2addr", "cmova_no", "cmov__dat", "cmov8data", "cmnovpydat", "cmove_len", "cmnovpydata", "cmnov_ata", "cmov_ata", "cmov_bin", "cmov__ata", "cmnov_data", "cmnovpyData", "cmov_dat", "cmov__Data", "cmove_data", "cmov2data", "cmvo____bin", "cmov2len", "cmnov_Data", "cmnov_dat", "cmove_buf", "cmove_type", "cmov_buf", "cmov__data", "cmove_ata", "cmvo_bin", "cmovpydata", "cmov7len", "cmov_area", "cmov____dat", "cmov7data", "cmov8len", "cmov_type", "cmvo____dat"], "moov_data": ["moov_", "moaj_len", "moov_mem", "mooveobj", "movo_data", "moaj_size", "moovobj", "moove_num", "movo_mem", "moaj_mem", "moove_", "moove_bytes", "moove_Data", "moov_length", "moaj_data", "poovobj", "moov_type", "moovalobj", "poovalobj", "monov_", "poov_", "moov_str", "moov_bytes", "moove_data", "pooval_", "monovobj", "moove_len", "moov_size", "moov_Data", "movo_str", "moov_num", "mooval_", "moove_type", "movo_length"], "cmov_len": ["cmov2length", "cmnov_len", "cmovtdata", "cmob_length", "cmov_den", "cmovitylen", "cmovi_len", "cmove_mem", "cmovi_l", "cmove_el", "cmov_mem", "cmovitl", "cmov_win", "cmovi_data", "cmob_den", "cmovitlength", "cmov_syn", "cmove_Len", "cmov2den", "cmov_length", "cmove_length", "cmnovitylon", "cmob_Len", "cmov_l", "cmove_len", "cmnovitywin", "cmovitdata", "cmove_syn", "cmnov_win", "cmove_data", "cmovi_length", "cmov2Len", "cmovitylon", "cmnovitylen", "cmov2len", "cmov_el", "cmovtlen", "cmob_len", "cmov_Len", "cmovitywin", "cmov_lon", "cmnov_lon", "cmovitlen", "cmovtlength", "cmovtl"], "moov_len": ["moova_len", "moova_size", "moovtlen", "moova_gen", "moovtdata", "moov3ler", "moovo__el", "moov__str", "moov_l", "moov3lp", "moovatsize", "moovatdata", "moovtlon", "moaven_rel", "moaven_len", "moaven_ler", "moov_lib", "moove_en", "moov2len", "moovJdata", "moovJsize", "moovo__str", "moov_fin", "moovo_el", "moovi_l", "moov_den", "moov__den", "moov_lon", "moov_lp", "moovtsize", "moovo__len", "moov_str", "moov2den", "moovo__den", "moova_fin", "moov__el", "moovi_lib", "moovi_len", "moov_en", "moov3rel", "moov_ls", "moovo_den", "moov_rel", "moove_data", "moov_def", "moova_ls", "moaven_lp", "moov_el", "moova_data", "moovJlen", "moov3len", "moov_ler", "moovJlon", "moova_lon", "moove_len", "moov_size", "moov_gen", "moov2str", "moovo_len", "moovo_str", "moovatlen", "moove_def", "moovatlon", "moov__len", "moov2el", "moovi_ls"]}}
{"project": "FFmpeg", "commit_id": "170870b77c8c71304f9eae946d49aa5e30a464bc", "target": 1, "func": "static int sdp_parse_rtpmap(AVFormatContext *s,\n\n                            AVCodecContext *codec, RTSPStream *rtsp_st,\n\n                            int payload_type, const char *p)\n\n{\n\n    char buf[256];\n\n    int i;\n\n    AVCodec *c;\n\n    const char *c_name;\n\n\n\n    /* Loop into AVRtpDynamicPayloadTypes[] and AVRtpPayloadTypes[] and\n\n     * see if we can handle this kind of payload.\n\n     * The space should normally not be there but some Real streams or\n\n     * particular servers (\"RealServer Version 6.1.3.970\", see issue 1658)\n\n     * have a trailing space. */\n\n    get_word_sep(buf, sizeof(buf), \"/ \", &p);\n\n    if (payload_type >= RTP_PT_PRIVATE) {\n\n        RTPDynamicProtocolHandler *handler;\n\n        for (handler = RTPFirstDynamicPayloadHandler;\n\n             handler; handler = handler->next) {\n\n            if (!strcasecmp(buf, handler->enc_name) &&\n\n                codec->codec_type == handler->codec_type) {\n\n                codec->codec_id          = handler->codec_id;\n\n                rtsp_st->dynamic_handler = handler;\n\n                if (handler->open)\n\n                    rtsp_st->dynamic_protocol_context = handler->open();\n\n                break;\n\n            }\n\n        }\n\n    } else {\n\n        /* We are in a standard case\n\n         * (from http://www.iana.org/assignments/rtp-parameters). */\n\n        /* search into AVRtpPayloadTypes[] */\n\n        codec->codec_id = ff_rtp_codec_id(buf, codec->codec_type);\n\n    }\n\n\n\n    c = avcodec_find_decoder(codec->codec_id);\n\n    if (c && c->name)\n\n        c_name = c->name;\n\n    else\n\n        c_name = (char *) NULL;\n\n\n\n    if (c_name) {\n\n        get_word_sep(buf, sizeof(buf), \"/\", &p);\n\n        i = atoi(buf);\n\n        switch (codec->codec_type) {\n\n        case CODEC_TYPE_AUDIO:\n\n            av_log(s, AV_LOG_DEBUG, \"audio codec set to: %s\\n\", c_name);\n\n            codec->sample_rate = RTSP_DEFAULT_AUDIO_SAMPLERATE;\n\n            codec->channels = RTSP_DEFAULT_NB_AUDIO_CHANNELS;\n\n            if (i > 0) {\n\n                codec->sample_rate = i;\n\n                get_word_sep(buf, sizeof(buf), \"/\", &p);\n\n                i = atoi(buf);\n\n                if (i > 0)\n\n                    codec->channels = i;\n\n                // TODO: there is a bug here; if it is a mono stream, and\n\n                // less than 22000Hz, faad upconverts to stereo and twice\n\n                // the frequency.  No problem, but the sample rate is being\n\n                // set here by the sdp line. Patch on its way. (rdm)\n\n            }\n\n            av_log(s, AV_LOG_DEBUG, \"audio samplerate set to: %i\\n\",\n\n                   codec->sample_rate);\n\n            av_log(s, AV_LOG_DEBUG, \"audio channels set to: %i\\n\",\n\n                   codec->channels);\n\n            break;\n\n        case CODEC_TYPE_VIDEO:\n\n            av_log(s, AV_LOG_DEBUG, \"video codec set to: %s\\n\", c_name);\n\n            break;\n\n        default:\n\n            break;\n\n        }\n\n        return 0;\n\n    }\n\n\n\n    return -1;\n\n}\n", "idx": 6125, "substitutes": {"s": ["rs", "q", "gs", "sw", "sg", "ns", "ctx", "h", "sys", "set", "sc", "cs", "os", "g", "is", "ds", "t", "es", "simple", "w", "js", "space", "sv", "an", "sm", "v", "sl", "m", "spec", "ss", "sn", "south", "sq", "f", "fs", "conv", "us", "e", "S", "sts", "z", "x", "a"], "codec": ["Codisc", "pedEC", "celleco", "odeco", "cellec", "Codrc", " codeco", " codac", "cmdef", "coduc", " codiac", "oderer", "typerer", "podeca", " coderer", " codef", "odac", "codoc", "podec", " codEC", "typec", "odec", "cmdeca", "predEC", "pedeco", " codet", "cmdect", "cryptEC", " coduc", " codeca", "cryptec", "pedef", "objoc", "codoe", " codener", "objener", "codisc", "predeca", "packeca", "Codoc", "peduc", "typeca", " codisc", "odiac", "cmdec", "predec", "codender", "odica", " codig", "pedect", " codica", "codrc", "Codec", " codfc", "casteco", "predener", "odisc", "objeca", "codeca", "podig", "odfc", "roteco", "odener", " codect", "cdec", "odeca", "codet", "cmdac", "castec", "cdoc", "cdrc", "packig", "cdEC", "castEC", "odoe", "codiac", "odEC", "cryptfc", " codoc", "codEC", "objec", "rotender", "cellender", "odoc", "codect", "codica", "castac", " codender", " codrc", "Codoe", "podet", "cmdiac", "packet", "rotect", "pedec", "typfc", "codac", "cellect", "Coderer", "pedeca", "packec", "codef", "codfc", "codig", "rotec", "cmduc", "codener", "codeco", "coderer", " codoe", "cryptica", "CodEC"], "rtsp_st": ["rtspckcont", "rtsptcon", "rtspckcon", "rtsps_sc", "rtssp_stream", "rtssp_cont", "rtssp_st", "rtsspckcont", "rtsptstream", "rtsptst", "rtsp2sc", "rtsps_stream", "rtsspckstream", "rtsp_start", "rtssp_con", "rtspckstream", "rtsp2stream", "rtsp_con", "rtspe_st", "rtsp_cont", "rtsp_sc", "rtsspckcon", "rtspe_start", "rtsptcont", "rtspe_stream", "rtsp2st", "rtsspckst", "rtsps_st", "rtspckst", "rtsp_stream"], "payload_type": ["payloadPype", "payloads_Type", "payloads_tag", "payloadPtype", "payload_Type", "payloadPname", "payloads_type", "payloads_TYPE", "payload_name", "payload_tag", "payloadPType", "payloads_ype", "payload_TYPE", "payload_ype", "payloads_name"], "p": ["post", "pid", "par", "q", "sp", "b", "wp", "cp", "ping", "pb", "pc", "h", "ctx", "pad", "pt", "prop", "g", "pa", "ps", "bp", "n", "vp", "op", "t", "pi", "r", "pe", "w", "pos", "pkg", "k", "lp", "v", "pard", "m", "a", "part", "pass", "pas", "jp", "np", "f", "pn", "P", "pp", "point", "x", "params", "tp"], "buf": ["bag", "bytes", "uf", "h", "cb", "queue", "fp", "w", "iter", "ait", "txt", "req", " b", " br", "tmp", "pause", "batch", "cur", "bin", " tmp", "buff", "mem", "cam", "pad", "bh", "wb", "str", "rb", "out", "v", "port", "pool", "conv", "text", "xff", "db", " buff", "ctx", "bc", "Buffer", "msg", "seq", "history", "pkg", "Buff", "bs", " buffer", "cv", " cmd", "result", "b", "window", "cp", "pb", "br", "pack", "box", "buffer", "raw", "cmd", "bp", "vp", "data", " buffers", "err", "mu", " arr", "cap", "block", "off", "tx", "img", "doc", "cache"], "i": ["init", "ic", "ini", " bi", "ci", "b", " ii", "it", "im", "ori", "cli", " ni", "oi", "gi", "mi", "qi", "ip", "li", "si", "ami", "zi", "n", "is", "ati", "xi", "index", "o", "hi", "pi", "bi", "multi", "ui", "ki", "mu", " I", "phi", "ti", "v", "ai", "m", "adi", "I", "y", "ish", "capacity", "fi", "io", "iu", "info", "length", "j", "di", "\u0438", "ni", "ii", "l"], "c": ["cf", "cod", "dc", "ci", "ct", "cp", "conf", "u", "cmp", "bc", "cam", "con", "cs", "sc", "fc", "cm", "co", "d", "etc", "ec", "nc", "cb", "lc", "ce", "cc", "rc", "coll", "cn", "cr", "ch", "ac", "uc", "vc", "ca", "cd", "cat", "mc", "f", "can", "C", "enc", "com", "cu", "abc", "tc"], "c_name": ["rc___name", "c_alias", "rc_name", " c_path", "cnamename", "crowkey", "c__alias", "ec_name", "c_value", "code_link", "c___NAME", "copkey", "c_model", " c__names", "ec_Name", "c2Name", "code_name", " c_names", "c_link", "codeopname", "crowmodel", "code_key", "c__name", "c___alias", "c2name", "cnamepath", "crowlink", "cnamenames", "codeoplink", "c__names", "c_type", "rc_alias", "dc_type", "rc___alias", "code_model", "c_key", "c_names", "codeopmodel", "cnamevalue", "dc_name", "ec_NAME", "c_Name", "c__value", " c__value", " c_value", "rc___NAME", "c__path", " c__name", "c_data", "crowname", "c_path", "c2NAME", "codeopkey", "dc_key", "coplink", "copname", "c__NAME", "c_NAME", "dc_data", " c__path", "copmodel", "rc_NAME", "c___name"], "handler": ["policy", "event", "function", "way", "when", "h", "dev", "or", "pointer", "attribute", "wrapper", "layer", "handled", "worker", "reader", "controller", "lambda", "entry", "owner", "loop", "test", "filter", "player", "folder", "instance", "managed", "job", "hook", "er", "iterator", "context", "index", "server", "timeout", "command", "done", "Handler", "info", "check", "menu", "ready", "hand", "error", "how", "interesting", "timer", "connection", "loader", "no", "history", "callback", "finder", "style", "usage", "host", "processor", "writer", "through", "shape", "engine", "definition", "magic", "window", "here", "only", "client", "actor", "profile", "parser", "data", "full", "func", "failed", "older", "hander", "handle", "sh", "man", "inner", "new", "driver", "manager", "obj", "runner", "unknown", "holder", "later"]}}
{"project": "FFmpeg", "commit_id": "dcc39ee10e82833ce24aa57926c00ffeb1948198", "target": 0, "func": "void ff_mpv_frame_end(MpegEncContext *s)\n\n{\n\n#if FF_API_XVMC\n\nFF_DISABLE_DEPRECATION_WARNINGS\n\n    /* redraw edges for the frame if decoding didn't complete */\n\n    // just to make sure that all data is rendered.\n\n    if (CONFIG_MPEG_XVMC_DECODER && s->avctx->xvmc_acceleration) {\n\n        ff_xvmc_field_end(s);\n\n    } else\n\nFF_ENABLE_DEPRECATION_WARNINGS\n\n#endif /* FF_API_XVMC */\n\n\n\n    emms_c();\n\n\n\n    if (s->current_picture.reference)\n\n        ff_thread_report_progress(&s->current_picture_ptr->tf, INT_MAX, 0);\n\n}\n", "idx": 6140, "substitutes": {"s": ["rs", "gs", "ses", "b", "less", "ns", "c", "its", "ats", "ags", "qs", "sys", "cs", "comm", "os", "p", "ps", "ms", "aunts", "n", "is", "ts", "ds", "t", "js", "w", "ins", "sv", "ls", "sb", "v", "ims", "stats", "m", "hs", "a", "ss", "bs", "states", "sq", "sf", "f", "parts", "fs", "ex", "S", "sts", "sports", "aws"], "xvmc_acceleration": ["xvmc_accelator", "xvmc_acccelation", "xvmc_aclevometer", "xvmc_accelerator", "xvmc_accelated", "xvmc_aclegometer", "xvmc_accelation", "xvmc_aclevator", "xvmc_accceleration", "xvmc_acccelometer", "xvmc_accelerated", "xvmc_accelometer", "xvmc_aclevated", "xvmc_accelerometer", "xvmc_aclevation", "xvmc_acccelerator", "xvmc_aclegated", "xvmc_acccelerated", "xvmc_acccelated", "xvmc_aclegator", "xvmc_aclegation", "xvmc_acccelerometer", "xvmc_acccelator"], "FF_ENABLE_DEPRECATION_WARNINGS": ["FF_ENABLE_DEPRECATION_DEBUGs", "FF_ENABLE_DEPRECATION_WARs", "FF_ENABLE_DEPRECATION_WARS", "FF_ENABLE_DEPRECATION_WARNINGs", "FF_ENABLE_DEPRECATION_DEBUGS", "FF_ENABLE_DEPRECATION_WARNs", "FF_ENABLE_DEPRECATION_WARNS"]}}
{"project": "FFmpeg", "commit_id": "b67f3d65757e9b08a797f584ee818ad7cfe7b303", "target": 1, "func": "static int read_ffserver_streams(AVFormatContext *s, const char *filename)\n\n{\n\n    int i, err;\n\n    AVFormatContext *ic;\n\n    int nopts = 0;\n\n\n\n    err = av_open_input_file(&ic, filename, NULL, FFM_PACKET_SIZE, NULL);\n\n    if (err < 0)\n\n        return err;\n\n    /* copy stream format */\n\n    s->nb_streams = ic->nb_streams;\n\n    for(i=0;i<ic->nb_streams;i++) {\n\n        AVStream *st;\n\n        AVCodec *codec;\n\n\n\n        // FIXME: a more elegant solution is needed\n\n        st = av_mallocz(sizeof(AVStream));\n\n        memcpy(st, ic->streams[i], sizeof(AVStream));\n\n        st->codec = avcodec_alloc_context();\n\n        if (!st->codec) {\n\n            print_error(filename, AVERROR(ENOMEM));\n\n            ffmpeg_exit(1);\n\n        }\n\n        avcodec_copy_context(st->codec, ic->streams[i]->codec);\n\n        s->streams[i] = st;\n\n\n\n        codec = avcodec_find_encoder(st->codec->codec_id);\n\n        if (st->codec->codec_type == AVMEDIA_TYPE_AUDIO) {\n\n            if (audio_stream_copy) {\n\n                st->stream_copy = 1;\n\n            } else\n\n                choose_sample_fmt(st, codec);\n\n        } else if (st->codec->codec_type == AVMEDIA_TYPE_VIDEO) {\n\n            if (video_stream_copy) {\n\n                st->stream_copy = 1;\n\n            } else\n\n                choose_pixel_fmt(st, codec);\n\n        }\n\n\n\n        if(!st->codec->thread_count)\n\n            st->codec->thread_count = 1;\n\n        if(st->codec->thread_count>1)\n\n            avcodec_thread_init(st->codec, st->codec->thread_count);\n\n\n\n        if(st->codec->flags & CODEC_FLAG_BITEXACT)\n\n            nopts = 1;\n\n    }\n\n\n\n    if (!nopts)\n\n        s->timestamp = av_gettime();\n\n\n\n    av_close_input_file(ic);\n\n    return 0;\n\n}\n", "idx": 6160, "substitutes": {"s": ["rs", "gs", "sp", "b", "sg", "ns", "c", "its", "ats", "acs", "sys", "set", "cs", "sc", "os", "ps", "als", "ms", "p", "n", "is", "ts", "ds", "es", "t", "r", "js", "w", "ins", "sv", "ls", "sb", "ess", "v", "stats", "m", "spec", "a", "ss", "bs", "fs", "obj", "S", "sts", "x", "aws", "l", "ops"], "filename": ["SOURCE", "jpg", "prefix", "asm", "file", "msg", "til", "ename", "ame", "FN", "SourceFile", "fle", "fp", "kl", "mpeg", "username", "r", "mson", "fil", "nil", "png", "nm", "txt", "v", "FIL", "sbm", "WARNING", "fn", "Filename", "FS", "f", "fs", "println", "AME", "family", "kj", "source", "json", "title", "name", "path"], "i": ["ini", "asi", "ij", " bi", "ci", " ii", "it", "im", "gl", " x", " ni", "gi", "mi", "qi", "ip", "li", "p", "si", "ami", " si", "zi", "n", "ie", "is", "g", "iq", "xi", "ind", "index", " ti", "t", "pi", "multi", "bi", "me", "id", "ui", "go", "list", "ji", "hi", " I", "phi", "ti", "try", "v", "ims", "ix", " j", "ai", "m", "ri", "status", "I", "batch", "y", "sim", "iu", "e", "series", "j", "z", "x", "di", "json", "ii", "l"], "err": ["ev", "result", "error", "ei", "ln", "empty", "it", "Er", "fee", "lr", "kr", "c", "cli", "conf", "asm", "here", "h", "nr", "br", "buf", "aaa", "mr", "msg", "er", "rn", "die", "eg", "norm", "order", "cmd", "timer", "n", "notice", "ec", "or", "cb", "pl", "usr", "ner", "r", "str", "trace", "rc", "rr", "attr", "pr", "ir", "iter", "cr", "txt", "try", "code", "out", "gz", "priv", "cer", "obj", "e", "fr", "Error", "arr", "l", "elt"], "ic": ["ico", "et", "gc", "ci", "ct", "ive", "ican", "it", "irs", "ics", "c", "ctx", "pc", "eric", "bc", "anc", "sc", "ik", "aic", "fc", "ip", "p", "ric", "ica", "wic", "iq", "mic", "ick", "lc", "cc", "sic", "icing", "icc", "nic", "ici", "oc", "ix", "ac", "vc", "pic", "ict", "sci", "isc", "ig", "mc", "ia", "rec", "iac", "irc", "lic", "icon", "IC", "inc", "tc"], "st": ["ck", "must", " St", "sw", "step", "kt", "nd", "state", "sc", "inst", "ts", "t", "se", "stan", "ast", "art", "tmp", "ST", "sta", "ost", "ust", "so", "stage", "store", "nt", "stack", "ut", "str", "start", "stream", "ste", "td", "St", "et", "ct", "it", "end", "pt", "stru", "mt", "std", "usr", "stop", "th", "rest", "sm", "rt", "net", "fr", " est", "tt", "act", "put", "sp", "est", "cl", "cont", "set", "stat", "etc", "irst", "sty", "stri", "sh", "sl", "stable", "ist", "storage", "obj", "sts", "z"], "codec": ["qualEC", "cellerer", "Codisc", "goeca", "godec", "qualeco", "Codect", "condect", "cmpec", " cododer", "Codpeg", "celleco", "codcc", "codeica", "codric", "odeco", "cellec", "codic", "odenc", "predeter", "condric", " codac", " codeco", "challic", "ldect", "ondEC", "predica", "edeco", "codeeca", "predisc", "oderer", "goec", " coderer", "dedec", "odac", "predac", "codoc", " codEC", "odec", "ldeco", "codeenc", "predEC", "communerer", "ordeca", "celleter", "cryptEC", "dependEC", "predric", "cryptica", "callisc", " codeca", "cryptec", "condeca", "ldek", "codew", "ordec", "coddec", "predel", "cellef", "codisc", "cmpdec", "edec", "compec", "predeca", "cellener", "ondec", "communew", "odel", "preddec", "equef", "equec", "predec", "contec", "dependica", "condica", "odect", "odica", " codica", "Codec", "cryptect", "qualpeg", "cmpenc", "codc", "contc", "qualel", "dedeco", "predener", "cellEC", "compenc", "odisc", "odeter", "ondeco", "codeca", "odener", "ododer", "ondoc", " codect", "contoder", "condeco", "cododer", "ldec", "codel", "Codeco", "odpeg", "communica", "dedek", "odeca", "condenc", " codek", "condec", "equerer", "qualec", "proppeg", "challec", "edeca", "condpeg", "condisc", "odEC", "compdec", "qualic", " codoc", "codEC", "codeec", "challpeg", "odoc", "codect", "codpeg", "celleca", "codica", "codedec", "qualric", "odew", "contel", "condic", "propisc", "odc", " codel", "codenc", "orddec", "cmpcc", "dependect", "condEC", "condel", "codecc", "callect", "compcc", "propec", "codeisc", "predect", "challeco", "equect", "dedect", "codeter", "cellisc", "codac", "callec", "edEC", "cellect", " codc", "ordect", "codef", "odef", "dependec", "communec", "codener", "propeco", "codeco", "coderer", "goect", "codek", " codew", "callEC", "CodEC"]}}
{"project": "FFmpeg", "commit_id": "ff763351e74550df3b9a0465634d1ec48b15b043", "target": 1, "func": "static void uninit(AVFilterContext *ctx)\n\n{\n\n    ZScaleContext *s = ctx->priv;\n\n\n\n    zimg_filter_graph_free(s->graph);\n\n\n    av_freep(&s->tmp);\n\n    s->tmp_size = 0;\n\n}", "idx": 6165, "substitutes": {"ctx": ["ck", "dc", "loc", "ij", "ct", "cp", "c", "kt", "pc", "cmp", "bc", "anc", "wx", "sc", "fc", "cm", "cmd", " cx", "unc", "nc", "context", "cb", "hw", "xc", "cc", "crit", "pkg", "kw", "txt", "cfg", "jac", "ac", "tx", "cv", "ca", "jp", "np", "mc", "ctr", "conn", "abc", "tc", "act"], "s": ["as", "rs", "gs", "sp", "q", "b", "sw", "sg", "ns", "c", "h", "ats", "sam", "acs", "aws", "i", "sys", "qs", "set", "cs", "comm", "os", "p", "ps", "n", "is", "ts", "ds", "js", "pkg", "sv", "ls", "sm", "sb", "ess", "scl", "ims", "stats", "sk", "sh", "sl", "sa", "hs", "vs", "st", "ss", "bs", "sq", "fs", "S", "sts", "z", "j", "a"]}}
{"project": "qemu", "commit_id": "47e04430ed3e6ab835f023a5c84381ca2ce9f4d8", "target": 0, "func": "static void decode_bo_addrmode_post_pre_base(CPUTriCoreState *env,\n\n                                             DisasContext *ctx)\n\n{\n\n    uint32_t op2;\n\n    uint32_t off10;\n\n    int32_t r1, r2;\n\n    TCGv temp;\n\n\n\n    r1 = MASK_OP_BO_S1D(ctx->opcode);\n\n    r2  = MASK_OP_BO_S2(ctx->opcode);\n\n    off10 = MASK_OP_BO_OFF10_SEXT(ctx->opcode);\n\n    op2 = MASK_OP_BO_OP2(ctx->opcode);\n\n\n\n    switch (op2) {\n\n    case OPC2_32_BO_CACHEA_WI_SHORTOFF:\n\n    case OPC2_32_BO_CACHEA_W_SHORTOFF:\n\n    case OPC2_32_BO_CACHEA_I_SHORTOFF:\n\n        /* instruction to access the cache */\n\n        break;\n\n    case OPC2_32_BO_CACHEA_WI_POSTINC:\n\n    case OPC2_32_BO_CACHEA_W_POSTINC:\n\n    case OPC2_32_BO_CACHEA_I_POSTINC:\n\n        /* instruction to access the cache, but we still need to handle\n\n           the addressing mode */\n\n        tcg_gen_addi_tl(cpu_gpr_d[r2], cpu_gpr_d[r2], off10);\n\n        break;\n\n    case OPC2_32_BO_CACHEA_WI_PREINC:\n\n    case OPC2_32_BO_CACHEA_W_PREINC:\n\n    case OPC2_32_BO_CACHEA_I_PREINC:\n\n        /* instruction to access the cache, but we still need to handle\n\n           the addressing mode */\n\n        tcg_gen_addi_tl(cpu_gpr_d[r2], cpu_gpr_d[r2], off10);\n\n        break;\n\n    case OPC2_32_BO_CACHEI_WI_SHORTOFF:\n\n    case OPC2_32_BO_CACHEI_W_SHORTOFF:\n\n        /* TODO: Raise illegal opcode trap,\n\n                 if tricore_feature(TRICORE_FEATURE_13) */\n\n        break;\n\n    case OPC2_32_BO_CACHEI_W_POSTINC:\n\n    case OPC2_32_BO_CACHEI_WI_POSTINC:\n\n        if (!tricore_feature(env, TRICORE_FEATURE_13)) {\n\n            tcg_gen_addi_tl(cpu_gpr_d[r2], cpu_gpr_d[r2], off10);\n\n        } /* TODO: else raise illegal opcode trap */\n\n        break;\n\n    case OPC2_32_BO_CACHEI_W_PREINC:\n\n    case OPC2_32_BO_CACHEI_WI_PREINC:\n\n        if (!tricore_feature(env, TRICORE_FEATURE_13)) {\n\n            tcg_gen_addi_tl(cpu_gpr_d[r2], cpu_gpr_d[r2], off10);\n\n        } /* TODO: else raise illegal opcode trap */\n\n        break;\n\n    case OPC2_32_BO_ST_A_SHORTOFF:\n\n        gen_offset_st(ctx, cpu_gpr_a[r1], cpu_gpr_a[r2], off10, MO_LESL);\n\n        break;\n\n    case OPC2_32_BO_ST_A_POSTINC:\n\n        tcg_gen_qemu_st_tl(cpu_gpr_a[r1], cpu_gpr_a[r2], ctx->mem_idx,\n\n                           MO_LESL);\n\n        tcg_gen_addi_tl(cpu_gpr_a[r2], cpu_gpr_a[r2], off10);\n\n        break;\n\n    case OPC2_32_BO_ST_A_PREINC:\n\n        gen_st_preincr(ctx, cpu_gpr_a[r1], cpu_gpr_a[r2], off10, MO_LESL);\n\n        break;\n\n    case OPC2_32_BO_ST_B_SHORTOFF:\n\n        gen_offset_st(ctx, cpu_gpr_d[r1], cpu_gpr_a[r2], off10, MO_UB);\n\n        break;\n\n    case OPC2_32_BO_ST_B_POSTINC:\n\n        tcg_gen_qemu_st_tl(cpu_gpr_d[r1], cpu_gpr_a[r2], ctx->mem_idx,\n\n                           MO_UB);\n\n        tcg_gen_addi_tl(cpu_gpr_a[r2], cpu_gpr_a[r2], off10);\n\n        break;\n\n    case OPC2_32_BO_ST_B_PREINC:\n\n        gen_st_preincr(ctx, cpu_gpr_d[r1], cpu_gpr_a[r2], off10, MO_UB);\n\n        break;\n\n    case OPC2_32_BO_ST_D_SHORTOFF:\n\n        gen_offset_st_2regs(cpu_gpr_d[r1+1], cpu_gpr_d[r1], cpu_gpr_a[r2],\n\n                            off10, ctx);\n\n        break;\n\n    case OPC2_32_BO_ST_D_POSTINC:\n\n        gen_st_2regs_64(cpu_gpr_d[r1+1], cpu_gpr_d[r1], cpu_gpr_a[r2], ctx);\n\n        tcg_gen_addi_tl(cpu_gpr_a[r2], cpu_gpr_a[r2], off10);\n\n        break;\n\n    case OPC2_32_BO_ST_D_PREINC:\n\n        temp = tcg_temp_new();\n\n        tcg_gen_addi_tl(temp, cpu_gpr_a[r2], off10);\n\n        gen_st_2regs_64(cpu_gpr_d[r1+1], cpu_gpr_d[r1], temp, ctx);\n\n        tcg_gen_mov_tl(cpu_gpr_a[r2], temp);\n\n        tcg_temp_free(temp);\n\n        break;\n\n    case OPC2_32_BO_ST_DA_SHORTOFF:\n\n        gen_offset_st_2regs(cpu_gpr_a[r1+1], cpu_gpr_a[r1], cpu_gpr_a[r2],\n\n                            off10, ctx);\n\n        break;\n\n    case OPC2_32_BO_ST_DA_POSTINC:\n\n        gen_st_2regs_64(cpu_gpr_a[r1+1], cpu_gpr_a[r1], cpu_gpr_a[r2], ctx);\n\n        tcg_gen_addi_tl(cpu_gpr_a[r2], cpu_gpr_a[r2], off10);\n\n        break;\n\n    case OPC2_32_BO_ST_DA_PREINC:\n\n        temp = tcg_temp_new();\n\n        tcg_gen_addi_tl(temp, cpu_gpr_a[r2], off10);\n\n        gen_st_2regs_64(cpu_gpr_a[r1+1], cpu_gpr_a[r1], temp, ctx);\n\n        tcg_gen_mov_tl(cpu_gpr_a[r2], temp);\n\n        tcg_temp_free(temp);\n\n        break;\n\n    case OPC2_32_BO_ST_H_SHORTOFF:\n\n        gen_offset_st(ctx, cpu_gpr_d[r1], cpu_gpr_a[r2], off10, MO_LEUW);\n\n        break;\n\n    case OPC2_32_BO_ST_H_POSTINC:\n\n        tcg_gen_qemu_st_tl(cpu_gpr_d[r1], cpu_gpr_a[r2], ctx->mem_idx,\n\n                           MO_LEUW);\n\n        tcg_gen_addi_tl(cpu_gpr_a[r2], cpu_gpr_a[r2], off10);\n\n        break;\n\n    case OPC2_32_BO_ST_H_PREINC:\n\n        gen_st_preincr(ctx, cpu_gpr_d[r1], cpu_gpr_a[r2], off10, MO_LEUW);\n\n        break;\n\n    case OPC2_32_BO_ST_Q_SHORTOFF:\n\n        temp = tcg_temp_new();\n\n        tcg_gen_shri_tl(temp, cpu_gpr_d[r1], 16);\n\n        gen_offset_st(ctx, temp, cpu_gpr_a[r2], off10, MO_LEUW);\n\n        tcg_temp_free(temp);\n\n        break;\n\n    case OPC2_32_BO_ST_Q_POSTINC:\n\n        temp = tcg_temp_new();\n\n        tcg_gen_shri_tl(temp, cpu_gpr_d[r1], 16);\n\n        tcg_gen_qemu_st_tl(temp, cpu_gpr_a[r2], ctx->mem_idx,\n\n                           MO_LEUW);\n\n        tcg_gen_addi_tl(cpu_gpr_a[r2], cpu_gpr_a[r2], off10);\n\n        tcg_temp_free(temp);\n\n        break;\n\n    case OPC2_32_BO_ST_Q_PREINC:\n\n        temp = tcg_temp_new();\n\n        tcg_gen_shri_tl(temp, cpu_gpr_d[r1], 16);\n\n        gen_st_preincr(ctx, temp, cpu_gpr_a[r2], off10, MO_LEUW);\n\n        tcg_temp_free(temp);\n\n        break;\n\n    case OPC2_32_BO_ST_W_SHORTOFF:\n\n        gen_offset_st(ctx, cpu_gpr_d[r1], cpu_gpr_a[r2], off10, MO_LEUL);\n\n        break;\n\n    case OPC2_32_BO_ST_W_POSTINC:\n\n        tcg_gen_qemu_st_tl(cpu_gpr_d[r1], cpu_gpr_a[r2], ctx->mem_idx,\n\n                           MO_LEUL);\n\n        tcg_gen_addi_tl(cpu_gpr_a[r2], cpu_gpr_a[r2], off10);\n\n        break;\n\n    case OPC2_32_BO_ST_W_PREINC:\n\n        gen_st_preincr(ctx, cpu_gpr_d[r1], cpu_gpr_a[r2], off10, MO_LEUL);\n\n        break;\n\n    }\n\n}\n", "idx": 6186, "substitutes": {"env": ["ev", "et", "esc", "setup", "installed", "window", "conf", "site", "gov", "conn", "buf", "set", "te", "map", "er", "erd", "dev", "ew", "ec", "viron", "eng", "cb", "environment", "context", "hw", "server", "pkg", "esp", "kw", "code", "en", "nv", "req", "cfg", "config", "tx", "cv", "jp", "e", "param"], "ctx": ["ck", "loc", "sp", "grad", "setup", "ct", "ctl", "prefix", "cp", "conf", "asm", "kt", "def", "cmp", "bc", "mom", "wx", "kind", "sc", "ann", "mk", " cx", "cmd", "tm", "nc", "context", "cb", "ind", "std", "hw", "xc", "cc", "crit", "pkg", "xs", "kw", "req", "cfg", "jac", "resp", "tx", "cv", "exec", "desc", "jp", "np", "mc", "conv", "shape", "xp", "tk", "work", "conn", "tc", "act"], "op2": ["rtwo", "typetwo", "oplet", " op0", " op3", " optwo", "OP0", "oper0", "op02", "OPtwo", "ip1", "OP4", "ip2", "operlet", "typelet", "oper02", "op0", "type4", "ip3", "optwo", "oper3", "oper2", "r3", "op3", "OPlet", " op1", "OP02", "type2", "OP2", "op1", "oper4", "OP3", "opertwo", "op4", " op02", "iptwo"], "off10": ["off0010", "ff20", "off12", " off12", "offset2010", " off0010", "off90", "offset20", "ff10", "offer10", "offTen", "Off10", "shift12", "OFF090", "offer12", "ff2010", "offer2010", "OFF12", "offset12", "ref10", "refTen", "offer50", "shift10", "Off090", "ffDir", "offer090", "OffTen", "OFFTen", "off20", "off090", "off50", "ref90", "off2010", "offer90", "offerTen", "offerDir", "offset0010", "offsetDir", "offer20", "Off50", "Off90", "OFF10", "shift0010", "offDir", "Off12", "offset10", "ref50"], "r1": [" r0", "dr8", "dr0", "t0", "r0", " r3", "dr1", " r4", "t1", "p4", "p2", " r8", "p1", "r3", "dr4", "t3", "p3", "r4", "p0", "t2", "r8", "p8"], "r2": ["r62", " r0", "rtwo", "nr8", " r7", " r8", "srtwo", "p02", "pr62", "pb", "nr02", "pr0", " rTwo", "R1", "errtwo", "ptwo", "rlet", "sr7", "sr02", " r5", "nrtwo", "dr02", "ertwo", "ortwo", "r0", "dr1", "nr2", "er7", "Rtwo", "p62", "orTwo", "ar2", "ar5", "sr2", "drlet", "err02", "or2", "artwo", "er02", "r02", "rb", " rtwo", "p2", " rb", "Rb", "p1", "pr2", " r62", "nr1", "r5", "dr2", "plet", "rTwo", "err2", "r7", "R2", "nrlet", "pr02", "or5", "p0", " r02", "er2", "arTwo", "err8", "r8"], "temp": [" tw", " tmp", " Temp", " cur", " buf", "Temp", " tv", " mem", " prev", " scratch", " unused", "tg", " tsp", " program", "mint", " wr", "tv", " bc", " dc", " ts", " temperature", " instr", " template", " gp", " tf", "tmp", "tx", "vt"]}}
{"project": "qemu", "commit_id": "bee62662a312b99b4418b558a99b3963a4cbff07", "target": 0, "func": "static int kvm_mips_get_fpu_registers(CPUState *cs)\n\n{\n\n    MIPSCPU *cpu = MIPS_CPU(cs);\n\n    CPUMIPSState *env = &cpu->env;\n\n    int err, ret = 0;\n\n    unsigned int i;\n\n\n\n    /* Only get FPU state if we're emulating a CPU with an FPU */\n\n    if (env->CP0_Config1 & (1 << CP0C1_FP)) {\n\n        /* FPU Control Registers */\n\n        err = kvm_mips_get_one_ureg(cs, KVM_REG_MIPS_FCR_IR,\n\n                                    &env->active_fpu.fcr0);\n\n        if (err < 0) {\n\n            DPRINTF(\"%s: Failed to get FCR_IR (%d)\\n\", __func__, err);\n\n            ret = err;\n\n        }\n\n        err = kvm_mips_get_one_ureg(cs, KVM_REG_MIPS_FCR_CSR,\n\n                                    &env->active_fpu.fcr31);\n\n        if (err < 0) {\n\n            DPRINTF(\"%s: Failed to get FCR_CSR (%d)\\n\", __func__, err);\n\n            ret = err;\n\n        } else {\n\n            restore_fp_status(env);\n\n        }\n\n\n\n        /* Floating point registers */\n\n        for (i = 0; i < 32; ++i) {\n\n            if (env->CP0_Status & (1 << CP0St_FR)) {\n\n                err = kvm_mips_get_one_ureg64(cs, KVM_REG_MIPS_FPR_64(i),\n\n                                              &env->active_fpu.fpr[i].d);\n\n            } else {\n\n                err = kvm_mips_get_one_ureg(cs, KVM_REG_MIPS_FPR_32(i),\n\n                                      &env->active_fpu.fpr[i].w[FP_ENDIAN_IDX]);\n\n            }\n\n            if (err < 0) {\n\n                DPRINTF(\"%s: Failed to get FPR%u (%d)\\n\", __func__, i, err);\n\n                ret = err;\n\n            }\n\n        }\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 6189, "substitutes": {"cs": ["ck", "rs", "csv", "gs", "cas", "CS", "gc", "cz", "cp", "ns", "ics", "c", "wcs", "ctx", "acs", "ats", "cks", "qs", "sc", "ces", "Cs", "acts", "caps", "ps", "cm", "ec", "ts", "yes", "ds", "css", "cus", "ce", "cc", "js", "ins", "proc", "ls", "s", "ras", "jac", "cell", "vs", "hs", "ss", "bs", "cv", "fs", "ys", "ks", "sts", "icks"], "cpu": ["ck", "CPU", "cf", "gc", "setup", "node", "mem", "cp", "ola", "c", "pu", "ctx", "tp", "cmp", "cam", "ka", "sc", "client", "cow", "arch", "stat", "ec", "name", "aux", "process", "hw", "cc", "proc", "device", "cn", "ork", "config", "processor", "serv", "cv", "cache", "core", "obj", "runner", "vm", "boot", "net", "gpu", "conn"], "env": ["ei", "esc", "skin", "sw", "den", "sc", "eg", "ec", "dev", "enter", "environment", "queue", "gear", "en", "ah", "bean", "worker", "estate", "entry", "enc", "esm", "next", "stage", "cam", "ve", "er", "context", "eh", "stack", "server", "el", "esp", "start", "v", "config", "vs", "der", "serv", "desc", "email", "shell", "db", "ev", "export", "et", "console", "end", "ctx", "eni", "era", "exc", "extra", "loader", "nc", "viron", "enable", "hw", " environment", "sv", "eur", "org", "nv", "cfg", "cv", "session", "vm", "engine", "net", "eve", "door", "window", "cp", "here", "te", "ext", "esi", "cmd", "ie", "vp", "ew", "eng", "ner", "Environment", "proc", "ef", "eu", "ea", "spec", "equ", "doc", "ee", "manager", "obj", "runner", "e", "conn"], "err": ["conf", "kr", "rel", "aaa", "arm", "die", "virt", "order", "hz", "cb", "trace", "iter", "cr", "txt", "req", "test", "Error", "coord", "elt", "ell", "lr", "nr", "rn", "er", "norm", "notice", "ach", "str", "rb", "der", "priv", "cer", "oe", "yr", "rer", "db", "ev", "eor", "error", "it", "ry", "cor", "mr", "msg", "exc", "usr", "r", "dr", "rc", "rr", "attr", "try", "rar", "cfg", "diff", "fr", "ll", "res", "hr", "result", "repl", "Er", "fee", "term", "br", "here", "eas", "sys", "raw", "cmd", "ie", "ner", "fer", "inner", "resp", "off", "gz", "ptr", "obj", "e", "arr", "warn", "conn"], "i": ["ic", "ini", "asi", "q", "ei", "ij", "ci", "b", " ii", "it", "c", "u", "cli", "oi", "gi", "mi", "ip", "li", "g", "si", "p", "ie", "zi", "ami", "n", "is", "iq", "ind", "xi", "index", "o", "t", "hi", "bi", "pi", "r", "multi", "dr", "id", "ui", "me", "ji", "slice", "phi", "ti", "v", "ix", " j", "ai", "m", "status", "ri", "I", "batch", "y", "fi", "sim", "iu", "in", "j", "x", "di", "ii", "l"]}}
{"project": "qemu", "commit_id": "42a268c241183877192c376d03bd9b6d527407c7", "target": 0, "func": "static void gen_loongson_integer(DisasContext *ctx, uint32_t opc,\n\n                                 int rd, int rs, int rt)\n\n{\n\n    const char *opn = \"loongson\";\n\n    TCGv t0, t1;\n\n\n\n    if (rd == 0) {\n\n        /* Treat as NOP. */\n\n        MIPS_DEBUG(\"NOP\");\n\n        return;\n\n    }\n\n\n\n    switch (opc) {\n\n    case OPC_MULT_G_2E:\n\n    case OPC_MULT_G_2F:\n\n    case OPC_MULTU_G_2E:\n\n    case OPC_MULTU_G_2F:\n\n#if defined(TARGET_MIPS64)\n\n    case OPC_DMULT_G_2E:\n\n    case OPC_DMULT_G_2F:\n\n    case OPC_DMULTU_G_2E:\n\n    case OPC_DMULTU_G_2F:\n\n#endif\n\n        t0 = tcg_temp_new();\n\n        t1 = tcg_temp_new();\n\n        break;\n\n    default:\n\n        t0 = tcg_temp_local_new();\n\n        t1 = tcg_temp_local_new();\n\n        break;\n\n    }\n\n\n\n    gen_load_gpr(t0, rs);\n\n    gen_load_gpr(t1, rt);\n\n\n\n    switch (opc) {\n\n    case OPC_MULT_G_2E:\n\n    case OPC_MULT_G_2F:\n\n        tcg_gen_mul_tl(cpu_gpr[rd], t0, t1);\n\n        tcg_gen_ext32s_tl(cpu_gpr[rd], cpu_gpr[rd]);\n\n        opn = \"mult.g\";\n\n        break;\n\n    case OPC_MULTU_G_2E:\n\n    case OPC_MULTU_G_2F:\n\n        tcg_gen_ext32u_tl(t0, t0);\n\n        tcg_gen_ext32u_tl(t1, t1);\n\n        tcg_gen_mul_tl(cpu_gpr[rd], t0, t1);\n\n        tcg_gen_ext32s_tl(cpu_gpr[rd], cpu_gpr[rd]);\n\n        opn = \"multu.g\";\n\n        break;\n\n    case OPC_DIV_G_2E:\n\n    case OPC_DIV_G_2F:\n\n        {\n\n            int l1 = gen_new_label();\n\n            int l2 = gen_new_label();\n\n            int l3 = gen_new_label();\n\n            tcg_gen_ext32s_tl(t0, t0);\n\n            tcg_gen_ext32s_tl(t1, t1);\n\n            tcg_gen_brcondi_tl(TCG_COND_NE, t1, 0, l1);\n\n            tcg_gen_movi_tl(cpu_gpr[rd], 0);\n\n            tcg_gen_br(l3);\n\n            gen_set_label(l1);\n\n            tcg_gen_brcondi_tl(TCG_COND_NE, t0, INT_MIN, l2);\n\n            tcg_gen_brcondi_tl(TCG_COND_NE, t1, -1, l2);\n\n            tcg_gen_mov_tl(cpu_gpr[rd], t0);\n\n            tcg_gen_br(l3);\n\n            gen_set_label(l2);\n\n            tcg_gen_div_tl(cpu_gpr[rd], t0, t1);\n\n            tcg_gen_ext32s_tl(cpu_gpr[rd], cpu_gpr[rd]);\n\n            gen_set_label(l3);\n\n        }\n\n        opn = \"div.g\";\n\n        break;\n\n    case OPC_DIVU_G_2E:\n\n    case OPC_DIVU_G_2F:\n\n        {\n\n            int l1 = gen_new_label();\n\n            int l2 = gen_new_label();\n\n            tcg_gen_ext32u_tl(t0, t0);\n\n            tcg_gen_ext32u_tl(t1, t1);\n\n            tcg_gen_brcondi_tl(TCG_COND_NE, t1, 0, l1);\n\n            tcg_gen_movi_tl(cpu_gpr[rd], 0);\n\n            tcg_gen_br(l2);\n\n            gen_set_label(l1);\n\n            tcg_gen_divu_tl(cpu_gpr[rd], t0, t1);\n\n            tcg_gen_ext32s_tl(cpu_gpr[rd], cpu_gpr[rd]);\n\n            gen_set_label(l2);\n\n        }\n\n        opn = \"divu.g\";\n\n        break;\n\n    case OPC_MOD_G_2E:\n\n    case OPC_MOD_G_2F:\n\n        {\n\n            int l1 = gen_new_label();\n\n            int l2 = gen_new_label();\n\n            int l3 = gen_new_label();\n\n            tcg_gen_ext32u_tl(t0, t0);\n\n            tcg_gen_ext32u_tl(t1, t1);\n\n            tcg_gen_brcondi_tl(TCG_COND_EQ, t1, 0, l1);\n\n            tcg_gen_brcondi_tl(TCG_COND_NE, t0, INT_MIN, l2);\n\n            tcg_gen_brcondi_tl(TCG_COND_NE, t1, -1, l2);\n\n            gen_set_label(l1);\n\n            tcg_gen_movi_tl(cpu_gpr[rd], 0);\n\n            tcg_gen_br(l3);\n\n            gen_set_label(l2);\n\n            tcg_gen_rem_tl(cpu_gpr[rd], t0, t1);\n\n            tcg_gen_ext32s_tl(cpu_gpr[rd], cpu_gpr[rd]);\n\n            gen_set_label(l3);\n\n        }\n\n        opn = \"mod.g\";\n\n        break;\n\n    case OPC_MODU_G_2E:\n\n    case OPC_MODU_G_2F:\n\n        {\n\n            int l1 = gen_new_label();\n\n            int l2 = gen_new_label();\n\n            tcg_gen_ext32u_tl(t0, t0);\n\n            tcg_gen_ext32u_tl(t1, t1);\n\n            tcg_gen_brcondi_tl(TCG_COND_NE, t1, 0, l1);\n\n            tcg_gen_movi_tl(cpu_gpr[rd], 0);\n\n            tcg_gen_br(l2);\n\n            gen_set_label(l1);\n\n            tcg_gen_remu_tl(cpu_gpr[rd], t0, t1);\n\n            tcg_gen_ext32s_tl(cpu_gpr[rd], cpu_gpr[rd]);\n\n            gen_set_label(l2);\n\n        }\n\n        opn = \"modu.g\";\n\n        break;\n\n#if defined(TARGET_MIPS64)\n\n    case OPC_DMULT_G_2E:\n\n    case OPC_DMULT_G_2F:\n\n        tcg_gen_mul_tl(cpu_gpr[rd], t0, t1);\n\n        opn = \"dmult.g\";\n\n        break;\n\n    case OPC_DMULTU_G_2E:\n\n    case OPC_DMULTU_G_2F:\n\n        tcg_gen_mul_tl(cpu_gpr[rd], t0, t1);\n\n        opn = \"dmultu.g\";\n\n        break;\n\n    case OPC_DDIV_G_2E:\n\n    case OPC_DDIV_G_2F:\n\n        {\n\n            int l1 = gen_new_label();\n\n            int l2 = gen_new_label();\n\n            int l3 = gen_new_label();\n\n            tcg_gen_brcondi_tl(TCG_COND_NE, t1, 0, l1);\n\n            tcg_gen_movi_tl(cpu_gpr[rd], 0);\n\n            tcg_gen_br(l3);\n\n            gen_set_label(l1);\n\n            tcg_gen_brcondi_tl(TCG_COND_NE, t0, -1LL << 63, l2);\n\n            tcg_gen_brcondi_tl(TCG_COND_NE, t1, -1LL, l2);\n\n            tcg_gen_mov_tl(cpu_gpr[rd], t0);\n\n            tcg_gen_br(l3);\n\n            gen_set_label(l2);\n\n            tcg_gen_div_tl(cpu_gpr[rd], t0, t1);\n\n            gen_set_label(l3);\n\n        }\n\n        opn = \"ddiv.g\";\n\n        break;\n\n    case OPC_DDIVU_G_2E:\n\n    case OPC_DDIVU_G_2F:\n\n        {\n\n            int l1 = gen_new_label();\n\n            int l2 = gen_new_label();\n\n            tcg_gen_brcondi_tl(TCG_COND_NE, t1, 0, l1);\n\n            tcg_gen_movi_tl(cpu_gpr[rd], 0);\n\n            tcg_gen_br(l2);\n\n            gen_set_label(l1);\n\n            tcg_gen_divu_tl(cpu_gpr[rd], t0, t1);\n\n            gen_set_label(l2);\n\n        }\n\n        opn = \"ddivu.g\";\n\n        break;\n\n    case OPC_DMOD_G_2E:\n\n    case OPC_DMOD_G_2F:\n\n        {\n\n            int l1 = gen_new_label();\n\n            int l2 = gen_new_label();\n\n            int l3 = gen_new_label();\n\n            tcg_gen_brcondi_tl(TCG_COND_EQ, t1, 0, l1);\n\n            tcg_gen_brcondi_tl(TCG_COND_NE, t0, -1LL << 63, l2);\n\n            tcg_gen_brcondi_tl(TCG_COND_NE, t1, -1LL, l2);\n\n            gen_set_label(l1);\n\n            tcg_gen_movi_tl(cpu_gpr[rd], 0);\n\n            tcg_gen_br(l3);\n\n            gen_set_label(l2);\n\n            tcg_gen_rem_tl(cpu_gpr[rd], t0, t1);\n\n            gen_set_label(l3);\n\n        }\n\n        opn = \"dmod.g\";\n\n        break;\n\n    case OPC_DMODU_G_2E:\n\n    case OPC_DMODU_G_2F:\n\n        {\n\n            int l1 = gen_new_label();\n\n            int l2 = gen_new_label();\n\n            tcg_gen_brcondi_tl(TCG_COND_NE, t1, 0, l1);\n\n            tcg_gen_movi_tl(cpu_gpr[rd], 0);\n\n            tcg_gen_br(l2);\n\n            gen_set_label(l1);\n\n            tcg_gen_remu_tl(cpu_gpr[rd], t0, t1);\n\n            gen_set_label(l2);\n\n        }\n\n        opn = \"dmodu.g\";\n\n        break;\n\n#endif\n\n    }\n\n\n\n    (void)opn; /* avoid a compiler warning */\n\n    MIPS_DEBUG(\"%s %s, %s\", opn, regnames[rd], regnames[rs]);\n\n    tcg_temp_free(t0);\n\n    tcg_temp_free(t1);\n\n}\n", "idx": 6193, "substitutes": {"ctx": ["setup", "ct", "cp", "conf", "cmp", "bc", " cx", "cmd", "cm", "nc", "context", "cb", "hw", "cc", "xc", "pkg", "kw", "txt", " context", "tx", "tmp", "KC", "mc", "obj", "Context", "CC", "work", "conn", "tc"], "opc": ["oppcn", "iopc", "iopn", "iopf", "OPf", "copcn", "iopcs", "opcs", "copc", " opcin", "oppx", "iopcin", "oopcin", "OPn", "opf", "oppf", "OPx", "OPpc", "oopcs", "copn", "oopc", "oopn", "opcn", "opppc", "coppc", "OPc", "iopx", "oppn", "oppc", "opcin", "opx", " opcs", "OPcn"], "rd": ["ck", "RD", "rod", "dat", "lr", "sr", "md", "ra", "nd", "rx", "lf", "mr", "rn", "mid", "d", "add", "round", "bd", "sd", "wr", "ds", "ind", "std", "usr", "red", "ri", "rw", "r", "rss", "err", "dr", "rc", "th", "each", "rr", "rf", "rh", "ird", "rb", "ren", "cr", "req", "dd", "rl", "fin", "rid", "rown", "dq", "R", "rg", "nder", "ru", "ord", "dra", "decl", "ld", "di", "rer", "hr", "rm", "da"], "rs": ["rates", "ris", "ars", "ns", "ubs", "sr", "ries", "ats", "pc", "pps", "ra", "cs", "ros", "mr", "ps", "arts", "ms", "ts", "rows", "ds", "ri", "rss", "js", "rc", "ins", "ls", "orts", "rr", "xs", "s", "ras", "ims", "rys", "vs", "bs", "fs", "ks", "Rs", "sts", "rings", "ro", "RS"], "rt": ["vr", "pt", "rx", "nt", "mr", "rn", "tt", "dt", "mt", "tm", "RT", "wr", "bt", "wt", "ri", "rw", "r", "rc", "rr", "rf", "pr", "rh", "rb", "cr", "rl", "rid", "tx", "rat", "vt", "ft", "fr", "adr", "hr", "rm"], "opn": ["OPnp", "Opns", "opnp", "OPr", "hopc", "optn", "opne", "hopnp", "optc", "opN", "oppN", "opr", " opr", "OPn", " opns", " opN", "optN", "Opcn", "opns", " opcn", "OPns", " opnp", "oppne", "opcn", "Opn", "OPc", "hopn", " opne", "hopr", "oppn", "oppc", "Opc", "optne", "OPcn"], "t0": [" t00", "T1", "pt2", "t000", "ta2", " t000", "TZero", "t8", "lat1", "ptau", "it0", "q000", "tt0", "ttZero", "t10", "latos", " T10", " T8", " t10", " t2", "T8", "ttos", "taZero", "pt0", " T1", "ent4", " tZero", "tt00", "tt1", "ptZero", "entzero", "p1", "tt050", "tzero", "it1", "ent0", " tzero", "it000", "lat0", "tos", "tt000", "tt8", "tZero", "l1", "t050", "p000", "taau", " T0", "t00", "lat050", " t4", "T0", "p0", "T00", "Tzero", "tt10", "ent1", "l0", "T000", "Tos", "l8", "T4", "ta0", " t8", "q1", " tau", "tau", "t2", "q8", "t4", "T050", "q0"], "t1": [" t001", "T1", " t7", "t001", "td0", "t8", "dt001", "wt1", "time1", "tt0", "tOne", "l7", "time0", "wt15", " t2", "pt1", "m1", "t01", "pt0", "pt001", "tone", "tt1", " tp", "dt1", "nt0", " tONE", " tOne", "pt9", "p1", "t15", "at9", "token1", "tt7", "time15", "tree0", "m2", "token01", "tokenp", "m8", " t9", "ptOne", "lOne", "ttOne", "T9", "l1", "p01", "Tone", "T0", "at1", "l0", "treeONE", "dt8", "p8", "at0", "token15", "ntONE", "wt01", "td1", "dtOne", "t7", "tONE", "tree9", "TONE", "T15", "t9", "pt8", "m01", " t15", " t01", "p2", "atone", "tree1", " t8", "wtp", "ptone", "t2", "tt15", "nt1", "tp", "tdONE"]}}
{"project": "qemu", "commit_id": "7d489dcdf5fd71b5052ffd401b869a627e1c751f", "target": 0, "func": "static void vfio_pci_load_rom(VFIOPCIDevice *vdev)\n\n{\n\n    struct vfio_region_info reg_info = {\n\n        .argsz = sizeof(reg_info),\n\n        .index = VFIO_PCI_ROM_REGION_INDEX\n\n    };\n\n    uint64_t size;\n\n    off_t off = 0;\n\n    size_t bytes;\n\n\n\n    if (ioctl(vdev->vbasedev.fd, VFIO_DEVICE_GET_REGION_INFO, &reg_info)) {\n\n        error_report(\"vfio: Error getting ROM info: %m\");\n\n        return;\n\n    }\n\n\n\n    trace_vfio_pci_load_rom(vdev->vbasedev.name, (unsigned long)reg_info.size,\n\n                            (unsigned long)reg_info.offset,\n\n                            (unsigned long)reg_info.flags);\n\n\n\n    vdev->rom_size = size = reg_info.size;\n\n    vdev->rom_offset = reg_info.offset;\n\n\n\n    if (!vdev->rom_size) {\n\n        vdev->rom_read_failed = true;\n\n        error_report(\"vfio-pci: Cannot read device rom at \"\n\n                    \"%s\", vdev->vbasedev.name);\n\n        error_printf(\"Device option ROM contents are probably invalid \"\n\n                    \"(check dmesg).\\nSkip option ROM probe with rombar=0, \"\n\n                    \"or load from file with romfile=\\n\");\n\n        return;\n\n    }\n\n\n\n    vdev->rom = g_malloc(size);\n\n    memset(vdev->rom, 0xff, size);\n\n\n\n    while (size) {\n\n        bytes = pread(vdev->vbasedev.fd, vdev->rom + off,\n\n                      size, vdev->rom_offset + off);\n\n        if (bytes == 0) {\n\n            break;\n\n        } else if (bytes > 0) {\n\n            off += bytes;\n\n            size -= bytes;\n\n        } else {\n\n            if (errno == EINTR || errno == EAGAIN) {\n\n                continue;\n\n            }\n\n            error_report(\"vfio: Error reading device ROM: %m\");\n\n            break;\n\n        }\n\n    }\n\n}\n", "idx": 6196, "substitutes": {"vdev": ["avev", "cvdes", "vval", "mdev", " vprop", "valgo", "evdev", " vgu", "vcdevice", "vcdev", "avplayer", "Vver", "avbuild", "vcver", " vstat", "vgu", "formstat", " vnt", " vdb", " vdef", "vdiv", "vgo", "svserver", "cvval", "uvcomment", " vdiv", "evdef", " vvar", "valdevice", "vcomment", "vbuild", "evgo", "tserv", "Vdevice", "formserver", "cvdef", "mcomment", "vdata", "cvdiv", "uvdev", "vrtest", "uvdef", "vrstat", "vserver", " vdata", "cvver", "valswitch", "vvar", " vgo", "vcdiv", "vrvar", "Vdev", "valcomment", "cvdebug", "vccomment", "vdes", "evver", "vcblock", "formvar", "svdevice", " vdevice", "avnt", "vdebug", "vardev", "svserv", "Vserv", "vstat", "formgu", "vev", "valdev", "valdata", "vswitch", "evdata", "evev", "vcval", "cvdev", "vcev", "vrdev", "evcomment", "cvplayer", "avdb", "uvblock", "vserv", "avdev", "evdevice", "vtest", "avdef", "varnt", "uvscan", "mdevice", "varev", "valserver", " vcomment", " vscan", "formtest", " vswitch", " vev", " vbuild", "evblock", "vcdebug", "evplayer", "valgu", "mdebug", "vdevice", "vver", "cvdevice", "mprop", "valprop", "cvserver", "vnt", "svdes", "evscan", "vplayer", "uvev", " vver", "svdev", " vdebug", " vtest", " vdes", "tver", "vscan", "vblock", "vdef", "tdevice", "avver", "tdev", "evdb", "mval", "varbuild", "vdb", "formdev", "svver", " vserver", "formswitch", "vprop"], "size": ["empty", "SIZE", "tes", "scope", "readable", "year", "settings", "general", "pos", "num", "memory", "io", "sum", "mem", "items", "os", "g", "ms", "zero", "index", "send", "start", "max", "done", "address", "info", "time", "length", "large", "gs", "power", " sizes", "any", "type", "offset", "cs", "equal", "no", "len", "sd", "izes", "total", "to", "s", "small", "city", "capacity", "serial", "shape", "ize", "name", "init", "negative", "sp", "fee", "Size", "set", "raw", "amount", "si", "group", "n", "used", "data", "sent", "full", "height", "scale", "number", "space", "mode", "sh", "args", "complete", "status", "new", "now", "sn", "storage", "area", "count", "sample", "global", "needed", "title", "speed"], "bytes": ["bes", "odes", "eros", "gs", "classes", "cells", "pieces", "points", "times", "tes", "ns", "items", "Bytes", "values", "steps", "cs", "files", "resses", "sites", "os", "pointers", "frames", "ms", "lines", "details", "pages", "words", "rows", "les", "ds", "uses", "total", "es", "errors", "seconds", "vals", "types", "ones", "byte", "ips", "gets", "blocks", "ales", "xs", "ls", "units", "bps", "checks", "outs", "args", "reads", "bits", "loads", "users", "keys", "codes", "bs", "parts", "io", "flags", "some", "features", "ops"]}}
{"project": "qemu", "commit_id": "684e508c23d28af8d6ed2c62738a0f60447c8274", "target": 1, "func": "static bool try_poll_mode(AioContext *ctx, bool blocking)\n\n{\n\n    if (blocking && ctx->poll_max_ns && ctx->poll_disable_cnt == 0) {\n\n        /* See qemu_soonest_timeout() uint64_t hack */\n\n        int64_t max_ns = MIN((uint64_t)aio_compute_timeout(ctx),\n\n                             (uint64_t)ctx->poll_max_ns);\n\n\n\n        if (max_ns) {\n\n            if (run_poll_handlers(ctx, max_ns)) {\n\n                return true;\n\n            }\n\n        }\n\n    }\n\n\n\n    return false;\n\n}\n", "idx": 6206, "substitutes": {"ctx": ["ck", "cf", "gc", "ct", "prefix", "window", "cp", "c", "wcs", "kt", "pc", "cmp", "bc", "wx", "comm", "nt", "sc", "ok", "mk", "p", "cm", "cmd", "addr", "co", "etc", "tm", "nc", "mt", "context", "cb", "hw", "history", "kl", "aus", "xc", "cc", "js", "rc", "pkg", "xs", "kw", "that", "txt", "tz", "req", "cfg", "resp", "ac", "tx", "tmp", "ca", "pool", "jp", "np", "mc", "cur", "xp", "ctr", "Context", "ctrl", "work", "conn", "tc", "act"], "blocking": ["forcing", "ssl", "cl", "calling", "enabled", "using", "locking", "partial", "locked", "majority", "full", "available", "ocking", "limited", "being", "confirmed", "blocks", "always", "timeout", "advertising", "exclusive", "necessary", "joining", "status", "quiet", "block", "including", "sharing", "friendly", "loading", "starting", "poll", "restricted", "optional", "checking", "lock", "ing", "running", "fully", "latest", "broad", "echo", "speaking", "excluding"]}}
{"project": "qemu", "commit_id": "f1d3b99154138741161fc52f5a8c373bf71613c6", "target": 1, "func": "static void pci_basic(gconstpointer data)\n\n{\n\n    QVirtioPCIDevice *dev;\n\n    QPCIBus *bus;\n\n    QVirtQueuePCI *tx, *rx;\n\n    QGuestAllocator *alloc;\n\n    void (*func) (const QVirtioBus *bus,\n\n                  QVirtioDevice *dev,\n\n                  QGuestAllocator *alloc,\n\n                  QVirtQueue *rvq,\n\n                  QVirtQueue *tvq,\n\n                  int socket) = data;\n\n    int sv[2], ret;\n\n\n\n    ret = socketpair(PF_UNIX, SOCK_STREAM, 0, sv);\n\n    g_assert_cmpint(ret, !=, -1);\n\n\n\n    bus = pci_test_start(sv[1]);\n\n    dev = virtio_net_pci_init(bus, PCI_SLOT);\n\n\n\n    alloc = pc_alloc_init();\n\n    rx = (QVirtQueuePCI *)qvirtqueue_setup(&qvirtio_pci, &dev->vdev,\n\n                                           alloc, 0);\n\n    tx = (QVirtQueuePCI *)qvirtqueue_setup(&qvirtio_pci, &dev->vdev,\n\n                                           alloc, 1);\n\n\n\n    driver_init(&qvirtio_pci, &dev->vdev);\n\n    func(&qvirtio_pci, &dev->vdev, alloc, &rx->vq, &tx->vq, sv[0]);\n\n\n\n    /* End test */\n\n    close(sv[0]);\n\n    guest_free(alloc, tx->vq.desc);\n\n    pc_alloc_uninit(alloc);\n\n    qvirtio_pci_device_disable(dev);\n\n    g_free(dev);\n\n    qpci_free_pc(bus);\n\n    test_end();\n\n}\n", "idx": 6217, "substitutes": {"data": ["db", "dat", "window", " dat", "box", "buf", "d", "p", "addr", " sd", " DATA", "sd", "ata", "val", "r", "Data", "str", "w", "rc", "ref", "pos", "mu", " d", "device", "out", "new", "f", "DATA", "obj", "size", "res", "def", "bin"], "dev": ["db", "iv", "ev", "des", "mem", "md", "av", "cam", "DEV", "den", "dem", "pt", "pro", "nt", "ve", "buf", "d", "dt", "cmd", "vol", "sd", "var", "ds", "tr", "hw", "w", "go", "adv", "debug", "device", "env", "v", "ad", "vo", "Device", "dd", "Dev", "driver", "der", "serv", "doc", "disk", "rent", "priv", "serial", "obj", "fo", "de", "gu", "tech", "test", "stick", "res", "wd", "ver", "di", "conn", "def", "loc"], "bus": ["bur", "chain", "b", "root", "usb", " BUS", "type", "ctx", "br", "bc", "box", "BUS", "sys", "buf", "state", "nt", "self", "msg", "os", "base", "Bus", "vol", "lib", "sync", "cus", "phys", "bu", "bal", "pos", "proc", "pkg", "board", "soc", "mount", "out", "host", "book", "bits", "block", "ac", "bs", "local", "home", "disk", "cat", "serial", "loop", "us", "family", "gen", "boot", "lock", "res", "ver", "def", "loc"], "tx": ["db", "loc", "ty", "q", "ct", "task", "ctx", "ox", "fx", "wx", "pt", "TX", "tl", "lex", "ta", "Tx", "ps", "cmd", "mt", "tg", "tm", "tn", "ts", "tim", "context", "tr", "t", "ax", " ty", "pr", "ti", "txt", "tz", "rt", "tri", "st", "tab", "mm", "vt", "test", "eth", "ex", "res", "x", "trans", "tk", "mx", "tt", "tc", "mp"], "rx": ["rs", "vr", "raf", "lr", "ctx", "ox", "fx", "wx", "ra", "ry", "lex", "ux", "mr", "rax", "tr", "ri", "rw", "r", "ax", "rc", "dr", "rack", "rr", "rf", "pr", "xs", "rb", "cr", "txt", "req", "rt", "rys", "rl", "re", "rin", "ru", "xp", "rec", "res", "x", "rez", "mx", "rex", "rou", "loc"], "alloc": ["init", "all", "agg", "uf", "grow", "mem", "access", "cp", "ctx", "pc", "gov", "sys", "buf", "sc", "nt", "ok", "at", "util", "addr", "fat", "vol", "unc", "ec", "toc", "aux", "rss", "err", "ax", "ref", "pkg", "coll", "proc", "soc", "attr", "org", "oc", "acc", "sec", "req", "scan", "ac", "reg", "cpu", "ptr", "iat", "ca", "pool", "priv", "isc", "exec", "can", "disk", "nz", "oss", "enc", "res", "cu", "conn", "loc", "urg"], "func": ["cf", "method", "cast", "function", "b", "call", "rpm", "c", "ctx", "bc", "buf", "con", "fc", "prop", "cmd", "vol", "impl", "unc", "nc", "var", "cb", "lc", "callback", "cc", "proc", "pkg", "wrapper", "fac", "fun", "df", "fn", "exec", "grid", "f", "obj", "conv", "tc", "bin"], "rvq": ["rvrq", "rpq", "rvrque", "rdvrue", "rdvq", "rdvrQ", "rdvue", "rvpue", "rdvrque", "rpue", "rvue", "rpQ", "rvQ", "rvpq", "rvque", "rvrue", "rvpque", "rdvque", "rvrQ", "rdvrq", "rvpQ", "rdvQ", "rpque"], "tvq": ["tvdq", "vdq", "tvqueue", "uvql", "tgq", "vdqueue", "tgqueue", "vddq", "uvqueue", "vdql", "tvql", "uvdq", "uvq", "tgdq", "tgql"], "socket": ["ty", "sp", "et", "ssl", "ser", "pack", "set", "sys", "buf", " sock", "ocket", "addr", "ec", "sel", "th", "id", "proc", "timeout", "port", "stream", "Socket", "ss", "sq", "address", "serial", "size", "x"], "sv": ["ev", "service", "uv", "csv", "sp", "gs", "sw", "sr", "wcs", "av", "aws", "sys", "buf", "set", "cs", "sc", "ve", "si", "sy", " sd", "sd", "ts", "ds", "sync", "tr", "se", "vals", "syn", "sm", "sb", "services", "s", "scl", "v", "stats", "nv", "sh", "sl", "spec", "vs", "vc", "st", "ss", "serv", "sn", "cv", "su", "ptr", "sq", "sf", "pse", "vt", "sum", "size", "spe", "snap", "esm", "sa"], "ret": ["result", "sp", "mem", "it", "back", "cont", "set", "buf", "store", "nt", "buffer", "p", "mt", "rets", "len", "val", "row", "tr", "sent", "t", "r", "err", "sel", "ref", "vec", "out", "rt", "status", "resp", "st", "tmp", "ptr", "lit", "RET", "Ret", "fi", "ft", "sat", "j", "res", "x", "conn", "def"]}}
{"project": "qemu", "commit_id": "bc7c08a2c375acb7ae4d433054415588b176d34c", "target": 0, "func": "static void test_qemu_strtoul_full_negative(void)\n\n{\n\n    const char *str = \" \\t -321\";\n\n    unsigned long res = 999;\n\n    int err;\n\n\n\n    err = qemu_strtoul(str, NULL, 0, &res);\n\n    g_assert_cmpint(err, ==, 0);\n\n    g_assert_cmpint(res, ==, -321ul);\n\n}\n", "idx": 6241, "substitutes": {"str": ["rs", "Str", "sp", "b", "ns", "c", "br", "gr", "i", "sys", "cs", "buffer", "msg", "seq", "g", "n", "ocr", "tr", "data", "t", "r", "list", "s", "out", "stri", "txt", "shr", "st", "obj", "fr", "ctr", "enc", "res", "text", "arr", "STR"], "err": [" terr", "act", "ev", "rs", " gr", "error", "result", " ptr", "Er", "lr", "kr", "gr", "br", "ox", "nr", "i", "sys", "rel", "msg", "exc", "er", "rn", "cmd", "urg", "unc", " error", "ocr", "tr", " er", " ans", "errors", "r", "dr", "rc", "id", "rr", "attr", "pr", " fr", "iter", "cr", "acc", "req", " typ", "resp", "ror", "der", " r", " Err", " rc", "oe", "fr", "ctr", "Error", "res", "arr", " cr"]}}
{"project": "qemu", "commit_id": "5fb6c7a8b26eab1a22207d24b4784bd2b39ab54b", "target": 0, "func": "static int vnc_validate_certificate(struct VncState *vs)\n\n{\n\n    int ret;\n\n    unsigned int status;\n\n    const gnutls_datum_t *certs;\n\n    unsigned int nCerts, i;\n\n    time_t now;\n\n\n\n    VNC_DEBUG(\"Validating client certificate\\n\");\n\n    if ((ret = gnutls_certificate_verify_peers2 (vs->tls_session, &status)) < 0) {\n\n\tVNC_DEBUG(\"Verify failed %s\\n\", gnutls_strerror(ret));\n\n\treturn -1;\n\n    }\n\n\n\n    if ((now = time(NULL)) == ((time_t)-1)) {\n\n\treturn -1;\n\n    }\n\n\n\n    if (status != 0) {\n\n\tif (status & GNUTLS_CERT_INVALID)\n\n\t    VNC_DEBUG(\"The certificate is not trusted.\\n\");\n\n\n\n\tif (status & GNUTLS_CERT_SIGNER_NOT_FOUND)\n\n\t    VNC_DEBUG(\"The certificate hasn't got a known issuer.\\n\");\n\n\n\n\tif (status & GNUTLS_CERT_REVOKED)\n\n\t    VNC_DEBUG(\"The certificate has been revoked.\\n\");\n\n\n\n\tif (status & GNUTLS_CERT_INSECURE_ALGORITHM)\n\n\t    VNC_DEBUG(\"The certificate uses an insecure algorithm\\n\");\n\n\n\n\treturn -1;\n\n    } else {\n\n\tVNC_DEBUG(\"Certificate is valid!\\n\");\n\n    }\n\n\n\n    /* Only support x509 for now */\n\n    if (gnutls_certificate_type_get(vs->tls_session) != GNUTLS_CRT_X509)\n\n\treturn -1;\n\n\n\n    if (!(certs = gnutls_certificate_get_peers(vs->tls_session, &nCerts)))\n\n\treturn -1;\n\n\n\n    for (i = 0 ; i < nCerts ; i++) {\n\n\tgnutls_x509_crt_t cert;\n\n\tVNC_DEBUG (\"Checking certificate chain %d\\n\", i);\n\n\tif (gnutls_x509_crt_init (&cert) < 0)\n\n\t    return -1;\n\n\n\n\tif (gnutls_x509_crt_import(cert, &certs[i], GNUTLS_X509_FMT_DER) < 0) {\n\n\t    gnutls_x509_crt_deinit (cert);\n\n\t    return -1;\n\n\t}\n\n\n\n\tif (gnutls_x509_crt_get_expiration_time (cert) < now) {\n\n\t    VNC_DEBUG(\"The certificate has expired\\n\");\n\n\t    gnutls_x509_crt_deinit (cert);\n\n\t    return -1;\n\n\t}\n\n\n\n\tif (gnutls_x509_crt_get_activation_time (cert) > now) {\n\n\t    VNC_DEBUG(\"The certificate is not yet activated\\n\");\n\n\t    gnutls_x509_crt_deinit (cert);\n\n\t    return -1;\n\n\t}\n\n\n\n\tif (gnutls_x509_crt_get_activation_time (cert) > now) {\n\n\t    VNC_DEBUG(\"The certificate is not yet activated\\n\");\n\n\t    gnutls_x509_crt_deinit (cert);\n\n\t    return -1;\n\n\t}\n\n\n\n\tgnutls_x509_crt_deinit (cert);\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 6243, "substitutes": {"vs": ["rs", "ses", "ns", "eps", "wcs", "vers", "qs", "cs", "terms", "caps", "ps", "verts", "ms", "blogs", "lines", "pages", "vp", "ts", "inv", "ds", "fps", "hw", "es", "vals", "js", "ails", "sv", "ls", "s", "v", "ims", "stats", "Vs", "vd", "VS", "views", "hs", "ss", "bs", "lbs", "vt", "fs", "vm", "posts", "docs", "sts", "otes", "roots", "links", "obs", "changes", "lists"], "ret": ["gt", "result", "mem", "back", "cont", "ter", "nt", "er", "mt", "val", "tr", "data", "red", "alt", "t", "r", "err", "rc", "rev", "out", "try", "iter", "v", "code", "rt", "reset", "resp", "re", "tmp", "RET", "fail", "Ret", "ll", "res", "x", "deg", "def", "flag"], "status": ["post", "only", "success", "result", "error", "ssl", "sw", "magic", "wait", "prefix", "ity", "access", "step", "note", "active", "set", "state", "sc", "compl", "login", "client", "ok", "msg", "valid", "stay", "progress", "g", "si", "stat", "no", "use", "uses", "index", "tr", "sync", "server", "temp", "str", "admin", "id", "reason", "rev", "confirmed", "code", "Status", "summary", "handle", "mode", "out", "config", "st", "comment", "version", "count", "current", "message", "test", "size", "info", "flags", "check", "STAT", "res", "comments", "title", "name", "flag"], "certs": [" certts", "Certs", "ertS", "ertrs", "ertts", "certS", " certS", "ertps", "curs", "certps", " certrs", "certes", "ertids", "certts", "ertes", "Certts", "Certrs", "CertS", "ptrs", "compls", "certcs", "comples", "cfes", "cures", "curcs", "ptrps", "ptrids", "ertcs", "complids", "cfs", "complps", "erts", "cfcs", "currs", "ptres", "certrs", "cfrs", "certids"], "nCerts": ["nCerters", "nDoci", " nCerters", " ncertabs", "ncertments", "nCertits", " nCertabs", "nLocments", "nDocers", "ncerters", "nVals", " nCertries", " ncerts", "nCookits", "nPKments", " ncertments", "nPKries", " ncertes", " ncerters", "nCooks", " ncerti", "nLocs", " ncertits", " ncertries", "ncertries", "ncertabs", "nLocries", "nCertes", "nVales", "nCookes", "nCertments", "ncerti", "nDocs", "ncerts", " nCertes", " nCertments", "ncertes", " nCerti", "nCertabs", "nValers", "nCerti", "nCookabs", " nCertits", "nPKs", "ncertits", "nVali", "nDoces", "nCertries"], "i": ["counter", "ic", "ini", "ij", "chain", "ei", "ci", "it", "im", "c", "u", "cli", "cgi", "gi", "mi", "qi", "ip", "li", "p", "si", "zi", "n", "is", "tim", "ind", "xi", "index", "o", "t", "hi", "pi", "bi", "multi", "dr", "me", "id", "ui", "ji", "phi", "ir", "ti", "iter", "v", "ims", "s", "ix", "ai", "m", "I", "batch", "y", "fi", "sim", "gu", "iu", "in", "e", "iri", "j", "di", "\u0438", "ii"], "now": ["gc", "sp", "never", "created", "wait", "when", "gm", "wa", "ctx", "null", "here", "set", "ok", "at", "raw", "dt", "mt", "tm", "on", "or", "tr", "t", "old", "w", "after", "to", " NOW", "Now", "start", "max", "ow", "tz", "NOW", "new", "st", "date", "off", "tmp", "ptr", "iat", " Now", "current", "test", "before", "time", "hold", "since", "today", "ready", "tt"], "cert": ["cf", "cast", "result", "chain", "sp", "ct", "ert", "ssl", "mem", "cp", "c", "Cert", "cont", "tar", "pt", "con", "compl", "client", "ificate", "msg", " Cert", "valid", "er", "card", "cmd", "pair", "data", "ce", "key", "crypt", "temp", "t", "mail", "trust", "tr", "alt", "str", "crit", "pg", "pl", "pr", "out", "cr", "cfg", "der", "ptr", "ca", "pub", "cer", "cur", "test", "gen", "ctr", "j", "ver", "conn", "car"]}}
{"project": "qemu", "commit_id": "85df0de4cfe54fd64df7e37448cd152d0c9199a4", "target": 0, "func": "int fw_cfg_add_callback(void *opaque, uint16_t key, FWCfgCallback callback,\n\n                        void *callback_opaque, uint8_t *data, size_t len)\n\n{\n\n    FWCfgState *s = opaque;\n\n    int arch = !!(key & FW_CFG_ARCH_LOCAL);\n\n\n\n    key &= FW_CFG_ENTRY_MASK;\n\n\n\n    if (key >= FW_CFG_MAX_ENTRY || !(key & FW_CFG_WRITE_CHANNEL)\n\n        || len > 65535)\n\n        return 0;\n\n\n\n    s->entries[arch][key].data = data;\n\n    s->entries[arch][key].len = len;\n\n    s->entries[arch][key].callback_opaque = callback_opaque;\n\n    s->entries[arch][key].callback = callback;\n\n\n\n    return 1;\n\n}\n", "idx": 6251, "substitutes": {"opaque": ["ipaques", "paque", "oaques", "popient", "ipaque", "entaques", "opque", "opaques", "pque", "paques", "oaque", "opaco", "ipque", "OPaque", "entque", "OPaques", "popaque", "opient", "popaques", "ipaco", "entient", "oque", "OPient", "OPque", "oaco", "popque", "paco", "entaque"], "key": ["policy", "Key", "event", "chain", "att", "po", "state", "link", "dev", "value", "trace", "query", "tag", "child", "num", "priority", "ch", "entry", "owner", "mask", "ey", "sum", "size", "x", "path", "flag", "q", "root", "next", "null", "KEY", "page", "ek", "base", "ak", "index", "str", "position", "expr", "code", "max", "keys", "port", "version", "item", "address", "info", "length", "header", "prefix", "any", "type", "offset", "kid", "kind", "primary", "at", "ip", "no", "total", "mac", "k", "sk", "oid", "y", "hash", "net", "ver", "name", "act", "window", "fee", "i", "client", "raw", "row", "temp", "id", "list", "token", "handle", "member", "cache", "count", "ex"], "callback": ["result", "event", "function", "binding", "call", "ff", "metadata", "Callback", "pb", "native", "back", "band", "phy", "binary", "state", "buffer", "msg", "plugin", "fc", "cmd", "bind", "connection", "context", "cb", "future", "fp", "func", "closure", "parser", "value", "cc", "wrapper", "timeout", "handle", "component", "soon", "command", "config", "cell", "CB", "close", "handler", "message", "library", "background", "conn"], "callback_opaque": ["callback_compient", "callback_popus", "callback_ropacity", "callback_ipient", "callback_obaque", "callback_ropaques", "callback_operaques", "callback_popaque", "callback_ipaque", "callback_operaque", "callback_compience", "callback_opacity", "callback_opient", "callback_opensaque", "callback_opsaque", "callback_compaques", "callback_ropque", "callback_compque", "callback_opus", "callback_popacity", "callback_opsaques", "callback_opensacity", "callback_obaques", "callback_opsacity", "callback_compacity", "callback_opque", "callback_obacity", "callback_opsus", "callback_ropaque", "callback_opensient", "callback_popaques", "callback_operacity", "callback_opaques", "callback_opensience", "callback_opience", "callback_ipacity", "callback_operus", "callback_obque", "callback_compaque", "callback_ipience"], "data": ["all", "content", "bytes", "padding", "results", "empty", "dat", "window", "ns", "any", "type", "pad", "binary", "rel", "buf", "buffer", "raw", "extra", "d", "table", "body", "partial", "no", "missing", "ata", "val", "input", "Data", "value", "pos", "to", "mu", "device", "timeout", "out", "bits", "done", "action", "response", "batch", "area", "cache", "DATA", "message", "size", "info", "length", "text", "image", "ops", "bin"], "len": ["all", "bytes", "ln", "mem", " clen", "wid", "Len", "cmp", "buf", " bl", "compl", "lf", "nt", "tl", "msg", "elt", "fc", "seq", "lon", "dl", "vol", "n", "lib", "val", "fl", "pl", "kl", "t", "err", "str", "lan", "el", "limit", "pos", "coll", "ls", "fil", "lp", "en", "num", "lim", " length", "fun", "fin", "fn", "lvl", " le", "size", "length", "lic", "ll", "nl", "enc", "ld", "l", " l", "loc"], "s": ["rs", "gs", "ses", "bis", "b", "sw", "less", "ns", "ants", "c", "h", "ers", "ats", "i", "sys", "store", "qs", "comm", "os", "p", "g", "ps", "details", "n", "als", "ts", "ds", "o", "t", "se", "r", "w", "js", "ins", "sv", "ls", "sb", "services", "stats", "status", "m", "spec", "hs", "vs", "st", "ss", "sn", "bs", "states", "sq", "fs", "ii", "e", "S", "sts", "changes", "j"]}}
{"project": "FFmpeg", "commit_id": "3e1028c625e11d9d19376f5c88267de1cee8fa70", "target": 1, "func": "static void lpc_analyze_remodulate(int32_t *decoded, const int coeffs[32],\n\n                                   int order, int qlevel, int len, int bps)\n\n{\n\n    int i, j;\n\n    int ebps = 1 << (bps-1);\n\n    unsigned sigma = 0;\n\n\n\n    for (i = order; i < len; i++)\n\n        sigma |= decoded[i] + ebps;\n\n\n\n    if (sigma < 2*ebps)\n\n        return;\n\n\n\n    for (i = len - 1; i >= order; i--) {\n\n        int64_t p = 0;\n\n        for (j = 0; j < order; j++)\n\n            p += coeffs[j] * (int64_t)decoded[i-order+j];\n\n        decoded[i] -= p >> qlevel;\n\n    }\n\n    for (i = order; i < len; i++, decoded++) {\n\n        int32_t p = 0;\n\n        for (j = 0; j < order; j++)\n\n            p += coeffs[j] * (uint32_t)decoded[j];\n\n        decoded[j] += p >> qlevel;\n\n    }\n\n}\n", "idx": 6272, "substitutes": {"decoded": ["deloded", "descoded", "decoding", " decrypted", "eccoded", "definedoding", "encoded", "ecayed", "octcoded", "octrypted", "octoded", "Decrypted", "ecoded", "definedoded", "definedrypted", "ecached", "encoder", "decaled", "deached", "descoding", "decrypted", "octoding", "decayed", "ecode", "ecoder", "enccoded", "deoded", " decoder", "ecrypted", "Decoded", " decaled", "decode", "descode", "ecoding", "deloding", "delayed", "deded", "decoder", " decaned", " decached", "ecaned", "encaled", "Deccoded", "decaned", " deccoded", " decoding", " decode", "Decoding", "encode", "definedcoded", "ecded", " decded", "decached", "delcoded", "decded", " decayed", "desoder", "encoding", "descaned", "desode", "ecaled", "desoded", "deccoded"], "coeffs": ["Coeffs", "coefficients", "coffs", "Coefficientts", "coeffiths", "coffes", "coefficientss", " coffes", " coeffes", " coeffiths", "coffS", "coefjs", "coeffS", "coffiths", "coefs", "coeffjs", "coffts", " coffiths", "coefficjs", "coefficientS", "Coefficients", "coeffes", "CoefficientS", "coffjs", "coefficientes", "coeffts", "coefficientsts", "coefficientts", " coffs", "coefficientiths", "CoeffS", " coeffjs", "coefficientsS", " coffjs", "coeffics", "Coeffts"], "order": ["ordered", "user", "depth", "error", "root", "ice", "end", "orders", "type", "grade", "offset", "store", "sort", "force", "er", "base", "p", "rank", "addr", "seed", "no", "op", "over", "score", "row", "index", "group", "zero", "range", "r", "err", "limit", "record", "id", "pos", "scale", "position", "pe", "byte", "after", "unit", "level", "code", "en", "num", "mode", "priority", "ordering", "iter", "angle", "block", "dir", "random", "off", "ptr", "address", "ord", "count", "rate", "edge", "before", "Order", "size", "e", "length", "ase", "ode", "sequence"], "qlevel": ["Qlvl", "iqlvl", "qqlvl", "qqscale", "qqtest", "qlvl", "qqtime", "cfmode", "qqmode", "qtest", "qmode", "cflevel", "dqlevels", "qtlvl", "dqtest", "iqlevel", "cftime", "dqscale", "Qlevel", "qlevels", "qLevel", "qscale", "cflvl", "qqLevel", "qqlevel", " qscale", "qtlevel", " qtest", "qttime", " qlevels", "qlow", "Qlow", "qqlow", "dqlevel", "qqlevels", "iqlow", "QLevel", "iqLevel", "qtmode", "qtime"], "len": ["db", "all", "bytes", "loc", "ln", "mem", "ell", "end", "lis", "grade", "Len", "den", "rel", "nt", "lf", "seq", "lon", "dl", "n", "ds", "val", "del", "ind", "vel", "lan", "limit", "el", "lang", "pos", "list", "coll", "vec", "ls", "lp", "en", "lim", "els", "lvl", "fn", "size", "length", "ld", "ll", "nl", "arr", "l", "le", "elt", "bin"], "bps": ["rates", "bytes", "hops", "gs", "points", "places", "eps", "orders", "its", "ats", "pps", "steps", "ints", "ries", "pins", "ps", "lines", "bles", "ds", "hz", "fps", "inters", "tops", "ONES", "errors", "iers", "ones", "ips", "ls", "xs", "s", "grades", "bits", "levels", "TPS", "bs", "days", "params", "tp", "ops"], "i": ["init", "this", "ic", "ij", "ini", "asi", "ei", "chain", "ci", "b", "uri", "it", "im", "ori", "h", "ik", "gi", "mi", "oi", "qi", "at", "ip", "li", "p", "si", "ami", "ie", "zi", "is", "ind", "xi", "index", "ri", "pi", "bi", "r", "multi", "me", "ui", "id", "ki", "list", "ji", " I", "ti", "ir", "v", "ims", "iii", "ix", "ai", "m", "I", "y", "print", "\u0438", "f", "ia", "sim", "io", "iu", "e", "in", "info", "x", "di", "ii", "l"], "j": ["dj", "att", "bot", "note", "rel", "ind", "t", "key", "pi", "Ja", "js", "jp", "by", "kj", "di", "ja", "q", "next", "job", "J", "kh", "aj", "g", "uj", "bi", "str", "ng", "v", "m", "ju", "json", "ev", "jo", "bj", "it", "pt", "ijk", "at", "p", "on", "bo", "jc", "r", "dr", "k", "oj", "try", "bs", "y", "fr", "ver", "ii", "ij", "b", "mn", "jj", "br", "ie", "n", "ge", "ji", "pr", "handle", "ix", "jac", "adj", "je", "jump", "jit", "obj", "jl", "z", "other"]}}
{"project": "FFmpeg", "commit_id": "b853cfe7eaf13b7d4ff3ceba7098544ccc049df8", "target": 0, "func": "static int read_thread(void *arg)\n\n{\n\n    VideoState *is = arg;\n\n    AVFormatContext *ic = NULL;\n\n    int err, i, ret;\n\n    int st_index[AVMEDIA_TYPE_NB];\n\n    AVPacket pkt1, *pkt = &pkt1;\n\n    int eof = 0;\n\n    int pkt_in_play_range = 0;\n\n    AVDictionaryEntry *t;\n\n    AVDictionary **opts;\n\n    int orig_nb_streams;\n\n    SDL_mutex *wait_mutex = SDL_CreateMutex();\n\n\n\n    memset(st_index, -1, sizeof(st_index));\n\n    is->last_video_stream = is->video_stream = -1;\n\n    is->last_audio_stream = is->audio_stream = -1;\n\n    is->last_subtitle_stream = is->subtitle_stream = -1;\n\n\n\n    ic = avformat_alloc_context();\n\n    ic->interrupt_callback.callback = decode_interrupt_cb;\n\n    ic->interrupt_callback.opaque = is;\n\n    err = avformat_open_input(&ic, is->filename, is->iformat, &format_opts);\n\n    if (err < 0) {\n\n        print_error(is->filename, err);\n\n        ret = -1;\n\n        goto fail;\n\n    }\n\n    if ((t = av_dict_get(format_opts, \"\", NULL, AV_DICT_IGNORE_SUFFIX))) {\n\n        av_log(NULL, AV_LOG_ERROR, \"Option %s not found.\\n\", t->key);\n\n        ret = AVERROR_OPTION_NOT_FOUND;\n\n        goto fail;\n\n    }\n\n    is->ic = ic;\n\n\n\n    if (genpts)\n\n        ic->flags |= AVFMT_FLAG_GENPTS;\n\n\n\n    opts = setup_find_stream_info_opts(ic, codec_opts);\n\n    orig_nb_streams = ic->nb_streams;\n\n\n\n    err = avformat_find_stream_info(ic, opts);\n\n    if (err < 0) {\n\n        fprintf(stderr, \"%s: could not find codec parameters\\n\", is->filename);\n\n        ret = -1;\n\n        goto fail;\n\n    }\n\n    for (i = 0; i < orig_nb_streams; i++)\n\n        av_dict_free(&opts[i]);\n\n    av_freep(&opts);\n\n\n\n    if (ic->pb)\n\n        ic->pb->eof_reached = 0; // FIXME hack, ffplay maybe should not use url_feof() to test for the end\n\n\n\n    if (seek_by_bytes < 0)\n\n        seek_by_bytes = !!(ic->iformat->flags & AVFMT_TS_DISCONT);\n\n\n\n    is->max_frame_duration = (ic->iformat->flags & AVFMT_TS_DISCONT) ? 10.0 : 3600.0;\n\n\n\n    /* if seeking requested, we execute it */\n\n    if (start_time != AV_NOPTS_VALUE) {\n\n        int64_t timestamp;\n\n\n\n        timestamp = start_time;\n\n        /* add the stream start time */\n\n        if (ic->start_time != AV_NOPTS_VALUE)\n\n            timestamp += ic->start_time;\n\n        ret = avformat_seek_file(ic, -1, INT64_MIN, timestamp, INT64_MAX, 0);\n\n        if (ret < 0) {\n\n            fprintf(stderr, \"%s: could not seek to position %0.3f\\n\",\n\n                    is->filename, (double)timestamp / AV_TIME_BASE);\n\n        }\n\n    }\n\n\n\n    is->realtime = is_realtime(ic);\n\n\n\n    for (i = 0; i < ic->nb_streams; i++)\n\n        ic->streams[i]->discard = AVDISCARD_ALL;\n\n    if (!video_disable)\n\n        st_index[AVMEDIA_TYPE_VIDEO] =\n\n            av_find_best_stream(ic, AVMEDIA_TYPE_VIDEO,\n\n                                wanted_stream[AVMEDIA_TYPE_VIDEO], -1, NULL, 0);\n\n    if (!audio_disable)\n\n        st_index[AVMEDIA_TYPE_AUDIO] =\n\n            av_find_best_stream(ic, AVMEDIA_TYPE_AUDIO,\n\n                                wanted_stream[AVMEDIA_TYPE_AUDIO],\n\n                                st_index[AVMEDIA_TYPE_VIDEO],\n\n                                NULL, 0);\n\n    if (!video_disable)\n\n        st_index[AVMEDIA_TYPE_SUBTITLE] =\n\n            av_find_best_stream(ic, AVMEDIA_TYPE_SUBTITLE,\n\n                                wanted_stream[AVMEDIA_TYPE_SUBTITLE],\n\n                                (st_index[AVMEDIA_TYPE_AUDIO] >= 0 ?\n\n                                 st_index[AVMEDIA_TYPE_AUDIO] :\n\n                                 st_index[AVMEDIA_TYPE_VIDEO]),\n\n                                NULL, 0);\n\n    if (show_status) {\n\n        av_dump_format(ic, 0, is->filename, 0);\n\n    }\n\n\n\n    is->show_mode = show_mode;\n\n\n\n    /* open the streams */\n\n    if (st_index[AVMEDIA_TYPE_AUDIO] >= 0) {\n\n        stream_component_open(is, st_index[AVMEDIA_TYPE_AUDIO]);\n\n    }\n\n\n\n    ret = -1;\n\n    if (st_index[AVMEDIA_TYPE_VIDEO] >= 0) {\n\n        ret = stream_component_open(is, st_index[AVMEDIA_TYPE_VIDEO]);\n\n    }\n\n    if (is->show_mode == SHOW_MODE_NONE)\n\n        is->show_mode = ret >= 0 ? SHOW_MODE_VIDEO : SHOW_MODE_RDFT;\n\n\n\n    is->refresh_tid = SDL_CreateThread(refresh_thread, is);\n\n\n\n    if (st_index[AVMEDIA_TYPE_SUBTITLE] >= 0) {\n\n        stream_component_open(is, st_index[AVMEDIA_TYPE_SUBTITLE]);\n\n    }\n\n\n\n    if (is->video_stream < 0 && is->audio_stream < 0) {\n\n        fprintf(stderr, \"%s: could not open codecs\\n\", is->filename);\n\n        ret = -1;\n\n        goto fail;\n\n    }\n\n\n\n    if (infinite_buffer < 0 && is->realtime)\n\n        infinite_buffer = 1;\n\n\n\n    for (;;) {\n\n        if (is->abort_request)\n\n            break;\n\n        if (is->paused != is->last_paused) {\n\n            is->last_paused = is->paused;\n\n            if (is->paused)\n\n                is->read_pause_return = av_read_pause(ic);\n\n            else\n\n                av_read_play(ic);\n\n        }\n\n#if CONFIG_RTSP_DEMUXER || CONFIG_MMSH_PROTOCOL\n\n        if (is->paused &&\n\n                (!strcmp(ic->iformat->name, \"rtsp\") ||\n\n                 (ic->pb && !strncmp(input_filename, \"mmsh:\", 5)))) {\n\n            /* wait 10 ms to avoid trying to get another packet */\n\n            /* XXX: horrible */\n\n            SDL_Delay(10);\n\n            continue;\n\n        }\n\n#endif\n\n        if (is->seek_req) {\n\n            int64_t seek_target = is->seek_pos;\n\n            int64_t seek_min    = is->seek_rel > 0 ? seek_target - is->seek_rel + 2: INT64_MIN;\n\n            int64_t seek_max    = is->seek_rel < 0 ? seek_target - is->seek_rel - 2: INT64_MAX;\n\n// FIXME the +-2 is due to rounding being not done in the correct direction in generation\n\n//      of the seek_pos/seek_rel variables\n\n\n\n            ret = avformat_seek_file(is->ic, -1, seek_min, seek_target, seek_max, is->seek_flags);\n\n            if (ret < 0) {\n\n                fprintf(stderr, \"%s: error while seeking\\n\", is->ic->filename);\n\n            } else {\n\n                if (is->audio_stream >= 0) {\n\n                    packet_queue_flush(&is->audioq);\n\n                    packet_queue_put(&is->audioq, &flush_pkt);\n\n                }\n\n                if (is->subtitle_stream >= 0) {\n\n                    packet_queue_flush(&is->subtitleq);\n\n                    packet_queue_put(&is->subtitleq, &flush_pkt);\n\n                }\n\n                if (is->video_stream >= 0) {\n\n                    packet_queue_flush(&is->videoq);\n\n                    packet_queue_put(&is->videoq, &flush_pkt);\n\n                }\n\n                if (is->seek_flags & AVSEEK_FLAG_BYTE) {\n\n                   //FIXME: use a cleaner way to signal obsolete external clock...\n\n                   update_external_clock_pts(is, (double)AV_NOPTS_VALUE);\n\n                } else {\n\n                   update_external_clock_pts(is, seek_target / (double)AV_TIME_BASE);\n\n                }\n\n            }\n\n            is->seek_req = 0;\n\n            eof = 0;\n\n            if (is->paused)\n\n                step_to_next_frame(is);\n\n        }\n\n        if (is->queue_attachments_req) {\n\n            avformat_queue_attached_pictures(ic);\n\n            is->queue_attachments_req = 0;\n\n        }\n\n\n\n        /* if the queue are full, no need to read more */\n\n        if (infinite_buffer<1 &&\n\n              (is->audioq.size + is->videoq.size + is->subtitleq.size > MAX_QUEUE_SIZE\n\n            || (   (is->audioq   .nb_packets > MIN_FRAMES || is->audio_stream < 0 || is->audioq.abort_request)\n\n                && (is->videoq   .nb_packets > MIN_FRAMES || is->video_stream < 0 || is->videoq.abort_request)\n\n                && (is->subtitleq.nb_packets > MIN_FRAMES || is->subtitle_stream < 0 || is->subtitleq.abort_request)))) {\n\n            /* wait 10 ms */\n\n            SDL_LockMutex(wait_mutex);\n\n            SDL_CondWaitTimeout(is->continue_read_thread, wait_mutex, 10);\n\n            SDL_UnlockMutex(wait_mutex);\n\n            continue;\n\n        }\n\n        if (eof) {\n\n            if (is->video_stream >= 0) {\n\n                av_init_packet(pkt);\n\n                pkt->data = NULL;\n\n                pkt->size = 0;\n\n                pkt->stream_index = is->video_stream;\n\n                packet_queue_put(&is->videoq, pkt);\n\n            }\n\n            if (is->audio_stream >= 0 &&\n\n                is->audio_st->codec->codec->capabilities & CODEC_CAP_DELAY) {\n\n                av_init_packet(pkt);\n\n                pkt->data = NULL;\n\n                pkt->size = 0;\n\n                pkt->stream_index = is->audio_stream;\n\n                packet_queue_put(&is->audioq, pkt);\n\n            }\n\n            SDL_Delay(10);\n\n            if (is->audioq.size + is->videoq.size + is->subtitleq.size == 0) {\n\n                if (loop != 1 && (!loop || --loop)) {\n\n                    stream_seek(is, start_time != AV_NOPTS_VALUE ? start_time : 0, 0, 0);\n\n                } else if (autoexit) {\n\n                    ret = AVERROR_EOF;\n\n                    goto fail;\n\n                }\n\n            }\n\n            eof=0;\n\n            continue;\n\n        }\n\n        ret = av_read_frame(ic, pkt);\n\n        if (ret < 0) {\n\n            if (ret == AVERROR_EOF || url_feof(ic->pb))\n\n                eof = 1;\n\n            if (ic->pb && ic->pb->error)\n\n                break;\n\n            SDL_LockMutex(wait_mutex);\n\n            SDL_CondWaitTimeout(is->continue_read_thread, wait_mutex, 10);\n\n            SDL_UnlockMutex(wait_mutex);\n\n            continue;\n\n        }\n\n        /* check if packet is in play range specified by user, then queue, otherwise discard */\n\n        pkt_in_play_range = duration == AV_NOPTS_VALUE ||\n\n                (pkt->pts - ic->streams[pkt->stream_index]->start_time) *\n\n                av_q2d(ic->streams[pkt->stream_index]->time_base) -\n\n                (double)(start_time != AV_NOPTS_VALUE ? start_time : 0) / 1000000\n\n                <= ((double)duration / 1000000);\n\n        if (pkt->stream_index == is->audio_stream && pkt_in_play_range) {\n\n            packet_queue_put(&is->audioq, pkt);\n\n        } else if (pkt->stream_index == is->video_stream && pkt_in_play_range) {\n\n            packet_queue_put(&is->videoq, pkt);\n\n        } else if (pkt->stream_index == is->subtitle_stream && pkt_in_play_range) {\n\n            packet_queue_put(&is->subtitleq, pkt);\n\n        } else {\n\n            av_free_packet(pkt);\n\n        }\n\n    }\n\n    /* wait until the end */\n\n    while (!is->abort_request) {\n\n        SDL_Delay(100);\n\n    }\n\n\n\n    ret = 0;\n\n fail:\n\n    /* close each stream */\n\n    if (is->audio_stream >= 0)\n\n        stream_component_close(is, is->audio_stream);\n\n    if (is->video_stream >= 0)\n\n        stream_component_close(is, is->video_stream);\n\n    if (is->subtitle_stream >= 0)\n\n        stream_component_close(is, is->subtitle_stream);\n\n    if (is->ic) {\n\n        avformat_close_input(&is->ic);\n\n    }\n\n\n\n    if (ret != 0) {\n\n        SDL_Event event;\n\n\n\n        event.type = FF_QUIT_EVENT;\n\n        event.user.data1 = is;\n\n        SDL_PushEvent(&event);\n\n    }\n\n    SDL_DestroyMutex(wait_mutex);\n\n    return 0;\n\n}\n", "idx": 6277, "substitutes": {"arg": ["gc", "call", "ive", "ar", "it", "pc", "ctx", "argument", "buffer", "g", "p", "base", "arp", "op", "val", "og", "AR", "ary", "w", "ax", "ref", "inter", "pg", "arc", "Arg", "out", "v", "args", "adi", "mm", "doc", "jp", "ag", "in", "param", "arr", "inc"], "is": ["was", "ists", "im", "ib", "ik", "inst", "ts", "or", "js", "irm", "tis", "iso", "ires", "in", "as", "ois", "lis", "os", "ms", "ri", "es", "bi", "isl", "are", "ips", "stats", "bits", "ai", "vs", "iris", "ia", "us", "info", "sis", "IC", "oss", "isf", "bis", "ris", "ar", "it", "ies", "isin", "at", "ip", "has", "does", "and", "rest", "s", "bs", "isc", "parts", "il", "init", "isa", "ics", "its", "set", "sys", "id", "ins", "ui", "ids", "ir", "ims", "iss", "Is", "ist", "isal", "ish", "IS", "ys", "ais", "isi", "ism"], "ic": ["init", "cit", "ico", "dc", "et", "gc", "ij", "ci", "ct", "it", "ics", "tic", "voc", "ib", "cli", "pc", "eric", "bc", "anc", "kt", "ik", "aic", "ip", "fc", "ric", "ec", "wic", "circ", "op", "mic", "ick", "aci", "lc", "pi", "sic", " nic", "icing", "icc", "nic", "ici", "oc", "ix", "ac", "vc", "pic", "ict", "iat", "kit", "mc", "ia", "ex", "iac", "iz", "irc", "icon", "cu", "il", "IC", "inc", "tc"], "err": ["ev", "result", "error", "outer", "repl", "Er", "fee", "lr", "c", "ber", "kr", "br", "conf", "any", "nr", "ter", "tar", "buf", "eas", "sys", "aaa", "mr", "my", "msg", "rn", "er", "die", "norm", "order", "cmd", "notice", "len", "dev", "score", "val", "or", "cb", "hz", "usr", "ner", "errors", "r", "str", "dr", "js", "go", "rr", "attr", "pr", "iter", "cr", "txt", "try", "plain", "rar", "req", "cfg", "resp", "inner", "der", "gz", "count", "cer", " Err", "test", "e", "fr", "ctr", "Error", "res", "arr", "coord", "elt"], "i": ["ij", "ini", "chain", "ei", "ci", "it", "im", "u", "oi", "gi", "mi", "qi", "ip", "li", "p", "si", "zi", "n", "ind", "xi", "index", "pi", "multi", "bi", "me", "id", "ui", "inter", "ji", "ki", "phi", "ir", "ti", "iter", "ims", "ix", "ai", "m", "I", "batch", "y", "fire", "\u0438", "fi", "us", "io", "sim", "gu", "e", "in", "iu", "j", "x", "di", "ii"], "ret": ["gt", "result", "gc", "mem", "att", "reply", "rel", "nt", "mi", "at", "mid", "dt", "addr", "cmd", "mt", " Ret", "tn", "rets", "len", "val", "usr", "alt", "dr", "ref", "rev", "rr", "rem", "opt", "out", "iter", "txt", "rt", "fin", "resp", "re", "print", "RET", "jp", "cat", "pub", "Ret", "fi", "ft", "nz", "ll", "res", "arr", "def", "elt"], "st_index": ["stairid", "str2order", "st2type", "stplnumber", "ST_info", "ST_ind", "str2ind", "sttxorder", "st_id", "stplind", "st_number", "ST_index", "ST_type", "st2ind", "stairind", "stplindex", "str_index", "str2id", "str_ind", "st2order", "stxindex", "st_ind", "str_order", "st_num", "st2id", "sttxind", "st2num", "sttxid", "sttxindex", "st_order", "stplinfo", "stairorder", "stxtype", "ST_num", "stairindex", "str_id", "str2index", "st_info", "stxnum", "st2index", "st_type", "ST_number"], "pkt1": ["packet0", "pk1", "cpkt8", "pnt3", "cpacket1", "packet3", "cpkt3", "ptx1", "ptx8", "pet0", "pnt2", "packet1", "cpacket3", " pet0", "packet2", "pkt8", " pkt2", " pet1", "pnt1", "cpkt1", " pet2", "pk8", "ptx3", "cpacket8", "pet3", "pnt0", " pet3", " pkt0", "pkt3", "pet2", "pet1", " pkt3", "pk3", "pkt0", "packet8", "pkt2"], "pkt": ["cacket", "packet", "Packet", "pdu", "ckt", " pct", "pct", "Pct", "cdu", "cct", " pdu", "Pkt", " packet", "Pdu"], "t": ["tree", "ct", "it", "c", "kt", "tar", "T", "pt", "nt", "ta", "at", "te", "template", "dt", "p", "tg", "d", "g", "tm", "table", "ent", "ts", "n", "tr", "o", "temp", "r", "to", "opt", "k", "ti", "tip", "v", "txt", "ot", "tu", "rt", "m", "tap", "vt", "f", "e", "tt", "tc"], "opts": ["opats", "props", "iopps", "optgs", "optd", " ops", "opertd", "optts", "optals", "prots", " opms", "iopts", "opms", "roptd", "OPps", "ropts", "optionsx", "optionstd", " opals", "operx", "iops", " opats", " optals", "OPs", "iopats", "optionsts", "opct", " opps", "proct", "roptp", " opct", " optds", "opgs", "ropx", "operps", "opals", " optts", "OPats", "opds", "operct", " opds", "proms", "OPts", "operms", "optp", "opps", " optgs", "opx", "optds", " opgs", "optionstp", "ops", "opertp", "operts"], "orig_nb_streams": ["orig_nb_reamers", "orig_nb_roundings", "orig_nb_reams", "orig_nb_rounders", "orig_nb_reamS", "orig_nb_sws", "orig_nb_streamers", "orig_nb_streami", "orig_nb_roundS", "orig_nb_swers", "orig_nb_StreamS", "orig_nb_hosters", "orig_nb_swings", "orig_nb_hosti", "orig_nb_lengthS", "orig_nb_rounds", "orig_nb_lengths", "orig_nb_Streamers", "orig_nb_Streami", "orig_nb_hosts", "orig_nb_Streams", "orig_nb_streamings", "orig_nb_lengthings", "orig_nb_streamS", "orig_nb_swS", "orig_nb_lengthi", "orig_nb_lengthers", "orig_nb_hostS"], "wait_mutex": ["wait_mutx", "wait_mtex", "wait_Mutlock", "wait_mtlock", "wait_mutix", "wait_mutlock", "wait_Mutix", "wait_Mutex", "wait_Mutx", "wait_muix", "wait_muex", "wait_mulock", "wait_mtix", "wait_mtx", "wait_mux"]}}
{"project": "FFmpeg", "commit_id": "859bb3cfee28efff9c965d4c9320c7837b85849e", "target": 0, "func": "int ff_xvmc_field_start(MpegEncContext *s, AVCodecContext *avctx)\n\n{\n\n    struct xvmc_pix_fmt *last, *next, *render = (struct xvmc_pix_fmt*)s->current_picture.data[2];\n\n    const int mb_block_count = 4 + (1 << s->chroma_format);\n\n\n\n    assert(avctx);\n\n    if (!render || render->xvmc_id != AV_XVMC_ID ||\n\n        !render->data_blocks || !render->mv_blocks) {\n\n        av_log(avctx, AV_LOG_ERROR,\n\n               \"Render token doesn't look as expected.\\n\");\n\n        return -1; // make sure that this is a render packet\n\n    }\n\n\n\n    if (render->filled_mv_blocks_num) {\n\n        av_log(avctx, AV_LOG_ERROR,\n\n               \"Rendering surface contains %i unprocessed blocks.\\n\",\n\n               render->filled_mv_blocks_num);\n\n        return -1;\n\n    }\n\n    if (render->allocated_mv_blocks   < 1 ||\n\n        render->allocated_data_blocks <  render->allocated_mv_blocks*mb_block_count ||\n\n        render->start_mv_blocks_num   >= render->allocated_mv_blocks                ||\n\n        render->next_free_data_block_num >\n\n                        render->allocated_data_blocks -\n\n                        mb_block_count*(render->allocated_mv_blocks-render->start_mv_blocks_num)) {\n\n        av_log(avctx, AV_LOG_ERROR,\n\n               \"Rendering surface doesn't provide enough block structures to work with.\\n\");\n\n        return -1;\n\n    }\n\n\n\n    render->picture_structure = s->picture_structure;\n\n    render->flags             = s->first_field ? 0 : XVMC_SECOND_FIELD;\n\n    render->p_future_surface  = NULL;\n\n    render->p_past_surface    = NULL;\n\n\n\n    switch(s->pict_type) {\n\n        case  FF_I_TYPE:\n\n            return 0; // no prediction from other frames\n\n        case  FF_B_TYPE:\n\n            next = (struct xvmc_pix_fmt*)s->next_picture.data[2];\n\n            if (!next)\n\n                return -1;\n\n            if (next->xvmc_id != AV_XVMC_ID)\n\n                return -1;\n\n            render->p_future_surface = next->p_surface;\n\n            // no return here, going to set forward prediction\n\n        case  FF_P_TYPE:\n\n            last = (struct xvmc_pix_fmt*)s->last_picture.data[2];\n\n            if (!last)\n\n                last = render; // predict second field from the first\n\n            if (last->xvmc_id != AV_XVMC_ID)\n\n                return -1;\n\n            render->p_past_surface = last->p_surface;\n\n            return 0;\n\n    }\n\n\n\nreturn -1;\n\n}\n", "idx": 6293, "substitutes": {"s": ["this", "as", "rs", "styles", "gs", "ses", "des", "b", "sg", "less", "times", "ns", "c", "its", "ctx", "ats", "h", "http", "sys", "qs", "cs", "comm", "self", "sort", "os", "uploads", "p", "ps", "aunts", "als", "n", "details", "is", "ts", "settings", "ds", "eds", "es", "t", "plays", "simple", "js", "w", "ins", "sv", "ls", "events", "sb", "params", "v", "ims", "stats", "args", "views", "spec", "vs", "hs", "a", "ss", "bs", "states", "sq", "parts", "fs", "e", "S", "sts", "series", "sports", "aws"], "avctx": ["vanctx", "vercaps", "airctl", "vrcfg", "avercb", " avjp", "avejac", "vrkw", "uvcfg", "avercfg", "avjp", "ivcaps", "avecfg", "vrctx", "avconn", "ajctx", "averconn", "aircfg", " avcontext", "ivcu", "ivctx", "avecb", "avercu", "avercontext", "avcontext", "aveconn", "avcaps", "ajjac", "avjac", "uvkw", "avcas", "vancfg", "vanjp", "avekw", "uvconn", "airctx", "avecas", "avectl", "ivcfg", "avectx", "vercfg", "verctx", "avercaps", "averctl", "vercu", "aircas", " avcfg", "avercas", "averjp", "avcb", "avcfg", "vrconn", "vancontext", "ajcb", "avctl", "avcu", "ajconn", "averctx", "uvctx", "averjac", "avkw"], "last": ["this", "all", "chain", "end", "any", "nd", "state", "self", "base", "table", "full", "first", "old", "push", "query", "list", "rev", "rest", "style", "send", "max", "final", "prev", "las", "st", "comment", "close", "ret", "reverse", "jump", "show", "rend", "cache", "current", "l", "length", "latest", "Last"], "next": ["this", "about", "header", "result", "end", "more", "reply", "then", "gov", "none", "buf", "nd", "primary", "self", "valid", "secondary", "extra", "body", "link", "n", "network", "foreign", "future", "data", "first", "ner", "follow", "button", "append", "after", "Next", "want", "forward", "ng", "start", "big", "txt", "mobile", "video", "normal", "prev", "new", "head", "response", "ptr", "entry", "second", "front", "jp", "current", "obj", "nav", "gen", "info", "j", "nl", "other", "ne", "latest", "l"], "render": ["draw", "rendered", "layout", "reflect", "run", "rel", "buf", "state", "display", "order", "plot", "trace", "tag", "hal", "wrapper", "transform", "req", "reset", "request", "nder", "filter", "respond", "detail", "player", "output", "vr", "download", "pen", "evaluate", "rect", "send", "begin", "video", "frame", "report", "remote", "parse", "rend", "html", "write", "relation", "header", "update", "end", "find", "template", "play", "progress", "riot", "review", "r", "dump", "record", "debug", "rev", "writer", "re", "head", "response", "build", "Render", "drm", "fr", "res", "trigger", "user", "design", "result", "form", "match", "metadata", "raw", "profile", "cmd", "erer", "err", "proc", "complete", "embed", "front", "print", "cache", "runner", "format"]}}
{"project": "FFmpeg", "commit_id": "0eec40b713eee84e2aec8af35ccce059817cad2a", "target": 1, "func": "static int calculate_bitrate(AVFormatContext *s)\n\n{\n\n    AVIContext *avi = s->priv_data;\n\n    int i, j;\n\n    int64_t lensum = 0;\n\n    int64_t maxpos = 0;\n\n\n\n    for (i = 0; i<s->nb_streams; i++) {\n\n        int64_t len = 0;\n\n        AVStream *st = s->streams[i];\n\n\n\n        if (!st->nb_index_entries)\n\n            continue;\n\n\n\n        for (j = 0; j < st->nb_index_entries; j++)\n\n            len += st->index_entries[j].size;\n\n        maxpos = FFMAX(maxpos, st->index_entries[j-1].pos);\n\n        lensum += len;\n\n    }\n\n    if (maxpos < avi->io_fsize*9/10) // index does not cover the whole file\n\n        return 0;\n\n    if (lensum*9/10 > maxpos || lensum < maxpos*9/10) // frame sum and filesize mismatch\n\n        return 0;\n\n\n\n    for (i = 0; i<s->nb_streams; i++) {\n\n        int64_t len = 0;\n\n        AVStream *st = s->streams[i];\n\n        int64_t duration;\n\n\n\n        for (j = 0; j < st->nb_index_entries; j++)\n\n            len += st->index_entries[j].size;\n\n\n\n        if (st->nb_index_entries < 2 || st->codec->bit_rate > 0)\n\n            continue;\n\n        duration = st->index_entries[j-1].timestamp - st->index_entries[0].timestamp;\n\n        st->codec->bit_rate = av_rescale(8*len, st->time_base.den, duration * st->time_base.num);\n\n    }\n\n    return 1;\n\n}\n", "idx": 6307, "substitutes": {"s": ["rs", "gs", "ses", "sw", "less", "times", "ns", "c", "its", "acs", "ats", "h", "aws", "qs", "cs", "comm", "os", "p", "ps", "aunts", "g", "n", "ms", "is", "ts", "ds", "o", "t", "es", "aus", "r", "js", "ins", "sv", "ls", "sb", "v", "ims", "m", "spec", "vs", "ss", "bs", "sq", "parts", "f", "fs", "S", "sts", "sis", "sports", "a", "ops"], "avi": ["ja", "aver", "ano", "ive", "cli", "ats", "av", "cam", "vi", "oga", "alist", "aic", "mi", "ami", "wav", "opus", "ava", "vp", "ati", "mic", "aci", "pi", "bi", "audio", "ui", "ahi", "au", "ti", "v", "video", "jac", "adi", "ai", "vc", "VI", "webkit", "iat", "ia", "IA", "gra", "format", "audi", "AV"], "i": ["ei", " ii", "im", "ik", "gi", "zi", "ind", "hi", "pi", "I", "batch", "in", "series", "x", "\u0438", "di", "ic", "um", "mi", "g", "xi", "index", "ri", "bi", "ki", "ti", "v", "ai", "m", "ia", "us", "info", "json", "l", "ci", "it", "u", "ip", "li", "p", "ami", "is", "o", "record", "to", " I", "try", "y", "ii", "init", "ij", "ini", "uri", "b", "qi", "si", "ie", "iq", "multi", "me", "ui", "id", "ji", "phi", "ir", "ims", "ix", "print", "sim", "iu", "e"], "j": ["dj", "ja", "ev", "ij", "q", "b", "bj", "jo", "mn", "att", "it", "jj", "job", "note", "J", "br", "h", "pt", "aj", "msg", "at", "er", "li", "p", "g", "ie", "n", "len", "on", "ind", "uj", "bo", "o", "t", "bi", "jc", "err", "js", "str", "el", "pos", "ji", "pr", "k", "ng", "jet", "oj", "try", "v", "out", "ix", "m", "adj", "off", "y", "jump", "jp", "bl", "jit", "je", "obj", "jl", "ju", "by", "kj", "z", "fr", "json", "other", "l", "jen"], "st": ["must", "sw", "step", "utt", "nd", "sc", "inst", "lo", "t", "se", "stan", "ast", "station", "art", "ss", "ST", "sta", "ost", "ust", "so", "stage", "sam", "store", "nt", "stack", "ut", "str", "start", "ste", "td", "ace", "St", "ct", "pt", "stru", "mt", "std", "usr", "stop", "th", "dr", "sv", "sm", "rest", "rt", "dd", "lt", "tra", "ft", "net", "ld", "tt", "sp", "est", "sth", "set", "stat", "etc", "irst", "lc", "sty", "list", "proc", "stri", "sh", "sl", "sn", "stable", "ist", "obj", "sts", "interface", "z"], "duration": ["depth", "uv", "result", "feat", "padding", "window", "end", "gl", "direction", "urations", "runtime", "vid", "extra", "amount", "d", "ler", "n", "len", "future", "total", "number", "record", "unit", "span", "dx", "delay", "distance", "timeout", "dim", "video", "volume", "date", "frequency", "doc", "count", "size", "time", "Duration", "trip", "length", "format", "origin", " dur", "relation", "ni", "fd", "resolution", "uration"]}}
{"project": "qemu", "commit_id": "7d1b0095bff7157e856d1d0e6c4295641ced2752", "target": 1, "func": "static inline void gen_st16(TCGv val, TCGv addr, int index)\n\n{\n\n    tcg_gen_qemu_st16(val, addr, index);\n\n    dead_tmp(val);\n\n}\n", "idx": 6335, "substitutes": {"val": ["cod", "uv", "b", "ct", "mem", "fee", "ctx", "Val", "buf", "lex", "valid", "msg", "p", "g", "pol", "ind", "data", "rol", "vals", "key", "sel", "value", "ref", "v", "txt", "cal", "status", "resp", "vc", "al", "serv", "ret", "cv", "eval", "tx", "local", "item", "vt", "VAL", "obj", "test", "arg", "arr", "x", "def", "act"], "addr": ["et", " ptr", "node", "src", "mem", "ctx", "offset", "pad", " mem", " address", "self", "aj", "help", "cmd", "add", "urg", "oad", "var", "ind", "hw", " pos", "dr", "ref", "pos", "id", "inter", "align", "gate", "host", "ad", "handle", " loc", "ack", "alloc", "now", "tx", "ptr", "address", " act", "obj", "work", "loc", "act"], "index": [" ind", "offset", "i", "set", "find", "IND", "add", "order", "location", "seek", "no", "ind", "zero", "row", " sidx", "number", "position", "slice", "id", "pos", "connect", "ion", "num", "Index", "cond", "address", "count", "size", "point", "length", "coord", "x", "inc"]}}
{"project": "qemu", "commit_id": "2f295167e0c429cec233aef7dc8e9fd6f90376df", "target": 1, "func": "static void q35_host_class_init(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n    PCIHostBridgeClass *hc = PCI_HOST_BRIDGE_CLASS(klass);\n\n\n\n    hc->root_bus_path = q35_host_root_bus_path;\n\n    dc->realize = q35_host_realize;\n\n    dc->props = mch_props;\n\n    /* Reason: needs to be wired up by pc_q35_init */\n\n    dc->user_creatable = false;\n\n    set_bit(DEVICE_CATEGORY_BRIDGE, dc->categories);\n\n    dc->fw_name = \"pci\";\n\n}\n", "idx": 6346, "substitutes": {"klass": ["ikclass", "Klasses", " klasses", "kcl", " kcl", "Kclass", "ikls", " kls", "tklasses", "tklass", "Klass", "Kls", "klasses", "tkclass", "iklasses", "iklass", "tkcl", "kls", "ikcl", "tkls", " kclass", "kclass"], "data": ["result", "dat", "type", "def", " Data", "d", " DATA", "rew", "dev", "ata", "Data", "w", "rc", "mu", " d", "params", "m", "new", "DATA", "obj", "info", "res", "di", "json", "bus", "name", "bin"], "dc": ["db", "cf", "design", "gc", "cp", "c", "pc", "cam", "bc", "cs", "fc", "DC", " DC", "d", "cm", "cmd", "dt", "du", "bd", "ec", "nc", "ds", "cc", "rc", "dm", "mac", "cr", "oc", "dd", "df", "ac", "dk", "cd", "disc", "cca", "doc", "ca", "mc", "dp", "desc", "currency", "dra", "iac", "ga", "td", "adr", "di", "cu", "tc", "da"], "hc": ["ehgc", " Hdc", " hbc", "hac", "hci", "phac", "ohc", "ehc", "ehdc", " Hbc", "Hci", "ohac", "phci", "Hc", "ohcc", "ohci", " hgc", "hcc", "Hcc", "hgc", "phcc", " hdc", " Hc", "hdc", "phc", "ehbc", " Hgc", "Hac", "hbc"]}}
{"project": "qemu", "commit_id": "340849a9ff2a246bbc9a2da3f079c9fdbd2d5852", "target": 1, "func": "static struct addrinfo *inet_parse_connect_saddr(InetSocketAddress *saddr,\n\n                                                 Error **errp)\n\n{\n\n    struct addrinfo ai, *res;\n\n    int rc;\n\n    Error *err = NULL;\n\n\n\n    memset(&ai, 0, sizeof(ai));\n\n\n\n    ai.ai_flags = AI_CANONNAME | AI_V4MAPPED | AI_ADDRCONFIG;\n\n    ai.ai_family = inet_ai_family_from_address(saddr, &err);\n\n    ai.ai_socktype = SOCK_STREAM;\n\n\n\n    if (err) {\n\n        error_propagate(errp, err);\n\n        return NULL;\n\n    }\n\n\n\n    if (saddr->host == NULL || saddr->port == NULL) {\n\n        error_setg(errp, \"host and/or port not specified\");\n\n        return NULL;\n\n    }\n\n\n\n    /* lookup */\n\n    rc = getaddrinfo(saddr->host, saddr->port, &ai, &res);\n\n    if (rc != 0) {\n\n        error_setg(errp, \"address resolution failed for %s:%s: %s\",\n\n                   saddr->host, saddr->port, gai_strerror(rc));\n\n        return NULL;\n\n    }\n\n    return res;\n\n}\n", "idx": 6374, "substitutes": {"saddr": ["sconn", "Spart", "Saddress", "jsaddr", "insaddress", "ssadr", "jspart", "ssert", "southacre", "jsaddon", "slive", "mysaddress", "insaddr", "Saddr", "southarp", "sysaddress", "sqllive", "mysaddr", "jslive", "saddress", " sert", "jsadr", "jsadd", "Sadd", " sarp", "dsadd", "insconn", "sqladdr", "ssaddr", "sysaddr", "southord", "saddon", "spart", "Sadr", "sadd", "dsaddr", "dsaddress", "sadr", " sord", "Sconn", "sert", "dsarp", "sord", "jsconn", "jsaddress", "ssadd", "sacre", "jsert", "sarp", " saddress", " sadr", " sacre", "dsord", "dsacre", "sqladdress", "sqladdon", "mysaddon", "inspart", "myslive", "sysadr", " sadd", "sysadd", "southaddr"], "errp": [" errP", "errwp", "errorpart", "fxp", "arrp", "aerpc", "fxpy", "aerpa", "aerp", "acerP", "errps", "errpc", " errpat", "ererp", " errpart", "arrpc", "errpy", "ererpc", "acerwp", "confping", "errpa", "rrp", "errorP", " errping", "acerp", "ererping", "arrps", "errorwp", "errorp", "arrpa", " errpc", "rrps", "rrpa", " errwp", "errpart", "confp", "aerps", "sprpy", "acerpart", "sprpat", "errP", "errpat", "fxpat", "sprp", "errping", "rrpc", " errpy", "confpc"], "ai": ["asi", "ei", "hai", " aux", " na", " ta", " ah", "aaa", "aa", "addr", " ay", "ali", "hi", " ap", "api", "aki", "ait", "pai", "ras", " pa", " an", "aq", "di", " ba", "aug", "cgi", "mi", "aj", " ali", "oci", "ak", "ati", "ay", "aci", " ail", "bi", "ki", "au", "air", "ti", "sa", "ia", "a", " acc", "ape", "ain", " wa", "ci", "ar", " ga", " au", " a", " fa", " da", "ami", "pa", "ae", " ac", "AI", "auth", "oa", "ii", "ao", "ass", " bi", " di", "iam", "acs", "i", " am", " ca", "aim", "iq", " sa", "aut", "aus", "ui", " av", " mi", " ar", "ais"], "res": ["rs", "result", "gc", "results", "ress", "mem", "ber", "gr", "rel", "i", "mr", "raw", "addr", "ms", " RES", "Res", "full", "r", "js", "rev", "rem", "rest", "out", "s", "ras", "RES", "reset", "resh", "resp", "re", "ack", "reg", "ret", "der", "response", "ptr", "GR", "pas", "obj", "ex", "rec", "j", "ro", "rez", "arr", "conn", "RS", "act"], "rc": ["ck", " ro", "rs", "gc", "src", " clen", "c", "pc", "cmp", "bc", "nr", "cs", "rx", "sc", "ry", "cor", "ok", "rn", "fc", "co", " src", "nc", "ec", "iq", "sync", "cb", "rob", "ce", "cc", "roc", "rr", "arc", " ec", "code", "cr", "ras", "sec", "rt", "rl", "ack", "uc", "rin", "usc", "isc", "cv", "cd", "cur", "nz", "rec", "tc", "ctr", "irc", "RC", "hr", " sc", " cr"], "err": [" terr", "ev", "rs", "eor", "error", "ei", "Er", "lr", "fee", "kr", "gr", "eas", "buf", "aaa", "mr", "cor", "exc", "er", "rn", "die", "erd", "p", "cmd", "order", "addr", "urg", "notice", "ec", "timer", "cb", "usr", "erb", "errors", "ere", "r", "dr", "rr", "attr", "esp", "rb", "org", "iter", "ah", "txt", "ait", "req", "cfg", "resp", "ch", "inner", "der", "gz", "cer", "later", " Err", "obj", "oe", "fr", "arr", "Error", "warn", "conn", "msg", "elt"]}}
{"project": "qemu", "commit_id": "4482e05cbbb7e50e476f6a9500cf0b38913bd939", "target": 1, "func": "static void bamboo_init(MachineState *machine)\n\n{\n\n    ram_addr_t ram_size = machine->ram_size;\n\n    const char *kernel_filename = machine->kernel_filename;\n\n    const char *kernel_cmdline = machine->kernel_cmdline;\n\n    const char *initrd_filename = machine->initrd_filename;\n\n    unsigned int pci_irq_nrs[4] = { 28, 27, 26, 25 };\n\n    MemoryRegion *address_space_mem = get_system_memory();\n\n    MemoryRegion *isa = g_new(MemoryRegion, 1);\n\n    MemoryRegion *ram_memories\n\n        = g_malloc(PPC440EP_SDRAM_NR_BANKS * sizeof(*ram_memories));\n\n    hwaddr ram_bases[PPC440EP_SDRAM_NR_BANKS];\n\n    hwaddr ram_sizes[PPC440EP_SDRAM_NR_BANKS];\n\n    qemu_irq *pic;\n\n    qemu_irq *irqs;\n\n    PCIBus *pcibus;\n\n    PowerPCCPU *cpu;\n\n    CPUPPCState *env;\n\n    uint64_t elf_entry;\n\n    uint64_t elf_lowaddr;\n\n    hwaddr loadaddr = 0;\n\n    target_long initrd_size = 0;\n\n    DeviceState *dev;\n\n    int success;\n\n    int i;\n\n\n\n    /* Setup CPU. */\n\n    if (machine->cpu_model == NULL) {\n\n        machine->cpu_model = \"440EP\";\n\n    }\n\n    cpu = POWERPC_CPU(cpu_generic_init(TYPE_POWERPC_CPU, machine->cpu_model));\n\n    if (cpu == NULL) {\n\n        fprintf(stderr, \"Unable to initialize CPU!\\n\");\n\n        exit(1);\n\n    }\n\n    env = &cpu->env;\n\n\n\n    if (env->mmu_model != POWERPC_MMU_BOOKE) {\n\n        fprintf(stderr, \"MMU model %i not supported by this machine.\\n\",\n\n            env->mmu_model);\n\n        exit(1);\n\n    }\n\n\n\n    qemu_register_reset(main_cpu_reset, cpu);\n\n    ppc_booke_timers_init(cpu, 400000000, 0);\n\n    ppc_dcr_init(env, NULL, NULL);\n\n\n\n    /* interrupt controller */\n\n    irqs = g_malloc0(sizeof(qemu_irq) * PPCUIC_OUTPUT_NB);\n\n    irqs[PPCUIC_OUTPUT_INT] = ((qemu_irq *)env->irq_inputs)[PPC40x_INPUT_INT];\n\n    irqs[PPCUIC_OUTPUT_CINT] = ((qemu_irq *)env->irq_inputs)[PPC40x_INPUT_CINT];\n\n    pic = ppcuic_init(env, irqs, 0x0C0, 0, 1);\n\n\n\n    /* SDRAM controller */\n\n    memset(ram_bases, 0, sizeof(ram_bases));\n\n    memset(ram_sizes, 0, sizeof(ram_sizes));\n\n    ram_size = ppc4xx_sdram_adjust(ram_size, PPC440EP_SDRAM_NR_BANKS,\n\n                                   ram_memories,\n\n                                   ram_bases, ram_sizes,\n\n                                   ppc440ep_sdram_bank_sizes);\n\n    /* XXX 440EP's ECC interrupts are on UIC1, but we've only created UIC0. */\n\n    ppc4xx_sdram_init(env, pic[14], PPC440EP_SDRAM_NR_BANKS, ram_memories,\n\n                      ram_bases, ram_sizes, 1);\n\n\n\n    /* PCI */\n\n    dev = sysbus_create_varargs(TYPE_PPC4xx_PCI_HOST_BRIDGE,\n\n                                PPC440EP_PCI_CONFIG,\n\n                                pic[pci_irq_nrs[0]], pic[pci_irq_nrs[1]],\n\n                                pic[pci_irq_nrs[2]], pic[pci_irq_nrs[3]],\n\n                                NULL);\n\n    pcibus = (PCIBus *)qdev_get_child_bus(dev, \"pci.0\");\n\n    if (!pcibus) {\n\n        fprintf(stderr, \"couldn't create PCI controller!\\n\");\n\n        exit(1);\n\n    }\n\n\n\n    memory_region_init_alias(isa, NULL, \"isa_mmio\",\n\n                             get_system_io(), 0, PPC440EP_PCI_IOLEN);\n\n    memory_region_add_subregion(get_system_memory(), PPC440EP_PCI_IO, isa);\n\n\n\n    if (serial_hds[0] != NULL) {\n\n        serial_mm_init(address_space_mem, 0xef600300, 0, pic[0],\n\n                       PPC_SERIAL_MM_BAUDBASE, serial_hds[0],\n\n                       DEVICE_BIG_ENDIAN);\n\n    }\n\n    if (serial_hds[1] != NULL) {\n\n        serial_mm_init(address_space_mem, 0xef600400, 0, pic[1],\n\n                       PPC_SERIAL_MM_BAUDBASE, serial_hds[1],\n\n                       DEVICE_BIG_ENDIAN);\n\n    }\n\n\n\n    if (pcibus) {\n\n        /* Register network interfaces. */\n\n        for (i = 0; i < nb_nics; i++) {\n\n            /* There are no PCI NICs on the Bamboo board, but there are\n\n             * PCI slots, so we can pick whatever default model we want. */\n\n            pci_nic_init_nofail(&nd_table[i], pcibus, \"e1000\", NULL);\n\n        }\n\n    }\n\n\n\n    /* Load kernel. */\n\n    if (kernel_filename) {\n\n        success = load_uimage(kernel_filename, &entry, &loadaddr, NULL,\n\n                              NULL, NULL);\n\n        if (success < 0) {\n\n            success = load_elf(kernel_filename, NULL, NULL, &elf_entry,\n\n                               &elf_lowaddr, NULL, 1, PPC_ELF_MACHINE,\n\n                               0, 0);\n\n            entry = elf_entry;\n\n            loadaddr = elf_lowaddr;\n\n        }\n\n        /* XXX try again as binary */\n\n        if (success < 0) {\n\n            fprintf(stderr, \"qemu: could not load kernel '%s'\\n\",\n\n                    kernel_filename);\n\n            exit(1);\n\n        }\n\n    }\n\n\n\n    /* Load initrd. */\n\n    if (initrd_filename) {\n\n        initrd_size = load_image_targphys(initrd_filename, RAMDISK_ADDR,\n\n                                          ram_size - RAMDISK_ADDR);\n\n\n\n        if (initrd_size < 0) {\n\n            fprintf(stderr, \"qemu: could not load ram disk '%s' at %x\\n\",\n\n                    initrd_filename, RAMDISK_ADDR);\n\n            exit(1);\n\n        }\n\n    }\n\n\n\n    /* If we're loading a kernel directly, we must load the device tree too. */\n\n    if (kernel_filename) {\n\n        if (bamboo_load_device_tree(FDT_ADDR, ram_size, RAMDISK_ADDR,\n\n                                    initrd_size, kernel_cmdline) < 0) {\n\n            fprintf(stderr, \"couldn't load device tree\\n\");\n\n            exit(1);\n\n        }\n\n    }\n\n}\n", "idx": 6385, "substitutes": {"machine": ["policy", "world", "chain", "magic", "instance", "power", "node", "computer", "managed", "note", "job", "hard", "model", "state", "template", "display", "zone", "domain", "connection", "green", "link", "monitor", "process", "environment", "server", "keeper", "me", "money", "module", "linux", "entity", "device", "password", "mode", "gate", "achine", "host", "memory", "man", "iso", "common", "command", "m", "frame", "config", "comment", "controller", "worker", "hello", "alias", "handler", "session", "manager", "Machine", "mc", "message", "sim", "vm", "smart", "engine", "check", "mouse", "series", "shell", "menu", "agent", "image"], "kernel_filename": ["kernel_type", "kernelpylabel", "kernelpydetails", "system_label", "system_details", "system_file", "kernel_file", "kernelpyfile", "kernelloglabel", "kernel_name", "kernellogfilename", "system_filename", "kernellogdetails", "kernel_details", "kernel_label", "kernelpyfilename", "machine_filename", "machine_file", "machine_name", "machine_type", "kernellogfile"], "kernel_cmdline": ["kernel_cmdlink", "kernel_cmdlines", "kernel_hostname", "kernel_hostlines", "kernel_commandname", "kernel_commandlink", "kernel_extlines", "kernel_commandline", "kernel_extlink", "kernel_cmdname", "kernel_extline", "kernel_bindlink", "kernel_bindline", "kernel_commandlines", "kernel_bindname", "kernel_hostline", "kernel_bindlines"], "initrd_filename": ["initrd__Filename", "initrd__filename", "initrdetyjson", "initrd_directory", "initrd_files", "initrb_filename", "initrd_Filename", "initrs_file", "initrd_file", "initrdetydirectory", "initrb_Filename", "initrs_json", "initrd__files", "initrs_directory", "initrdetyfilename", "initrb_file", "initrs_filename", "initrd_json", "initrdetyfile", "initrb_files", "initrd__file"], "pci_irq_nrs": ["pci_irq_numrs", "pci_irq_srs", "pci_irq_snodes", "pci_irq_nris", "pci_irq_sodes", "pci_irq2nrs", "pci_irq_numris", "pci_irq2snps", "pci_irq2snris", "pci_irq_sris", "pci_irq2snodes", "pci_irq_snps", "pci_irq_numodes", "pci_irq2nris", "pci_irq_sps", "pci_irq_snris", "pci_irq_nps", "pci_irq_snrs", "pci_irq2snrs", "pci_irq2nodes", "pci_irq2nps", "pci_irq_nodes", "pci_irq_numps"], "address_space_mem": ["address_line_memory", "address_line_ram", "address_line_mem", "address_space_map", "address_space_ram", "address_space2memory", "address_space2map", "address_space2ram", "address_space2mem", "address_line_map", "address_space_memory"], "isa": ["asi", "asa", "amin", "aria", "iva", "sha", "ila", "aa", "ami", "si", "is", "ya", "ida", "igi", "iso", "ista", "ISA", "ea", "ina", "isc", "iza", "agi", "aka", "ia", "isi", "sis", "sta", "esa", "ii"], "ram_memories": ["ram_memos", "ram_tempory", "ram_cryptologies", "ram_histometers", "ram_temory", "ram_history", "ram_cryptograms", "ram_temos", "ram_temories", "ram_cryptories", "ram_tempos", "ram_histories", "ram_temograms", "ram_memograms", "ram_tempometers", "ram_histos", "ram_temologies", "ram_temometers", "ram_cryptory", "ram_tempories", "ram_memometers", "ram_histograms", "ram_memologies", "ram_memory", "ram_histologies"], "ram_bases": ["ram_Bias", "ram_Bases", "ram_beases", "ram_Bounds", "ram_bounds", "ram_bease", "ram_beounds", "ram_nbounds", "ram_nbases", "ram_beias", "ram_bias", "ram_Base", "ram_nbase", "ram_base", "ram_nbias"], "ram_sizes": ["ram_seizers", "ram_seids", "ram_ssizers", "ram_sizers", "ram_sids", "ram_sumbers", "ram_seumbers", "ram_bumbers", "ram_ssids", "ram_ssizes", "ram_bids", "ram_bizes", "ram_ssumbers", "ram_seizes", "ram_bizers"], "pic": ["ic", "asi", "pid", "gc", "wp", "pc", "eric", "cam", "pan", "anc", "ik", "mi", "fc", "pa", "pol", "wic", "xi", "mic", "pi", "nic", "txt", "inis", "ig", "pac", "jp", "mc", "fi", "isi", "pin"], "irqs": ["IRqi", " irques", "mirques", "ireigs", "mirews", "mirqs", "iorews", "irqi", "pirqs", " irews", "pirques", " irq", "mirq", "irqq", "ireews", "IRques", "pirqq", "rinews", "irq", "iorqs", "ireq", "rinqs", "irques", "pirq", "pirqi", "iorigs", "ireqq", "IRq", "irigs", "rinq", "iorqq", "ireqs", "IRqs", "ireqi", "irews", "pirigs", "ireques", "pirews", "rinques"], "pcibus": [" pcis", "pcia", "mcia", "pcis", "mciu", "pciu", "PCia", " pciu", "mcibus", " pcia", "mcis", "PCibus", "PCiu", "PCis"], "cpu": ["ck", "CPU", "gc", "desktop", "node", "mem", "cum", "cp", "po", "ola", "pu", "ctx", "pc", "cli", "cam", "ka", "clock", "client", " CPU", "ram", "cow", "uart", "nice", "util", "cmd", "chip", "php", "process", "ce", "hw", "phys", "nu", "linux", "proc", "mu", "mac", "device", "cn", "nic", "memory", "bean", "processor", "pixel", "uu", "cv", "pool", "disk", "cache", "np", "aco", "uda", "core", "vm", "boot", "net", "cu", "rom", "gpu", "conn", "computer"], "env": ["ei", "po", "conf", "den", "buf", "except", "eg", "ec", "enter", "environment", "pe", "gear", "docker", "device", "en", "worker", "entry", "enc", " agent", "mem", "stage", "cookie", "ve", "er", " vm", "context", "server", "el", "esp", "v", "config", "vs", "priv", "desc", "info", "oe", "db", "ev", "export", "et", "end", "ctx", "eni", "dem", "em", "era", "extra", "ent", "viron", "hw", " environment", "agent", "ote", "nv", "common", " en", "vm", "net", "engine", " engine", "app", "window", "here", "eas", "con", "te", "erd", "ext", "ew", "eng", "me", "proc", "ef", "eu", "ea", " ent", "equ", "alias", "ee", "vt", "obj", " ev", "e", "conn", "def", " envoy"], "elf_entry": ["elf_ptr", "elf2entry", "elf2addr", "elf2ptr", "ipel_entry", "ipel_ptr", "elf2info", "ipel_addr", "ipel_info", "elf_addr", "elf_info"], "elf_lowaddr": ["elf_highaddress", "elf_loadptr", "elf_smallr", "elf_smallptr", "elf_loadaddr", "elf_highptr", "elf_highaddr", "elf_highr", "elf_lowr", "elf_lowptr", "elf_lowaddress", "elf_loadaddress", "elf_smalladdress", "elf_loadr", "elf_smalladdr"], "dev": ["db", "ev", "node", "mem", "def", "cam", "DEV", "sys", "ve", "sd", "vision", "ds", "hw", "device", "vo", "fin", "cho", "serv", "doc", "disk", "de", "gu", "vm", "res", "di", "Dev", "conn"], "success": ["result", "b", " clen", "h", "ok", "aj", "os", " successes", "g", "d", "A", "usr", "o", "lo", "err", "go", "rc", "k", "code", "s", "num", "status", "Success", " o", "ia", "e", "j", "res"], "i": ["ci", "b", "it", "im", "c", "h", "mi", "ip", "li", "p", "g", "t", "pi", "r", "v", "m", "I", "y", "f", "ia", "fi", "io", "iu", "e", "j", "x", "ii", "l"]}}
{"project": "qemu", "commit_id": "6476615d385eb249105b25873ef30ba4b9c808dc", "target": 0, "func": "void HELPER(stpq)(CPUS390XState *env, uint64_t addr,\n\n                  uint64_t low, uint64_t high)\n\n{\n\n    uintptr_t ra = GETPC();\n\n\n\n    if (parallel_cpus) {\n\n#ifndef CONFIG_ATOMIC128\n\n        cpu_loop_exit_atomic(ENV_GET_CPU(env), ra);\n\n#else\n\n        int mem_idx = cpu_mmu_index(env, false);\n\n        TCGMemOpIdx oi = make_memop_idx(MO_TEQ | MO_ALIGN_16, mem_idx);\n\n\n\n        Int128 v = int128_make128(low, high);\n\n        helper_atomic_sto_be_mmu(env, addr, v, oi, ra);\n\n#endif\n\n    } else {\n\n        check_alignment(env, addr, 16, ra);\n\n\n\n        cpu_stq_data_ra(env, addr + 0, high, ra);\n\n        cpu_stq_data_ra(env, addr + 8, low, ra);\n\n    }\n\n}\n", "idx": 6408, "substitutes": {"env": ["outer", "esc", "sw", "conf", "h", "ra", "den", "sc", "self", "dev", "enter", "cb", "environment", "queue", "w", "pg", "en", "ah", "txt", "entry", "home", "cur", "enc", "ve", "er", "context", "eh", "server", "esp", "code", "v", "config", "vs", "desc", "En", "shell", "db", "ev", "et", "end", "ctx", "msg", "nc", "viron", "hw", "rc", "pkg", "eq", "org", "nv", "st", "cv", "EN", "vm", "net", "init", "sp", "node", "window", "con", "te", "erd", "cmd", "Environment", "proc", "tx", "ptr", "equ", "vt", "obj", "e", "conn", "nw"], "addr": ["src", "oa", "mem", "asm", "ctx", "tp", "sha", "offset", "pad", "store", "msg", "arch", "cmd", "add", "arp", "url", "hw", "alt", "r", "dr", "rc", "ref", "id", "pos", "pkg", "inter", "attr", "expr", "align", "gate", "ad", "handle", "ix", "Address", "rt", "ack", "now", "tx", "ptr", "arity", "alias", "address", "ord", "obj", "eth", "hash", "adr", "ace", "arr", "x", "work", "coord", "name", "loc", "act"], "low": ["mem", "late", "gl", "cmp", "offset", "pro", "dem", "nd", "last", "mid", "flow", "dl", "light", "len", "lu", "zero", "ind", "row", "lc", "data", "range", "lo", "hi", "from", "old", "scale", "slice", "ly", "little", "level", "mode", "lim", "req", "small", "m", "now", "local", "Low", "diff", "min", "size", "dis", "lower", "l", "le", "loc"], "high": ["upper", "large", "gh", "end", "highest", "igh", "High", "h", "up", "ra", "last", "alpha", "mid", "flow", "med", "co", "vol", "hub", "row", "peak", "full", "history", "hi", "range", "height", "bound", "lo", "value", "rem", "top", "phi", "max", "v", "sh", "hei", "final", "re", "pper", "ho", " High", "close", "cur", "hist", "hl", "length", "x", "higher"]}}
{"project": "FFmpeg", "commit_id": "2da0d70d5eebe42f9fcd27ee554419ebe2a5da06", "target": 1, "func": "static inline void RENAME(yuy2ToUV)(uint8_t *dstU, uint8_t *dstV, uint8_t *src1, uint8_t *src2, long width)\n\n{\n\n#ifdef HAVE_MMX\n\n\tasm volatile(\n\n\t\t\"movq \"MANGLE(bm01010101)\", %%mm4\\n\\t\"\n\n\t\t\"mov %0, %%\"REG_a\"\t\t\\n\\t\"\n\n\t\t\"1:\t\t\t\t\\n\\t\"\n\n\t\t\"movq (%1, %%\"REG_a\",4), %%mm0\t\\n\\t\"\n\n\t\t\"movq 8(%1, %%\"REG_a\",4), %%mm1\t\\n\\t\"\n\n\t\t\"psrlw $8, %%mm0\t\t\\n\\t\"\n\n\t\t\"psrlw $8, %%mm1\t\t\\n\\t\"\n\n\t\t\"packuswb %%mm1, %%mm0\t\t\\n\\t\"\n\n\t\t\"movq %%mm0, %%mm1\t\t\\n\\t\"\n\n\t\t\"psrlw $8, %%mm0\t\t\\n\\t\"\n\n\t\t\"pand %%mm4, %%mm1\t\t\\n\\t\"\n\n\t\t\"packuswb %%mm0, %%mm0\t\t\\n\\t\"\n\n\t\t\"packuswb %%mm1, %%mm1\t\t\\n\\t\"\n\n\t\t\"movd %%mm0, (%3, %%\"REG_a\")\t\\n\\t\"\n\n\t\t\"movd %%mm1, (%2, %%\"REG_a\")\t\\n\\t\"\n\n\t\t\"add $4, %%\"REG_a\"\t\t\\n\\t\"\n\n\t\t\" js 1b\t\t\t\t\\n\\t\"\n\n\t\t: : \"g\" (-width), \"r\" (src1+width*4), \"r\" (dstU+width), \"r\" (dstV+width)\n\n\t\t: \"%\"REG_a\n\n\t);\n\n#else\n\n\tint i;\n\n\tfor(i=0; i<width; i++)\n\n\t{\n\n\t\tdstU[i]= src1[4*i + 1];\n\n\t\tdstV[i]= src1[4*i + 3];\n\n\t}\n\n#endif\n\n        assert(src1 == src2);\n\n}\n", "idx": 6432, "substitutes": {"dstU": ["dputG", "dtdR", " dputU", "destUS", "dSTU", "lstUI", "dstUS", "ddestPU", "dputPU", "lstUp", "dportEU", "fdstPU", "dportU", "dstUp", "dportUI", "dostUS", "dputUV", "dSTEU", "ddestG", "dtdG", "dndEU", "destU", " dputEU", "dputEU", "dstUI", "fdtdPU", "fdstR", "dstR", " dstEU", "lstEU", "dSTUp", "dndUI", "destUV", "dputR", "lstU", "fdtdU", "dostEU", " dstUS", "dtdU", "dstPU", "dostUV", "lndUI", "dputU", "dostU", "lndEU", "dstUV", "ddestR", "dportUp", " dputUS", "dndUp", "lndUp", "dstG", " dputUV", "dputUS", "fdtdG", "fdstG", "dndU", "ddestU", "fdtdR", " dstUV", "destEU", "dSTUI", "dtdPU", "fdstU", "dstEU", "lndU"], "dstV": [" dblVC", "DstG", "wtdTV", " dblv", "dstTV", "dtdVC", "dtdV", "dblv", "dvVC", "dstJ", "dstVC", "dblJ", "dstrVC", "dvU", "dvG", "dndVC", "dostVC", "dstv", "DstV", "wtdVR", "dntV", "DstVC", "wstVC", "wstVR", "DndU", "wstV", "wtdV", "dictv", " dstv", "dostTV", "dendV", "dtdTV", "dendVC", "dntVC", "dstrTV", "dstrVR", "dtdVR", " dstJ", "dendJ", "DstU", "dostVR", "dictV", "dndV", "dntG", "wtdVC", "dstVR", "wstTV", "DndG", "dictJ", "dntU", "dictVC", " dblV", "dstG", "dostV", "dendv", " dstVC", "dstrV", "dndU", "dndG", "DndV", "dvV", "dblV", "dblVC", " dblJ", "DndVC"], "src1": ["sourceOne", "sr8", " src3", "usc0", "usc91", "source2", "loc0", "source8", "srcOne", "rc2", "source01", "loc1", "sr0", "locOne", "loc2", " src91", "src0", "rc8", "src01", "rc3", "sr2", "source3", "usc2", "rc1", " src01", "rc01", "source1", "src3", "rc0", "usc1", "src91", "source0", "sr1", "src8", "rcOne", "rc91", " src0"], "src2": ["rc4", " src3", "source2", " srcTwo", "rc2", "rc3", "sr2", "srTwo", "source3", "rcTwo", "rc1", "src4", "sr3", "source1", "src3", "source4", "sr1", " src4", "srcTwo"], "i": ["depth", "asi", "chain", "ei", " ii", "gi", "zi", "ind", " ti", "key", "pi", " pi", "iter", " j", "I", "batch", "in", "j", "di", "\u0438", "x", "this", "ic", "mi", "xi", "index", "ri", "bi", "ki", "span", "ti", "out", "v", "ai", "m", "remote", "us", "info", "ci", "it", "ip", "li", "p", "ami", "is", "ski", " I", "fi", "ii", "name", "init", "ini", "ij", "sp", "uri", "cli", "oi", "qi", "si", "n", " err", "multi", "me", "ui", "slice", "ji", "id", "phi", "ims", "ix", "status", "print", "sim", "iu", "point"]}}
{"project": "FFmpeg", "commit_id": "fdbbf2e0fc1bb91a5d735a49f39337eb172e68a7", "target": 0, "func": "static void h261_v_loop_filter_c(uint8_t *dest,uint8_t *src, int stride){\n\n    int i,j,xy,yz;\n\n    int res;\n\n    for(i=0; i<8; i++){\n\n        for(j=1; j<7; j++){\n\n            xy = j * stride + i;\n\n            yz = j * 8 + i;\n\n            res = (int)src[yz-1*8] + ((int)(src[yz+0*8]) * 2) + (int)src[yz+1*8];\n\n            res +=2;\n\n            res >>=2;\n\n            dest[xy] = (uint8_t)res;\n\n        }\n\n    }\n\n}\n", "idx": 6452, "substitutes": {"dest": ["loc", "result", "mem", "target", "est", "save", "set", "map", "d", "table", "tr", "usr", "data", "temp", "w", "pos", "list", "master", "rest", "Dest", "out", "iter", "v", "dist", "port", "new", "spec", "ptr", "scan", "desc", "priv", "cat", "obj", "sum", "decl", "trans", "source", "vec"], "src": ["rs", "loc", "b", "ser", "copy", "sr", "view", "bc", "sc", "seq", "inst", "impl", "sync", "input", "js", "str", "rc", "slice", "ins", "syn", "proc", "pkg", "sb", "s", "txt", "Source", "sec", "sh", "sur", "rt", "inner", "stream", "sl", "st", "sub", "ch", "usc", "secure", "img", "ptr", "supp", "sq", "ur", "desc", "cur", "in", "comp", "ctr", "stock", "source"], "stride": ["spIDE", "strIDE", "state", "fride", "sprude", "stide", "spide", "Strude", "spride", "frude", "frade", "Stride", "Strade", "STRIDE", "sprade", "stIDE", "strride", "strate", "spate", "STRride", "strude", "strade", "STRide", "STRate"], "i": ["init", "ic", "ij", "ini", "ci", " ii", "it", "im", "IJ", "h", "mi", "my", "qi", "at", "ip", "li", "ami", "si", "ie", "zi", "n", "is", "iq", "ind", "xi", "o", "hi", "pi", "bi", "multi", "me", "ui", "id", "ki", "ji", " I", "phi", "ti", "iter", "v", "ims", "ix", "ai", "m", "wi", "I", "iat", "y", "ish", "\u0438", "f", "ia", "us", "sim", "io", "iu", "e", "by", "z", "x", "di", "ni", "ii", "l"], "j": ["dj", "ja", "ij", "q", "jo", "bj", "it", "jj", "job", "J", "br", "kh", "pt", "aj", "at", "er", "p", "ie", "n", "ge", "on", "uj", "jas", "o", "key", "bi", "jc", "r", "js", "el", "let", "ji", "ion", "oj", "v", "jac", "bs", "y", "jump", "jp", "jit", "je", "ju", "obj", "jl", "e", "by", "kj", "z", "fr", "json", "x", "other"], "xy": ["fy", "rot", "wy", "ox", "wx", "my", "ube", "px", "ele", "ie", "mx", "zo", "xx", "ay", "hi", "XY", "zip", "zz", "pos", "py", "dx", "che", "yy", "ot", "roxy", "iso", "foo", "yt", "y", "biz", "yx", "sky", "chan", "fo", "io", "ey", "oe", "oxy", "z", "xxx", "x", "json", "cho", "coord", "oy", "axy"], "yz": ["dj", "eddy", "zy", "fy", "cz", "cy", "iaz", "zon", "wy", "ox", "lat", "sys", "yi", "ry", "ky", "gy", "zh", "zi", "xx", "lib", "zzy", "hz", "ez", "iq", "err", "zip", "zz", "js", "yy", "tz", "ot", "qq", "dq", "cart", "gz", "yt", "y", "biz", "yx", "sky", "uz", "oz", "nz", "yout", "z", "xxx", "az", "oy", "loc", "axy"], "res": ["rs", "result", "des", "results", "ress", "mem", "sol", "gr", "rel", "cs", "os", "ps", "norm", "vol", "ms", "yes", "val", "Res", "red", "vals", "css", "r", "rss", "js", "prime", "rc", "resource", "expr", "rem", "rest", "RES", "req", "reset", "resh", "dq", "re", "resp", "bs", "ret", "cond", "cons", "obj", "VAL", "sum", "pres", "z", "stock", "def", "resolution", "vec"]}}
{"project": "FFmpeg", "commit_id": "c3ab0004ae4dffc32494ae84dd15cfaa909a7884", "target": 1, "func": "static inline void RENAME(uyvyToY)(uint8_t *dst, const uint8_t *src, int width, uint32_t *unused)\n\n{\n\n#if COMPILE_TEMPLATE_MMX\n\n    __asm__ volatile(\n\n        \"mov                  %0, %%\"REG_a\"         \\n\\t\"\n\n        \"1:                                         \\n\\t\"\n\n        \"movq  (%1, %%\"REG_a\",2), %%mm0             \\n\\t\"\n\n        \"movq 8(%1, %%\"REG_a\",2), %%mm1             \\n\\t\"\n\n        \"psrlw                $8, %%mm0             \\n\\t\"\n\n        \"psrlw                $8, %%mm1             \\n\\t\"\n\n        \"packuswb          %%mm1, %%mm0             \\n\\t\"\n\n        \"movq              %%mm0, (%2, %%\"REG_a\")   \\n\\t\"\n\n        \"add                  $8, %%\"REG_a\"         \\n\\t\"\n\n        \" js                  1b                    \\n\\t\"\n\n        : : \"g\" ((x86_reg)-width), \"r\" (src+width*2), \"r\" (dst+width)\n\n        : \"%\"REG_a\n\n    );\n\n#else\n\n    int i;\n\n    for (i=0; i<width; i++)\n\n        dst[i]= src[2*i+1];\n\n#endif\n\n}\n", "idx": 6455, "substitutes": {"dst": ["sput", "sst", "Dbr", "lsts", "sest", " dtd", "dbr", "ddest", "dsts", "sdest", "hest", " dsts", "hdest", "lbr", "Dsts", "Dest", "lst", " dest", "Dst", "ldest", "Ddest", "Dput", "Dtd", " dbr", "dest", "dput", "dtd", "htd", " dput", " ddest", "hst"], "src": ["rs", "loc", "filename", "ust", "sr", "pack", "sys", "sc", "sup", "seq", "inst", "lib", "usr", "r", "input", "str", "th", "rc", "slice", "ins", "proc", "attr", "sb", "s", "out", "rb", "txt", "dist", "sec", "req", "rt", "sl", "sur", "rl", "st", "sub", "usc", "ptr", "img", "sq", "supp", "ur", "ord", "desc", "dest", "cur", "in", "via", "hl", "ctr", "x", "trans", "RC", "source", "bin"], "unused": ["unchecked", "universe", " universe", "Unuse", "sunchecked", "sunuse", "suniverse", " unchecked", "Unchecked", "sunused", "Unused", "unuse", " unuse", "Universe"], "i": ["init", "ini", "ic", "chain", " bi", "sp", "ci", "b", " ii", "uni", "it", "im", "u", "cli", " v", "oi", "gi", "mi", "qi", "ip", "li", "p", "si", "zi", "n", "is", "xi", "ind", "index", " ti", "t", "bi", "pi", " err", "multi", "ri", "me", "ui", "id", "ki", "span", " I", "phi", "ti", "iter", "try", "v", "ims", "ix", " j", "ai", "m", "status", "I", "batch", "y", "\u0438", "f", "sim", "gu", "iu", "j", "di", "x", "ii", "l"]}}
{"project": "qemu", "commit_id": "aec4b054ea36c53c8b887da99f20010133b84378", "target": 1, "func": "static void simple_number(void)\n\n{\n\n    int i;\n\n    struct {\n\n        const char *encoded;\n\n        int64_t decoded;\n\n        int skip;\n\n    } test_cases[] = {\n\n        { \"0\", 0 },\n\n        { \"1234\", 1234 },\n\n        { \"1\", 1 },\n\n        { \"-32\", -32 },\n\n        { \"-0\", 0, .skip = 1 },\n\n        { },\n\n    };\n\n\n\n    for (i = 0; test_cases[i].encoded; i++) {\n\n        QInt *qint;\n\n\n\n        qint = qobject_to_qint(qobject_from_json(test_cases[i].encoded, NULL));\n\n        g_assert(qint);\n\n        g_assert(qint_get_int(qint) == test_cases[i].decoded);\n\n        if (test_cases[i].skip == 0) {\n\n            QString *str;\n\n\n\n            str = qobject_to_json(QOBJECT(qint));\n\n            g_assert(strcmp(qstring_get_str(str), test_cases[i].encoded) == 0);\n\n            QDECREF(str);\n\n        }\n\n\n\n        QDECREF(qint);\n\n    }\n\n}\n", "idx": 6486, "substitutes": {"i": ["init", "ic", "ij", "asi", "ini", " bi", "ei", "ci", "chain", " ii", "uri", "it", "ori", "cli", "gl", " x", "yi", " v", "oi", "gi", "mi", "ip", "li", "p", "si", " n", "zi", "n", "is", "xi", "ind", "index", " ti", "t", "pi", "multi", "bi", "go", "dr", "me", "id", "ui", "ki", "to", "ji", " I", "phi", "ti", " iter", "v", "ims", "ix", " j", "ai", "m", "ri", "status", "I", "batch", "y", "\u0438", " index", "sim", "io", "info", "iu", "j", "series", "x", "di", "ii"], "encoded": ["encored", "decoding", " decrypted", "eccoded", "encleted", "encrypted", "encached", "decoded", "enanded", "Encrypted", "enleted", "ecached", "expoded", "enored", "ecoded", "encoder", "enoded", "decaled", "decrypted", "enrypted", "exprypted", "ecoder", "enccoded", "expcoded", " decaled", " decleted", "Encoding", "decoder", "decleted", "encanded", "expoding", "enoder", "Encoded", "encaled", "decored", " encanded", "decached", " decoded", "Enccoded", "enached", "encoding", "enaled", " encrypted", " encored", "decanded", "deccoded"], "test_cases": ["old___case", "update_except", "test_case", "test___packs", "old_abilities", "old_case", "update_drivers", " test_times", " test_abilities", "test2times", "test2cases", "test___case", "test17except", "train_cases", "test___abilities", "test17drivers", "test_features", "fake_cases", "test_times", "test2steps", " test_case", "old___cases", "fake_times", "test67abilities", "update_features", "test17features", "old___abilities", "test_steps", "update_cases", "test___tests", "test_drivers", "old___tests", "test_abilities", "test___cases", "test67case", "test_except", "test67cases", "train_case", "test_packs", "train_packs", "test17cases", "fake_steps", "old_cases", "old_tests", "test_tests"], "qint": ["gInt", "qvuint", "queryint", "quINT", "qustr", "quInt", "dqstr", "quind", "dquint", "qucheck", "iqinter", "quinit", "qinit", " qinit", "gi", "qi", "dqinter", "qInt", " qinter", "quinter", "qINT", "qqint", "qqInt", "qquint", "qqpoint", "qind", "ginit", "qqINT", "queryInt", "qinter", "iqint", "iqpoint", "qvcheck", "qvint", " qpoint", "dqpoint", "dqcheck", "qbit", "qui", " qi", " qbit", "queryind", " qInt", "quuint", " quint", "qcheck", "qpoint", "iqbit", "dqbit", "dqint", "quint", "qqinter", "dqInt", "qqind", "queryINT", "gint", "qstr", " qind", "qvstr"], "str": ["draw", "Str", "rs", "chain", "sp", "sw", "ns", "sr", "br", "cont", "buf", "cs", "msg", "seq", "g", "p", "vol", "mt", "n", "url", "tr", "t", "temp", "r", "dr", "pr", "s", "cr", "txt", "shr", "st", "ss", "print", "bl", "obj", "sts", "fr", "ctr", "j", "arr", "spr", "text", "String", "STR"]}}
{"project": "FFmpeg", "commit_id": "951e715cebfaffced7f13c1525771ff917fe1d38", "target": 1, "func": "static int video_thread(void *arg)\n\n{\n\n    VideoState *is = arg;\n\n    AVFrame *frame = avcodec_alloc_frame();\n\n    int64_t pts_int;\n\n    double pts;\n\n    int ret;\n\n\n\n#if CONFIG_AVFILTER\n\n    AVFilterGraph *graph = avfilter_graph_alloc();\n\n    AVFilterContext *filt_out = NULL;\n\n    int64_t pos;\n\n    int last_w = is->video_st->codec->width;\n\n    int last_h = is->video_st->codec->height;\n\n\n\n    if ((ret = configure_video_filters(graph, is, vfilters)) < 0)\n\n        goto the_end;\n\n    filt_out = is->out_video_filter;\n\n#endif\n\n\n\n    for (;;) {\n\n#if !CONFIG_AVFILTER\n\n        AVPacket pkt;\n\n#else\n\n        AVFilterBufferRef *picref;\n\n        AVRational tb;\n\n#endif\n\n        while (is->paused && !is->videoq.abort_request)\n\n            SDL_Delay(10);\n\n#if CONFIG_AVFILTER\n\n        if (   last_w != is->video_st->codec->width\n\n            || last_h != is->video_st->codec->height) {\n\n            av_dlog(NULL, \"Changing size %dx%d -> %dx%d\\n\", last_w, last_h,\n\n                    is->video_st->codec->width, is->video_st->codec->height);\n\n            avfilter_graph_free(&graph);\n\n            graph = avfilter_graph_alloc();\n\n            if ((ret = configure_video_filters(graph, is, vfilters)) < 0)\n\n                goto the_end;\n\n            filt_out = is->out_video_filter;\n\n            last_w = is->video_st->codec->width;\n\n            last_h = is->video_st->codec->height;\n\n        }\n\n        ret = get_filtered_video_frame(filt_out, frame, &picref, &tb);\n\n        if (picref) {\n\n            pts_int = picref->pts;\n\n            pos     = picref->pos;\n\n            frame->opaque = picref;\n\n        }\n\n\n\n        if (av_cmp_q(tb, is->video_st->time_base)) {\n\n            av_unused int64_t pts1 = pts_int;\n\n            pts_int = av_rescale_q(pts_int, tb, is->video_st->time_base);\n\n            av_dlog(NULL, \"video_thread(): \"\n\n                    \"tb:%d/%d pts:%\"PRId64\" -> tb:%d/%d pts:%\"PRId64\"\\n\",\n\n                    tb.num, tb.den, pts1,\n\n                    is->video_st->time_base.num, is->video_st->time_base.den, pts_int);\n\n        }\n\n#else\n\n        ret = get_video_frame(is, frame, &pts_int, &pkt);\n\n#endif\n\n\n\n        if (ret < 0)\n\n            goto the_end;\n\n\n\n        if (!ret)\n\n            continue;\n\n\n\n        pts = pts_int * av_q2d(is->video_st->time_base);\n\n\n\n#if CONFIG_AVFILTER\n\n        ret = output_picture2(is, frame, pts, pos);\n\n#else\n\n        ret = output_picture2(is, frame, pts,  pkt.pos);\n\n        av_free_packet(&pkt);\n\n#endif\n\n        if (ret < 0)\n\n            goto the_end;\n\n\n\n        if (step)\n\n            if (cur_stream)\n\n                stream_pause(cur_stream);\n\n    }\n\n the_end:\n\n#if CONFIG_AVFILTER\n\n    avfilter_graph_free(&graph);\n\n#endif\n\n    av_free(frame);\n\n    return 0;\n\n}\n", "idx": 6489, "substitutes": {"arg": ["event", "gc", "call", "ar", "it", "pc", "ctx", "argument", "i", "g", "p", "base", "cmd", "ark", "arp", "val", "og", "err", "ax", "ref", "inter", "pg", "ng", "Arg", "v", "slot", "args", "mm", "doc", "jp", "ag", "obj", "info", "in", "param", "j", "arr", "inc"], "is": ["was", "ists", "im", "terms", "ps", "ports", "ts", " IS", "js", "tis", " cis", "iso", "obs", "as", "ic", "ois", "lis", "mis", "os", "ms", "ri", "plays", "es", "isl", "are", "isp", "ips", "orts", "ti", "stats", "nis", "bits", "vis", "iris", "us", "info", "ks", "sis", "oss", "isf", "bis", "ris", "ar", "ars", "it", "times", "any", "ates", "cms", "isin", "ip", "has", "does", "s", "bs", "isc", "parts", "fs", " indis", "ii", "init", "isa", "ics", "its", "i", "details", "id", "ins", "ids", "ls", "ims", "iss", "Is", "args", "states", "ist", "isal", "ish", "IS", "ais", "isi", "ism"], "frame": ["ence", "draw", "rame", "form", "feat", "call", "window", "channel", "Frame", "iframe", "ox", "page", "state", "msg", "scene", "profile", "base", "p", " frames", "frames", "zo", "link", "picture", "row", "process", "movie", "t", " timeframe", "dr", "position", "ref", "word", "proc", "out", "video", "feature", "block", "shot", "load", " Frame", "request", "fb", "version", "show", "f", "message", " framed", "face", "point", "info", "fr", "def", "image"], "pts_int": ["pts2ints", "pts_str", "pts_ints", "iptref", "ptns_ints", "pts2int", "ptref", "ptns_str", "ptxs_Int", "pts2inter", "pts_inter", "ptns2inter", "ptns_inter", "aptref", "ptns2ints", "ptxs_ints", "pts2str", "ptns_int", "ptns2int", "pts_Int", "ptns2str", "ppref", "ptxs_int"], "pts": ["PTts", "tdxs", "portts", "iptts", " ptrsd", " ptrts", "tdsets", "iptxs", "apts", "aptn", "PTsd", "ptsd", "iptsets", "PTs", "portsets", "ports", "aptsd", "ptn", "aptts", "ptxs", " ptrs", "tdts", "ptts", "tds", "PTn", "portxs", "ipts", "ptsets", " ptrn"], "ret": ["gt", "result", "gc", "it", "mem", "att", "ber", "reply", "br", "back", "det", "nt", "at", "mt", "rets", "len", "val", "tr", "alt", "t", "err", "ref", "rev", "rem", "expr", "out", "v", "reset", "fun", "status", "resp", "re", "reg", "cond", "print", "RET", "desc", "f", "Ret", "fi", "ft", "net", "hash", "ll", "nl", "res", " RET", "deg", "def", "rm", "elt", "flag"], "graph": ["widget", "draw", "gh", "tree", "gc", "layout", "node", "window", "pen", "h", "gr", "ctx", "box", "buf", "map", "profile", "g", "p", "vol", "connection", "dict", "gd", "network", "context", "og", "data", "closure", "history", "stack", "ograph", "github", "dr", "query", "go", "ref", "pg", "pkg", "raph", "png", "van", "ng", "qa", "host", "memory", "container", "man", "sign", "port", "stream", "jac", "driver", "reg", "adj", "pool", "cache", "session", "shape", "igraph", "gen", "Graph", "net", "json", "conn", "path"], "filt_out": ["fld_in", "filtensum", "filtaxyout", "fld_ex", "filt_Out", "filt_sum", "fld_sum", "filtaxyto", "filt_pool", "fld_out", "filtenin", "filt_in", "fld_co", "filtenpool", "filt_to", "filtaxyin", "flt_out", "filt_co", "flt_cache", "fld_pool", "flt_Out", "fld_to", "filtenout", "filt_ex", "filt_cache"], "pos": ["pid", "rot", "sp", "po", "conf", "pc", "offset", "pro", "pt", "os", "at", "p", "base", "ps", "ms", "len", "ts", "op", "val", "data", "t", "alt", "limit", "position", "ref", "top", "pr", "POS", "start", "slot", "port", "resp", "st", "pose", "off", "ptr", "cond", "doc", "Pos", "size", "point", "pres", "z", "res", "x", "trans", "def", "loc", "bin"], "pkt": ["packet", "pkl", "opacket", "Packet", "opct", "Pkl", " pct", "opkl", "pct", "Pct", " pkl", "opkt", " packet", "Pkt"], "picref": ["pcRef", "icref", "pinref", "piref", "icrep", "pinreference", "nicarg", "picrel", "igreference", "nicref", "picturereference", "igarg", "Picrel", "picreference", "pcrel", "pinarg", "Picref", "icreference", " picreference", "nicro", "piRef", "pcrep", "nicreference", "pegRef", " picRef", " picrange", "PicRef", "pcreference", "picturearg", "pegrel", "pireference", "picro", "nicRef", "pegref", "pinRef", "picturero", "Picreference", "pcref", "picrange", "icRef", "igref", "picrep", "pegreference", "pcarg", "nicrel", "pictureref", "pirep", "pinrange", "picRef", "pinro", "picarg", "pcrange", "igRef", " picrel"], "tb": ["trbl", " tbb", " ptrb", " Trb", " trb", "ctbb", "tbe", "trbe", " tp", "rtbe", " Tb", " ptbb", "ptb", "rtbs", " ptb", "tbase", "ctb", " Tbase", "ptbe", " tbs", "rtbl", "tbs", "ctbe", "trb", "tbb", "rtb", "ptp", " tbl", " tbase", " tbe", "ctp", " Tbb", "ptbb", "tp", "tbl", "trbs", " ptbase"]}}
{"project": "qemu", "commit_id": "e13e973eedba0a52b4b8b079c4b85cdc68b7b4f0", "target": 1, "func": "static int ccid_initfn(USBDevice *dev)\n\n{\n\n    USBCCIDState *s = DO_UPCAST(USBCCIDState, dev, dev);\n\n\n\n    s->bus = ccid_bus_new(&dev->qdev);\n\n    s->card = NULL;\n\n    s->cardinfo = NULL;\n\n    s->migration_state = MIGRATION_NONE;\n\n    s->migration_target_ip = 0;\n\n    s->migration_target_port = 0;\n\n    s->dev.speed = USB_SPEED_FULL;\n\n    s->notify_slot_change = false;\n\n    s->powered = true;\n\n    s->pending_answers_num = 0;\n\n    s->last_answer_error = 0;\n\n    s->bulk_in_pending_start = 0;\n\n    s->bulk_in_pending_end = 0;\n\n    s->current_bulk_in = NULL;\n\n    ccid_reset_error_status(s);\n\n    s->bulk_out_pos = 0;\n\n    ccid_reset_parameters(s);\n\n    ccid_reset(s);\n\n    return 0;\n\n}\n", "idx": 6500, "substitutes": {"dev": ["db", "ev", "des", "mem", "devices", "usb", "conf", "window", "av", "cam", "pad", "DEV", "dem", "pro", "buf", " Dev", "nt", "ve", "den", "sys", "raw", "prop", "d", "cmd", "ds", "o", "hw", "w", "proc", "debug", "dm", "device", "out", "v", "ad", "Device", "dd", "Dev", "port", "block", "driver", "serv", "home", "doc", "priv", "disk", "serial", "obj", "test", "tech", "de", "info", "ver", "bus", "conn", "def", "loc"], "s": ["less", "sol", "ers", "h", "locks", "ads", "ps", "ports", "ts", "settings", "t", "pers", "js", "w", "gets", "services", "ss", "j", "sports", "as", "rs", "ses", "results", "sam", "os", "er", "g", "ms", "tests", "sets", "es", "stats", "m", "vs", "conv", "us", "aws", "l", "ops", "gs", "bis", "ns", "ats", "cs", "actions", "is", "r", "sv", "hs", "bs", "y", "parts", "fs", "S", "b", "eps", "its", "i", "set", "qs", "sys", "details", "n", "ds", "sync", "ins", "ids", "ls", "ims", "args", "sl", "spec", "states", "sts", "mods"]}}
{"project": "qemu", "commit_id": "5a1972c8472fafd519a68b689fdcaf33ec857945", "target": 1, "func": "static void ppc4xx_pob_reset (void *opaque)\n\n{\n\n    ppc4xx_pob_t *pob;\n\n\n\n    pob = opaque;\n\n    /* No error */\n\n    pob->bear = 0x00000000;\n\n    pob->besr[0] = 0x0000000;\n\n    pob->besr[1] = 0x0000000;\n\n}\n", "idx": 6507, "substitutes": {"opaque": ["OPacity", "popolean", "oaques", "poplay", "oplay", "ocacity", "opaques", "opsolean", "opsacity", "oaque", "opacity", "OPaque", "opsaque", "OPaques", "popacity", "popaque", "opllay", "oplacity", "opslay", "ocaque", "ocaques", "oacity", "oplaque", "opolean", "oplolean"], "pob": ["pobb", "poz", "pobi", "pingdeb", " pobe", "tipob", "pmobi", "pingob", "tipobe", " pobs", "Pub", "porp", "pmoz", "proy", " pobi", "pobe", "pingobe", "Pog", "ppob", "tiporb", "paoy", "pmob", " pub", " pdeb", "pmoby", "ppobb", " porb", "paoz", "pmoy", "paob", "prub", "pmobs", "probb", "poy", "pdeb", " poy", " pobb", "prob", "paoby", "Pob", "proby", "pporb", " porp", "probs", "pobs", "poby", "pingorb", "pub", " pog", "Pobb", "probi", "tipdeb", "Porp", "Porb", "pog", "ppog", "prorp", "proz", "porb"]}}
{"project": "FFmpeg", "commit_id": "5d20f19be25c973fe10d0d17db9245002585710d", "target": 1, "func": "int av_aes_init(AVAES *a, const uint8_t *key, int key_bits, int decrypt)\n\n{\n\n    int i, j, t, rconpointer = 0;\n\n    uint8_t tk[8][4];\n\n    int KC = key_bits >> 5;\n\n    int rounds = KC + 6;\n\n    uint8_t log8[256];\n\n    uint8_t alog8[512];\n\n\n\n    if (!enc_multbl[FF_ARRAY_ELEMS(enc_multbl)-1][FF_ARRAY_ELEMS(enc_multbl[0])-1]) {\n\n        j = 1;\n\n        for (i = 0; i < 255; i++) {\n\n            alog8[i] = alog8[i + 255] = j;\n\n            log8[j] = i;\n\n            j ^= j + j;\n\n            if (j > 255)\n\n                j ^= 0x11B;\n\n        }\n\n        for (i = 0; i < 256; i++) {\n\n            j = i ? alog8[255 - log8[i]] : 0;\n\n            j ^= (j << 1) ^ (j << 2) ^ (j << 3) ^ (j << 4);\n\n            j = (j ^ (j >> 8) ^ 99) & 255;\n\n            inv_sbox[j] = i;\n\n            sbox[i] = j;\n\n        }\n\n        init_multbl2(dec_multbl[0], (const int[4]) { 0xe, 0x9, 0xd, 0xb },\n\n                     log8, alog8, inv_sbox);\n\n        init_multbl2(enc_multbl[0], (const int[4]) { 0x2, 0x1, 0x1, 0x3 },\n\n                     log8, alog8, sbox);\n\n    }\n\n\n\n    if (key_bits != 128 && key_bits != 192 && key_bits != 256)\n\n        return -1;\n\n\n\n    a->rounds = rounds;\n\n\n\n    memcpy(tk, key, KC * 4);\n\n\n\n    for (t = 0; t < (rounds + 1) * 16;) {\n\n        memcpy(a->round_key[0].u8 + t, tk, KC * 4);\n\n        t += KC * 4;\n\n\n\n        for (i = 0; i < 4; i++)\n\n            tk[0][i] ^= sbox[tk[KC - 1][(i + 1) & 3]];\n\n        tk[0][0] ^= rcon[rconpointer++];\n\n\n\n        for (j = 1; j < KC; j++) {\n\n            if (KC != 8 || j != KC >> 1)\n\n                for (i = 0; i < 4; i++)\n\n                    tk[j][i] ^= tk[j - 1][i];\n\n            else\n\n                for (i = 0; i < 4; i++)\n\n                    tk[j][i] ^= sbox[tk[j - 1][i]];\n\n        }\n\n    }\n\n\n\n    if (decrypt) {\n\n        for (i = 1; i < rounds; i++) {\n\n            av_aes_block tmp[3];\n\n            tmp[2] = a->round_key[i];\n\n            subshift(&tmp[1], 0, sbox);\n\n            mix(tmp, dec_multbl, 1, 3);\n\n            a->round_key[i] = tmp[0];\n\n        }\n\n    } else {\n\n        for (i = 0; i < (rounds + 1) >> 1; i++) {\n\n            FFSWAP(av_aes_block, a->round_key[i], a->round_key[rounds-i]);\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 6509, "substitutes": {"a": ["this", "as", "apa", "b", "app", "ar", "ab", "it", "c", "h", "eas", "ma", "aaa", "ta", "at", "aa", "p", "A", "ak", "n", "ava", "aux", "ae", "na", "o", "ach", "w", "an", "au", "s", "v", "ack", "m", "sa", "ac", "ca", "am", "y", "area", "f", "aka", "e", "ace", "x", "ao", "act"], "key": ["ck", "iv", "init", "Key", "et", "ice", "type", "KEY", "box", "ek", "mk", "te", "table", "ak", "seed", "ke", "row", "pair", "input", "str", "id", "list", "k", "kw", "v", "sk", "ket", "keys", "ch", "y", "kit", "obj", "ey", "hash", "lock", "text", "x", "json", "name"], "key_bits": ["key0bits", "key0abilities", "key0values", "key0its", "key2bit", "KEY_bit", " key_its", "int_bytes", "key_bit", "key_bytes", "key_values", " key_values", "key_mask", " key_bots", "key_its", "key2bits", " key_files", "key_bots", "KEY_mask", "int_bits", " key_abilities", "key2bytes", "key_files", "int_bit", "hash_bits", "key_abilities", "hash_its", "KEY_bits", "hash_bit"], "decrypt": ["Decryption", "decryption", "encrypt", "encryption", "encode", "scryption", "deccrypt", "Deccrypt", "sccrypt", "decode", "Decode", "enccrypt", "scode", "scrypt", "Decrypt"], "i": ["ei", "im", "gi", "zi", "ind", "hi", "pi", "iter", "I", "jp", "io", "in", "x", "\u0438", "di", "this", "ic", "q", "um", "mi", "er", "g", "xi", "index", "ri", "bi", "ki", "ti", "v", "ai", "m", "ia", "info", "l", "ci", "it", "u", "ip", "li", "p", "ami", "is", "o", "r", "dr", "s", "y", "ii", "name", "ij", "ini", "b", "qi", "si", "ie", "n", "multi", "me", "id", "ui", "ji", "phi", "ix", "status", "f", "sim", "gu", "iu", "e", "point", "z", "ite"], "j": ["dj", "ja", "ij", "tree", "q", "b", "jo", "it", "jj", "note", "job", "J", "h", "br", "aj", "prop", "p", "si", "g", "ie", "li", "n", "uj", "index", "o", "jas", "bi", "jc", "r", "js", "pi", "str", "err", "prime", "ji", "pr", "k", "ion", "oj", "try", "v", "ot", "ix", "jac", "m", "ch", "adj", "y", "jump", "jp", "jit", "f", "obj", "jl", "io", "iu", "kj", "z", "lock", "json", "di", "ni", "ii", "l"], "t": ["q", "ct", "it", "type", "c", "u", "kt", "h", "tar", "T", "pt", "set", "nt", "ta", "at", "te", "ht", "dt", "p", "ent", "mt", "g", "tm", "typ", "n", "ts", "d", "tr", "o", "bt", "wt", " ti", "r", "trace", "to", "k", "ti", "out", "tip", "v", "txt", "ot", "s", "tu", "rt", "m", "st", "tx", "y", "tf", "vt", "test", "qt", "td", "z", "tp", "l", "tt", "tc"], "tk": ["ty", "uk", "awk", "term", "kr", "ctx", "kh", "kt", "ku", "kk", "tar", "ek", "ik", "self", "ok", "ta", "mk", "te", "ijk", "tg", "table", "util", "ak", "typ", "tm", "tv", "tif", "kar", "kl", "wk", "wt", "k", "kw", "txt", "sk", "tu", "ket", "new", "ac", "dk", "tek", "kit", "tf", "sky", "look", "tile", "tap", "obj", "qt", "td", "json", "tp", "tt", "tc"], "log8": ["alogode", "alog4", "alogoo", "el32", "olog8", "ologoff", "log08", " log32", "log6", " logo", "alog28", "alog7", " log2", "cat8", "ogoo", "el8", "alog2", "ologo", "el28", " log7", "log4", "alog6", " logode", "olog2", "cat7", " log28", "alog32", "log9", "alog9", " log4", "logo", "catode", "log28", "alog08", "cat9", "logode", " log6", "log7", "logoff", "alogoff", "logoo", " log9", "log2", "alogo", " logoff", " log08", "og4", "olog6", " logoo", "og8", "log32", "el08"], "alog8": ["blogo", "alog4", "sl9", "cil32", "sl64", "ob8", "log08", "blog7", "afbl", "ll7", "alog7", "afo", "cat8", "blog4", "langbl", "af8", "log80", "lang64", "ateg8", "ob08", "catbl", "og64", "lang08", "ang9", "af9", "ateg64", "lang4", "ang80", "ang8", "ll64", "blog64", "alogbl", "obo", "sl8", "alog32", "og7", "log9", "cato", "alog9", "lango", "blog08", "ll24", "ll8", "ob4", "cil80", "lang24", "alog08", "cat9", "ateg9", "lang9", "lang8", "log64", "lang7", "ang32", "log7", "ateg08", "cil8", "alogo", "sl08", "og24", "alog64", "cil9", "blog8", "og8", "alog24", "log32", "alog80"]}}
{"project": "FFmpeg", "commit_id": "7f526efd17973ec6d2204f7a47b6923e2be31363", "target": 1, "func": "static inline void RENAME(yv12touyvy)(const uint8_t *ysrc, const uint8_t *usrc, const uint8_t *vsrc, uint8_t *dst,\n\n\tunsigned int width, unsigned int height,\n\n\tint lumStride, int chromStride, int dstStride)\n\n{\n\n\t//FIXME interpolate chroma\n\n\tRENAME(yuvPlanartouyvy)(ysrc, usrc, vsrc, dst, width, height, lumStride, chromStride, dstStride, 2);\n\n}\n", "idx": 6519, "substitutes": {"ysrc": ["sysrc", "vsr", "iesurg", "iesrc", "ssurg", "sysrs", "vsurg", "iessrc", "iesr", "sssrc", "iesrs", "ssrc", "assrc", "ysrs", "syssrc", "asrs", "yssrc", "ysr", "ysurg", "asrc", "ssr", "asr", "sysr", "vssrc"], "usrc": ["usessrc", "usesr", "udscur", "umsirc", "uscur", "ausrc", "usirc", "cusrc", "cuscur", "udsrc", "aususc", "usr", "aussrc", "usesrc", " ussrc", " usr", "umssrc", "umsr", "ussrc", "cususc", "umsrc", " usirc", "udssrc", "ususc", "usesirc", "cussrc", "auscur", "udsusc"], "vsrc": ["vsr", "vrc", "vsource", "ivsource", "Vsr", "fsr", "Vrc", "dstr", "Vsrc", "drc", "ivrc", "fsrc", " vrc", "ivstr", "ivsrc", " vsource", "fsource", " vstr", "frc", "dsource", " vsr", "dsrc", "Vsource", "vstr"], "dst": ["sst", "dnt", "lsts", "ddnd", "dasts", "ddest", "dddest", "lnd", "snd", "dsts", "fnd", "sdest", "fst", "fdest", " dnd", " dsts", "dadest", "dast", "ddst", "lst", "ldest", "dnd", "dand", "fnt", "snt", " ddest", "ddnt"], "height": ["stroke", "depth", "gh", "error", "padding", "grow", "Height", "window", "inches", "h", "bottom", "density", "ht", "rank", "history", "headers", "above", "angle", "gravity", "frame", "loss", "ch", "build", "yt", "y", "he", "sky", "wh", "shape", "size", "family", "length", "html", "hang", "crop", "resolution"], "lumStride": ["lumSTride", "lumRestride", "lamStr", "lamStrrid", "limStbit", "lamStrride", "lumstride", "lumStide", "lumStr", "lumStbit", "lamStrid", "lumStrbit", "lumStrid", "lumRestrid", "lumstbit", "limStrbit", "limStrid", "lumRestrat", "lamStrrat", "lumStrrat", "lumStrride", "lumLbit", "lumLrid", "lamStrat", "lumSTrat", "lumSTr", "lamStrr", "limStide", "lumLide", "lumstrid", "limStride", "limStrride", "lumRestr", "lumSTrid", "lumstide", "lumStrrid", "lamStride", "lumStrat", "lumStrr", "lumLride", "limStrrid"], "chromStride": ["romStr", "chromStrride", "chromStbit", "romStide", "romStbit", "romStrbit", "chromStrid", "chromStrr", "chromStr", "chromstide", "chromChide", "chromStrbit", "chromChbit", "romStrrid", "romStrride", "chromstride", "romStrid", "chromstrid", "chromChrid", "romStride", "chromstr", "chromChride", "chromStide", "romStrr", "chromStrrid"], "dstStride": ["deststrid", "dstStbit", "destStrid", "destStr", "dustStride", "dustStrbit", "dststr", "dststbit", "dstStrride", "dstRestride", "deststide", "dustStide", "dstStrbit", "dstStrid", "dstStr", "dustStrr", "destStride", "deststride", "dstStrrid", "deststr", "dstRestrid", "dststrid", "dustStrride", "dustStr", "dstRestbit", "destStide", "dststide", "dstStide", "dustStbit", "dststride", "dstRestr", "dstStrr", "dstRestide"]}}
{"project": "qemu", "commit_id": "3dc6f8693694a649a9c83f1e2746565b47683923", "target": 0, "func": "static void spapr_populate_cpu_dt(CPUState *cs, void *fdt, int offset,\n\n                                  sPAPRMachineState *spapr)\n\n{\n\n    PowerPCCPU *cpu = POWERPC_CPU(cs);\n\n    CPUPPCState *env = &cpu->env;\n\n    PowerPCCPUClass *pcc = POWERPC_CPU_GET_CLASS(cs);\n\n    int index = ppc_get_vcpu_dt_id(cpu);\n\n    uint32_t segs[] = {cpu_to_be32(28), cpu_to_be32(40),\n\n                       0xffffffff, 0xffffffff};\n\n    uint32_t tbfreq = kvm_enabled() ? kvmppc_get_tbfreq()\n\n        : SPAPR_TIMEBASE_FREQ;\n\n    uint32_t cpufreq = kvm_enabled() ? kvmppc_get_clockfreq() : 1000000000;\n\n    uint32_t page_sizes_prop[64];\n\n    size_t page_sizes_prop_size;\n\n    uint32_t vcpus_per_socket = smp_threads * smp_cores;\n\n    uint32_t pft_size_prop[] = {0, cpu_to_be32(spapr->htab_shift)};\n\n    int compat_smt = MIN(smp_threads, ppc_compat_max_threads(cpu));\n\n    sPAPRDRConnector *drc;\n\n    int drc_index;\n\n    uint32_t radix_AP_encodings[PPC_PAGE_SIZES_MAX_SZ];\n\n    int i;\n\n\n\n    drc = spapr_drc_by_id(TYPE_SPAPR_DRC_CPU, index);\n\n    if (drc) {\n\n        drc_index = spapr_drc_index(drc);\n\n        _FDT((fdt_setprop_cell(fdt, offset, \"ibm,my-drc-index\", drc_index)));\n\n    }\n\n\n\n    _FDT((fdt_setprop_cell(fdt, offset, \"reg\", index)));\n\n    _FDT((fdt_setprop_string(fdt, offset, \"device_type\", \"cpu\")));\n\n\n\n    _FDT((fdt_setprop_cell(fdt, offset, \"cpu-version\", env->spr[SPR_PVR])));\n\n    _FDT((fdt_setprop_cell(fdt, offset, \"d-cache-block-size\",\n\n                           env->dcache_line_size)));\n\n    _FDT((fdt_setprop_cell(fdt, offset, \"d-cache-line-size\",\n\n                           env->dcache_line_size)));\n\n    _FDT((fdt_setprop_cell(fdt, offset, \"i-cache-block-size\",\n\n                           env->icache_line_size)));\n\n    _FDT((fdt_setprop_cell(fdt, offset, \"i-cache-line-size\",\n\n                           env->icache_line_size)));\n\n\n\n    if (pcc->l1_dcache_size) {\n\n        _FDT((fdt_setprop_cell(fdt, offset, \"d-cache-size\",\n\n                               pcc->l1_dcache_size)));\n\n    } else {\n\n        error_report(\"Warning: Unknown L1 dcache size for cpu\");\n\n    }\n\n    if (pcc->l1_icache_size) {\n\n        _FDT((fdt_setprop_cell(fdt, offset, \"i-cache-size\",\n\n                               pcc->l1_icache_size)));\n\n    } else {\n\n        error_report(\"Warning: Unknown L1 icache size for cpu\");\n\n    }\n\n\n\n    _FDT((fdt_setprop_cell(fdt, offset, \"timebase-frequency\", tbfreq)));\n\n    _FDT((fdt_setprop_cell(fdt, offset, \"clock-frequency\", cpufreq)));\n\n    _FDT((fdt_setprop_cell(fdt, offset, \"slb-size\", env->slb_nr)));\n\n    _FDT((fdt_setprop_cell(fdt, offset, \"ibm,slb-size\", env->slb_nr)));\n\n    _FDT((fdt_setprop_string(fdt, offset, \"status\", \"okay\")));\n\n    _FDT((fdt_setprop(fdt, offset, \"64-bit\", NULL, 0)));\n\n\n\n    if (env->spr_cb[SPR_PURR].oea_read) {\n\n        _FDT((fdt_setprop(fdt, offset, \"ibm,purr\", NULL, 0)));\n\n    }\n\n\n\n    if (env->mmu_model & POWERPC_MMU_1TSEG) {\n\n        _FDT((fdt_setprop(fdt, offset, \"ibm,processor-segment-sizes\",\n\n                          segs, sizeof(segs))));\n\n    }\n\n\n\n    /* Advertise VMX/VSX (vector extensions) if available\n\n     *   0 / no property == no vector extensions\n\n     *   1               == VMX / Altivec available\n\n     *   2               == VSX available */\n\n    if (env->insns_flags & PPC_ALTIVEC) {\n\n        uint32_t vmx = (env->insns_flags2 & PPC2_VSX) ? 2 : 1;\n\n\n\n        _FDT((fdt_setprop_cell(fdt, offset, \"ibm,vmx\", vmx)));\n\n    }\n\n\n\n    /* Advertise DFP (Decimal Floating Point) if available\n\n     *   0 / no property == no DFP\n\n     *   1               == DFP available */\n\n    if (env->insns_flags2 & PPC2_DFP) {\n\n        _FDT((fdt_setprop_cell(fdt, offset, \"ibm,dfp\", 1)));\n\n    }\n\n\n\n    page_sizes_prop_size = ppc_create_page_sizes_prop(env, page_sizes_prop,\n\n                                                  sizeof(page_sizes_prop));\n\n    if (page_sizes_prop_size) {\n\n        _FDT((fdt_setprop(fdt, offset, \"ibm,segment-page-sizes\",\n\n                          page_sizes_prop, page_sizes_prop_size)));\n\n    }\n\n\n\n    spapr_populate_pa_features(env, fdt, offset, false);\n\n\n\n    _FDT((fdt_setprop_cell(fdt, offset, \"ibm,chip-id\",\n\n                           cs->cpu_index / vcpus_per_socket)));\n\n\n\n    _FDT((fdt_setprop(fdt, offset, \"ibm,pft-size\",\n\n                      pft_size_prop, sizeof(pft_size_prop))));\n\n\n\n    if (nb_numa_nodes > 1) {\n\n        _FDT(spapr_fixup_cpu_numa_dt(fdt, offset, cpu));\n\n    }\n\n\n\n    _FDT(spapr_fixup_cpu_smt_dt(fdt, offset, cpu, compat_smt));\n\n\n\n    if (pcc->radix_page_info) {\n\n        for (i = 0; i < pcc->radix_page_info->count; i++) {\n\n            radix_AP_encodings[i] =\n\n                cpu_to_be32(pcc->radix_page_info->entries[i]);\n\n        }\n\n        _FDT((fdt_setprop(fdt, offset, \"ibm,processor-radix-AP-encodings\",\n\n                          radix_AP_encodings,\n\n                          pcc->radix_page_info->count *\n\n                          sizeof(radix_AP_encodings[0]))));\n\n    }\n\n}\n", "idx": 6524, "substitutes": {"cs": ["rs", "gc", "cas", "ci", "ct", "CS", "cp", "ns", "c", "pc", "acs", "ctx", "cks", "cms", "sys", "sc", "ces", "ps", "ms", "ec", "ts", "ds", "cus", "css", "cc", "js", "proc", "ls", "s", "cn", "ix", "vs", "hs", "bs", "core", "fs", "ks", "sts", "cu"], "fdt": ["tdg", "fdb", "fcts", "fcwt", "fcte", "dfb", "iddb", "dls", "fdg", "idddt", "uddt", "FDt", "ondt", "fdwt", "fxg", "fxc", "fdte", "tdt", "fdn", "fddt", "FDte", "dlte", "dfdt", "dlg", "fct", "tdc", "udt", "fds", "udts", "dlt", "iddts", "dlc", "iddt", "dlts", "dfts", "fdts", "dlwt", "ondte", "udb", "FDs", "ondwt", "fdc", "fxt", "fcs", "ondts", "FDn", "dln", "dft", "fcn"], "offset": ["atomic", "initialized", "error", "padding", "encrypted", "operation", "shift", "pad", "set", "vector", "buffer", "secondary", "extra", "util", "si", "seed", "seek", "location", "row", "pointer", "index", "o", "bound", "position", "slice", "id", "pos", "attribute", "align", "style", "start", "timeout", "num", "handle", "slot", "exclusive", "oid", "offs", "scroll", "tab", "off", "frequency", "ptr", "batch", "entry", "axis", "alias", "address", " index", "count", "f", "tile", "point", "optional", "Offset", "lock", "interface", "length", "format", "x", "origin"], "spapr": ["spapep", "ispaper", "ispapep", "spiprar", " spiprd", "spipR", "spasprd", "spapprb", " spipR", " spaprd", "spipr", " spapR", " spiprar", "spaprb", "ispapero", "spaptR", "spapp", "ispaperb", " spaprar", "spaperb", "spaspR", "spapero", "spampp", "spasprar", "ispapro", "spaspr", "spaprar", "spampr", "spaprd", "spaper", "spaptrar", "spiprd", "ispapp", "spampro", "spapR", "spappp", "spamprb", " spipr", "spaptr", "spappro", "spaptrd", "ispaprb", "ispapr", "spapro", "spappr"], "cpu": ["ck", "CPU", "thread", "gc", "node", "mem", "cum", "cp", "c", "pu", "ctx", "pc", "prof", "tp", "cli", "sys", "ka", "clock", "sc", "density", "util", "cmd", "stat", "mx", "nc", "process", "hw", "phys", "nu", "cc", "linux", "proc", "mac", "device", "cn", "lp", "nic", "processor", "cv", "pool", "cache", "aco", "core", "us", "vm", "boot", "cu", "gpu", "conn"], "env": ["ev", "ei", "window", "end", "conf", "ework", "ctx", "scope", "conn", "buf", "er", "map", "ext", "ec", "dev", "viron", "eng", "cb", "environment", "context", "win", "pe", "proc", "attr", "en", "v", "cap", "ef", "cfg", "config", "vs", "estate", "cv", "equ", "priv", "obj", "e", "pillar"], "pcc": ["pcs", "Pcc", " pcs", "cpct", "cpcs", " pct", "pCC", "cpCC", "pct", "Pcs", "Pct", " pCC", "cpcc", "PCC"], "segs": ["begments", "vegs", "vegm", "beg", "begm", "vegments", "segm", " segments", "seg", "segments", " seg", " segm", "begs", "veg"], "page_sizes_prop": ["page_sizers_ps", "page_sizers_prop", "page_sizes_property", "page_sizes_tmp", "page_sizers_tmp", "page_sizers_property", "page_sizes_ps"], "page_sizes_prop_size": ["page_sizes_prop2val", "page_sizes_property_val", "page_sizes_prop2length", "page_sizes_prop_val", "page_sizes_prop_length", "page_sizes_property_len", "page_sizes_property_size", "page_sizes_prop2len", "page_sizes_property_length", "page_sizes_prop_len", "page_sizes_prop2size"], "pft_size_prop": ["pft_name_prop", "pft_size2buf", "pft_name_desc", "pft_name2buf", "pft_size_desc", "pft_size2desc", "pft_size_properties", "pft_size2prop", "pft_size2properties", "pft_size_buf", "pft_name2prop", "pft_name_buf", "pft_name2desc", "pft_name2properties", "pft_name_properties"], "drc": ["bdarc", "bdrc", "drs", " darc", " dcur", "Drc", "dcur", "prc", "Darc", " drom", "Drs", "darc", "Dfc", "prt", "drt", "dfc", "Dcur", "pRC", " drt", " dfc", "Drom", "Drt", "DRC", "bdrom", " dRC", "bdrs", "drom", "dRC", " drs", "pfc", "bdRC"], "drc_index": ["drc__num", "dRC_index", "drc__index", "drc_size", "drc_num", "drc_Index", "dRC_size", "dRC_Index", "drc__size", "drc_count", "drc_id", "drc2index", "drc2id", "drc__Index", "dRC_count", "dRC_id", "dRC_num", "drc2Index"], "radix_AP_encodings": ["radix_prop_enccoding", "radix_prop_encodings", "radix_prop_encODings", "radix_prop_enODings", "radix_prop_encodesINGS", "radix_prop_enccodING", "radix_prop_enODing", "radix_prop_encodesings", "radix_prop_encoding", "radix_prop_enodings", "radix_prop_enODING", "radix_prop_encODING", "radix_prop_enccodINGS", "radix_prop_encODing", "radix_prop_enodINGS", "radix_prop_enodING", "radix_prop_encodesing", "radix_prop_enccodings", "radix_prop_encodINGS", "radix_prop_enoding", "radix_prop_encODINGS", "radix_prop_enODINGS", "radix_prop_encodING", "radix_prop_encodesING"], "i": ["ci", "b", " ii", "it", "c", "p", "si", "base", "n", "index", "o", "id", "list", " j", "m", "a", "I", "y", " index", "f", "io", "e", "point", "j", "x", "di", "ii", "l"]}}
{"project": "qemu", "commit_id": "f94d18d6c6df388fde196d3ab252f57e33843a8b", "target": 0, "func": "static void xhci_kick_epctx(XHCIEPContext *epctx, unsigned int streamid)\n\n{\n\n    XHCIState *xhci = epctx->xhci;\n\n    XHCIStreamContext *stctx;\n\n    XHCITransfer *xfer;\n\n    XHCIRing *ring;\n\n    USBEndpoint *ep = NULL;\n\n    uint64_t mfindex;\n\n    int length;\n\n    int i;\n\n\n\n    trace_usb_xhci_ep_kick(epctx->slotid, epctx->epid, streamid);\n\n\n\n    /* If the device has been detached, but the guest has not noticed this\n\n       yet the 2 above checks will succeed, but we must NOT continue */\n\n    if (!xhci->slots[epctx->slotid - 1].uport ||\n\n        !xhci->slots[epctx->slotid - 1].uport->dev ||\n\n        !xhci->slots[epctx->slotid - 1].uport->dev->attached) {\n\n        return;\n\n    }\n\n\n\n    if (epctx->retry) {\n\n        XHCITransfer *xfer = epctx->retry;\n\n\n\n        trace_usb_xhci_xfer_retry(xfer);\n\n        assert(xfer->running_retry);\n\n        if (xfer->timed_xfer) {\n\n            /* time to kick the transfer? */\n\n            mfindex = xhci_mfindex_get(xhci);\n\n            xhci_check_intr_iso_kick(xhci, xfer, epctx, mfindex);\n\n            if (xfer->running_retry) {\n\n                return;\n\n            }\n\n            xfer->timed_xfer = 0;\n\n            xfer->running_retry = 1;\n\n        }\n\n        if (xfer->iso_xfer) {\n\n            /* retry iso transfer */\n\n            if (xhci_setup_packet(xfer) < 0) {\n\n                return;\n\n            }\n\n            usb_handle_packet(xfer->packet.ep->dev, &xfer->packet);\n\n            assert(xfer->packet.status != USB_RET_NAK);\n\n            xhci_complete_packet(xfer);\n\n        } else {\n\n            /* retry nak'ed transfer */\n\n            if (xhci_setup_packet(xfer) < 0) {\n\n                return;\n\n            }\n\n            usb_handle_packet(xfer->packet.ep->dev, &xfer->packet);\n\n            if (xfer->packet.status == USB_RET_NAK) {\n\n                return;\n\n            }\n\n            xhci_complete_packet(xfer);\n\n        }\n\n        assert(!xfer->running_retry);\n\n        xhci_ep_free_xfer(epctx->retry);\n\n        epctx->retry = NULL;\n\n    }\n\n\n\n    if (epctx->state == EP_HALTED) {\n\n        DPRINTF(\"xhci: ep halted, not running schedule\\n\");\n\n        return;\n\n    }\n\n\n\n\n\n    if (epctx->nr_pstreams) {\n\n        uint32_t err;\n\n        stctx = xhci_find_stream(epctx, streamid, &err);\n\n        if (stctx == NULL) {\n\n            return;\n\n        }\n\n        ring = &stctx->ring;\n\n        xhci_set_ep_state(xhci, epctx, stctx, EP_RUNNING);\n\n    } else {\n\n        ring = &epctx->ring;\n\n        streamid = 0;\n\n        xhci_set_ep_state(xhci, epctx, NULL, EP_RUNNING);\n\n    }\n\n    assert(ring->dequeue != 0);\n\n\n\n    while (1) {\n\n        length = xhci_ring_chain_length(xhci, ring);\n\n        if (length <= 0) {\n\n            break;\n\n        }\n\n        xfer = xhci_ep_alloc_xfer(epctx, length);\n\n        if (xfer == NULL) {\n\n            break;\n\n        }\n\n\n\n        for (i = 0; i < length; i++) {\n\n            TRBType type;\n\n            type = xhci_ring_fetch(xhci, ring, &xfer->trbs[i], NULL);\n\n            assert(type);\n\n        }\n\n        xfer->streamid = streamid;\n\n\n\n        if (epctx->epid == 1) {\n\n            xhci_fire_ctl_transfer(xhci, xfer);\n\n        } else {\n\n            xhci_fire_transfer(xhci, xfer, epctx);\n\n        }\n\n        if (xfer->complete) {\n\n            xhci_ep_free_xfer(xfer);\n\n            xfer = NULL;\n\n        }\n\n\n\n        if (epctx->state == EP_HALTED) {\n\n            break;\n\n        }\n\n        if (xfer != NULL && xfer->running_retry) {\n\n            DPRINTF(\"xhci: xfer nacked, stopping schedule\\n\");\n\n            epctx->retry = xfer;\n\n            break;\n\n        }\n\n    }\n\n\n\n    ep = xhci_epid_to_usbep(epctx);\n\n    if (ep) {\n\n        usb_device_flush_ep_queue(ep->dev, ep);\n\n    }\n\n}\n", "idx": 6532, "substitutes": {"epctx": ["epshistory", "espcmp", "epcontext", "epsconfig", "eptimeout", "ipcmp", "epinit", "ipctx", "ippkg", "epercontext", "ipca", "ipcontext", " epinit", "eqtimeout", "pecontext", "iptx", "pefunc", "eqpkg", "eccmp", "ectx", "epscmp", "aptx", "ipconn", "epconfig", "eqctx", "epspkg", "ephistory", "epscmd", "espcontext", "epscfg", "epcmp", "epstimeout", "ipcmd", " epcfg", "epfunc", "pecmp", "epsconn", "peca", "appkg", "epstx", " epconfig", "pectx", "petimeout", "ecconfig", "ecctx", "eqcontext", "epsinit", "pepkg", "eppkg", "eperctx", "epsca", "epsctx", "epscontext", "espctx", "eperinit", "espfunc", "epcfg", "epconn", "apctx", "ecpkg", "eccontext", "ecconn", "iphistory", "epca", "apcmp", "epcmd", " epcontext", "apcontext", "epsfunc", "eptx", "epercfg", "apcmd", "pehistory", " eptx"], "streamid": ["reamuid", "channelId", "streamId", "reamID", " streamId", " streamident", "windowident", "streamuid", "reamident", "reamid", "windowId", "streamID", " streamID", "channelid", "channeluid", "windowid", "streamident", "reamId", " streamuid", "windowID"], "xhci": ["xharcgi", "xhwci", "xhecgi", "xheki", "xrhlic", "xccci", "xccs", "Xheci", "xohcli", "xhinni", "xhdi", "xahcci", "xrhiesta", "xxrhlic", "xhlic", "Xhecci", "Xhci", "xdhcs", "xharpy", "xxhcci", "xrhci", "wxohcit", "xdhci", "xhcu", "Xhcci", "xhc", "xxhlic", " cxwcci", "xhecu", "xhipy", "xhldi", "xohcit", "rxhci", "wxohcli", "xharci", "xhlcli", "xhlki", "wxhcit", "xhepy", "xohki", "xhilic", "xhiiesta", "xohci", "xxhiesta", "xhmcs", "xohcu", "xhecci", "xhicci", "xxrhiesta", "xihcit", "xwci", "xahcom", "xwni", "xohdi", "xhlc", " cxhci", "xccom", "xhlcu", "xhedi", "rxhldi", "xheco", "Xhcom", "xihci", "wxohci", "rxhepy", " cxhco", "xdohci", "xdohuci", "rxhcu", "xhwcci", "wxhci", "xheci", "rxhlki", "xhinci", "Xhki", "xdohcs", "xhpy", "xhuci", "xhlci", "xdohlink", " cxhni", "Xheki", " cxwco", "rxheci", "xhni", "xhcgi", "xhmuci", "xhki", " cxwni", "rxhlci", "xrhcci", "xhinco", "xheni", "wxhc", "xdhuci", "xihc", " cxwci", "xohuci", "xxrhcci", "xhcom", "Xhecom", "xhcci", "xwcci", "rxhlcu", "rxhcgi", "xcci", "wxhcli", "xclink", "rxhdi", "xwco", "xhidi", "xhicgi", "xhiesta", "xhmci", "xhlink", "rxhedi", "xhincci", "xhcit", "xhcs", "xohlink", "rxhpy", "rxhecgi", "xcki", "xohc", "xcuci", "xhwiesta", "xxhci", "xdhlink", "xhmlink", "xhcli", "xhco", "xhecom", "xhlcit", "xahci", "xihcli", "xhici", "xhardi", "wxohc", "rxhki", "xahki", " cxhcci", "xxrhci", "xohcs", "xhwlic"], "stctx": ["ostconn", "ostctx", " stconn", "stytx", "stconn", "ostcontext", " sttx", " stcontext", "stcontext", "styctx", "osttx", "sttx", "styconn", "stycontext"], "xfer": ["xter", "lexporter", "wxfer", "xcer", "wxiter", "oxference", "nexference", "xfort", "nexfer", "exfer", "mxft", "tference", "eyfer", "mxcer", "eter", "oxfer", "rxpire", "xxver", "ecer", "xfire", "vference", "exporter", "rxcer", "axfer", "zxfe", "exference", "ixft", "rxfe", "zxpire", "tfer", "mxfire", "fxfer", "xxcer", "checkbury", "axference", "xfe", "uxfort", "wxference", "checkfer", "nexferred", " xferred", "ttransfer", "xfr", " xporter", "vporter", " xfort", "crosstransfer", "oxporter", "pxporter", "lexfer", "oxformer", "rxfer", "mxference", "oxfr", "workporter", "vfr", "xporter", "uxferred", "xxfer", "pxfer", "rxfire", "xft", "xxlate", "xhr", "oxcer", "fxft", "oxfe", "oxferred", "nexbury", "crossfe", "workfer", "xxferred", "oxputer", "lexcer", "wxft", "rxtransfer", "exiter", "xpire", "tter", "oxbury", "mxter", "lexfe", "xypire", "rxferred", "crossception", "checkferred", " xpire", "ixhr", "eyference", "xyference", "lexfr", "ixiter", "xlate", "ixception", "crossporter", "pxfort", "wxformer", "uxformer", "crossffer", "eyfire", "xpect", "xffer", "dxfe", " xference", "rxiter", "crossiter", "dxporter", "crosshr", "dxfer", "rxformer", "fxfort", "crossference", "xxft", "pxft", "rxbury", "xyiter", "workferred", "xtransfer", "xxporter", "uxbury", "mxformer", "zxFER", "zxiter", "xFER", "crossfer", "dxffer", "efer", "ixporter", "xyfer", "oxpire", "xformer", "zxporter", "uxference", "mxfer", "zxference", "mxporter", "oxtransfer", "xxpire", "wxfort", "xver", "exbury", "workFER", "ixferred", "zxffer", "xferred", "expect", "xxtransfer", "xception", "xiter", "zxfer", "lexference", "ixfort", "xputer", "oxver", "xference", "zxferred", "checkference", "wxpect", "crossferred", "xbury", "uxporter", "uxiter", "fxporter", "uxfer", "vfer", "ixpect", "xxception", "rxference", "ixference", "wxporter", "eyformer", " xFER", "ixfer", "oxter", " xiter", "xxference", "ixcer", "xxputer", "oxlate", "rxver", "axputer", "eference", "xxter", "axlate", "xxhr"], "ring": ["rs", "ral", "ings", "binding", "prefix", "ling", "ping", "sam", "rel", "ra", "ram", "rol", "range", "ri", "record", "rest", "ng", "ray", "inding", "rin", "reg", "Ring", "ing", "setting", "rings", "star", "ro", "path"], "ep": ["ev", "peer", "et", "sp", "gp", "cp", "wp", "eb", "est", "eps", "dep", "pb", "ek", "ip", "er", "eg", "p", "ele", "ech", "ec", "vp", "op", "dev", "ew", "peak", "ept", "EP", "pe", "ever", "pipe", "pkg", "esp", "eper", "ap", "ef", "dp", "eth", "pp", "e", "ream", "Ep", "tp", "env", "ape", "mp"], "mfindex": ["dmfaindex", " mvind", "mferindex", "mferind", "mfervalue", " mxfoffset", "mfnum", "mfaaddress", " mfind", "mvIndex", "mlfindex", " mvIndex", " mxfindex", "mxfindex", "mfanum", "mvvalue", "mcind", "mfaddress", "mlfpointer", "mfaindex", "mfapointer", "mrfoffset", "mofpointer", " mfIndex", "mvindex", "mferIndex", "mfoffset", "mfind", "dmfapointer", "dmfnum", "mcindex", "mfpointer", "mofaddress", "dmfpointer", "dmfanum", "mrfIndex", " mxfIndex", "mxfIndex", "mfIndex", "mvind", "mfacoffset", " mfvalue", " mfoffset", "mcIndex", "mxfoffset", "mcvalue", " mvvalue", "mofnum", "mrfindex", "mofindex", "mlfnum", "mfacIndex", "mfvalue", "dmfaaddress", "mfacindex", "dmfindex", "mlfaddress", "dmfaddress", " mvindex"], "length": ["sp", "h", "ffff", "duration", "link", "len", "total", "data", "t", "Length", "byte", "phi", "en", "ength", "sl", "load", "le", "ptr", "ish", "count", "fi", " len", "z", "l", " l", "sequence"], "i": ["ci", "it", "c", "ip", "li", "p", "si", "o", "t", "bi", "pi", "id", "ki", "phi", "ti", "v", " j", "ai", "m", "I", "iat", "f", "fi", "io", "j", "di", "ii", "l"]}}
{"project": "FFmpeg", "commit_id": "b04665ac028d26747396eaf4dbf9188225a6f2a1", "target": 0, "func": "static int opt_preset(const char *opt, const char *arg)\n\n{\n\n    FILE *f=NULL;\n\n    char filename[1000], tmp[1000], tmp2[1000], line[1000];\n\n    int i;\n\n    const char *base[3]= { getenv(\"HOME\"),\n\n                           \"/usr/local/share\",\n\n                           \"/usr/share\",\n\n                         };\n\n\n\n    for(i=!base[0]; i<3 && !f; i++){\n\n        snprintf(filename, sizeof(filename), \"%s/%sffmpeg/%s.ffpreset\", base[i], i ? \"\" : \".\", arg);\n\n        f= fopen(filename, \"r\");\n\n        if(!f){\n\n            char *codec_name= *opt == 'v' ? video_codec_name :\n\n                              *opt == 'a' ? audio_codec_name :\n\n                                            subtitle_codec_name;\n\n            snprintf(filename, sizeof(filename), \"%s/%sffmpeg/%s-%s.ffpreset\", base[i],  i ? \"\" : \".\", codec_name, arg);\n\n            f= fopen(filename, \"r\");\n\n        }\n\n    }\n\n    if(!f && ((arg[0]=='.' && arg[1]=='/') || arg[0]=='/' ||\n\n              is_dos_path(arg))){\n\n        snprintf(filename, sizeof(filename), arg);\n\n        f= fopen(filename, \"r\");\n\n    }\n\n\n\n    if(!f){\n\n        fprintf(stderr, \"File for preset '%s' not found\\n\", arg);\n\n        av_exit(1);\n\n    }\n\n\n\n    while(!feof(f)){\n\n        int e= fscanf(f, \"%999[^\\n]\\n\", line) - 1;\n\n        if(line[0] == '#' && !e)\n\n            continue;\n\n        e|= sscanf(line, \"%999[^=]=%999[^\\n]\\n\", tmp, tmp2) - 2;\n\n        if(e){\n\n            fprintf(stderr, \"%s: Preset file invalid\\n\", filename);\n\n            av_exit(1);\n\n        }\n\n        if(!strcmp(tmp, \"acodec\")){\n\n            opt_audio_codec(tmp2);\n\n        }else if(!strcmp(tmp, \"vcodec\")){\n\n            opt_video_codec(tmp2);\n\n        }else if(!strcmp(tmp, \"scodec\")){\n\n            opt_subtitle_codec(tmp2);\n\n        }else if(opt_default(tmp, tmp2) < 0){\n\n            fprintf(stderr, \"%s: Invalid option or argument: %s=%s\\n\", filename, tmp, tmp2);\n\n            av_exit(1);\n\n        }\n\n    }\n\n\n\n    fclose(f);\n\n\n\n    return 0;\n\n}\n", "idx": 6535, "substitutes": {"opt": ["init", "open", "prefix", "it", "type", "cmp", "buf", "alg", "ext", "prop", "cmd", "stat", "etc", "typ", "no", "var", "op", "option", "alt", "OP", "str", "let", "opted", "crit", "options", "attr", "expr", "params", "kw", "org", "txt", "not", "altern", "lt", "config", "parent", "cat", "obj", "pres", "j", "ver", "ost", "oop", "name", "Opt", "bin"], "arg": ["event", "ob", "file", "valid", "key", "w", "tag", "word", "txt", "req", "ack", "ret", "ag", "params", "star", "path", "loc", "flag", "ring", "gt", "par", "mem", "null", "alg", "g", "op", "bit", "str", "v", "config", "parse", "supp", "decl", "agg", "ar", "target", "argument", "msg", "vol", "var", "val", "nick", "ax", "attr", "rest", "mac", "kw", "sec", "cal", "reg", "param", "name", "match", "call", "pack", "ext", "cmd", "arp", "range", "err", "ref", "list", "Arg", "slot", "args", "emb", "spec", "doc", "lag", "arr", "def"], "f": ["cf", "form", "uf", "alf", "b", "ff", "fm", "xf", "c", "u", "h", "fe", "feed", "lf", "file", "fc", "elf", "p", "d", "g", "n", "F", "fl", "o", "fp", "t", "full", "func", "r", "w", "rf", "bf", "try", "v", "fac", "fed", "found", "m", "stream", "fn", "fb", "tf", "y", "sf", "fi", "fs", "fo", "e", "l", "fr", "j", "x", "fg", "fd", "fw"], "filename": ["ln", "unction", "file", "ename", "fp", "kl", "mpeg", "username", "ames", "png", "txt", "amd", "message", "dest", "size", "directory", "j", "origin", "names", "source", "path", "output", "folder", "this", "csv", "root", "stem", "ame", "nil", "out", "pdf", "video", "config", "fn", "dir", "subject", "length", "json", "original", "prefix", "src", "target", "files", "msg", "fil", "nm", "Filename", "disk", "sql", "fr", "xxx", "latest", "name", "fd", "lua", "jpg", "window", "binary", "sys", "buffer", "wav", "n", "unc", "temp", "err", "slice", "bf", "tp", "title"], "tmp": ["fake", "sp", "buff", "jpg", "copy", "prefix", "src", "cp", "tem", "ctx", "cmp", "sam", "tar", "buf", "nt", "file", "msg", "template", "nam", "mk", "tg", "cmd", "etc", "tm", "perm", "upload", "t", "split", "temp", "emp", "zip", "slice", "to", "proc", "pkg", "top", "png", "out", "txt", "video", "tu", "orig", "clip", "mb", "rt", "shot", "st", "dir", "part", "tab", "img", "mm", "cache", "np", "obj", "test", "size", "td", "snap", "stuff", "name", "path", "mp"], "tmp2": ["txt3", "txt6", "mp6", " tmp4", "tmp4", " tmp6", "txt1", "temp4", "mp2", "tmp6", " tmp1", "temp6", "mp3", "mp1", " tmp3", "temp2", "tmp3", "txt2", "tmp1", "temp3", "temp1", "mp4"], "line": ["header", "error", "ine", "LINE", "call", "ln", "end", "c", "lin", "page", "file", "force", "d", "co", "lines", "ie", "link", "len", "row", " Line", "se", "lo", "range", "pe", "str", "limit", "word", "pos", "list", "inter", "pipe", "code", "iter", "out", "frame", "block", "cell", "comment", "entry", "Line", "eline", "e", "lock", "nl", "flag", "l", "le"], "i": ["init", "ic", "ini", "ij", "ei", "ci", "it", "im", "any", "c", "cli", "gl", "oi", "gi", "mi", "qi", "ip", "li", "g", "si", "p", "ami", "zi", "n", "is", "xi", "ind", "index", "o", "t", "key", "pi", "multi", "bi", "ri", "me", "ui", "id", "ki", "list", "ji", "phi", "ti", "v", "ims", "ix", "ai", "m", "status", "I", "y", "\u0438", "us", "sim", "io", "iu", "e", "info", "gu", "j", "z", "in", "x", "di", "ii"], "base": ["absolute", "tree", "chain", "b", "root", "prefix", "node", "it", "quote", "type", "null", "real", "box", "set", "sys", "store", "relative", "client", "file", "buffer", "force", "template", "profile", "var", "name", "val", "enable", "win", "range", "se", "server", "stack", "bound", "Base", "prime", "bit", "id", "list", "bar", "space", "rest", "start", "max", "bare", "status", "block", "basic", "area", "cache", "size", "bas", "ase", "tail", "based"], "codec_name": ["coditor_size", "codEC_Name", "codec_type", "codec___size", "codEC_name", "coditor___name", "codec2name", "codec2type", "codecitylen", "codecityname", "codec_len", "codec_id", "coditor_len", "codec___len", "codecitysize", "codec_Name", "codecityid", "codEC_no", "codec___name", "codec2no", "codec_no", "codec___id", "coditor_id", "coditor___len", "coditor___size", "coditor_name", "codEC_type", "codec2Name", "coditor___id", "codec_size"]}}
{"project": "FFmpeg", "commit_id": "fdbc544d29176ba69d67dd879df4696f0a19052e", "target": 1, "func": "static int asf_read_ext_content(AVFormatContext *s, const GUIDParseTable *g)\n\n{\n\n    ASFContext *asf  = s->priv_data;\n\n    AVIOContext *pb  = s->pb;\n\n    uint64_t size    = avio_rl64(pb);\n\n    uint16_t nb_desc = avio_rl16(pb);\n\n    int i, ret;\n\n\n\n    for (i = 0; i < nb_desc; i++) {\n\n        uint16_t name_len, type, val_len;\n\n        uint8_t *name = NULL;\n\n\n\n        name_len = avio_rl16(pb);\n\n        if (!name_len)\n\n            return AVERROR_INVALIDDATA;\n\n        name = av_malloc(name_len);\n\n        if (!name)\n\n            return AVERROR(ENOMEM);\n\n        avio_get_str16le(pb, name_len, name,\n\n                         name_len);\n\n        type    = avio_rl16(pb);\n\n        val_len = avio_rl16(pb);\n\n\n\n        if ((ret = process_metadata(s, name, name_len, val_len, type, &s->metadata)) < 0)\n\n            return ret;\n\n    }\n\n\n\n    align_position(pb, asf->offset, size);\n\n    return 0;\n\n}\n", "idx": 6543, "substitutes": {"s": ["as", "rs", "gs", "q", "sp", "b", "sg", "less", "ns", "c", "its", "ctx", "h", "ats", "sys", "cs", "sc", "os", "p", "ps", "ms", "n", "ts", "ds", "o", "t", "es", "js", "ins", "sv", "ls", "sb", "v", "stats", "m", "sa", "hs", "ss", "bs", "y", "sq", "f", "fs", "e", "S", "in", "sts", "x", "a"], "g": ["gt", "gb", "gs", "gc", "sg", "gp", "gm", "gas", " m", "bg", "msg", "tg", "mg", "ge", "group", "gd", "go", "pg", " gp", "vg", "cfg", "m", "gu", "gen", "ga", "j", "gg", "G"], "asf": [" asuf", "rasc", " asfe", "atsf", "Asv", "Asf", "Asfo", "atsuf", "rasv", "asfo", "rasfo", "Asuf", "asv", " asfo", " asc", "Asfe", "rasf", "asc", "asfe", "atsfo", "atsfe", "Asc", "asuf", " asv"], "pb": ["stab", "apa", "uf", "sp", "peer", "bj", "ab", "gp", "cp", "wp", "eb", "asm", "pc", "ctx", "pan", "phy", "pt", "buf", "ob", "prot", "p", "tg", "pa", "mt", "bp", "orp", "typ", "vp", "cb", "pl", "wb", "fp", "erb", "queue", "pm", "ub", "pg", "pkg", "proc", "ap", "sb", "pr", "py", "lp", "summary", "rb", "emb", "mb", "resp", "tab", "bs", "fb", "cv", "iat", "pool", "jp", "np", "dp", "amp", "xp", "PB", "pp", "td", "tk", "tp", "mp"], "i": ["init", "ic", "ini", "chain", " bi", " multi", "ci", " li", " ii", " di", "it", "ei", " m", "im", "c", "mi", "qi", "li", "p", "si", " si", "zi", "ms", "n", "is", "iq", "xi", "ind", "index", "t", " ti", "pi", "multi", "bi", "go", "me", "ui", "q", " I", "phi", "ti", " pi", " iter", "v", "ims", "ix", "ai", "m", "status", " mi", "I", "batch", "y", "print", "us", "sim", "ex", "iu", "in", "j", "z", "x", "di", "ii"], "ret": ["gt", "result", "pret", "term", "ber", "job", "mel", "rel", "det", "ter", "nt", "mt", " Ret", "rets", "len", "val", "aux", "over", "tr", "red", "alt", "r", "err", "ref", "rem", "out", "try", "txt", "not", "rt", "fun", "reset", "lt", "re", "resp", "port", "status", "print", "RET", "jp", "Ret", "ft", "ll", "nl", "res", " RET", "j", "def", "elt", "flag"], "name_len": ["name_loc", "name_Len", " name_list", "Name_len", "namelengthlen", " name_fin", "namelengthspec", "name_spec", "name_ll", "name_list", "val_spec", "namelengthLen", "namelengthden", "Name_length", "val_den", "Name_lon", " name_num", "name_den", " name_length", "name_elt", "name_length", " name_elt", "name_fin", "val_Len", "name_num", " name_ll", "name_ln", " name_ln", "name_lon", " name_Len", "Name_loc", "Name_Len"], "type": ["TYPE", "cast", "ty", "form", "ico", "error", "ping", "kind", "what", "typ", "ype", "len", "op", "val", "t", "key", "types", "pe", "value", "ime", "unit", "tag", "id", "role", "style", "try", "ack", "parent", "desc", "cat", "Type", "test", "size", "time", "info", "length", "by", "format", "other", "class", "ver", "color"], "val_len": ["valjpl", "val67Len", "value_mem", "val_mem", "val_Len", "value_Len", " val_compl", "value_len", "valjln", "value_val", "val_ln", "val_val", "valjlen", "val_pl", " val_Len", "val67len", "value_ln", "val67pl", "value_pl", "val_compl", "val67ln", "valjLen"], "name": ["error", "names", "b", "prefix", "mem", "null", "def", "ma", "create", "nam", "p", "ame", "n", "no", "len", "var", "val", "na", "label", "data", "key", "t", "value", "str", "record", "id", "ref", "word", "me", "nm", "code", "num", "v", "m", "new", "NAME", "part", "parent", "alias", "local", "size", "info", "length", "a", "title", "Name", "path"]}}
{"project": "qemu", "commit_id": "3f910692c287e1c611c00e763ebeb95ed0e017f8", "target": 1, "func": "static int vhdx_log_write(BlockDriverState *bs, BDRVVHDXState *s,\n\n                          void *data, uint32_t length, uint64_t offset)\n\n{\n\n    int ret = 0;\n\n    void *buffer = NULL;\n\n    void *merged_sector = NULL;\n\n    void *data_tmp, *sector_write;\n\n    unsigned int i;\n\n    int sector_offset;\n\n    uint32_t desc_sectors, sectors, total_length;\n\n    uint32_t sectors_written = 0;\n\n    uint32_t aligned_length;\n\n    uint32_t leading_length = 0;\n\n    uint32_t trailing_length = 0;\n\n    uint32_t partial_sectors = 0;\n\n    uint32_t bytes_written = 0;\n\n    uint64_t file_offset;\n\n    VHDXHeader *header;\n\n    VHDXLogEntryHeader new_hdr;\n\n    VHDXLogDescriptor *new_desc = NULL;\n\n    VHDXLogDataSector *data_sector = NULL;\n\n    MSGUID new_guid = { 0 };\n\n\n\n    header = s->headers[s->curr_header];\n\n\n\n    /* need to have offset read data, and be on 4096 byte boundary */\n\n\n\n    if (length > header->log_length) {\n\n        /* no log present.  we could create a log here instead of failing */\n\n        ret = -EINVAL;\n\n        goto exit;\n\n    }\n\n\n\n    if (guid_eq(header->log_guid, zero_guid)) {\n\n        vhdx_guid_generate(&new_guid);\n\n        vhdx_update_headers(bs, s, false, &new_guid);\n\n    } else {\n\n        /* currently, we require that the log be flushed after\n\n         * every write. */\n\n        ret = -ENOTSUP;\n\n        goto exit;\n\n    }\n\n\n\n    /* 0 is an invalid sequence number, but may also represent the first\n\n     * log write (or a wrapped seq) */\n\n    if (s->log.sequence == 0) {\n\n        s->log.sequence = 1;\n\n    }\n\n\n\n    sector_offset = offset % VHDX_LOG_SECTOR_SIZE;\n\n    file_offset = (offset / VHDX_LOG_SECTOR_SIZE) * VHDX_LOG_SECTOR_SIZE;\n\n\n\n    aligned_length = length;\n\n\n\n    /* add in the unaligned head and tail bytes */\n\n    if (sector_offset) {\n\n        leading_length = (VHDX_LOG_SECTOR_SIZE - sector_offset);\n\n        leading_length = leading_length > length ? length : leading_length;\n\n        aligned_length -= leading_length;\n\n        partial_sectors++;\n\n    }\n\n\n\n    sectors = aligned_length / VHDX_LOG_SECTOR_SIZE;\n\n    trailing_length = aligned_length - (sectors * VHDX_LOG_SECTOR_SIZE);\n\n    if (trailing_length) {\n\n        partial_sectors++;\n\n    }\n\n\n\n    sectors += partial_sectors;\n\n\n\n    /* sectors is now how many sectors the data itself takes, not\n\n     * including the header and descriptor metadata */\n\n\n\n    new_hdr = (VHDXLogEntryHeader) {\n\n                .signature           = VHDX_LOG_SIGNATURE,\n\n                .tail                = s->log.tail,\n\n                .sequence_number     = s->log.sequence,\n\n                .descriptor_count    = sectors,\n\n                .reserved            = 0,\n\n                .flushed_file_offset = bdrv_getlength(bs->file->bs),\n\n                .last_file_offset    = bdrv_getlength(bs->file->bs),\n\n              };\n\n\n\n    new_hdr.log_guid = header->log_guid;\n\n\n\n    desc_sectors = vhdx_compute_desc_sectors(new_hdr.descriptor_count);\n\n\n\n    total_length = (desc_sectors + sectors) * VHDX_LOG_SECTOR_SIZE;\n\n    new_hdr.entry_length = total_length;\n\n\n\n    vhdx_log_entry_hdr_le_export(&new_hdr);\n\n\n\n    buffer = qemu_blockalign(bs, total_length);\n\n    memcpy(buffer, &new_hdr, sizeof(new_hdr));\n\n\n\n    new_desc = buffer + sizeof(new_hdr);\n\n    data_sector = buffer + (desc_sectors * VHDX_LOG_SECTOR_SIZE);\n\n    data_tmp = data;\n\n\n\n    /* All log sectors are 4KB, so for any partial sectors we must\n\n     * merge the data with preexisting data from the final file\n\n     * destination */\n\n    merged_sector = qemu_blockalign(bs, VHDX_LOG_SECTOR_SIZE);\n\n\n\n    for (i = 0; i < sectors; i++) {\n\n        new_desc->signature       = VHDX_LOG_DESC_SIGNATURE;\n\n        new_desc->sequence_number = s->log.sequence;\n\n        new_desc->file_offset     = file_offset;\n\n\n\n        if (i == 0 && leading_length) {\n\n            /* partial sector at the front of the buffer */\n\n            ret = bdrv_pread(bs->file, file_offset, merged_sector,\n\n                             VHDX_LOG_SECTOR_SIZE);\n\n            if (ret < 0) {\n\n                goto exit;\n\n            }\n\n            memcpy(merged_sector + sector_offset, data_tmp, leading_length);\n\n            bytes_written = leading_length;\n\n            sector_write = merged_sector;\n\n        } else if (i == sectors - 1 && trailing_length) {\n\n            /* partial sector at the end of the buffer */\n\n            ret = bdrv_pread(bs->file,\n\n                            file_offset,\n\n                            merged_sector + trailing_length,\n\n                            VHDX_LOG_SECTOR_SIZE - trailing_length);\n\n            if (ret < 0) {\n\n                goto exit;\n\n            }\n\n            memcpy(merged_sector, data_tmp, trailing_length);\n\n            bytes_written = trailing_length;\n\n            sector_write = merged_sector;\n\n        } else {\n\n            bytes_written = VHDX_LOG_SECTOR_SIZE;\n\n            sector_write = data_tmp;\n\n        }\n\n\n\n        /* populate the raw sector data into the proper structures,\n\n         * as well as update the descriptor, and convert to proper\n\n         * endianness */\n\n        vhdx_log_raw_to_le_sector(new_desc, data_sector, sector_write,\n\n                                  s->log.sequence);\n\n\n\n        data_tmp += bytes_written;\n\n        data_sector++;\n\n        new_desc++;\n\n        file_offset += VHDX_LOG_SECTOR_SIZE;\n\n    }\n\n\n\n    /* checksum covers entire entry, from the log header through the\n\n     * last data sector */\n\n    vhdx_update_checksum(buffer, total_length,\n\n                         offsetof(VHDXLogEntryHeader, checksum));\n\n\n\n    /* now write to the log */\n\n    ret = vhdx_log_write_sectors(bs, &s->log, &sectors_written, buffer,\n\n                                 desc_sectors + sectors);\n\n    if (ret < 0) {\n\n        goto exit;\n\n    }\n\n\n\n    if (sectors_written != desc_sectors + sectors) {\n\n        /* instead of failing, we could flush the log here */\n\n        ret = -EINVAL;\n\n        goto exit;\n\n    }\n\n\n\n    s->log.sequence++;\n\n    /* write new tail */\n\n    s->log.tail = s->log.write;\n\n\n\nexit:\n\n    qemu_vfree(buffer);\n\n    qemu_vfree(merged_sector);\n\n    return ret;\n\n}\n", "idx": 6545, "substitutes": {"bs": ["rs", "gs", "ses", "b", "ns", "ubs", "its", "bc", "sys", "cs", "os", "bh", "ps", "ms", "bp", "ts", "ds", "BS", "bt", "es", "js", "bb", "ls", "blocks", "sb", "vs", "aos", "ss", "bl", "fs", "sts", "bm", "obs", "lbs"], "s": ["rs", "sp", "gs", "ses", "b", "bis", "ns", "its", "h", "sys", "qs", "state", "cs", "comm", "store", "os", "actions", "p", "ps", "ms", "n", "is", "ts", "settings", "ds", "t", "es", "server", "r", "support", "js", "sv", "ls", "sb", "services", "v", "stats", "bits", "hs", "vs", "ss", "sn", "serv", "socket", "session", "fs", "S", "sts", "changes", "comments"], "data": ["bytes", "error", "next", "binary", "buf", "extra", "table", "d", "body", "partial", "ata", "row", "o", "Data", "pos", "command", "block", "reader", "batch", "DATA", "message", "size", "text", "image", "bin"], "length": ["all", "present", "read", "bytes", "padding", "SIZE", "half", "end", "term", "type", "h", "shift", "oh", "amount", "f", "duration", "location", "len", "required", "name", "row", "index", "total", "t", "available", "full", "maximum", "history", "height", "number", "Length", "position", "limit", "HH", "start", "ENGTH", "angle", "ength", "block", "head", "expected", "version", "ptr", "enth", "capacity", "count", "address", "message", "loop", "shape", "DATA", "size", "family", "before", "L", "l"], "offset": ["rot", "error", "padding", "window", "shift", "pad", "set", "page", "vector", "ob", "base", "addr", "seed", "location", "seek", "len", "row", "pointer", "index", "o", "range", "t", "trace", "position", "ref", "pos", "id", "foot", "start", "out", "sector", "timeout", "slot", "reset", "block", "head", "off", "version", "ptr", "address", "f", "message", "size", "Offset", "origin"], "buffer": ["buff", "channel", "binary", "buf", "Buffer", "table", "base", "row", "history", "section", "sector", "v", "memory", "command", "block", "writer", "comment", "ptr", "batch", "cache", "address", "message", "size", "tail"], "merged_sector": ["merge_ser", "merged2section", "merged_section", "merge_section", "merge_sector", "merged2sector", "merge_vector", "merged_vector", "merged2ser", "merged2vector", "merged_ser"], "data_tmp": ["data_buf", "dataacwriter", " data_writer", "dataacmp", "data_writer", "dataactmp", "dataacbuf", " data_mp", "data_mp", " data_buf"], "sector_write": ["sector___len", "section_offset", "sector_len", "section_len", "sector2offset", "section_writ", "sector___writ", "section_write", "sector2write", "sector___offset", "sector_writ", "sector2writ", "sector2len", "sector___write"], "i": ["ci", "set", " v", "ip", "p", "si", " si", " t", "o", "t", "pi", " pos", "phi", "start", " j", "I", " index", "f", "info", " len", "e", "j", " count", "di", "ii", "l", " l"], "sector_offset": ["sector_mask", "sector_index", "sector_length", "test_left", "testityid", "sector_Offset", "sector_point", "testitymask", "vector_length", "leader_off", "test_mask", "sectoritymask", "vector_point", "leader_no", "sector_no", "sector_off", "vector_offset", "ector_offset", "sector_id", "ector_index", "ector_start", "sectorityleft", "sectorityoffset", "sector_start", "sector_area", "sectorityid", "testityleft", "leader_index", "testityoffset", "test_offset", "vector_Offset", "ector_area", "test_id", "leader_offset", "sector_left"], "desc_sectors": ["desc_velements", "desc_pectors", "desc_segments", "desc_pelements", "desc_vectors", "desc_beors", "desc_peors", "desc_vegments", "desc_pegments", "desc_begments", "desc_seors", "desc_belements", "desc_bectors", "desc_selements", "desc_veors"], "sectors": ["spegments", "speriers", " segments", "segments", "spectors", "vevers", "seriers", "vectors", "tellers", "teors", "spevers", "seors", "veriers", " severs", "vellers", "nellers", " sellers", "tectors", "negments", "neriers", " seors", "veors", "tegments", " seriers", "severs", "sellers", "vegments", "nectors"], "total_length": ["total_offset", "total_len", " total_len", "total_duration", " total_offset", " total_duration"], "aligned_length": ["aligned_direction", "aligned_build", "fixedtlen", "aligned_command", "alignedtcommand", "fixed_command", "aligned_offset", "aligned_position", " aligned_Length", "aligned___offset", "alignedityduration", "fixed_length", "aligned___len", "fixed_len", " aligned___distance", "aligned67offset", "aligned_value", "fixedtlength", "aligned67length", "aligned67build", "balanced_result", "aligned___duration", "aligned_count", "alignedmingcapacity", " aligned_duration", "aligned67result", "alignedmingvalue", "aligned_capacity", "aligned67direction", "reported_length", "fixed_count", "alignedlycount", "aligned_Length", "aligned_duration", " aligned___len", "alignedmingresult", "balanced_length", "alignedJlen", "balanced_value", " aligned_offset", "alignedlycommand", " aligned___duration", "alignedJdistance", "reported_direction", "reported_build", "aligneditylen", "alignedJlength", "alignedminglength", "aligned___distance", "alignedJduration", " aligned_distance", "aligned_result", "alignedlylen", " aligned___length", "aligneditydistance", "balanced_capacity", "aligned___length", "alignedlylength", "aligneditylength", "aligned_len", "aligned67capacity", "aligned___direction", " aligned_position", "fixedtcommand", "aligned67value", "aligned___build", " aligned_len", "reported_offset", "fixedtcount", "aligned_distance", "alignedtlen", "alignedtcount", "alignedtlength"], "file_offset": ["byte_index", "byte_offset", "file___page", "file__page", "base_index", "byte_start", "file__index", "file__start", "file_page", "file_start", "file___start", "file_index", "file___index", "base_start", "base_offset", "file64start", "file64off", "file64offset", "byte_off", "file_off", "file__offset", "file64index", "base_page", "file___offset"], "header": ["policy", "peer", "tree", "event", "padding", "metadata", "window", "h", "state", "description", "heading", "prot", "er", "profile", "table", "p", "order", "body", "hawk", "document", "index", "tr", "history", "t", "headers", "server", "dr", "record", "section", "attribute", "wrapper", "master", "layer", "summary", "meta", "status", "config", "writer", "block", "frame", "head", "comment", "response", "ptr", "version", "handler", "cache", "address", "Header", "filter", "hash", "subject", "definition"], "new_hdr": ["new_chder", "new_cdr", "new_hDR", "new_chdr", "new_hld", "new_shDR", "new_shld", "new_cder", "new_chld", "new_cld", "new_chDR", "new_shdr", "new_hder", "new_cDR", "new_shder"], "new_desc": ["new2des", "next_description", "next_desc", "new_description", "new_def", "new___description", "new2def", "next___des", "next___description", "new2desc", "new___desc", "new_des", "next___def", "new2description", "next_def", "new___des", "next___desc", "next_des", "new___def"], "data_sector": [" data_section", " data_table", "data_table", " data_ser", "data_ser", "data_section"], "partial_sectors": ["partial_spegments", "partial_serctors", "partial_spevers", "partial_severs", "partial_sesctors", "partial_sesors", "partial_vectors", "partial_beors", "partial_veores", "partial_vegments", "partial_bevers", "partial_seors", "partial_spectors", "partial_seores", "partial_segments", "partial_speors", "partial_veors", "partial_sesores", "partial_begments", "partial_serors", "partial_serores", "partial_sercars", "partial_secars", "partial_sescars", "partial_vevers", "partial_vecars", "partial_bectors"], "sequence": ["ence", "counter", "chain", "next", "choice", "step", "sequ", "note", "store", "cycle", "seq", "seed", "index", "queue", "se", "server", "scale", "repeat", "position", "section", "timeout", "component", "command", "frame", "secret", "expected", "controller", "frequency", "action", "version", "batch", "serial", "sample", "message", "series", "reference", "delay"]}}
{"project": "qemu", "commit_id": "aa4a3dce1c88ed51b616806b8214b7c8428b7470", "target": 1, "func": "static void vmxnet3_net_uninit(VMXNET3State *s)\n\n{\n\n    g_free(s->mcast_list);\n\n    vmxnet_tx_pkt_reset(s->tx_pkt);\n\n    vmxnet_tx_pkt_uninit(s->tx_pkt);\n\n    vmxnet_rx_pkt_uninit(s->rx_pkt);\n\n    qemu_del_nic(s->nic);\n\n}\n", "idx": 6547, "substitutes": {"s": ["as", "rs", "gs", "ses", "less", "ns", "sol", "c", "its", "h", "ies", "qs", "set", "comm", "cs", "os", "d", "ps", "details", "n", "is", "ts", "ds", "r", "js", "w", "ins", "sv", "ls", "sb", "v", "ties", "stats", "args", "sl", "spec", "hs", "vs", "a", "ss", "bs", "states", "y", "sq", "fs", "S", "sts", "changes", "sports", "aws", "l", "ops"]}}
{"project": "FFmpeg", "commit_id": "ec3b22326dc07fb8300a577bd6b17c19a0f1bcf7", "target": 1, "func": "static int http_prepare_data(HTTPContext *c)\n\n{\n\n    int i;\n\n\n\n    switch(c->state) {\n\n    case HTTPSTATE_SEND_DATA_HEADER:\n\n        memset(&c->fmt_ctx, 0, sizeof(c->fmt_ctx));\n\n        if (c->stream->feed) {\n\n            /* open output stream by using specified codecs */\n\n            c->fmt_ctx.oformat = c->stream->fmt;\n\n            c->fmt_ctx.nb_streams = c->stream->nb_streams;\n\n            for(i=0;i<c->fmt_ctx.nb_streams;i++) {\n\n                AVStream *st;\n\n                st = av_mallocz(sizeof(AVStream));\n\n                c->fmt_ctx.streams[i] = st;\n\n                if (c->stream->feed == c->stream)\n\n                    memcpy(st, c->stream->streams[i], sizeof(AVStream));\n\n                else\n\n                    memcpy(st, c->stream->feed->streams[c->stream->feed_streams[i]], sizeof(AVStream));\n\n\n\n                st->codec.frame_number = 0; /* XXX: should be done in\n\n                                               AVStream, not in codec */\n\n            }\n\n            c->got_key_frame = 0;\n\n        } else {\n\n            /* open output stream by using codecs in specified file */\n\n            c->fmt_ctx.oformat = c->stream->fmt;\n\n            c->fmt_ctx.nb_streams = c->fmt_in->nb_streams;\n\n            for(i=0;i<c->fmt_ctx.nb_streams;i++) {\n\n                AVStream *st;\n\n                st = av_mallocz(sizeof(AVStream));\n\n                c->fmt_ctx.streams[i] = st;\n\n                memcpy(st, c->fmt_in->streams[i], sizeof(AVStream));\n\n                st->codec.frame_number = 0; /* XXX: should be done in\n\n                                               AVStream, not in codec */\n\n            }\n\n            c->got_key_frame = 0;\n\n        }\n\n        init_put_byte(&c->fmt_ctx.pb, c->pbuffer, PACKET_MAX_SIZE,\n\n                      1, c, NULL, http_write_packet, NULL);\n\n        c->fmt_ctx.pb.is_streamed = 1;\n\n        /* prepare header */\n\n        av_write_header(&c->fmt_ctx);\n\n        c->state = HTTPSTATE_SEND_DATA;\n\n        c->last_packet_sent = 0;\n\n        break;\n\n    case HTTPSTATE_SEND_DATA:\n\n        /* find a new packet */\n\n#if 0\n\n        fifo_total_size = http_fifo_write_count - c->last_http_fifo_write_count;\n\n        if (fifo_total_size >= ((3 * FIFO_MAX_SIZE) / 4)) {\n\n            /* overflow : resync. We suppose that wptr is at this\n\n               point a pointer to a valid packet */\n\n            c->rptr = http_fifo.wptr;\n\n            c->got_key_frame = 0;\n\n        }\n\n        \n\n        start_rptr = c->rptr;\n\n        if (fifo_read(&http_fifo, (UINT8 *)&hdr, sizeof(hdr), &c->rptr) < 0)\n\n            return 0;\n\n        payload_size = ntohs(hdr.payload_size);\n\n        payload = av_malloc(payload_size);\n\n        if (fifo_read(&http_fifo, payload, payload_size, &c->rptr) < 0) {\n\n            /* cannot read all the payload */\n\n            av_free(payload);\n\n            c->rptr = start_rptr;\n\n            return 0;\n\n        }\n\n        \n\n        c->last_http_fifo_write_count = http_fifo_write_count - \n\n            fifo_size(&http_fifo, c->rptr);\n\n        \n\n        if (c->stream->stream_type != STREAM_TYPE_MASTER) {\n\n            /* test if the packet can be handled by this format */\n\n            ret = 0;\n\n            for(i=0;i<c->fmt_ctx.nb_streams;i++) {\n\n                AVStream *st = c->fmt_ctx.streams[i];\n\n                if (test_header(&hdr, &st->codec)) {\n\n                    /* only begin sending when got a key frame */\n\n                    if (st->codec.key_frame)\n\n                        c->got_key_frame |= 1 << i;\n\n                    if (c->got_key_frame & (1 << i)) {\n\n                        ret = c->fmt_ctx.format->write_packet(&c->fmt_ctx, i,\n\n                                                                   payload, payload_size);\n\n                    }\n\n                    break;\n\n                }\n\n            }\n\n            if (ret) {\n\n                /* must send trailer now */\n\n                c->state = HTTPSTATE_SEND_DATA_TRAILER;\n\n            }\n\n        } else {\n\n            /* master case : send everything */\n\n            char *q;\n\n            q = c->buffer;\n\n            memcpy(q, &hdr, sizeof(hdr));\n\n            q += sizeof(hdr);\n\n            memcpy(q, payload, payload_size);\n\n            q += payload_size;\n\n            c->buffer_ptr = c->buffer;\n\n            c->buffer_end = q;\n\n        }\n\n        av_free(payload);\n\n#endif\n\n        {\n\n            AVPacket pkt;\n\n\n\n            /* read a packet from the input stream */\n\n            if (c->stream->feed) {\n\n                ffm_set_write_index(c->fmt_in, \n\n                                    c->stream->feed->feed_write_index,\n\n                                    c->stream->feed->feed_size);\n\n            }\n\n            \n\n            if (av_read_packet(c->fmt_in, &pkt) < 0) {\n\n                if (c->stream->feed && c->stream->feed->feed_opened) {\n\n                    /* if coming from feed, it means we reached the end of the\n\n                       ffm file, so must wait for more data */\n\n                    c->state = HTTPSTATE_WAIT_FEED;\n\n                    return 1; /* state changed */\n\n                } else {\n\n                    /* must send trailer now because eof or error */\n\n                    c->state = HTTPSTATE_SEND_DATA_TRAILER;\n\n                }\n\n            } else {\n\n                /* send it to the appropriate stream */\n\n                if (c->stream->feed) {\n\n                    /* if coming from a feed, select the right stream */\n\n                    for(i=0;i<c->stream->nb_streams;i++) {\n\n                        if (c->stream->feed_streams[i] == pkt.stream_index) {\n\n                            pkt.stream_index = i;\n\n                            if (pkt.flags & PKT_FLAG_KEY) {\n\n                                c->got_key_frame |= 1 << i;\n\n                            }\n\n                            /* See if we have all the key frames, then \n\n                             * we start to send. This logic is not quite\n\n                             * right, but it works for the case of a \n\n                             * single video stream with one or more\n\n                             * audio streams (for which every frame is \n\n                             * typically a key frame). \n\n                             */\n\n                            if (!c->stream->send_on_key || ((c->got_key_frame + 1) >> c->stream->nb_streams)) {\n\n                                goto send_it;\n\n                            }\n\n                        }\n\n                    }\n\n                } else {\n\n                    AVCodecContext *codec;\n\n                send_it:\n\n                    /* Fudge here */\n\n                    codec = &c->fmt_ctx.streams[pkt.stream_index]->codec;\n\n\n\n                    codec->key_frame = ((pkt.flags & PKT_FLAG_KEY) != 0);\n\n\n\n#ifdef PJSG\n\n                    if (codec->codec_type == CODEC_TYPE_AUDIO) {\n\n                        codec->frame_size = (codec->sample_rate * pkt.duration + 500000) / 1000000;\n\n                        /* printf(\"Calculated size %d, from sr %d, duration %d\\n\", codec->frame_size, codec->sample_rate, pkt.duration); */\n\n                    }\n\n#endif\n\n\n\n                    if (av_write_packet(&c->fmt_ctx, &pkt, 0))\n\n                        c->state = HTTPSTATE_SEND_DATA_TRAILER;\n\n\n\n                    codec->frame_number++;\n\n                }\n\n\n\n                av_free_packet(&pkt);\n\n            }\n\n        }\n\n        break;\n\n    default:\n\n    case HTTPSTATE_SEND_DATA_TRAILER:\n\n        /* last packet test ? */\n\n        if (c->last_packet_sent)\n\n            return -1;\n\n        /* prepare header */\n\n        av_write_trailer(&c->fmt_ctx);\n\n        c->last_packet_sent = 1;\n\n        break;\n\n    }\n\n    return 0;\n\n}\n", "idx": 6556, "substitutes": {"c": ["dc", "gc", "chain", "conf", "h", "d", "ec", "cb", "ce", "t", "w", "cn", "oc", "cr", "ch", "cat", "can", "mc", "enc", "com", "cu", "abc", "this", "cam", "g", "coll", "v", "m", "uc", "ac", "config", "cd", "ca", "a", "l", "cf", "ci", "ct", "pc", "ctx", "bc", "anc", "cs", "comm", "at", "p", "cm", "co", "nc", "o", "r", "rc", "cal", "cv", "C", "cod", "form", "b", "call", "cp", "cl", "cont", "cmp", "con", "fc", "n", "etc", "lc", "xc", "cc", "err", "vc", "cache", "f", "rec", "e", "tc"], "i": ["chain", "ei", " multi", " ii", "im", "gi", "zi", "ind", " ti", "hi", "pi", " pi", " j", "I", "batch", " my", "io", "in", "j", "series", "x", "\u0438", "di", " l", "ic", " m", " all", " ni", "mi", "g", " si", "xi", "index", "ri", "bi", "ki", "ti", "v", "ai", "m", "PI", "remote", "us", " p", "info", "json", " li", "ci", "it", "u", " v", "ip", "li", "ami", "is", "ski", "history", "to", "rest", " I", " iter", "y", " index", " k", "ii", "ini", "ij", " bi", "uri", "cli", " wi", "oi", "qi", "si", "ie", " t", " pos", "multi", "err", "me", "ui", "slice", "ji", "list", "phi", "ims", "ix", "eu", "status", " mi", "sim", "ex", "iu", "point", "e", "gu", " port", " count"], "st": ["must", "cast", "sp", "et", "sw", "ct", "it", "est", "sth", "step", "stage", "kt", "sam", "cont", "ost", "set", "nd", "pt", "sc", "nt", "inst", "mt", "stat", "no", "ind", "std", "irst", "red", "t", "stack", "ut", "stop", "kl", "str", "th", "ast", "sv", "rest", "sm", "start", "sh", "sl", "art", "sn", "stable", "ist", "storage", "ST", "ft", "ste", "net", "sts", "sta", "ld", "ace", "z", "ust", "St", "tt"], "codec": ["odvec", "coeesc", "codvec", "coeenc", "codenc", "codevec", "codeesc", "dependvec", "componentenc", "oderer", "codeman", "codeerer", "componentesc", "odec", "componentec", "codeenc", "dependerer", "componenteman", "dependec", "coeec", "codeeman", "codesc", "coderer", "codeec", "coeeman"], "frame_number": ["framecknumber", "frame___span", "component_name", "frame_date", "frameckcode", "state_code", "state_key", "component_number", "frame____number", "frame64number", "frame___zero", "frame_key", "frame____span", "frame____zero", "frame64key", "frameCountname", "frame64date", "state_number", "frameckkey", "frame_code", "frame___name", "state_date", "frameCountnumber", "component___span", "component___name", "frameCountzero", "frame_name", "frameCountspan", "frameckdate", "frame64code", "frame_span", "component_span", "frame_zero", "frame____name", "component_zero", "component___number", "frame___number", "component___zero"]}}
{"project": "FFmpeg", "commit_id": "65db4899fa8790049bec3af16ecdb75dd81051fd", "target": 1, "func": "static void input_callback(MMAL_PORT_T *port, MMAL_BUFFER_HEADER_T *buffer)\n\n{\n\n    if (!buffer->cmd) {\n\n        AVBufferRef *buf = buffer->user_data;\n\n        av_buffer_unref(&buf);\n\n    }\n\n    mmal_buffer_header_release(buffer);\n\n}\n", "idx": 6575, "substitutes": {"port": ["pid", "ort", "gp", "window", "cp", "age", "pc", "pad", "pod", "page", "ip", "table", "p", "connection", "Port", "ports", "number", "position", "PORT", "ref", "id", "timeout", " sport", "m", "version", "socket", "address"], "buffer": ["header", "cast", "flag", "buff", "match", "error", "reflect", "empty", "window", "null", "pad", "ter", "Buffer", "uffer", "map", "profile", "table", "base", "timer", "program", "seek", "zero", "sync", "index", "queue", "data", "callback", "button", "server", "attribute", "bar", "device", "timeout", "iter", "command", "block", "bridge", "frame", "head", "comment", "phrase", "request", "batch", "entry", "cache", "address", "message", "face", "interface", "reference", "transfer"], "buf": ["ph", "bag", "uf", "buff", "br", "bc", "box", "nt", "mk", "bh", "seq", "map", "cmd", "var", "cb", "queue", "data", "func", "ref", "bar", "pkg", "Buff", "rb", "iter", "ah", "txt", "cap", "v", "alloc", "tmp", "ptr", "cv", "batch", "bl", "aka", "arr", "vec"]}}
{"project": "qemu", "commit_id": "61c7480fa36775cc2baa2f8141f0c64a15f827b5", "target": 1, "func": "CPUArchState *cpu_copy(CPUArchState *env)\n\n{\n\n    CPUState *cpu = ENV_GET_CPU(env);\n\n    CPUState *new_cpu = cpu_init(cpu_model);\n\n    CPUArchState *new_env = cpu->env_ptr;\n\n    CPUBreakpoint *bp;\n\n    CPUWatchpoint *wp;\n\n\n\n    /* Reset non arch specific state */\n\n    cpu_reset(new_cpu);\n\n\n\n    memcpy(new_env, env, sizeof(CPUArchState));\n\n\n\n    /* Clone all break/watchpoints.\n\n       Note: Once we support ptrace with hw-debug register access, make sure\n\n       BP_CPU break/watchpoints are handled correctly on clone. */\n\n    QTAILQ_INIT(&cpu->breakpoints);\n\n    QTAILQ_INIT(&cpu->watchpoints);\n\n    QTAILQ_FOREACH(bp, &cpu->breakpoints, entry) {\n\n        cpu_breakpoint_insert(new_cpu, bp->pc, bp->flags, NULL);\n\n    }\n\n    QTAILQ_FOREACH(wp, &cpu->watchpoints, entry) {\n\n        cpu_watchpoint_insert(new_cpu, wp->vaddr, wp->len, wp->flags, NULL);\n\n    }\n\n\n\n    return new_env;\n\n}\n", "idx": 6577, "substitutes": {"env": ["ev", "et", "node", "window", "end", "ctx", "h", "conn", "buf", "ve", "buffer", "er", "eg", "enter", "ew", "dev", "viron", "ec", "context", "environment", "vp", "server", "err", "w", "me", "sv", "esp", "eq", "en", "v", "ah", "nv", "ef", "vs", "cv", "ptr", "np", "vt", "obj", "cur", "vm", "e", "eve", "enc", "esm"], "cpu": ["CPU", "gb", "gc", "node", "cum", "cp", "rpm", "pu", "ctx", "CP", "prof", "none", "ka", "clock", "coin", "uart", "goal", "software", "profile", "util", "clus", "CU", "stat", "aux", "process", "ni", "hw", "crypt", "nu", "ilo", "linux", "ockey", "proc", "bench", "docker", "cn", "nic", "ruby", "lif", "bean", "processor", "apache", "uu", "pixel", "core", "us", "que", "nz", "currency", "runner", "efficiency", "net", "cu", "hog", "gpu", "ne", "library", "name", "rane", "computer", "python"], "new_cpu": ["export_CPU", "admin67processor", "exportingcp", "newlycpu", "admin67cpu", "New_gnu", "new___cpu", "new___cp", "new67processor", "admin_cpu", "exportingenv", "newablecpu", "New_nic", "admin_uu", "new_pu", "new_uu", "old_cpu", "export_cpu", "new_gnu", "export_env", "new_nic", "old___cp", "admin_processor", "newingcp", "newablenic", "old_pu", "old___cpu", "new_CPU", "new67uu", "admin67uu", "new___pu", "exportingCPU", "newlyprocessor", "newlyuu", "export_cp", "old_cu", "new_cp", "new67cpu", "old_cp", "New_cpu", "newablepu", "old___pu", "newingCPU", "newingenv", "exportingcpu", "new_processor", "newingcpu", "newablegnu", "new_cu", "old___cu", "new___cu", "New_pu"], "new_env": ["new___db", "NEW_en", "newResenv", "newResptr", "newResen", "new_en", "new___env", " new_db", "new_ev", "NEW_ev", "new___environment", "NEW_env", "newResenvironment", " new_ptr", "NEW_end", "new_db", " new_en", " new_vert", "new_environment", "new___vert", "new_ptr", "new_end", "new_vert", " new_environment"], "bp": ["gb", "lip", "bj", "gp", "cp", "eb", "pb", "bg", "pc", "br", "bc", "bsp", "bh", "p", "osp", "vp", "arp", "wr", "BIP", "bt", "fp", "BP", "lb", "isp", "bb", "sb", "lp", "bf", "ipp", "bps", "vs", "bs", "nb", "yp", "jp", "np", "bl", "dp", "pd", "pp", "kb", "PB", "tp", "hp", "lbs", "ba"], "wp": ["fw", "ww", "cp", "wal", "pb", "wy", "pc", "wx", "ht", "wm", "we", "p", "WP", "vp", "arp", "wr", "php", "wn", "wb", "hw", "iw", "wt", "rw", "fp", "wk", "wu", "w", "pkg", "wordpress", "lp", "vc", "wi", "mm", "yp", "jp", "np", "dp", "wl", "wd", "hop", "tp", "nw", "hp", "mp"]}}
{"project": "FFmpeg", "commit_id": "72dbc610be3272ba36603f78a39cc2d2d8fe0cc3", "target": 0, "func": "static void avc_luma_vt_and_aver_dst_16x16_msa(const uint8_t *src,\n\n                                               int32_t src_stride,\n\n                                               uint8_t *dst, int32_t dst_stride)\n\n{\n\n    int32_t loop_cnt;\n\n    int16_t filt_const0 = 0xfb01;\n\n    int16_t filt_const1 = 0x1414;\n\n    int16_t filt_const2 = 0x1fb;\n\n    v16u8 dst0, dst1, dst2, dst3;\n\n    v16i8 src0, src1, src2, src3, src4, src5, src6, src7, src8;\n\n    v16i8 src10_r, src32_r, src54_r, src76_r, src21_r, src43_r, src65_r;\n\n    v16i8 src87_r, src10_l, src32_l, src54_l, src76_l, src21_l, src43_l;\n\n    v16i8 src65_l, src87_l;\n\n    v8i16 out0_r, out1_r, out2_r, out3_r, out0_l, out1_l, out2_l, out3_l;\n\n    v16i8 filt0, filt1, filt2;\n\n    v16u8 res0, res1, res2, res3;\n\n\n\n    filt0 = (v16i8) __msa_fill_h(filt_const0);\n\n    filt1 = (v16i8) __msa_fill_h(filt_const1);\n\n    filt2 = (v16i8) __msa_fill_h(filt_const2);\n\n\n\n    LD_SB5(src, src_stride, src0, src1, src2, src3, src4);\n\n    src += (5 * src_stride);\n\n\n\n    XORI_B5_128_SB(src0, src1, src2, src3, src4);\n\n    ILVR_B4_SB(src1, src0, src2, src1, src3, src2, src4, src3,\n\n               src10_r, src21_r, src32_r, src43_r);\n\n    ILVL_B4_SB(src1, src0, src2, src1, src3, src2, src4, src3,\n\n               src10_l, src21_l, src32_l, src43_l);\n\n\n\n    for (loop_cnt = 4; loop_cnt--;) {\n\n        LD_SB4(src, src_stride, src5, src6, src7, src8);\n\n        src += (4 * src_stride);\n\n\n\n        XORI_B4_128_SB(src5, src6, src7, src8);\n\n        ILVR_B4_SB(src5, src4, src6, src5, src7, src6, src8, src7,\n\n                   src54_r, src65_r, src76_r, src87_r);\n\n        ILVL_B4_SB(src5, src4, src6, src5, src7, src6, src8, src7,\n\n                   src54_l, src65_l, src76_l, src87_l);\n\n        out0_r = DPADD_SH3_SH(src10_r, src32_r, src54_r, filt0, filt1, filt2);\n\n        out1_r = DPADD_SH3_SH(src21_r, src43_r, src65_r, filt0, filt1, filt2);\n\n        out2_r = DPADD_SH3_SH(src32_r, src54_r, src76_r, filt0, filt1, filt2);\n\n        out3_r = DPADD_SH3_SH(src43_r, src65_r, src87_r, filt0, filt1, filt2);\n\n        out0_l = DPADD_SH3_SH(src10_l, src32_l, src54_l, filt0, filt1, filt2);\n\n        out1_l = DPADD_SH3_SH(src21_l, src43_l, src65_l, filt0, filt1, filt2);\n\n        out2_l = DPADD_SH3_SH(src32_l, src54_l, src76_l, filt0, filt1, filt2);\n\n        out3_l = DPADD_SH3_SH(src43_l, src65_l, src87_l, filt0, filt1, filt2);\n\n        SRARI_H4_SH(out0_r, out1_r, out2_r, out3_r, 5);\n\n        SRARI_H4_SH(out0_l, out1_l, out2_l, out3_l, 5);\n\n        SAT_SH4_SH(out0_r, out1_r, out2_r, out3_r, 7);\n\n        SAT_SH4_SH(out0_l, out1_l, out2_l, out3_l, 7);\n\n        LD_UB4(dst, dst_stride, dst0, dst1, dst2, dst3);\n\n        PCKEV_B4_UB(out0_l, out0_r, out1_l, out1_r, out2_l, out2_r, out3_l,\n\n                    out3_r, res0, res1, res2, res3);\n\n        XORI_B4_128_UB(res0, res1, res2, res3);\n\n        AVER_UB4_UB(res0, dst0, res1, dst1, res2, dst2, res3, dst3,\n\n                    res0, res1, res2, res3);\n\n        ST_UB4(res0, res1, res2, res3, dst, dst_stride);\n\n        dst += (4 * dst_stride);\n\n\n\n        src10_r = src54_r;\n\n        src32_r = src76_r;\n\n        src21_r = src65_r;\n\n        src43_r = src87_r;\n\n        src10_l = src54_l;\n\n        src32_l = src76_l;\n\n        src21_l = src65_l;\n\n        src43_l = src87_l;\n\n        src4 = src8;\n\n    }\n\n}\n", "idx": 6580, "substitutes": {"src": ["iv", "rs", "ser", "sr", "sys", "sc", "sort", "addr", "inst", "stat", "seek", "url", "sync", "usr", "tr", "rob", "std", "rol", "input", "sel", "rc", "syn", "ins", "sb", "dist", "rt", "sl", "rl", "sub", "st", "load", "serv", "sn", "img", "scan", "ul", "supp", "cur", "dest", "comp", "ctr", "enc", "source", "RC", "loc"], "src_stride": ["src_strade", "src_strride", "src_STRid", "src_trides", "src_brides", "src_trride", "src_decade", "src_drides", "src_strend", "src_decate", "src_Strice", "src_strension", "src_Strate", "src_slension", "src_slate", "src_divid", "src_dride", "src_divade", "src_Stride", "src_STRice", "src_Strade", "src_brride", "src_slide", "src_strides", "src_trend", "src_divice", "src_drride", "src_strid", "src_brend", "src_strate", "src_decide", "src_strice", "src_bride", "src_slade", "src_drend", "src_STRade", "src_divide", "src_Strension", "src_STRide", "src_Strid", "src_tride", "src_decension"], "dst": ["ssrc", "dest", "ddest", "Dest", "sst", "Dsrc", "sest", " dsrc", "Dst", " ddest", " dest", "dsrc", "sdest", "Ddest"], "dst_stride": ["dst_tride", "dst_strend", "dst_decend", "dst_decide", "dst_decider", "dst_slider", "dst_trride", "dst_slide", "dst_strider", "dst_trider", "dst_slride", "dst_strride", "dst_trend", "dst_slend", "dst_decride"], "loop_cnt": ["loop_Cgt", "loop_Cnc", "loop_cgt", "loop_tcgt", "loop_lcnc", "loop_lcNT", "loop_tcnc", "loop_cnc", "loop_CNT", "loop_cNT", "loop_lcgt", "loop_tcnt", "loop_Cnt", "loop_lcnt", "loop_tcNT"], "dst0": ["dest0", "dset4", "dset0", " dset1", "dost4", "dest4", "dest1", "dst4", " dst4", " dset4", "dost1", "dost0", " dset0", "dset1"], "dst1": ["dput3", "daput5", "dest1", "daput3", "dast1", "dest3", "dst5", "ddest3", "ddest1", "ddest2", "dput5", "dput2", "dast5", "daput2", "daput1", "dput1", "dast2", "dest5", "dest2", "ddest5", "dast3"], "dst2": ["dsp8", "dost6", "dost02", "dsp2", "dost2", " dsp6", " dsp8", "dput6", " dsp2", "dst6", "dput2", " dst6", "dst8", " dst02", "dsp6", "dsp02", "dost8", " dsp02", " dst8", "dput8", "dput02", "dst02"], "dst3": [" dint3", "dint8", "dost2", " dint8", "dint2", "dest1", "dest8", "dest3", "dst8", " dint2", "dost1", "dint3", "dost8", " dint1", "dest2", " dst8", "dost3", "dint1"], "src0": [" src00", "source2", "rc00", "sr0", "rc2", "rc5", "rc3", "source5", "source3", "rc1", "sr00", "source1", "src00", "rc0", "source0", "sr1"], "src1": ["rc4", "proc3", "source2", "sys2", "source6", "rc2", "source01", "sys0", "src01", "rc3", "sys3", " src11", "rc6", "sys1", "source3", "src11", "rc1", " src01", "source11", "proc2", "source1", "rc01", "rc0", "rc11", "source4", "source0", "proc1", "proc6"], "src2": ["rc4", " src10", "source2", " src02", "rc2", "ser2", "src10", "rc10", "rc3", "source3", "rc1", "source02", "src02", "ser02", "rc02", "source1", "ser1", "rc0", "source4", "source0", "ser0", "ser4", "source10"], "src3": ["usr1", "rc4", "source2", "usr3", "rc43", "rc2", "ser2", "sc3", "sc03", "rc3", "src43", "source03", "source3", "src03", "rc1", "usr43", "source1", "rc03", "usr2", "ser03", "rc0", " src03", "source4", "source0", "sc2", "ser3", "source43"], "src4": ["rc4", "sn32", "sc6", "sn44", "rc32", "sc5", "source2", " src44", "source32", "rc2", "rc5", "sn4", "rc3", "source5", "rc6", "source3", "src32", "sc4", "source44", "rc0", "source4", "src44", "source0", "sc2", "rc44"], "src5": ["st5", "src65", "stFive", "inst65", "srcFive", "rc5", "inst5", "rc65", "rcFive", "instFive", "st65"], "src6": ["source6", "source7", "rc6", "sr48", "rc48", "sr7", "rc7", "sr8", "sr6", "source8", "source48", "rc8", "src48"], "src7": [" src17", "sr7", "rc7", "sr07", "sr8", "rc07", "rc17", "rc8", " src07", "sr17", "src07", "src17"], "src8": ["src9", "source5", " src9", "rc0", "rc9", "source9", "source0", "source8", "rc5", "rc8"], "src10_r": ["src90_pr", "src90_r", "src8_R", "src8_m", "src90_l", "src10_m", "src8_l", "src8_r", "src10_R", "src90_R", "src10_pr"], "src32_r": ["src3200sr", "src42_r", "src3200r", "src32_sr", "src42_er", "src3200er", "src42_l", "src3200l", "src32_er", "src42_sr"], "src54_r": ["src54___k", "src54_k", "src54___r", "src54___ro", "src43_k", "src54___l", "src54_ro", "src43_ro"], "src76_r": ["src74_m", "src74_l", "src76_m", "src76_R", "src74_r", "src74_R"], "src21_r": ["src41_r", "src41_right", "src21_ro", "src41_l", "src41_ro", "src21_right"], "src43_r": ["src43_R", "src65_R", "src65_cr", "src43_cr", "src65_ro", "src43_ro"], "src65_r": ["src66_ro", "src66_e", "src66_l", "src66_r", "src65_e", "src65_ro"], "src87_r": ["src57_l", "src87_p", "src57_r", "src57_R", "src57_p", "src87_R"], "src10_l": ["src80_l", "src80_ls", "src80_ml", "src10_lb", "src10_ml", "src10_ls", "src80_lb"], "src32_l": ["src44ablel", "src44ablecl", "src44ablell", "src32_rl", "src44_ll", "src44_l", "src32_ll", "src44ablerl", "src32ablerl", "src32ablecl", "src32_cl", "src32ablell", "src32ablel", "src44_rl", "src44_cl"], "src54_l": ["src62_pl", "src62_loc", "src62_c", "src54_pl", "src62_l", "src54_loc", "src54_c"], "src76_l": ["src76_lp", "src65_lp", "src76___pl", "src76_m", "src76___l", "src76___lp", "src76___m", "src76_pl", "src65_m", "src65_pl"], "src21_l": ["src31_ls", "src21_p", "src31_p", "src21_ls", "src21_h", "src31_h", "src31_l"], "src43_l": ["src43___pl", "src73___lp", "src73_ml", "src43___l", "src73___ml", "src43_pl", "src43_ml", "src43___ml", "src73___pl", "src43_lp", "src73_l", "src73_lp", "src43___lp", "src73___l", "src73_pl"], "src65_l": ["src48_p", "src65_h", "src48_l", "src48_h", "src48_b", "src65_b", "src65_p"], "src87_l": ["src87_lb", "src63_h", "src63_lb", "src87_lc", "src63_l", "src63_lc", "src87_h"], "out0_r": ["out02p", "out02m", "out10_m", "out0_R", "out10_p", "out10_r", "out02R", "out02r", "out10_R", "out0_p", "out0_m"], "out1_r": ["out4_rd", "out1_fr", "out1_rd", "out4_fr", "out4_r"], "out2_r": ["out2_b", "out02_r", "out02_re", "out02_b", "out2_re", "out02_l"], "out3_r": ["out3_R", "out15_r", "out15_s", "out3_s", "out15_R", "out15_l"], "out0_l": ["out10_ll", "out10_m", "out0_sl", "out10_l", "out10_sl", "out0_m", "out0_ll"], "out1_l": ["out1_hl", "out3_n", "out1_n", "out3_t", "out1_t", "out3_hl"], "out2_l": ["out12_m", "out2_i", "out2_sl", "out12_sl", "out12_i", "out2_m", "out12_l"], "out3_l": ["out3_b", "out3_d", "out1_h", "out3_h", "out1_b", "out1_d"], "filt0": ["feltee", "filt5", "fil0", "fil9", " fittee", " filtee", "filtration0", "fitt1", " filt9", " fil2", "fitt2", "fitt3", "filtration9", "flet0", " fitt0", " fil0", "flet1", " fitt1", "fitt5", " filt3", " fil9", " fil5", " fitt3", "fitt9", "fittee", "fitt0", "felt3", "flet3", "fil2", " filt5", "filt9", "felt1", "filtration5", "fletee", "filtee", "filtration2", "filt3", "fil5", "felt0"], "filt1": ["filt5", "frirmOne", "fil0", " fault0", "firm2", "fil4", "fault1", "filtOne", " filt4", "firm1", "fault0", "friltOne", "filtration3", "firmOne", "frirm1", "fault5", " fault4", "fault4", "filtrationOne", "fil1", "filt4", "firt4", "ffilterOne", "frirm3", "filtration1", "firt0", "frirm2", "frilt2", " fault5", "ffilter2", " filt5", "ffilter1", "frilt3", " fault1", "ffilter3", "filtration2", "firm3", "firt5", "firt1", "filt3", "frilt1", "fil5"], "filt2": ["filt5", "fift3", "filt12", "fil4", " filt4", "frird6", "fld42", "filt42", "filt6", "facet2", "fift6", "fird2", "fld5", "facet4", "frilt12", " fld42", "frird12", "fift12", "filt4", "fil42", " filt42", "fil12", "frilt6", "fil3", "frilt2", "fld4", " fld2", "fil2", "facet42", " filt5", "fift2", " fld4", "fird3", "frird3", " fld5", "fird6", "frilt3", "frird2", "facet5", "fird12", "fld2", "filt3", "fil6", "fil5"], "res0": ["pres3", "Res2", "Res1", "pres0", "pres1", "Res0", "pres2", "Res3"], "res1": ["resolution0", "resolution4", "pres01", "res01", "pres0", "pres1", " res4", "resolution01", "resolution1", "pres4", "res4", " res01"], "res2": [" res8", "Res2", " res02", "pres2", "res02", " res4", "Res02", "Res4", "pres8", "Res8", "pres4", "pres02", "res4", "res8"], "res3": ["ret43", "pres3", " res43", "ret5", "res5", "ret3", "res43", "ret03", "res03", "pres43", "pres03", " res5", "pres5", " res03"]}}
{"project": "qemu", "commit_id": "6e99c631f116221d169ea53953d91b8aa74d297a", "target": 0, "func": "static int net_socket_can_send(void *opaque)\n\n{\n\n    NetSocketState *s = opaque;\n\n\n\n    return qemu_can_send_packet(&s->nc);\n\n}\n", "idx": 6594, "substitutes": {"opaque": ["ogacity", " opossibly", "opoid", "ogity", "ploid", "hopause", " Opaque", "plity", " Opacement", "opossibly", "hopaque", "ocacity", "ocity", "hopacement", " Opossibly", "opity", "opacement", "opacity", "ocoid", "opause", " opacement", "ocaque", "placity", "ogoid", " Opause", "plaque", "hopossibly", " opause", "ogaque"], "s": ["rs", "gs", "q", "sp", "b", "less", "c", "ats", "sam", "i", "set", "cs", "os", "p", "ps", "n", "is", "ts", "ds", "o", "t", "r", "sv", "ls", "sm", "sb", "ess", "v", "sl", "a", "hs", "ss", "sq", "fs", "S", "sts", "j", "sis", "aws"]}}
{"project": "qemu", "commit_id": "64d7e9a421fea0ac50b44541f5521de455e7cd5d", "target": 0, "func": "static void ppc_prep_init (ram_addr_t ram_size,\n\n                           const char *boot_device,\n\n                           const char *kernel_filename,\n\n                           const char *kernel_cmdline,\n\n                           const char *initrd_filename,\n\n                           const char *cpu_model)\n\n{\n\n    CPUState *env = NULL;\n\n    char *filename;\n\n    nvram_t nvram;\n\n    M48t59State *m48t59;\n\n    int PPC_io_memory;\n\n    int linux_boot, i, nb_nics1, bios_size;\n\n    ram_addr_t ram_offset, bios_offset;\n\n    uint32_t kernel_base, initrd_base;\n\n    long kernel_size, initrd_size;\n\n    PCIBus *pci_bus;\n\n    qemu_irq *i8259;\n\n    qemu_irq *cpu_exit_irq;\n\n    int ppc_boot_device;\n\n    DriveInfo *hd[MAX_IDE_BUS * MAX_IDE_DEVS];\n\n    DriveInfo *fd[MAX_FD];\n\n\n\n    sysctrl = qemu_mallocz(sizeof(sysctrl_t));\n\n\n\n    linux_boot = (kernel_filename != NULL);\n\n\n\n    /* init CPUs */\n\n    if (cpu_model == NULL)\n\n        cpu_model = \"602\";\n\n    for (i = 0; i < smp_cpus; i++) {\n\n        env = cpu_init(cpu_model);\n\n        if (!env) {\n\n            fprintf(stderr, \"Unable to find PowerPC CPU definition\\n\");\n\n            exit(1);\n\n        }\n\n        if (env->flags & POWERPC_FLAG_RTC_CLK) {\n\n            /* POWER / PowerPC 601 RTC clock frequency is 7.8125 MHz */\n\n            cpu_ppc_tb_init(env, 7812500UL);\n\n        } else {\n\n            /* Set time-base frequency to 100 Mhz */\n\n            cpu_ppc_tb_init(env, 100UL * 1000UL * 1000UL);\n\n        }\n\n        qemu_register_reset((QEMUResetHandler*)&cpu_reset, env);\n\n    }\n\n\n\n    /* allocate RAM */\n\n    ram_offset = qemu_ram_alloc(NULL, \"ppc_prep.ram\", ram_size);\n\n    cpu_register_physical_memory(0, ram_size, ram_offset);\n\n\n\n    /* allocate and load BIOS */\n\n    bios_offset = qemu_ram_alloc(NULL, \"ppc_prep.bios\", BIOS_SIZE);\n\n    if (bios_name == NULL)\n\n        bios_name = BIOS_FILENAME;\n\n    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);\n\n    if (filename) {\n\n        bios_size = get_image_size(filename);\n\n    } else {\n\n        bios_size = -1;\n\n    }\n\n    if (bios_size > 0 && bios_size <= BIOS_SIZE) {\n\n        target_phys_addr_t bios_addr;\n\n        bios_size = (bios_size + 0xfff) & ~0xfff;\n\n        bios_addr = (uint32_t)(-bios_size);\n\n        cpu_register_physical_memory(bios_addr, bios_size,\n\n                                     bios_offset | IO_MEM_ROM);\n\n        bios_size = load_image_targphys(filename, bios_addr, bios_size);\n\n    }\n\n    if (bios_size < 0 || bios_size > BIOS_SIZE) {\n\n        hw_error(\"qemu: could not load PPC PREP bios '%s'\\n\", bios_name);\n\n    }\n\n    if (filename) {\n\n        qemu_free(filename);\n\n    }\n\n\n\n    if (linux_boot) {\n\n        kernel_base = KERNEL_LOAD_ADDR;\n\n        /* now we can load the kernel */\n\n        kernel_size = load_image_targphys(kernel_filename, kernel_base,\n\n                                          ram_size - kernel_base);\n\n        if (kernel_size < 0) {\n\n            hw_error(\"qemu: could not load kernel '%s'\\n\", kernel_filename);\n\n            exit(1);\n\n        }\n\n        /* load initrd */\n\n        if (initrd_filename) {\n\n            initrd_base = INITRD_LOAD_ADDR;\n\n            initrd_size = load_image_targphys(initrd_filename, initrd_base,\n\n                                              ram_size - initrd_base);\n\n            if (initrd_size < 0) {\n\n                hw_error(\"qemu: could not load initial ram disk '%s'\\n\",\n\n                          initrd_filename);\n\n            }\n\n        } else {\n\n            initrd_base = 0;\n\n            initrd_size = 0;\n\n        }\n\n        ppc_boot_device = 'm';\n\n    } else {\n\n        kernel_base = 0;\n\n        kernel_size = 0;\n\n        initrd_base = 0;\n\n        initrd_size = 0;\n\n        ppc_boot_device = '\\0';\n\n        /* For now, OHW cannot boot from the network. */\n\n        for (i = 0; boot_device[i] != '\\0'; i++) {\n\n            if (boot_device[i] >= 'a' && boot_device[i] <= 'f') {\n\n                ppc_boot_device = boot_device[i];\n\n                break;\n\n            }\n\n        }\n\n        if (ppc_boot_device == '\\0') {\n\n            fprintf(stderr, \"No valid boot device for Mac99 machine\\n\");\n\n            exit(1);\n\n        }\n\n    }\n\n\n\n    isa_mem_base = 0xc0000000;\n\n    if (PPC_INPUT(env) != PPC_FLAGS_INPUT_6xx) {\n\n        hw_error(\"Only 6xx bus is supported on PREP machine\\n\");\n\n    }\n\n    i8259 = i8259_init(first_cpu->irq_inputs[PPC6xx_INPUT_INT]);\n\n    pci_bus = pci_prep_init(i8259);\n\n    /* Hmm, prep has no pci-isa bridge ??? */\n\n    isa_bus_new(NULL);\n\n    isa_bus_irqs(i8259);\n\n    //    pci_bus = i440fx_init();\n\n    /* Register 8 MB of ISA IO space (needed for non-contiguous map) */\n\n    PPC_io_memory = cpu_register_io_memory(PPC_prep_io_read,\n\n                                           PPC_prep_io_write, sysctrl,\n\n                                           DEVICE_LITTLE_ENDIAN);\n\n    cpu_register_physical_memory(0x80000000, 0x00800000, PPC_io_memory);\n\n\n\n    /* init basic PC hardware */\n\n    pci_vga_init(pci_bus);\n\n    //    openpic = openpic_init(0x00000000, 0xF0000000, 1);\n\n    //    pit = pit_init(0x40, i8259[0]);\n\n    rtc_init(2000, NULL);\n\n\n\n    if (serial_hds[0])\n\n        serial_isa_init(0, serial_hds[0]);\n\n    nb_nics1 = nb_nics;\n\n    if (nb_nics1 > NE2000_NB_MAX)\n\n        nb_nics1 = NE2000_NB_MAX;\n\n    for(i = 0; i < nb_nics1; i++) {\n\n        if (nd_table[i].model == NULL) {\n\n\t    nd_table[i].model = qemu_strdup(\"ne2k_isa\");\n\n        }\n\n        if (strcmp(nd_table[i].model, \"ne2k_isa\") == 0) {\n\n            isa_ne2000_init(ne2000_io[i], ne2000_irq[i], &nd_table[i]);\n\n        } else {\n\n            pci_nic_init_nofail(&nd_table[i], \"ne2k_pci\", NULL);\n\n        }\n\n    }\n\n\n\n    if (drive_get_max_bus(IF_IDE) >= MAX_IDE_BUS) {\n\n        fprintf(stderr, \"qemu: too many IDE bus\\n\");\n\n        exit(1);\n\n    }\n\n\n\n    for(i = 0; i < MAX_IDE_BUS * MAX_IDE_DEVS; i++) {\n\n        hd[i] = drive_get(IF_IDE, i / MAX_IDE_DEVS, i % MAX_IDE_DEVS);\n\n    }\n\n\n\n    for(i = 0; i < 1/*MAX_IDE_BUS*/; i++) {\n\n        isa_ide_init(ide_iobase[i], ide_iobase2[i], ide_irq[i],\n\n                     hd[2 * i],\n\n\t\t     hd[2 * i + 1]);\n\n    }\n\n    isa_create_simple(\"i8042\");\n\n\n\n    cpu_exit_irq = qemu_allocate_irqs(cpu_request_exit, NULL, 1);\n\n    DMA_init(1, cpu_exit_irq);\n\n\n\n    //    SB16_init();\n\n\n\n    for(i = 0; i < MAX_FD; i++) {\n\n        fd[i] = drive_get(IF_FLOPPY, 0, i);\n\n    }\n\n    fdctrl_init_isa(fd);\n\n\n\n    /* Register speaker port */\n\n    register_ioport_read(0x61, 1, 1, speaker_ioport_read, NULL);\n\n    register_ioport_write(0x61, 1, 1, speaker_ioport_write, NULL);\n\n    /* Register fake IO ports for PREP */\n\n    sysctrl->reset_irq = first_cpu->irq_inputs[PPC6xx_INPUT_HRESET];\n\n    register_ioport_read(0x398, 2, 1, &PREP_io_read, sysctrl);\n\n    register_ioport_write(0x398, 2, 1, &PREP_io_write, sysctrl);\n\n    /* System control ports */\n\n    register_ioport_read(0x0092, 0x01, 1, &PREP_io_800_readb, sysctrl);\n\n    register_ioport_write(0x0092, 0x01, 1, &PREP_io_800_writeb, sysctrl);\n\n    register_ioport_read(0x0800, 0x52, 1, &PREP_io_800_readb, sysctrl);\n\n    register_ioport_write(0x0800, 0x52, 1, &PREP_io_800_writeb, sysctrl);\n\n    /* PCI intack location */\n\n    PPC_io_memory = cpu_register_io_memory(PPC_intack_read,\n\n                                           PPC_intack_write, NULL,\n\n                                           DEVICE_LITTLE_ENDIAN);\n\n    cpu_register_physical_memory(0xBFFFFFF0, 0x4, PPC_io_memory);\n\n    /* PowerPC control and status register group */\n\n#if 0\n\n    PPC_io_memory = cpu_register_io_memory(PPC_XCSR_read, PPC_XCSR_write,\n\n                                           NULL, DEVICE_LITTLE_ENDIAN);\n\n    cpu_register_physical_memory(0xFEFF0000, 0x1000, PPC_io_memory);\n\n#endif\n\n\n\n    if (usb_enabled) {\n\n        usb_ohci_init_pci(pci_bus, -1);\n\n    }\n\n\n\n    m48t59 = m48t59_init(i8259[8], 0, 0x0074, NVRAM_SIZE, 59);\n\n    if (m48t59 == NULL)\n\n        return;\n\n    sysctrl->nvram = m48t59;\n\n\n\n    /* Initialise NVRAM */\n\n    nvram.opaque = m48t59;\n\n    nvram.read_fn = &m48t59_read;\n\n    nvram.write_fn = &m48t59_write;\n\n    PPC_NVRAM_set_params(&nvram, NVRAM_SIZE, \"PREP\", ram_size, ppc_boot_device,\n\n                         kernel_base, kernel_size,\n\n                         kernel_cmdline,\n\n                         initrd_base, initrd_size,\n\n                         /* XXX: need an option to load a NVRAM image */\n\n                         0,\n\n                         graphic_width, graphic_height, graphic_depth);\n\n\n\n    /* Special port to get debug messages from Open-Firmware */\n\n    register_ioport_write(0x0F00, 4, 1, &PPC_debug_write, NULL);\n\n}\n", "idx": 6605, "substitutes": {"ram_size": ["ram_scale", "ram_space", " ram_Size", "ram_name", "ram_length", "rom_size", " ram_space", "ram_SIZE", "ram_Size", "rom_device", "rom_SIZE", " ram_scale", " ram_length", " ram_SIZE", "ram_device", "rom_name"], "boot_device": ["bootingdev", "cpu_directory", "cpu_device", "cpu_address", "cpu_dev", "boot_dev", "bootingdirectory", "cpuingdevice", "cpuingdev", "cpuingaddress", "bootingdevice", "boot_address", "bootingaddress", "boot_directory", "cpuingdirectory"], "kernel_filename": ["kernel_fp", "kernel_binary", "disk_family", "disk_file", "disk_fp", "kernel_file", "kernel_username", "disk_username", "kernel_family", "kernel_address", "disk_address", "disk_binary", "disk_filename"], "kernel_cmdline": ["kernel_ctrline", "kernel_directline", "kernel_commandline", "kernel_directcode", "kernel_cmdcode", "kernel_commandcode", "kernel_ctrl", "kernel_directl", "kernel_cmdl", "kernel_ctrcode", "kernel_commandl"], "initrd_filename": ["initrt_filename", "initrt_Filename", "initrd_Filename", "initrt_file", "initrd_file", "initrd_name", "initrt_name"], "cpu_model": ["pu2name", "cpu67relation", "cpu2variable", "CPU_model", "cli67relation", "pu_Model", "cpu_rule", "pu2model", "pu_variable", "cli_relation", "CPU_name", "cpu2type", "pu2Model", "cpu_label", "CPU_label", "cpu2model", "cli_model", "cpu2Model", "cli67model", "cpu_variable", "cli67rule", "cpu_name", "cpu67rule", "cpu67model", "cpu2name", "CPU_fine", "CPU_Model", "cpu2label", "pu_name", "pu_model", "cli67name", "cli_rule", "CPU_type", "cpu_relation", "cpu_type", "cpu67name", "cli_name", "pu2variable", "cpu_fine", "cpu_Model"], "env": ["policy", "db", "ev", "vv", "export", "uv", "event", "esc", "ei", "mem", "window", "po", "conf", "ped", "forge", "end", "ctx", "here", "eni", "conn", "buf", "state", "era", "buffer", "er", "te", "ext", "ent", "ec", "dev", "ew", "viron", "context", "eng", "environment", "cb", "enter", "t", "vp", "server", "err", "gear", "Environment", "bar", "proc", "esp", "en", "v", "ah", "cap", "nv", "ef", "eu", "worker", "vs", "entry", "tmp", "cv", "desc", "ee", "manager", "vt", "obj", "qt", "vm", "e", "info", "door", "menu", "iev"], "filename": ["lua", "uri", "jpg", "ln", "prefix", "src", "file", "rn", "til", "wav", "ename", "ame", "location", "fp", "kl", "fle", "username", "ames", "fil", "nm", "txt", "FIL", "sbm", "processor", "fn", "Filename", "f", "fs", "println", "family", "nl", "json", "name", "path"], "nvram": ["vgram", "nngram", "nvrom", "nnmem", "vrom", "vmem", "nvgram", "nnrom", "NVmem", "NVrom", "nvmem", "nnram", "vram", "NVram", "NVgram"], "m48t59": ["m48t23", "m48n58", "m48t60", "m48t58", "m48T58", "m64T60", "m48p23", "m64T23", "m64t60", "m48p59", "m48n23", "m48n60", "m48n59", "m64t59", "m64t58", "m48T60", "m48T59", "m64t23", "m48p60", "m48T23", "m64T58", "m64T59", "m48p58"], "PPC_io_memory": ["PPC_io_address", "PPC_physical2address", "PPC_physical_size", "PPC_physical2mem", "PPC_io2mem", "PPC_physical_memory", "PPC_io2size", "PPC_io2memory", "PPC_physical2size", "PPC_physical2memory", "PPC_physical_address", "PPC_io_mem", "PPC_physical_mem", "PPC_io2address", "PPC_io_size"], "linux_boot": ["linux5bus", "linux_bs", "cpu_start", "kernel_bus", "linux5Boot", "linux5bs", "linux_start", "kernel_boot", "kernel_Boot", "cpu_bus", "linux5boot", "cpu_boot", "linux_bus", "kernel_bs", "linux_Boot"], "i": ["ini", "ci", "b", "it", "im", "c", "cli", "h", "gi", "mi", "qi", "li", "p", "si", "g", "ami", "zi", "n", "tim", "xi", "ind", "index", "t", "hi", "pi", "bi", "r", "multi", "me", "id", "ui", "k", "phi", "ti", "v", "ims", "ix", "ai", "m", "I", "y", "f", "fi", "sql", "sim", "gu", "ex", "e", "iu", "in", "info", "j", "di", "ii", "l"], "nb_nics1": ["nb_nicks1", "nb_nicksize", "nb_nicksmb", "nb_nimsize", "nb_micksmb", "nb_micks3", "nb_niscmb", "nb_nims1", "nb_nims3", "nb_nimsmb", "nb_micsmb", "nb_nicsize", "nb_nisc1", "nb_nisc3", "nb_nics3", "nb_mics1", "nb_micsize", "nb_micksize", "nb_nicsmb", "nb_micks1", "nb_niscize", "nb_mics3", "nb_nicks3"], "bios_size": ["biosibsize", "bio_name", "bios_sha", "bio_sha", "bios_memory", "bio_memory", "bio_size", "biosibsha", "bios_name", "biosibmemory", "biosibname"], "ram_offset": ["ram67addr", "gram_size", "ram67offset", "ram_index", "RAM_index", "gram_location", "ram_Offset", "gram_offset", "RAM_offset", "ram67index", "ram_address", "ram67seed", "ram__offset", "gram_addr", "ram__addr", "ram_location", "ram_seed", "gram_Offset", "gram_address", "RAM_addr", "ram_addr", "RAM_seed", "ram__index", "ram__seed"], "bios_offset": ["bio_name", "bios__name", "bios__address", "bios_online", "bos_address", "bos_addr", "bio_offset", "bos_name", "bios_index", "bios__offset", "bio_index", "bio_online", "bios_address", "bios_name", "bos_offset", "bios__addr"], "kernel_base": ["system_size", "kernel2base", "system_name", "kernel2name", "kernel_name", "system_base", "kernel2buffer", "system_buffer", "kernel_buffer", "kernel2size"], "initrd_base": ["initrd2length", "initrs_length", "initrd2name", "initrs_size", "initrd_name", "initrd2size", "initrd_length", "initrs_base", "initrs_name", "initrd2base"], "kernel_size": ["system_size", "kernel_count", "system_count", "kernel_SIZE", "system_name", "system_SIZE", "kernel_name"], "initrd_size": ["initrd_len", "initrs_SIZE", "initrs_size", "initrd_SIZE", "initrd_name", "initrs_name", "initrs_len"], "pci_bus": ["pci__bus", "pci2us", "pci__BUS", "pci__boot", "pci2bus", "pki_boot", "pci2BUS", "pci_us", "pci_boot", "pci__us", "pci2boot", "pki_us", "pki_bus", "pki_BUS", "pci_BUS"], "i8259": ["pi8191", "i5285", "i3259", "pi5285", "i6259", "i6191", "i5191", "pi5192", "i8285", "pi8285", "pi5191", "i5192", "i5259", "pi5259", "pi8192", "i6192", "i8191", "i8192", "i6285", "i3192", "i3191", "i3285", "pi8259"], "cpu_exit_irq": ["cpu_exit_pirq", "cpu_exit_pirque", "cpu_exit_irque", "cpu_exit_mrQ", "cpu_exit_mirque", "cpu_exit_irQ", "cpu_exit_pirQ", "cpu_exit_mirq", "cpu_exit_pirqs", "cpu_exit_irqs", "cpu_exit_mirqs", "cpu_exit_mirQ", "cpu_exit_mrq", "cpu_exit_mrqs", "cpu_exit_mrque"], "ppc_boot_device": ["ppc_bind_model", "ppc_boot2dev", "ppc_bind_buffer", "ppc_boot_model", "ppc_boot_buffer", "ppc_boot2buffer", "ppc_boot_dev", "ppc_bind_dev", "ppc_boot2model", "ppc_bind_device", "ppc_boot2device"], "hd": ["wid", "md", "h", "ht", "dl", "bd", "sd", "ds", "ed", "hw", "HD", "dh", "dr", "him", "rh", "dm", "vd", "dd", "hs", "dn", "hn", "cd", "hid", "pd", "ha", "kb", "ld", "hp", "da"], "MAX_IDE_BUS": ["MAX_IDE_BS", "MAX_IDEOPUS", "MAX_IDEOPDOS", "MAX_IDE2BUS", "MAX_IDE2BS", "MAX_ID_BUS", "MAX_IDE_US", "MAX_IDEOPBS", "MAX_IDE2US", "MAX_ID_DOS", "MAX_IDE_DOS", "MAX_ID_US", "MAX_IDEOPBUS", "MAX_IDE2DOS", "MAX_ID_BS"], "MAX_IDE_DEVS": ["MAX_IDE_DPV", "MAX_IDE_DIRPS", "MAX_IDE_DEV", "MAX_IDE_DPPS", "MAX_IDE_DPS", "MAX_IDE_DEBS", "MAX_IDE_DPVS", "MAX_IDE_DPBS", "MAX_IDE_DIRV", "MAX_IDE_DIRVS", "MAX_IDE_DBS", "MAX_IDE_DEPS", "MAX_IDE_DV", "MAX_IDE_DVS", "MAX_IDE_DIRBS"], "fd": ["pid", "dc", "ff", "lf", "fc", "du", "dt", "d", "fat", "dl", "bd", "sd", "ds", "fl", "fp", "id", "pipe", "dd", "df", "dir", "fb", "cd", "f", "FD", "fs", "fi", "td", "fr", "wd"], "MAX_FD": ["MAX_FS", "MAX_DIR", "Max_DIR", "Max_FH", "MAX_FH", "Max_FD", "Max_FS"]}}
{"project": "FFmpeg", "commit_id": "15ea222778caaec0877b3f9938140b707c931d96", "target": 0, "func": "static void copy_picture_field(InterlaceContext *s,\n\n                               AVFrame *src_frame, AVFrame *dst_frame,\n\n                               AVFilterLink *inlink, enum FieldType field_type,\n\n                               int lowpass)\n\n{\n\n    const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(inlink->format);\n\n    int hsub = desc->log2_chroma_w;\n\n    int vsub = desc->log2_chroma_h;\n\n    int plane, j;\n\n\n\n    for (plane = 0; plane < desc->nb_components; plane++) {\n\n        int cols  = (plane == 1 || plane == 2) ? -(-inlink->w) >> hsub : inlink->w;\n\n        int lines = (plane == 1 || plane == 2) ? -(-inlink->h) >> vsub : inlink->h;\n\n        uint8_t *dstp = dst_frame->data[plane];\n\n        const uint8_t *srcp = src_frame->data[plane];\n\n\n\n        av_assert0(cols >= 0 || lines >= 0);\n\n\n\n        lines = (lines + (field_type == FIELD_UPPER)) / 2;\n\n        if (field_type == FIELD_LOWER)\n\n            srcp += src_frame->linesize[plane];\n\n        if (field_type == FIELD_LOWER)\n\n            dstp += dst_frame->linesize[plane];\n\n        if (lowpass) {\n\n            int srcp_linesize = src_frame->linesize[plane] * 2;\n\n            int dstp_linesize = dst_frame->linesize[plane] * 2;\n\n            for (j = lines; j > 0; j--) {\n\n                const uint8_t *srcp_above = srcp - src_frame->linesize[plane];\n\n                const uint8_t *srcp_below = srcp + src_frame->linesize[plane];\n\n                if (j == lines)\n\n                    srcp_above = srcp; // there is no line above\n\n                if (j == 1)\n\n                    srcp_below = srcp; // there is no line below\n\n                s->lowpass_line(dstp, cols, srcp, srcp_above, srcp_below);\n\n                dstp += dstp_linesize;\n\n                srcp += srcp_linesize;\n\n            }\n\n        } else {\n\n            av_image_copy_plane(dstp, dst_frame->linesize[plane] * 2,\n\n                                srcp, src_frame->linesize[plane] * 2,\n\n                                cols, lines);\n\n        }\n\n    }\n\n}\n", "idx": 6622, "substitutes": {"s": ["rs", "gs", "ses", "sp", "ssl", "b", "sg", "ar", "ns", "c", "h", "cs", "sc", "self", "os", "p", "g", "d", "n", "is", "ds", "t", "r", "w", "an", "ls", "sb", "v", "sl", "m", "sa", "ss", "sq", "fs", "e", "S", "sts", "a", "l"], "src_frame": ["srcipscope", "src_frames", "targetipFrame", "sr_sequence", "srcpoeffect", "srcipframes", "srcptframes", "srcationwindow", "uploadpocomponent", "srcpofunction", "src_Frame", "srcptcomponent", "srcmmsequence", "srcationframe", "uploadpoeffect", "src2sequence", " src_window", "srcationprocess", "usr_frame", " src_effect", "src2frame", "src_component", "srcmlprocess", "targetipframes", "src2frames", "srcmmFrame", "target_Frame", "upload_component", "srcptframe", "targetipscope", "srcipframe", "srcmmframe", "sr_frames", " src_process", "src_effect", "srcationeffect", "src_function", " src_frames", "uploadpoframe", "src_sequence", "target_scope", "srcmlwindow", "upload_function", "usr_Frame", "target_frame", "sr_frame", "upload_effect", "srcpocomponent", "src_window", "usr_effect", " src_component", "targetipframe", "src_scope", "target_frames", "usr_sequence", "srcmmeffect", "srcmlframe", "upload_frame", "src_process", "srcipFrame", "srcmleffect", "srcptwindow", "uploadpofunction", "srcpoframe"], "dst_frame": ["ddest_frame", "dest_frames", "dsrc_frame", "dest_frame", "dsrc_Frame", "ddest_frames", "dst_Frame", "dstiptable", "dsrc_frames", "dst_table", "dst_session", "dstipframe", "dst_frames", "dest_session", "dest_table", "ddest_fram", "dst_fram", "dstipframes", "dsrc_sequence", "dstipsession", "dst_sequence"], "inlink": ["dinlike", "inlinked", "ninmatch", "rinlink", "innlink", "inconnect", "inroute", "cinlike", "dinlink", "innroute", "fromlike", "dinroute", "vinstream", "pinstream", "inink", "inctl", "innlinked", "dinLink", "inlist", "inLink", "innlabel", "inconnection", "cinctl", "pinroute", "vinlog", "cinLink", " inLink", "Inconnect", "inlog", "innload", "rinlabel", "innink", "vinlinked", "vinlink", "rinroute", "innlog", "dinlist", "fromlink", "dinlinks", "rinload", "inload", "dinctl", " instream", "cinconnection", "ninlink", " inlinked", "cinink", "inlike", "instream", "inmatch", " inroute", "ninink", "pinlinked", "dinlabel", "cinlink", "cinmatch", "fromconnection", "cinconnect", "dinload", "Inink", "ninconnect", "Inlink", "Inlinked", "dinconnection", "cinlinks", " inlinks", "Inmatch", "inlinks", "vinink", "pinlink", "vinroute", "inlabel", "Inlog", " inlist", "cinlist", "fromctl"], "field_type": ["query64id", "field_class", "fieldcasetype", "field_name", "fieldcasemode", "fieldTypeclass", "query_Type", "fieldNametype", "fieldNameclass", "field64operator", "field_option", "field64id", "fieldTypename", "player_type", "player_mode", "fieldNamemode", "channel_operator", "fieldtypename", "fieldTypetype", "fieldTypefile", "playercasemode", " field_name", "field64type", "field64ype", "field_relation", "query64ype", "channel_relation", "field64option", "query_type", "channel_type", "channel64type", "playercaseclass", "query64Type", "field_handle", "channel64operator", "fieldcasehandle", " field_class", "channel_option", "fieldcaseclass", "query_id", "field_id", "fieldtypeclass", "player_handle", "playercasehandle", "fieldNamehandle", "channel64relation", "field_operator", "channel64option", "playercasetype", "fieldtypetype", "field64Type", "field_ype", "field64relation", "query_ype", "fieldtypefile", "field_Type", " field_file", "field_file", "query64type", "player_class", "field_mode"], "lowpass": [" lowPass", "lowPass", "lowPASS", "slowpass", "lowcross", "slowPASS", "LowPASS", "Lowcross", "highPASS", "Lowpass", "highPass", "highpass", "highcross", "LowPass", "slowPass", " lowcross", "slowcross"], "desc": ["Desc", "dc", "esc", "des", "dep", "cmp", "cont", "cam", "det", "description", "sc", "comm", "cor", "msg", "fc", "ext", "cmd", "dev", "ec", "lib", "ds", "or", "lc", "asc", "dr", "dim", "txt", "dist", "sec", "meta", "req", "ript", "config", "sub", "dir", "reg", "comment", "ptr", "disc", "doc", "ca", "diff", "conv", "rec", "info", " Desc", "tor", "enc", "def"], "plane": ["depth", "layout", "ice", "way", "note", "cone", "den", "scope", "goal", "flow", "plot", "vert", "pe", "trace", "en", "priority", "clip", "straight", " Plane", "player", "flag", "package", "stroke", "forge", "flat", "pen", "ve", "zone", "position", "pipe", "span", "board", "jet", "normal", "port", "frame", "project", "pose", "version", "axis", " planes", "ask", "cube", "ine", "half", "flake", "place", "offset", "ker", "connection", "bo", "line", "limit", "animate", "anes", "planes", "pei", "atten", "unity", "plan", "que", "square", "ane", "mate", "user", "sheet", "panel", "window", "buffer", "profile", "plate", "slave", "slice", "id", "me", "mode", "gate", "component", "pal", "POSE", "alias", "eline", "pin", "lane", "sequence"], "j": ["dj", "ja", "ij", "q", "jo", "bj", "it", "jj", "job", "J", "h", "br", "i", "aj", "g", "p", "d", "ie", "n", "ind", "uj", "index", "o", "jas", "jc", "r", "js", "ji", "k", "jet", "oj", "v", "port", "m", "ch", "bs", "jack", "y", "jump", "jp", "jit", "jl", "kj", "z", "fr", "json", "other", "l"], "dstp": ["xy", "dndp", "dstf", "destp", "dstl", "dputp", " dstm", "dservf", "dndm", "arc", "dstsv", "dndjp", " dstsv", " destl", "dstjp", "dstsp", "drestp", "destd", " dstsP", "destjp", " dostp", " dstf", " dostf", "destf", "dstsm", " dstfp", "dservfp", " dstP", "conv", "drestP", " dstsm", "dservp", "dostm", "dostp", "dstd", "copy", "dputm", "dndl", " dstv", "dostfp", "destP", "dputjp", "dstm", "dctd", "dostf", "drestv", " dstsp", "dservm", "drestm", " dostd", " dstl", " dstd", "destl", "dostd", "jpg", "dctp", " dostfp", "destm", "dctm", "dstv", "destv", "dstsP", " destm", "_", "dputl", "dstfp", " destp", "dstP", " dostm", "destfp", " destjp", "img", " dstjp", "def"], "srcp": ["secureping", "ourcep", "securen", "srcping", "srcP", "rcl", "sortm", "securel", "securep", "srcn", "rcg", "sortg", "srcpa", "rcpa", " srcl", "sourcef", "rccp", "rcP", "ourcepb", "rcping", "srccp", "rcpid", "sourcel", " srcpid", "rcf", "sourceP", " srcP", "sourcen", "sourceping", "srcpb", " srcm", "sortpa", "procm", "ourcem", "ourceP", " srcn", "rcm", "procpid", "rcn", "syncm", "sortP", "srcg", "srcm", "srcf", "syncg", "sortp", "sourcep", "procp", "srcl", "rcp", "sourcem", "sortcp", "rcpb", " srccp", "syncpa", " srcf", " srcpb", "srcpid", "syncp"], "srcp_above": ["srcp_over", "srcP_behind", "srcP_over", "srcP_below", "srcP_upper", "srcp_within", "srcp_behind", "srcp_area", "srcP_area", "srcP_above", "srcp_upper"], "srcp_below": ["srcp_floor", "srcm_low", "srcm_floor", "srcm_bottom", "srcp_Below", "srcm_above", "srcm_Below", "srcp_bottom", "srcm_allows", "srcp_allows", "srcp_low", "srcm_below"]}}
{"project": "qemu", "commit_id": "d96391c1ffeb30a0afa695c86579517c69d9a889", "target": 1, "func": "target_ulong helper_rdhwr_cpunum(CPUMIPSState *env)\n\n{\n\n    check_hwrena(env, 0);\n\n    return env->CP0_EBase & 0x3ff;\n\n}\n", "idx": 6628, "substitutes": {"env": ["ev", "vv", "uv", "result", "sp", "esc", "event", "next", "mem", "window", "end", "ov", "conf", "ctx", "h", "gov", "set", "buf", "state", "ve", "self", "buffer", "msg", "te", "dev", "vp", "enter", "viron", "context", "eng", "environment", "nc", "data", "server", "w", "gear", "proc", "en", "org", "v", "ah", "nv", "ef", "config", "vs", "st", "entry", "cv", "doc", "desc", "vt", "obj", "cur", "info", "e", "ten"]}}
{"project": "qemu", "commit_id": "9cb805fd2674f474d058fee6d7aa9e83fcd3d336", "target": 1, "func": "void qmp_inject_nmi(Error **errp)\n\n{\n\n#if defined(TARGET_I386)\n\n    CPUState *cs;\n\n\n\n    CPU_FOREACH(cs) {\n\n        X86CPU *cpu = X86_CPU(cs);\n\n\n\n        if (!cpu->apic_state) {\n\n            cpu_interrupt(cs, CPU_INTERRUPT_NMI);\n\n        } else {\n\n            apic_deliver_nmi(cpu->apic_state);\n\n        }\n\n    }\n\n#elif defined(TARGET_S390X)\n\n    CPUState *cs;\n\n    S390CPU *cpu;\n\n\n\n    CPU_FOREACH(cs) {\n\n        cpu = S390_CPU(cs);\n\n        if (cpu->env.cpu_num == monitor_get_cpu_index()) {\n\n            if (s390_cpu_restart(S390_CPU(cs)) == -1) {\n\n                error_set(errp, QERR_UNSUPPORTED);\n\n                return;\n\n            }\n\n            break;\n\n        }\n\n    }\n\n#else\n\n    error_set(errp, QERR_UNSUPPORTED);\n\n#endif\n\n}\n", "idx": 6635, "substitutes": {"errp": ["ererpre", " errP", "arrp", "errpp", "bufpt", "arrP", "lrp", " errpp", "arrsp", "ererp", " errsp", "bufpy", "errpre", "ErP", "errpy", "rrpb", "rrpt", "ererpy", "errpt", "lrpy", "errpb", "rrp", "ererpt", "rrpre", "nerp", "arrpp", "errsp", "Erpp", "Erp", "nerping", "rrpy", "errP", "rrping", "lrpb", "Ersp", "bufp", "nerpb", "bufpre", "lrping", "errping", "nerpy"], "cs": ["ck", "cf", "rs", "gc", "csv", "cas", "CS", "gs", "ns", "ics", "irs", "cp", "c", "wcs", "pc", "acs", "ats", "its", "cks", "ctx", "ants", "qs", "sc", "aps", "ces", "acts", "ps", "ms", "ec", "ts", "ds", "eds", "cus", "css", "ce", "onents", "cc", "js", "rc", "ins", "ips", "ls", "s", "ims", "checks", "ix", "ras", "rys", "vs", "bs", "fs", "ys", "ks", "sts", "icks", "ows", "tc"], "cpu": ["ck", "CPU", "pid", "thread", "cf", "gc", "console", "cas", "kernel", "copy", "cum", "cp", "c", "pu", "pc", "ctx", "prof", "cam", "tp", "anc", "none", "ka", "clock", "client", "nn", "uart", "goal", "util", "cmd", "chip", "aux", "hz", "process", "hw", "linux", "proc", "pkg", "docker", "nic", "cn", "ruby", "cal", "port", "processor", "pixel", "uu", "alloc", "percent", "bean", "cv", "socket", "sky", "cache", "cat", "core", "runner", "currency", "vm", "net", "cu", "gpu", "mx", "computer"]}}
{"project": "qemu", "commit_id": "e175bce587936bf479889881488821ea8d61c89c", "target": 1, "func": "void helper_single_step(CPUX86State *env)\n\n{\n\n#ifndef CONFIG_USER_ONLY\n\n    check_hw_breakpoints(env, 1);\n\n    env->dr[6] |= DR6_BS;\n\n#endif\n\n    raise_exception(env, EXCP01_DB);\n\n}\n", "idx": 6641, "substitutes": {"env": ["ev", "vv", "uv", "console", "esc", "sw", "window", "end", "ov", "ctx", "h", "def", "gov", "scope", "conn", "buf", "store", "sc", "ve", "er", "erd", "ext", "eg", "vp", "dev", "ew", "viron", "eng", "context", "environment", "nc", "cb", "ds", "queue", "server", "w", "rc", "sv", "sb", "code", "en", "rb", "v", "ah", "txt", "nv", "req", "cfg", "block", "vs", "st", "entry", "cv", "desc", "manager", "obj", "En", "vm", "e", "engine", "shell", "ten"]}}
{"project": "FFmpeg", "commit_id": "3ab9a2a5577d445252724af4067d2a7c8a378efa", "target": 1, "func": "static av_always_inline void rv40_weak_loop_filter(uint8_t *src,\n\n                                                   const int step,\n\n                                                   const int stride,\n\n                                                   const int filter_p1,\n\n                                                   const int filter_q1,\n\n                                                   const int alpha,\n\n                                                   const int beta,\n\n                                                   const int lim_p0q0,\n\n                                                   const int lim_q1,\n\n                                                   const int lim_p1)\n\n{\n\n    uint8_t *cm = ff_cropTbl + MAX_NEG_CROP;\n\n    int i, t, u, diff;\n\n\n\n    for (i = 0; i < 4; i++, src += stride) {\n\n        int diff_p1p0 = src[-2*step] - src[-1*step];\n\n        int diff_q1q0 = src[ 1*step] - src[ 0*step];\n\n        int diff_p1p2 = src[-2*step] - src[-3*step];\n\n        int diff_q1q2 = src[ 1*step] - src[ 2*step];\n\n\n\n        t = src[0*step] - src[-1*step];\n\n        if (!t)\n\n            continue;\n\n\n\n        u = (alpha * FFABS(t)) >> 7;\n\n        if (u > 3 - (filter_p1 && filter_q1))\n\n            continue;\n\n\n\n        t <<= 2;\n\n        if (filter_p1 && filter_q1)\n\n            t += src[-2*step] - src[1*step];\n\n\n\n        diff = CLIP_SYMM((t + 4) >> 3, lim_p0q0);\n\n        src[-1*step] = cm[src[-1*step] + diff];\n\n        src[ 0*step] = cm[src[ 0*step] - diff];\n\n\n\n        if (filter_p1 && FFABS(diff_p1p2) <= beta) {\n\n            t = (diff_p1p0 + diff_p1p2 - diff) >> 1;\n\n            src[-2*step] = cm[src[-2*step] - CLIP_SYMM(t, lim_p1)];\n\n        }\n\n\n\n        if (filter_q1 && FFABS(diff_q1q2) <= beta) {\n\n            t = (diff_q1q0 + diff_q1q2 + diff) >> 1;\n\n            src[ 1*step] = cm[src[ 1*step] - CLIP_SYMM(t, lim_q1)];\n\n        }\n\n    }\n\n}\n", "idx": 6646, "substitutes": {"src": ["iv", "stab", "sw", "ln", "c", "http", "sc", "nn", "addr", "inst", "impl", "url", "fp", "sb", "iter", "txt", "req", "ack", "secure", "cur", "dest", "loc", "source", "sites", "rs", "ic", "eff", "nr", "sort", "bh", "seed", "sel", "str", "control", "rb", "stream", "config", "load", "scan", "supp", "ur", "np", "conv", "via", "ctr", "irc", "gs", "ssl", "it", "sr", "bc", "rx", "usr", "r", "rc", "pkg", "s", "sec", "sur", "rt", "st", "usc", "bs", "uint", "sq", "boot", "hl", "ij", "result", "ser", "its", "cmp", "cont", "sys", "raw", "screen", "tn", "aux", "sync", "func", "input", "cc", "slice", "ins", "syn", "proc", "dist", "sl", "rl", "inner", "spec", "new", "block", "sn", "ptr", "reverse", "cache", "obj", "tp", "tc"], "step": ["draw", "chain", "wait", "way", "run", "save", "display", "order", "chip", "pointer", "walk", "key", "device", "layer", "iter", "watch", "batch", "loop", "test", "filter", "path", "stroke", "read", "next", "weight", "stage", "move", "store", "page", "touch", "dt", "seed", "index", "stack", "push", "start", "dim", "frame", "load", "version", "pass", "rate", "time", "check", "patch", "delay", "update", "error", "drop", "channel", "shift", "steps", "skip", "progress", "track", "history", "stop", "debug", "route", "try", "change", "scroll", "shape", "ride", "roll", "name", "match", "STEP", "window", "set", "table", "group", "row", "height", "scale", "input", "space", "mode", "Step", "feature", "status", "block", "driver", "print", "lag", "trip", "lock", "hop", "tick", "sequence"], "stride": ["stringange", "strategy", "swategy", "swIDE", "stockIDE", "strIDE", "stategy", "stringride", "stide", "stockride", "stringide", "stockategy", "STRategy", "STRIDE", "strange", "swride", "stockide", " strange", " strategy", "strride", "STRride", "stange", "swide", "stringategy", "STRide", " strride"], "filter_p1": ["filter_P1", "filter_pOne", "filter_tlet", "filter_t1", "filter_pt3", "filter_P2", "filter_q6", "filter_q2", "filter_q5", "filter_P3", "filter_cp2", "filter_cp5", "filter_P6", "filter_P5", "filter_sp2", "filter_POne", "filter_cp0", "filter_t2", "filter_q3", "filter_plet", "filter_p3", "filter_t3", "filter_p2", "filter_spOne", "filter_p6", "filter_h2", "filter_pt1", "filter_sp1", "filter_cp1", "filter_ptlet", "filter_pt2", "filter_p5", "filter_q0", "filter_p0", "filter_sp6", "filter_P0", "filter_h1", "filter_qOne", "filter_h0", "filter_h3"], "filter_q1": ["filter_qw", "filter_pw", "filter_ppw", "filter_dq3", "filter_q2", "filter_px", "filter_dq2", "filter_Q3", "filter_q3", "filter_pp1", "filter_pp0", "filter_qu1", "filter_qx", "filter_dq0", "filter_p2", "filter_dq4", "filter_p3", "filter_qu2", "filter_q4", "filter_Q4", "filter_Q2", "filter_pp2", "filter_p4", "filter_dqx", "filter_qux", "filter_dqw", "filter_q0", "filter_p0", "filter_qu0", "filter_dq1", "filter_Q0", "filter_Q1"], "alpha": ["power", "ar", "Alpha", "weight", "star", "phas", "ma", "ta", "extra", " gamma", "A", "si", "mad", "pi", "height", "scale", "asc", "rc", "mu", "phi", "qa", "au", "igma", "angle", "fa", "ac", "acl", "ho", "la", "lambda", "ca", "area", "appa", "filter", "pha", "a", "da"], "beta": ["bis", "b", "grad", "Alpha", "fee", "eta", "late", "margin", "binary", "ma", "buffer", "ta", "Beta", "extra", "fc", "base", "bil", "norm", "cb", "factor", "bi", "pi", "scale", "nu", "prime", "unit", "mu", "confirmed", "phi", "mix", "bf", "igma", "v", "fine", "fa", "lambda", "stable", "cv", "\u03b2", "pha", "abc", "tc", "ba"], "lim_p0q0": ["lim_p1q1", "lim_p0Q2", "lim_p0p2", "lim_p0Q0", "lim_p0Q1", "lim_p1q8", "lim_p1p2", "lim_p0h9", "lim_p0p9", "lim_p0h0", "lim_p0dq0", "lim_p0p8", "lim_p0p0", "lim_p0p1", "lim_p0dq8", "lim_p0q2", "lim_p0Q8", "lim_p0q1", "lim_p1p8", "lim_p1q2", "lim_p1q9", "lim_p0dq1", "lim_p0h2", "lim_p0dq9", "lim_p0h1", "lim_p0q9", "lim_p1p0", "lim_p1p1", "lim_p0dq2", "lim_p0q8", "lim_p1q0", "lim_p1p9"], "lim_q1": ["lim_quantOne", "lim_quant2", "lim_q2", "lim_pOne", "lim_Q0", "lim_p0", "lim_q0", "lim_p2", "lim_QOne", "lim_qOne", "lim_Q2", "lim_quant1", "lim_quant0", "lim_Q1"], "lim_p1": ["lim_q9", "lim_m2", "lim_q2", "lim_t0", "lim_m1", "lim_p0", "lim_p9", "lim_t9", "lim_p3", "lim_m3", "lim_q0", "lim_t2", "lim_t1", "lim_cp9", "lim_cp0", "lim_p2", "lim_m0", "lim_cp2", "lim_cp1", "lim_t3"], "cm": ["dc", "gc", "km", "mn", "ct", "ci", "fm", "um", "cp", "conf", "gm", "im", "c", "asm", "ctx", "iam", "cl", "cont", "mom", "CM", "cms", "em", "ram", "ry", "fc", "wm", "co", "lc", "cc", "pm", "irm", "module", "rem", "sem", "nm", "cn", "cr", "fine", "mb", "m", "mm", "cv", "ca", "cache", "mc", "core", "vm", "ctr", "bm", "com", "tk", "rom", "ym", "tc", "mp"], "i": ["init", "ic", "ini", "ci", " ii", "it", "c", "cli", "mi", "qi", "at", "ip", "li", "p", "si", "zi", "n", "is", "xi", "ind", "index", "pi", "bi", "multi", "me", "id", "ui", "inter", "phi", "ti", "start", "out", "v", "ims", "ix", " j", "ai", "m", "status", "I", "batch", "y", "f", "sim", "ex", "iu", "in", "j", "x", "di", "ii"], "t": ["all", "tree", "q", "b", "it", "type", "c", "h", " T", "tar", "T", "pt", "set", "xt", "ta", "at", "te", "dt", "p", "d", "ent", "g", "n", "tm", "tg", "ts", "table", "tr", "o", "total", "wt", "temp", "trace", "to", "ti", "out", "tip", "txt", "v", "ot", "tz", "tu", "rt", "status", "m", "new", "st", "tmp", "iat", "tf", "y", "f", "test", "vt", "qt", "time", "td", "j", "a", "tp", "title", "l", "tt", "tc"], "u": ["upper", "uv", "uf", "q", "um", "uni", "it", "c", "ou", "U", "fu", "util", "p", "lu", "un", "uid", "o", "ut", "nu", "ui", "unit", "mu", "ue", "au", "units", "v", "tu", "eu", "m", "uc", "uu", "ul", "ur", "f", "us", "iu"], "diff": ["update", "error", "call", "iff", "eff", "it", "conf", "def", "shift", "cmp", "hard", "offset", "det", "help", "extra", "d", "fix", "dl", "add", "equal", "missing", "dev", "good", "del", "Diff", " difference", "split", "range", "dh", "err", "added", "ref", "debug", "distance", "attr", "mix", "different", "dirty", "change", "dist", "dust", "df", "dd", "new", "driver", "part", "comment", "tmp", "changed", "cond", "tf", "test", "edge", "td", "length", "changes", "fd", "Delta"]}}
{"project": "qemu", "commit_id": "e0cb42ae4bc4438ba4ec0760df2d830b8759b255", "target": 1, "func": "static void con_disconnect(struct XenDevice *xendev)\n\n{\n\n    struct XenConsole *con = container_of(xendev, struct XenConsole, xendev);\n\n\n\n    if (con->chr) {\n\n        qemu_chr_add_handlers(con->chr, NULL, NULL, NULL, NULL);\n\n        qemu_chr_fe_release(con->chr);\n\n    }\n\n    xen_be_unbind_evtchn(&con->xendev);\n\n\n\n    if (con->sring) {\n\n        if (!xendev->dev) {\n\n            munmap(con->sring, XC_PAGE_SIZE);\n\n        } else {\n\n            xengnttab_unmap(xendev->gnttabdev, con->sring, 1);\n\n        }\n\n        con->sring = NULL;\n\n    }\n\n}\n", "idx": 6650, "substitutes": {"xendev": ["xendoc", "wendev", "xndec", "xtndir", "wxenddev", "xndew", "xsendoc", " xndel", "xsenddev", "xtenddev", " xendsek", "xendsel", "wxendeddev", " xendec", "xinddev", "xendef", " xendek", "xentew", "xndev", " xndeg", "xndir", " xendem", " xndev", "xenddev", "xendek", "xendsek", "xendedir", "xenderv", " xndew", "xendeddev", "wendedev", "xentef", "xentdev", "wenderv", "xendseg", " xenddev", "xindew", "wxendew", " xendel", "wxendedev", "xndel", "wendederv", "xindec", " xendeg", "xtnddev", " xendsem", "xendedev", "xenterv", "xsendev", "xsenderv", " xendew", "xendsdev", "xentec", "xtndev", "wxendedef", "xentoc", "xtendir", "xbeginek", "wendef", "xbeginem", "xindev", "xtendev", "xendel", " xendsel", "xsendef", "xendederv", "xendsem", "xendedek", "xndeg", "xendedoc", "xendec", "wendoc", "xbeginev", "xentev", " xndec", "xendem", "xendedem", "wendedoc", "xendedew", "xnddev", "xbeginel", "xendedef", "xendedel", "wxendef", "xndef", "xendsev", "xendedeg", "xendeg", "wxendedew", " xnddev", " xendsev", "wxendev", "xendir", "xendew", "wendedef", "xsendir"], "con": ["rain", "act", "cast", "ain", "call", " cons", " CON", "conf", "c", "dial", "pen", "cone", "pan", "CON", "cont", "don", "comm", "client", "mon", "fc", " Con", " conn", "co", "cmd", "connection", "canon", "ran", "un", "Con", "col", "go", "lang", "connect", "stan", "rc", "Conn", " conc", "an", "Cons", "cn", "en", "gate", "num", "fac", "out", "man", "cal", "bean", "ac", "dn", "scan", "tun", "cat", "acon", "can", "cons", "conv", "com", "ctrl", "ver", " uncon", "conn", "non", "ocon", " co"]}}
{"project": "FFmpeg", "commit_id": "8772d2511a4ac45f275eaef2b4b6b1ef132c993b", "target": 1, "func": "static int normalize_bits(int num, int width)\n\n{\n\n    if (!num)\n\n        return 0;\n\n    if (num == -1)\n\n        return width;\n\n    if (num < 0)\n\n        num = ~num;\n\n\n\n    return width - av_log2(num);\n\n}\n", "idx": 6670, "substitutes": {"num": ["draw", "Num", "mult", "result", "um", "mn", "mem", "im", "mun", "type", "note", "cmp", "none", "set", "con", "comm", "mon", "msg", "valid", "nam", "p", "n", "missing", "tim", "zero", "eng", "na", "index", "t", "nu", "number", "bit", "th", "to", "pos", "mu", "nm", "mix", "max", "en", "dim", "NUM", "cal", "alph", "orig", "final", "m", "new", "block", "al", "off", "np", "ord", "conv", "sum", "net", "nom", "snap", "one", "coord", "check", "multipl", "name"]}}
{"project": "qemu", "commit_id": "2e63eb2becc228232f12a1ea30a91b2aa8c5cecd", "target": 1, "func": "static void xen_pci_passthrough_class_init(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n    PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);\n\n\n\n    k->realize = xen_pt_realize;\n\n    k->exit = xen_pt_unregister_device;\n\n    k->config_read = xen_pt_pci_read_config;\n\n    k->config_write = xen_pt_pci_write_config;\n\n\n    set_bit(DEVICE_CATEGORY_MISC, dc->categories);\n\n    dc->desc = \"Assign an host PCI device with Xen\";\n\n    dc->props = xen_pci_passthrough_properties;\n\n};", "idx": 6674, "substitutes": {"klass": ["ikclass", "kickestro", "kestro", "kickstal", "ekclass", "iklas", "kjlor", "kcl", "tklor", "ekcl", " kcl", "ekls", "ikls", " kls", "tkestro", "tklass", "kjestro", "kicklor", "kicklass", "klas", "eklass", "tkclass", "kstal", "kjlass", "iklass", "kjstal", "tkstal", "kls", "klor", "ikcl", "tkls", " kclass", " klas", "kclass", "tklas"], "data": ["result", "dat", "def", "kind", " Data", "raw", "d", " sd", " DATA", "ata", "o", "key", "r", "value", "Data", "mu", " d", "module", "m", "cache", "DATA", "res", "json", "di", "name", "bin"], "dc": ["db", "gc", "cp", "c", "md", "pc", "bc", "fc", "DC", " DC", "d", "cm", "dt", "nc", "ec", "ds", "lc", "cc", "dr", "rc", "dm", "oc", "cr", "dd", "df", "ac", "dk", "cd", "disc", "cca", "doc", "ca", "mc", "dp", "desc", "nz", "iac", "ga", "adr", "di", "cu", "tc", "da"], "k": ["ck", "uk", "q", "km", "it", "kr", "c", "kh", "kt", "kk", "ku", "anc", "ka", "kind", "K", "ik", "ek", "ok", "ijk", "mk", "g", "ak", "ke", "kan", "kar", "key", "wk", "t", "kl", "ki", "ikk", "rek", "kw", "kn", "sk", "ack", "dk", "ko", "kit", "kick", "ks", "kj", "z", "j", "tk"]}}
{"project": "qemu", "commit_id": "fa1298c2d623522eda7b4f1f721fcb935abb7360", "target": 1, "func": "static int ohci_bus_start(OHCIState *ohci)\n\n{\n\n    ohci->eof_timer = timer_new_ns(QEMU_CLOCK_VIRTUAL,\n\n                    ohci_frame_boundary,\n\n                    ohci);\n\n\n\n    if (ohci->eof_timer == NULL) {\n\n        trace_usb_ohci_bus_eof_timer_failed(ohci->name);\n\n        ohci_die(ohci);\n\n        return 0;\n\n    }\n\n\n\n    trace_usb_ohci_start(ohci->name);\n\n\n\n    /* Delay the first SOF event by one frame time as\n\n     * linux driver is not ready to receive it and\n\n     * can meet some race conditions\n\n     */\n\n\n\n    ohci_eof_timer(ohci);\n\n\n\n    return 1;\n\n}\n", "idx": 6685, "substitutes": {"ohci": ["hcu", "ohca", "ahli", "hli", "hci", "ahcci", "ohc", "orgcu", "orgci", "ehc", "ehdi", "ohcci", "hhcu", "ohpi", "hhdi", "ahca", "Ohci", " ohcu", "hrci", "ehpi", "ahdi", "ohdi", " ohdi", " ehcci", "ehcci", "ehca", "hrc", "ehli", " ehca", "ehci", "ahpi", "ohli", " ehcu", "ahc", "ahci", "ihci", "hrcci", "Ohdi", "ohcu", "orgcci", "orgdi", "ahcu", "ihpi", "ehcu", "hc", "ihli", "hhci", "hpi", "hdi", "hrpi", "hcci", " ehci", "Ohcu", "hhcci", "ihdi", " ohcci", "Ohcci"]}}
{"project": "qemu", "commit_id": "3ac2f2f765a0bc18dfb18c38a522e6123289ffc1", "target": 1, "func": "void bdrv_image_info_specific_dump(fprintf_function func_fprintf, void *f,\n\n                                   ImageInfoSpecific *info_spec)\n\n{\n\n    QObject *obj, *data;\n\n    Visitor *v = qmp_output_visitor_new(&obj);\n\n\n\n    visit_type_ImageInfoSpecific(v, NULL, &info_spec, &error_abort);\n\n    visit_complete(v, &obj);\n\n    assert(qobject_type(obj) == QTYPE_QDICT);\n\n    data = qdict_get(qobject_to_qdict(obj), \"data\");\n\n    dump_qobject(func_fprintf, f, 1, data);\n\n\n    visit_free(v);\n\n}", "idx": 6699, "substitutes": {"func_fprintf": ["func_mprintln", "func_mprint", "func_vprintln", "func_mformat", "func_fprintln", "func__vwp", "func_fformat", "func_lfformat", "func__vprintf", "func_vprintf", "func_dprintf", "func_vprint", "func__vprint", "func_lfprintf", "func_lfwp", "func_dprintln", "func_fwp", "func__fprintf", "func_vwp", "func_fprint", "func_vformat", "func_lfprint", "func_mprintf", "func__fwp", "func__fformat", "func_dwp", "func__fprint", "func_dformat", "func_dprint", "func__vformat"], "f": ["cf", "uf", "b", "ff", "xf", "c", "h", "fx", "lf", "file", "fc", "p", "d", "g", "F", "o", "fp", "func", "t", "full", "from", "w", "rf", "bf", "fac", "fun", "fn", "fb", "fi", "fs", "l", "fr", "fd"], "info_spec": ["info2spe", "infoptspec", "info2spec", "infoptdata", "fo_data", "fo_spe", "info2match", "infommspe", "infommspec", " info_match", " info_spe", "fo_spec", "info_spe", "infoptspe", "infommmatch", "info_data", "info_match"], "obj": ["iv", "xy", "b", "bj", "src", "att", "po", "ctx", "cont", "objects", "nt", "ob", "self", "elt", "os", "ht", "bh", "ent", "addr", "cmd", "ie", "typ", "og", "ind", "bo", "o", "cb", "t", "alt", "hw", "js", "str", "opp", "ref", "pos", "pkg", "expr", "attr", "opt", "pr", "nm", "oj", "oc", "org", "ot", "vo", "txt", "orig", "oid", "resp", "object", "tmp", "y", "np", "ex", "info", "j", "res", "obs", "arr", "tk", "Obj", "act"], "data": ["output", "all", "content", "bytes", "result", "error", "results", "dat", "metadata", "ns", "type", "rel", " Data", "valid", "help", "extra", "map", "raw", "d", "p", "table", "details", "n", "partial", " DATA", "group", "name", "ata", "ed", "rew", "context", "o", "t", "Data", "str", "value", "list", "mu", "iter", "pretty", "missing", "keys", "m", "done", "batch", "cache", "np", "DATA", "message", "info", "format", "text", "di", "json", "def", "da"], "v": ["iv", "ev", "vr", "uv", "vy", "q", "b", "lv", "it", "ov", "c", "u", "h", "av", "view", "vi", "i", "ve", "p", "d", "g", "vp", "tv", "o", "pi", "r", "w", "sv", "nv", "m", "vs", "V", "vc", "vis", "cv", "y", "vt", "conv", "vm", "j", "x", "ver", "l"]}}
{"project": "FFmpeg", "commit_id": "7b94df232a4b76c44e243e618573f8d331a1eb1c", "target": 0, "func": "static int srt_decode_frame(AVCodecContext *avctx,\n\n                            void *data, int *got_sub_ptr, AVPacket *avpkt)\n\n{\n\n    AVSubtitle *sub = data;\n\n    AVBPrint buffer;\n\n    int x1 = -1, y1 = -1, x2 = -1, y2 = -1;\n\n    int size, ret;\n\n    const uint8_t *p = av_packet_get_side_data(avpkt, AV_PKT_DATA_SUBTITLE_POSITION, &size);\n\n    FFASSDecoderContext *s = avctx->priv_data;\n\n\n\n    if (p && size == 16) {\n\n        x1 = AV_RL32(p     );\n\n        y1 = AV_RL32(p +  4);\n\n        x2 = AV_RL32(p +  8);\n\n        y2 = AV_RL32(p + 12);\n\n    }\n\n\n\n    if (avpkt->size <= 0)\n\n        return avpkt->size;\n\n\n\n    av_bprint_init(&buffer, 0, AV_BPRINT_SIZE_UNLIMITED);\n\n\n\n    srt_to_ass(avctx, &buffer, avpkt->data, x1, y1, x2, y2);\n\n    ret = ff_ass_add_rect(sub, buffer.str, s->readorder++, 0, NULL, NULL);\n\n    av_bprint_finalize(&buffer, NULL);\n\n    if (ret < 0)\n\n        return ret;\n\n\n\n    *got_sub_ptr = sub->num_rects > 0;\n\n    return avpkt->size;\n\n}\n", "idx": 6708, "substitutes": {"avctx": ["abtc", " avconn", "abctx", "avpkg", "afctx", "afcmp", "savctx", " avcmp", "avtx", " avtc", "avconn", "abcontext", " avcontext", "savpkg", "aftx", "savcontext", "avtc", "Avctl", "avecontext", "avcontext", "aveconn", "abconn", "Avctx", "avectx", " avtx", "avetc", " avpkg", "avcmp", "Avcontext", "Avcmp", " avctl", "avctl", "afcontext", "savtx", "afctl", "afpkg"], "data": ["as", "form", "padding", "next", "empty", "dat", "window", "join", "pad", "feed", "rel", "buf", "description", "at", "raw", "d", "table", "body", "missing", " DATA", "rew", "name", "ata", "t", "input", "value", "Data", "str", "to", "device", "ad", "txt", "video", "inner", "stream", "block", "action", "batch", "area", "DATA", "message", "obj", "length", "text", "def", "image", "path", "da", "bin"], "got_sub_ptr": ["got_desc_ref", "got_rel_tr", "got_sub_rel", "got_desc_ptr", "got_sub2rel", "got_sub_ref", "got_desc_rel", "got_relxpos", "got_sub2pos", "got_desc_addr", "got_rel_addr", "got_subxtr", "got_relxaddr", "got_rel_ptr", "got_sub_tr", "got_sub_addr", "got_sub2tr", "got_sub2ptr", "got_sub_pos", "got_subxpos", "got_sub2addr", "got_subxptr", "got_sub2ref", "got_subxaddr", "got_relxtr", "got_rel_pos", "got_relxptr"], "avpkt": [" avcpkg", "avopcht", "avcpacket", "avPkg", "ajprent", "raftpcht", "avepnt", "avprent", "avpaacket", "avpppt", " avcpet", " avcpkt", " avpdu", "avecpnt", " avcpdu", "avnpkt", "avepkt", "avpnt", "raftpacht", "avnpcmd", "avecpdu", "avpcht", " avpcmd", " avcpcmd", "avecppt", "avppacket", "raftpakt", "avnppt", "avppkt", "avpett", "ajpnt", "avppkg", "avpakt", "avppt", "avpawk", "avnpacket", "avcpett", "avprekg", "avnpdu", "ajpkt", "avdpwp", "avcpkt", "avPdu", "aveppt", "avpreacket", "avcpwp", "avpet", "avcpnt", "avprewk", "avnpnt", "avprecht", "avcpcmd", "avcpkg", "avepdu", "avpdu", "raftpaacket", "avpkg", "avdpacket", "avcpet", "avpcmd", "raftpkt", "avnpet", "avnpett", " avpacket", "avopwk", "avcppt", " avpet", " avcpacket", "ajprekg", "raftpawk", "avdpkg", " avpkg", "avPcmd", "avppnt", "avprekt", "ajpkg", "raftpwk", "avPett", "avpwk", " avpwp", "ajprekt", "raftpacket", "avopkt", "ajpacket", " avpett", "avopacket", "avPkt", "avPet", "avppwp", "avpacket", "avPnt", " avcpett", " avcpwp", "ajpreacket", "avpwp", "avPacket", "avdpkt", "avecpkt", "avcpdu", "avppdu", "avpacht"], "sub": ["butt", "buff", "b", "um", "ab", "pb", "job", "sam", "set", " unsub", "buf", "sc", "con", "ob", "sup", " subt", "ext", "add", " subs", "Sub", "un", "aux", "pl", "tr", "bi", "sel", "ub", "rc", "pre", "tag", "sb", "summary", "SU", "txt", "v", "sec", " subp", "sur", "sl", "ch", "tab", "st", "desc", "supp", "mod", "sum", "sim", "info", "subject", "j", "text", "sing"], "buffer": ["output", "package", "result", "uf", "buff", " buff", "sound", "match", " buf", "b", "mem", "window", "pb", "null", "h", "view", "pad", "binary", "buf", "Buffer", "uffer", "file", "template", "base", "screen", "table", "document", "context", "row", "callback", "queue", "stack", "temp", "line", "ref", "bar", "board", "out", "iter", "v", "command", "stream", "writer", "clear", "comment", "phrase", "ptr", "batch", "cache", "address", "f", "message", "builder", "sum", "engine", "length", "surface", "text", "reference", "sequence"], "size": ["sw", "empty", "SIZE", "c", "h", "scope", "state", "general", "t", "value", "pos", "sid", "message", "sum", "mem", "store", "g", "notice", "index", "str", "position", "send", "start", "code", "summary", "max", "dim", "v", "m", "loss", "address", "length", "l", "power", "type", "shift", "offset", "extra", "score", "len", "no", "use", "style", "small", "capacity", "shape", "ize", "news", "name", "sp", "padding", "window", "fee", "Size", "set", "body", "n", "sent", "height", "scale", "number", "id", "space", "status", "sn", "gz", "storage", "area", "cache", "count", "e", "z", "format", "speed"], "ret": ["gt", "success", "result", "gc", "repl", "uf", "mem", "back", "ter", "buf", "nt", "ext", "mt", " Ret", "rets", "len", "tn", "val", "tr", "t", "alt", "r", "value", "ref", "rev", "rem", "out", "iter", "txt", "code", "complete", "not", "rt", "reset", "fun", "resp", "re", "final", "status", "ptr", "print", "RET", "tf", "f", "Ret", "nz", "ft", "arg", "j", "res", "def", "elt", "flag"], "p": ["post", "sp", "q", "padding", "b", "power", "wp", "cp", "ping", "pb", "c", "u", "pc", "up", "pad", "i", "pt", "at", "ip", "ps", "pa", "d", "bp", "n", "g", "vp", "op", "perm", "fp", "t", "r", "pe", "pos", "pre", "pkg", "pg", "ap", "lp", "v", "m", "per", "y", "jp", "np", "dp", "pp", "P", "j", "tp", "l"], "s": ["rs", "gs", "sp", "b", "sg", "ns", "c", "its", "ats", "h", "sam", "sys", "set", "cs", "sc", "os", "ps", "n", "is", "ts", "ds", "t", "se", "js", "w", "ins", "sv", "ls", "sb", "sa", "spec", "bs", "ss", "serv", "sq", "fs", "S", "sts"]}}
{"project": "FFmpeg", "commit_id": "221f902f1dc167bdc0bfdff6b6af3214ae3cc1f4", "target": 1, "func": "static int filter_slice(AVFilterContext *ctx, void *arg, int jobnr, int nb_jobs)\n\n{\n\n    YADIFContext *s = ctx->priv;\n\n    ThreadData *td  = arg;\n\n    int refs = s->cur->linesize[td->plane];\n\n    int df = (s->csp->comp[td->plane].depth_minus1 + 8) / 8;\n\n    int pix_3 = 3 * df;\n\n    int slice_h = td->h / nb_jobs;\n\n    int slice_start = jobnr * slice_h;\n\n    int slice_end   = (jobnr == nb_jobs - 1) ? td->h : (jobnr + 1) * slice_h;\n\n    int y;\n\n\n\n    /* filtering reads 3 pixels to the left/right; to avoid invalid reads,\n\n     * we need to call the c variant which avoids this for border pixels\n\n     */\n\n    for (y = slice_start; y < slice_end; y++) {\n\n        if ((y ^ td->parity) & 1) {\n\n            uint8_t *prev = &s->prev->data[td->plane][y * refs];\n\n            uint8_t *cur  = &s->cur ->data[td->plane][y * refs];\n\n            uint8_t *next = &s->next->data[td->plane][y * refs];\n\n            uint8_t *dst  = &td->frame->data[td->plane][y * td->frame->linesize[td->plane]];\n\n            int     mode  = y == 1 || y + 2 == td->h ? 2 : s->mode;\n\n            s->filter_line(dst + pix_3, prev + pix_3, cur + pix_3,\n\n                           next + pix_3, td->w - 6,\n\n                           y + 1 < td->h ? refs : -refs,\n\n                           y ? -refs : refs,\n\n                           td->parity ^ td->tff, mode);\n\n            s->filter_edges(dst, prev, cur, next, td->w,\n\n                            y + 1 < td->h ? refs : -refs,\n\n                            y ? -refs : refs,\n\n                            td->parity ^ td->tff, mode);\n\n        } else {\n\n            memcpy(&td->frame->data[td->plane][y * td->frame->linesize[td->plane]],\n\n                   &s->cur->data[td->plane][y * refs], td->w * df);\n\n        }\n\n    }\n\n    return 0;\n\n}\n", "idx": 6727, "substitutes": {"ctx": ["ck", "cf", "gc", "grad", "ct", "ctl", "sg", "ns", "c", "kt", "pc", "cmp", "bc", "anc", "cs", "sc", "fc", " cx", "cmd", "cm", "tn", "nc", "ds", "context", "hw", "xc", "cc", "pkg", "nil", "kw", "cn", "jac", "ac", "vc", "bs", "tx", "tmp", "np", "mc", "ia", "obj", "conn", "tc", "act"], "arg": ["call", "ar", "cand", "pb", "md", "argument", "i", "ang", "ann", "at", "g", "p", "cmd", "ark", "arp", "val", "ay", "ary", "t", "input", "ax", "ref", "inter", "attr", "ng", "Arg", "gate", "v", "ad", "args", "ray", "reg", "doc", "ag", "obj", "info", "in", "param", "arr"], "jobnr": ["jumpnr", "bugattr", "taskattr", "jobattr", "jumpattr", "bugnos", "tasknb", " jobgr", "jobn", "bugnr", " jobnum", "Jobsn", "buggr", "tasknos", " jobNR", "jobgr", "tasknum", "tasknumber", "JobNR", "tasksn", "jobsn", "jobnum", "Jobnum", "tasknor", "jumpnum", "jobnumber", " jobnumber", " jobsn", "jobNR", " jobnb", " jobn", "taskgr", "bugnumber", "jobnos", "jumpnos", "jumpn", "jumpnor", "jumpnb", "jobnor", "jobnb", "taskn", "tasknr", "bugnb", "Jobnr", "bugnor", "taskNR"], "nb_jobs": ["NB_obs", "nb_videos", "nb_groups", "numberjjobs", "number_frames", "nbipmodels", "span_models", "nbJframes", "nbjjobs", "nbTimeblocks", "spanipgroups", "span_groups", "nbofframes", "spanipobs", "nb___jobs", "nbTimeresults", "NBJobs", "nb___obs", "nb___frames", "spanipjobs", "span_obs", "span_jobs", "nb_obs", "nb___videos", "NB_jobs", "nbipjobs", "nbofobs", "spanipmodels", "nb_blocks", "nbTimejobs", "nbipgroups", "nbJjobs", "nbJvideos", "nbofjobs", "nb_frames", "number_jobs", "nbipobs", "numberjframes", "nbJobs", "nbjblocks", "NB_videos", "number_results", "NBJvideos", "NBJjobs", "nb_models", "NBJframes", "number_blocks", "numberjblocks", "nbjresults", "nbTimeframes", "nb_results", "NB_frames", "nbjframes", "nbofvideos", "numberjresults"], "s": ["as", "rs", "so", "sp", "gs", "ses", "ssl", "b", "sg", "sw", "src", "ns", "c", "h", "ats", "sam", "sys", "set", "cs", "sc", "os", "ps", "p", "stat", "g", "is", "ts", "ds", "t", "es", "utils", "r", "js", "ins", "sv", "ls", "sm", "sb", "scl", "stats", "sl", "sa", "hs", "st", "spec", "ss", "bs", "tmp", "sac", "states", "sq", "fs", "ys", "S", "sts", "a"], "td": ["gt", " TD", "cod", "ty", "ctl", "dat", "cz", "SD", "TD", "att", "pb", "tic", "md", "pc", "managed", "det", "dem", "nd", "pt", "tl", "nt", "elt", "ht", "ta", "dt", "tg", "d", "dl", "tm", "tn", "bd", "sd", "ts", "dev", "typ", "std", "tr", "tif", "dad", "t", "mont", "dh", "tw", "edd", "ud", "dm", "cmd", "ti", "ad", "txt", "vd", "tu", "rt", "dd", "dn", "tab", "cd", "tf", "desc", "disc", "pd", "rd", "obj", "hd", "ld", "tk", "tp", "fd", "tt", "tc", "od"], "y": ["hey", "vy", "ty", "xy", "b", "cy", "dy", "any", "wy", "h", "ies", "ley", "i", "sys", "yi", "Y", "ry", "my", "ip", "year", "gy", "uy", "sy", "ery", "hot", "n", "ky", "icy", "aily", "yd", "p", "ya", "ay", "t", "key", "ny", "w", "go", "ly", "ady", "py", "hy", "yy", "ye", "yn", "yu", "try", "v", "iy", "sym", "asy", "yet", "rey", "yer", "m", "ch", "yt", "kit", "sky", "yl", "ys", "ey", "yout", "io", "j", "z", "yo", "x", "yr", "ym", "oy", "axy"], "prev": ["iv", "vr", "par", "vious", "cmp", "up", "rel", "sys", "ve", "pri", "ip", "inv", "vert", "pred", "cop", "var", "op", "perm", "first", "history", "dr", "ref", "pend", "pre", "inter", "rev", "rem", "rr", "veh", "ren", "iter", "tip", "cap", "neg", "orig", "new", "re", "serv", "tmp", "ptr", "cv", "per", "pub", "current", "obj", "before", "Prev", "rec", "via", "pres", "ver"], "cur": ["ph", "deb", "dc", "result", "bur", "ct", "ser", "src", "cp", "keep", "sr", "c", "gr", " Cur", "cont", "cmp", "ter", "buf", "con", "cul", "ve", "sc", "cor", "pri", "mk", "Cur", "cmd", "row", "tr", "cb", "err", "dr", "rc", "th", "pre", "currently", "rev", "fer", "proc", "inter", "iter", "cr", "orig", "sur", "ch", "dir", "serv", "now", "ptr", "cv", "der", "cat", "desc", "ur", "current", "cer", "rec", "ctr", "ctrl", "ver", "car"], "next": ["node", "end", "target", "br", "then", "get", "nr", "ter", "buf", "nd", "last", "nt", "ve", "nn", "pri", "n", "pred", "data", "ner", "first", "nu", "Next", "start", "out", "en", "v", "be", "sec", "final", "new", "st", "adj", "now", "ptr", "np", "current", "obj", "sen", "gen", "net", "fr", "z", "nl", "obs", "ne", "ver", "j", "nw", "path"], "dst": [" dut", "dsnd", "sddest", "Dbr", "dsST", "but", "nsts", "dST", "dbr", "ddest", "sdst", "dsts", "dsdest", "dsst", "nest", "nst", " dsts", "bost", "nbr", "dut", "Dsts", "Dest", "dost", "sdST", "rost", " dest", "Dst", "bsts", "dnd", "bST", "rst", " dbr", "dest", "bnd", " dost", "bst", "sdnd", "bdest", "rsts", "rut"]}}
{"project": "qemu", "commit_id": "d5fee0bbe68d5e61e2d2beb5ff6de0b9c1cfd182", "target": 0, "func": "int ppc64_v3_handle_mmu_fault(PowerPCCPU *cpu, vaddr eaddr, int rwx,\n\n                              int mmu_idx)\n\n{\n\n    if (ppc64_radix_guest(cpu)) { /* Guest uses radix */\n\n        /* TODO - Unsupported */\n\n        error_report(\"Guest Radix Support Unimplemented\");\n\n        exit(1);\n\n    } else { /* Guest uses hash */\n\n        return ppc_hash64_handle_mmu_fault(cpu, eaddr, rwx, mmu_idx);\n\n    }\n\n}\n", "idx": 6753, "substitutes": {"cpu": ["ck", "CPU", "pid", "gc", "kernel", "cum", "gp", "cp", "c", "pu", "pc", "ctx", "prof", "sys", " CPU", "clock", "nt", "util", "chip", "process", "hw", "phys", "cc", "linux", "proc", "mac", "nic", "pai", "ork", "processor", "cil", "alloc", "aq", "jp", "np", "core", "boot", "cu", "gpu", "conn", "onet"], "eaddr": ["oaddr", "adder", " eldder", "adrs", "edddr", "eddder", " elddr", "oadder", "addr", "add", "eadder", "eadd", "eddr", "eddrs", "eddd", " eldrs", " eldd", "eadrs", "adr", "oadr", "eadr"], "rwx": ["rbxx", "rwxs", "rwy", "rwv", "randxs", "ourxs", "rhc", "RWy", "ourxx", "rww", "wxc", "rwc", "rbw", "rwxx", "RWv", "rbx", "randw", "ourw", "rhx", "wxy", "RWx", "RWc", "randxx", "wxv", "randx", "rhy", "wxx", "rbxs", "ourx", "rhv"], "mmu_idx": ["mmu_Idm", "mmu_Idv", "mmu_idsx", "mmu_idsv", "mmu_idz", "mmu_fdm", "mmu_idv", "mmu_basedv", "mmu_basedx", "mmu_Idx", "mmu_idm", "mmu_Idz", "mmu_idu", "mmu_fdz", "mmu_basedu", "mmu_idsu", "mmu_fdv", "mmu_idsz", "mmu_fdx", "mmu_basedz"]}}
{"project": "FFmpeg", "commit_id": "1f361124d97cf8b8ce6d3aacb10cdc53706470de", "target": 1, "func": "int ff_img_read_packet(AVFormatContext *s1, AVPacket *pkt)\n\n{\n\n    VideoDemuxData *s = s1->priv_data;\n\n    char filename_bytes[1024];\n\n    char *filename = filename_bytes;\n\n    int i;\n\n    int size[3]           = { 0 }, ret[3] = { 0 };\n\n    AVIOContext *f[3]     = { NULL };\n\n    AVCodecContext *codec = s1->streams[0]->codec;\n\n\n\n    if (!s->is_pipe) {\n\n        /* loop over input */\n\n        if (s->loop && s->img_number > s->img_last) {\n\n            s->img_number = s->img_first;\n\n        }\n\n        if (s->img_number > s->img_last)\n\n            return AVERROR_EOF;\n\n        if (s->use_glob) {\n\n#if HAVE_GLOB\n\n            filename = s->globstate.gl_pathv[s->img_number];\n\n#endif\n\n        } else {\n\n        if (av_get_frame_filename(filename_bytes, sizeof(filename_bytes),\n\n                                  s->path,\n\n                                  s->img_number) < 0 && s->img_number > 1)\n\n            return AVERROR(EIO);\n\n        }\n\n        for (i = 0; i < 3; i++) {\n\n            if (avio_open2(&f[i], filename, AVIO_FLAG_READ,\n\n                           &s1->interrupt_callback, NULL) < 0) {\n\n                if (i >= 1)\n\n                    break;\n\n                av_log(s1, AV_LOG_ERROR, \"Could not open file : %s\\n\",\n\n                       filename);\n\n                return AVERROR(EIO);\n\n            }\n\n            size[i] = avio_size(f[i]);\n\n\n\n            if (!s->split_planes)\n\n                break;\n\n            filename[strlen(filename) - 1] = 'U' + i;\n\n        }\n\n\n\n        if (codec->codec_id == AV_CODEC_ID_NONE) {\n\n            AVProbeData pd;\n\n            AVInputFormat *ifmt;\n\n            uint8_t header[PROBE_BUF_MIN + AVPROBE_PADDING_SIZE];\n\n            int ret;\n\n            int score = 0;\n\n\n\n            ret = avio_read(f[0], header, PROBE_BUF_MIN);\n\n            if (ret < 0)\n\n                return ret;\n\n\n            avio_skip(f[0], -ret);\n\n            pd.buf = header;\n\n            pd.buf_size = ret;\n\n            pd.filename = filename;\n\n\n\n            ifmt = av_probe_input_format3(&pd, 1, &score);\n\n            if (ifmt && ifmt->read_packet == ff_img_read_packet && ifmt->raw_codec_id)\n\n                codec->codec_id = ifmt->raw_codec_id;\n\n        }\n\n\n\n        if (codec->codec_id == AV_CODEC_ID_RAWVIDEO && !codec->width)\n\n            infer_size(&codec->width, &codec->height, size[0]);\n\n    } else {\n\n        f[0] = s1->pb;\n\n        if (url_feof(f[0]))\n\n            return AVERROR(EIO);\n\n        if (s->frame_size > 0) {\n\n            size[0] = s->frame_size;\n\n        } else {\n\n            size[0] = 4096;\n\n        }\n\n    }\n\n\n\n    if (av_new_packet(pkt, size[0] + size[1] + size[2]) < 0)\n\n        return AVERROR(ENOMEM);\n\n    pkt->stream_index = 0;\n\n    pkt->flags       |= AV_PKT_FLAG_KEY;\n\n    if (s->ts_from_file) {\n\n        struct stat img_stat;\n\n        if (stat(filename, &img_stat))\n\n            return AVERROR(EIO);\n\n        pkt->pts = (int64_t)img_stat.st_mtime;\n\n        av_add_index_entry(s1->streams[0], s->img_number, pkt->pts, 0, 0, AVINDEX_KEYFRAME);\n\n    } else if (!s->is_pipe) {\n\n        pkt->pts      = s->pts;\n\n    }\n\n\n\n    pkt->size = 0;\n\n    for (i = 0; i < 3; i++) {\n\n        if (f[i]) {\n\n            ret[i] = avio_read(f[i], pkt->data + pkt->size, size[i]);\n\n            if (!s->is_pipe)\n\n                avio_close(f[i]);\n\n            if (ret[i] > 0)\n\n                pkt->size += ret[i];\n\n        }\n\n    }\n\n\n\n    if (ret[0] <= 0 || ret[1] < 0 || ret[2] < 0) {\n\n        av_free_packet(pkt);\n\n        return AVERROR(EIO); /* signal EOF */\n\n    } else {\n\n        s->img_count++;\n\n        s->img_number++;\n\n        s->pts++;\n\n        return 0;\n\n    }\n\n}", "idx": 6763, "substitutes": {"s1": ["js1", "S2", "js3", "s0", "js2", "ds3", "s3", "S6", "js9", "S1", " s0", "S0", "S3", "s9", " s3", "js6", " s9", "ds2", "ds0", "ds1", "S9", "s2", " s6", " s2", "s6"], "pkt": ["pet", "packet", "ppkt", "ppet", "Packet", " pct", "pct", "Pct", "Pet", "ppct", " pet", "ppacket", " packet", "Pkt"], "s": ["styles", "sw", "less", "conf", "c", "save", "h", "state", "sc", "ps", "ts", "se", "js", "w", "sb", "ss", "south", "changes", "j", "series", "sports", "comments", "source", "as", "rs", "ses", "sam", "https", "os", "g", "ms", "es", "v", "stats", "m", "sa", "vs", "local", "conv", "aws", "a", "l", "ops", "gs", "ssl", "times", "ns", "ats", "comm", "cs", "p", "is", "sd", "has", "sv", "st", "sq", "session", "fs", "S", "single", "sp", "b", "its", "sys", "qs", "set", "details", "n", "ds", "sync", "ins", "space", "ls", "ess", "ims", "sl", "status", "spec", "search", "sim", "sts"], "filename_bytes": ["filename2byte", "filename_seconds", "filename2Bytes", " filename_Bytes", "filename_keys", "filename_Bytes", "username_lines", "filename2tes", "filename2bytes", "username_keys", "filename_uses", "username_Bytes", " filename_byte", "path_bytes", " filename_tes", "username_bytes", "username_seconds", "filename_lines", "path_uses", "filename_tes", "filename_byte", "path_tes"], "filename": ["folder", "output", "original", "result", "names", "jpg", "prefix", "src", "metadata", "binary", "buf", "description", "file", "files", "buffer", "til", "ename", "ame", "n", "location", "FN", "unc", "url", "kan", "upload", "fp", "fle", "mpeg", "username", "ames", "position", "river", "fil", "nil", "png", "nm", "ren", "txt", "video", "v", "FIL", "far", "sbm", "sorry", "status", "final", "fn", "Filename", "NAME", "tmp", "fi", "AME", "fs", "family", "l", "via", "length", "kj", "subject", "source", "json", "nl", "directory", "title", "name", "image", "path"], "i": ["ei", " ii", "im", "c", "h", "gi", "d", "zi", "tim", "ind", "t", "pi", "I", "batch", "io", "in", "j", "x", "\u0438", "di", "ic", "q", "um", "cgi", "mi", "g", "xi", "index", "ri", "bi", "go", "ki", "out", "ti", "v", "ai", "m", "port", "ia", "l", "ci", "it", "u", "ip", "li", "p", "o", "to", "k", "y", "ii", "init", "ij", "ini", "uri", "cli", "oi", "qi", "si", "n", "iq", "multi", "me", "id", "ui", "ji", "ix", "status", "sim", "ex", "iu", "e", "point", "z"], "size": ["share", "export", "form", "sp", "error", "SIZE", "fee", "type", "grade", "offset", "Size", "set", "buffer", "g", "order", "equal", "score", "fit", "len", "use", "data", "scale", "style", "send", "start", "max", "en", "v", "dim", "small", "status", "sn", "cache", "count", "message", "shape", "ize", "length", "z", "format", "needed", "name", "source"], "ret": ["gt", "read", "result", "uf", "next", "mem", "it", "ber", "back", "get", "offset", "ter", "set", "buf", "nt", "true", "ry", "buffer", "valid", "er", "dt", "cmd", " Ret", "score", "len", "rets", "val", "tr", "usr", "ner", "alt", "ary", "utils", "r", "err", "value", "dr", "rc", "ref", "after", "rev", "rem", "rr", "pert", "out", "en", "iter", "v", "txt", "code", "try", "fun", "rt", "status", "reset", "re", "RET", "jump", "Ret", "nz", "ft", "test", "net", "j", "res", "arr", "tail", "def", "elt", "flag"], "f": ["q", "uf", "b", "xf", "ff", "it", "window", "c", "u", "h", "fe", "file", "buffer", "fc", "d", "g", "p", "n", "F", "fl", "o", "fp", "t", "r", "w", "of", "rf", "bf", "iter", "v", "fac", "m", "fn", "fb", "y", "sf", "fi", "fs", "e", "l", "fr", "j", "a", "fd", "fw"], "codec": ["codep", " codic", "compenc", "chec", "Codep", "cedec", "codric", "coddec", "codic", "chep", "Codrc", "codenc", "predoc", "Codenc", "compec", "cdenc", " coddec", "Codoc", "cdec", "cedoc", "cedic", "compoc", "chdec", "predec", "codoc", " codEC", " codep", "cdoc", "cdrc", "cedric", "codrc", "Codec", " codoc", "chEC", "codEC", "comprc", "predic", "Coddec", "predric", " codric", "CodEC"], "pd": [" pooled", " buff", " cd", " cond", " proc", " pdf", " prog", " bo", " dh", " prov", " df", " td", " pars", " prod", " program", " sd", " pro", " proto", "PD", " pc", " ed", " dd", " ep", " din", " dw", " prof", " ad", " prot", " pe"], "ifmt": ["ifformat", "IFlt", "fMT", "iflt", "ifMT", "flt", " iflt", " ifMT", "fformat", "IFMT", " ifformat", "fmt", "IFmt", "IFformat"], "header": ["padding", "metadata", "type", "h", "HEAD", "offset", "tar", "heading", "file", "buffer", "extra", "er", "table", "var", " HDR", "index", "t", "headers", "dr", "tag", "list", "border", "code", "layer", "iter", "status", "command", "writer", "block", "head", "version", "address", "Header", "filter", "info", "length", "holder", "format", "name", "flag"], "img_number": ["image_note", "img_no", "img_num", "img_type", "img_id", "img7number", "img_nb", "image_nr", "img__num", "img_last", "imguglast", "img_position", "image_no", "orig_number", "image_type", "image_number", "image_first", "image_name", "image_last", "orig_num", "img7num", "imgugnumber", "img___note", "img_name", "img_note", "imgugnum", "orig_id", "img_nr", "image_nb", "img__nb", "image_num", "img_first", "img___number", "img___no", "imgugtype", "orig_no", "img7no", "img7id", "image_position", "img__name", "img__number", "img___position"]}}
{"project": "qemu", "commit_id": "40c4ed3f95f0b2ffa0848df0fc311556bb7472a1", "target": 1, "func": "void ide_data_writew(void *opaque, uint32_t addr, uint32_t val)\n\n{\n\n    IDEBus *bus = opaque;\n\n    IDEState *s = idebus_active_if(bus);\n\n    uint8_t *p;\n\n\n\n    /* PIO data access allowed only when DRQ bit is set */\n\n    if (!(s->status & DRQ_STAT))\n\n        return;\n\n\n\n    p = s->data_ptr;\n\n    *(uint16_t *)p = le16_to_cpu(val);\n\n    p += 2;\n\n    s->data_ptr = p;\n\n    if (p >= s->data_end)\n\n        s->end_transfer_func(s);\n\n}\n", "idx": 6775, "substitutes": {"opaque": ["opos", "paque", "opoid", "boque", "opux", "oppux", "opque", "hopque", "hopaque", "boos", "oppaque", " opos", "patile", "oaque", "oppatile", " opque", "oppoid", "pux", "oux", "poid", "boaque", "hopos", "opatile", "ooid", "oatile"], "addr": ["db", " ptr", "src", "mem", "wid", "cmp", "rel", " address", "cmd", "data", "rol", "rc", "ref", "pos", "id", "attr", "ad", "host", "v", "ix", "tx", "ptr", "address", "eth", "hl", "arr", "res", "loc"], "val": [" data", "uv", "mem", "cmp", "buf", " v", "state", "Val", " vel", "valid", "seq", "vol", "pol", "var", "data", " value", "vals", "alt", "key", "rol", "sel", "value", "ref", "pos", " ty", " seq", "v", "slot", "txt", "resp", " aval", "reg", "serv", "tx", "ret", "eval", "Value", " arg", "vt", "VAL", "test", " eval", "res", "x"], "bus": ["bur", "chain", "b", " busy", "usb", "c", "ctx", "h", "back", "BUS", "pod", "box", "store", "sys", " device", "os", " unused", "base", "Bus", " mailbox", "dev", "aque", "phys", "bolt", "board", "device", "proxy", "mount", "gate", "handle", "port", "driver", "bridge", "bs", "home", "loop", "us", "boot", "lock", "stick", "ase", "onet", "l"], "s": ["rs", "so", "sp", "gs", "ses", "b", "less", "ns", "sol", "c", "h", "sys", "qs", "state", "cs", "self", "store", "comm", "os", "ps", "als", "ms", "g", "is", "ts", "sd", "ds", "t", "se", "es", "js", "space", "sv", "ls", "sm", "sb", "v", "stats", "sl", "status", "m", "spec", "hs", "vs", "sa", "ss", "bs", "y", "sq", "socket", "f", "fs", "us", "e", "S", "sts", "z", "sis", "j", "sports", "a", "l"], "p": ["post", "q", "sp", "b", "wp", "cp", "ping", "pb", "c", "pu", "pc", "pad", "i", "pro", "pt", "ip", "g", "pa", "d", "ps", "n", "bp", "vp", "op", "php", "pl", "perm", "fp", "t", "pi", "pers", "pe", "pre", "pkg", "ap", "pr", "lp", "v", "m", "ptr", "parse", "jp", "np", "f", "dp", "pp", "P", "point", "j", "x", "tp", "l", "mp"]}}
{"project": "FFmpeg", "commit_id": "01ecb7172b684f1c4b3e748f95c5a9a494ca36ec", "target": 1, "func": "static void quantize_and_encode_band_cost_SPAIR_mips(struct AACEncContext *s,\n\n                                                     PutBitContext *pb, const float *in, float *out,\n\n                                                     const float *scaled, int size, int scale_idx,\n\n                                                     int cb, const float lambda, const float uplim,\n\n                                                     int *bits, const float ROUNDING)\n\n{\n\n    const float Q34 = ff_aac_pow34sf_tab[POW_SF2_ZERO - scale_idx + SCALE_ONE_POS - SCALE_DIV_512];\n\n    const float IQ  = ff_aac_pow2sf_tab [POW_SF2_ZERO + scale_idx - SCALE_ONE_POS + SCALE_DIV_512];\n\n    int i;\n\n    int qc1, qc2, qc3, qc4;\n\n\n\n    uint8_t  *p_bits  = (uint8_t  *)ff_aac_spectral_bits[cb-1];\n\n    uint16_t *p_codes = (uint16_t *)ff_aac_spectral_codes[cb-1];\n\n    float    *p_vec   = (float    *)ff_aac_codebook_vectors[cb-1];\n\n\n\n    abs_pow34_v(s->scoefs, in, size);\n\n    scaled = s->scoefs;\n\n    for (i = 0; i < size; i += 4) {\n\n        int curidx, curidx2;\n\n        int *in_int = (int *)&in[i];\n\n        uint8_t v_bits;\n\n        unsigned int v_codes;\n\n        int t0, t1, t2, t3, t4, t5, t6, t7;\n\n        const float *vec1, *vec2;\n\n\n\n        qc1 = scaled[i  ] * Q34 + ROUND_STANDARD;\n\n        qc2 = scaled[i+1] * Q34 + ROUND_STANDARD;\n\n        qc3 = scaled[i+2] * Q34 + ROUND_STANDARD;\n\n        qc4 = scaled[i+3] * Q34 + ROUND_STANDARD;\n\n\n\n        __asm__ volatile (\n\n            \".set push                      \\n\\t\"\n\n            \".set noreorder                 \\n\\t\"\n\n\n\n            \"ori    %[t4],  $zero,  4       \\n\\t\"\n\n            \"slt    %[t0],  %[t4],  %[qc1]  \\n\\t\"\n\n            \"slt    %[t1],  %[t4],  %[qc2]  \\n\\t\"\n\n            \"slt    %[t2],  %[t4],  %[qc3]  \\n\\t\"\n\n            \"slt    %[t3],  %[t4],  %[qc4]  \\n\\t\"\n\n            \"movn   %[qc1], %[t4],  %[t0]   \\n\\t\"\n\n            \"movn   %[qc2], %[t4],  %[t1]   \\n\\t\"\n\n            \"movn   %[qc3], %[t4],  %[t2]   \\n\\t\"\n\n            \"movn   %[qc4], %[t4],  %[t3]   \\n\\t\"\n\n            \"lw     %[t0],  0(%[in_int])    \\n\\t\"\n\n            \"lw     %[t1],  4(%[in_int])    \\n\\t\"\n\n            \"lw     %[t2],  8(%[in_int])    \\n\\t\"\n\n            \"lw     %[t3],  12(%[in_int])   \\n\\t\"\n\n            \"srl    %[t0],  %[t0],  31      \\n\\t\"\n\n            \"srl    %[t1],  %[t1],  31      \\n\\t\"\n\n            \"srl    %[t2],  %[t2],  31      \\n\\t\"\n\n            \"srl    %[t3],  %[t3],  31      \\n\\t\"\n\n            \"subu   %[t4],  $zero,  %[qc1]  \\n\\t\"\n\n            \"subu   %[t5],  $zero,  %[qc2]  \\n\\t\"\n\n            \"subu   %[t6],  $zero,  %[qc3]  \\n\\t\"\n\n            \"subu   %[t7],  $zero,  %[qc4]  \\n\\t\"\n\n            \"movn   %[qc1], %[t4],  %[t0]   \\n\\t\"\n\n            \"movn   %[qc2], %[t5],  %[t1]   \\n\\t\"\n\n            \"movn   %[qc3], %[t6],  %[t2]   \\n\\t\"\n\n            \"movn   %[qc4], %[t7],  %[t3]   \\n\\t\"\n\n\n\n            \".set pop                       \\n\\t\"\n\n\n\n            : [qc1]\"+r\"(qc1), [qc2]\"+r\"(qc2),\n\n              [qc3]\"+r\"(qc3), [qc4]\"+r\"(qc4),\n\n              [t0]\"=&r\"(t0), [t1]\"=&r\"(t1), [t2]\"=&r\"(t2), [t3]\"=&r\"(t3),\n\n              [t4]\"=&r\"(t4), [t5]\"=&r\"(t5), [t6]\"=&r\"(t6), [t7]\"=&r\"(t7)\n\n            : [in_int]\"r\"(in_int)\n\n            : \"memory\"\n\n        );\n\n\n\n        curidx = 9 * qc1;\n\n        curidx += qc2 + 40;\n\n\n\n        curidx2 = 9 * qc3;\n\n        curidx2 += qc4 + 40;\n\n\n\n        v_codes = (p_codes[curidx] << p_bits[curidx2]) | (p_codes[curidx2]);\n\n        v_bits  = p_bits[curidx] + p_bits[curidx2];\n\n        put_bits(pb, v_bits, v_codes);\n\n\n\n        if (out) {\n\n           vec1 = &p_vec[curidx*2 ];\n\n           vec2 = &p_vec[curidx2*2];\n\n           out[i+0] = vec1[0] * IQ;\n\n           out[i+1] = vec1[1] * IQ;\n\n           out[i+2] = vec2[0] * IQ;\n\n           out[i+3] = vec2[1] * IQ;\n\n        }\n\n    }\n\n}\n", "idx": 6778, "substitutes": {"s": ["init", "as", "rs", "sp", "gs", "sg", "src", "ns", "c", "its", "h", "ats", "qs", "sys", "state", "cs", "sc", "self", "p", "ps", "ts", "ds", "es", "js", "ins", "sv", "ls", "sb", "v", "stats", "sa", "hs", "a", "spec", "ss", "bs", "sq", "sf", "f", "fs", "e", "S", "sts", "aws", "source"], "pb": ["uf", "wp", "cp", "pc", "ctx", "kB", "bh", "pa", "bp", "vp", "pl", "fp", "BP", "lb", "pm", " cp", "sb", "lp", "bf", "bps", "xb", "nb", "cv", "np", "pp", "bm", "tk", "tp", "tc"], "in": ["init", "nin", "it", "c", "up", "isin", "In", "raw", "p", "vin", "ind", "data", "t", "input", "din", "ins", "IN", "inf", "inner", "m", "rin", "new", "scan", "local", "doc", "gin", "f", "min", "sum", "ex", "pin", "l", "inc", "inn", "bin"], "out": ["output", "gt", "result", "b", "flat", "sys", "buf", "set", "os", "p", "Out", "n", "o", "data", "t", "OUT", "w", "to", "v", "ot", "outs", "final", "new", "tmp", "conv", "net", "res"], "scaled": ["staled", "escaped", "escaled", "escalled", " unscale", "configaling", "SCale", "expaled", " unscalled", "escaling", "shaped", "pscaling", "scaling", "rcale", "Scaling", "descale", " unscaled", "scalled", "expatted", "shaled", "configaped", "pscalled", "configaled", "Scaled", "scatted", "configale", "shaling", "descaled", "sculed", "esculed", "scale", "shale", "pscatted", "desculed", "stale", "expalled", "Scalled", "SCaling", "Scale", "SCalled", "Scatted", "descalled", "stalled", "scaped", " unscaling", " unsculed", "escale", "pscaled", "SCaled", "expaling", "rculed", "rcaling", "rcaled", "staling"], "size": ["ci", "empty", "SIZE", " sizes", "fee", "c", "type", "ctx", "shift", "offset", "Size", "set", "sc", "see", "g", "si", "cm", "zone", "score", "len", "no", " Size", "win", "range", "scale", "number", "slice", "send", "max", "dim", "small", "sn", "south", "area", "capacity", "count", "shape", "sum", "ize", "length", "z", "l", "loc"], "scale_idx": ["scale_Idy", "scaleableidxt", "scale_idez", "scale_idxes", "scale_edxt", "scale_ideX", "scale_edice", "scaleableidt", "scale_edt", "scale_indX", "scale_identt", "scale_indz", "scale_indxc", "scaleableedice", "scale_indx", "scaleableedt", "scale_idxs", "scale_idy", "scale_iterz", "scale_idt", "scale_iterxes", "scale_Idxs", "scale_indy", "scale_didt", "scale_idice", "scaleableidice", "scale_didice", "scaleableidx", "scale_Idx", "scale_idX", "scale_iterX", "scale_identxt", "scaleableedx", "scale_idex", "scale_idexes", "scale_indxes", "scaleableedxt", "scale_Idxc", "scale_didx", "scale_indxs", "scale_didxt", "scale_idz", "scale_identx", "scale_identice", "scale_iterx", "scale_idxc", "scale_idxt", "scale_edx"], "cb": ["ck", "db", "cf", "gb", "dc", "gc", "ctl", "cp", "conf", "eb", "fee", "cli", "ctx", "bc", "gov", "sc", "ob", "cor", "fc", "dt", "CU", "bp", "nc", "wb", "lc", "bound", "callback", "lb", "cc", "bb", "bar", "sb", "rb", "bf", "cn", "cr", "cfg", "cell", "cale", "nb", "CB", "usc", "cv", "cd", "conv", "tc", "ctr", "coord", "ctrl", "cu", "loc"], "lambda": ["aug", "Alpha", "lr", "Lu", "density", "alpha", "beta", " gamma", "lam", "Delta", "LG", "lu", "lc", "elta", "hi", "nu", "LU", "mu", "dB", "phi", "igma", "ima", "appa", "mega", "pha", "Mu", "LA", "da"], "uplim": ["uiplength", "uiplim", "uppims", "uippims", "uppim", "uiplIM", "umlim", "umlims", "uplength", "umlIM", "uippength", "uiplims", "uppIM", "umlength", "uippim", "uippIM", "uplIM", "uppength", "uplims"], "bits": ["bytes", "gs", "bis", "weights", "items", "its", "ints", "qs", "cs", "pins", "ms", "vals", "bi", "bit", "ls", "xs", "bf", "planes", "units", "bps", "outs", "codes", "bs", "limits", "heads", "flags"], "ROUNDING": ["RINDing", "ROUNDing", "RroundED", " RoundingED", "Rround1", "ROUND1", "RINDING", "Rounding1", "RoundingED", "RINDED", " Roundinging", " ROUND1", "ROUNDED", "Rrounding", "RoundingING", " Rounding1", " ROUNDED", " ROUNDing", "RIND1", "RroundING", "Roundinging", " RoundingING"], "i": ["init", "this", "ic", "ij", "ini", " bi", "ei", "ci", "uri", " ii", "it", "im", "cli", "oi", "gi", "mi", "ip", "li", "g", "si", "zi", "n", "is", "ski", "xi", "ind", "index", "o", " ti", "hi", "pi", "bi", "multi", "t", "ri", "me", "id", "ui", "ki", "ji", "slice", "err", " I", "ti", "iter", "ims", "ix", "key", " j", "ai", "m", "status", "I", "batch", "y", "ia", "sim", "gu", "iu", "info", "j", "x", "di", "ii"], "qc1": [" qr1", "qr4", " qr4", "qr2", " qc6", "qc6", "qrc1", "qfc1", "qpc2", "qpc1", "qr1", "qr6", " qr2", " qrc2", " qc0", " qr6", "qpc4", "qfc4", " qrc1", "qdc4", "qc0", "qfc6", "qdc1", " qrc0", "qrc2", "qdc0", " qrc4", "qpc0", "qrc6", "qfc2", "qrc4", "qdc2", "qrc0"], "qc2": ["qlc102", "qc102", " qc7", "qlc4", "quc2", "qec7", " qec7", " qlc4", "qcc5", "qcc2", "qec2", " qec5", "qt2", "qcc4", "qcc102", " qlc2", "quc3", "qrc5", " qlc5", " qc102", "quc7", "qec3", " qlc102", "qrc102", "qt5", "qrc2", "quc5", " qec3", "qc7", "qc5", "qec5", "qt3", "qlc2", " qc5", "qrc4", "qlc5", " qec2", "qt7"], "qc3": ["qct3", "qc23", "qup11", "qpcThree", "qp23", "qcthree", "quc23", "questc2", "qcThree", "qunc3", "questpc2", "qacThree", "qpc2", "qctThree", "qn3", "qn23", "questpcthree", "qp11", "qunc11", "qp7", "qunc23", "qacthree", "qpcthree", "questcthree", "questcThree", "quc3", "quc11", "questpcThree", "quc7", "qct2", "questc3", "qn7", "qup23", "qup3", "qctthree", "questpc3", "qp3", "qc7", "qac3", "qup7", "qc11", "qunc7", "qpc3", "qac2", "qn11"], "qc4": ["qarc4", " qc6", "ql5", "qc6", "qc04", "qm12", "qrc3", "qm5", "qarc12", " qdc6", " qdc4", " qc12", "qarc5", "qt4", "qarc04", "qdc3", "qm4", " qdc3", "qt8", "qt6", " qdc8", " qc8", "qdc4", "ql04", " ql4", " ql12", "qrc8", "qm04", " qc04", " ql04", "qdc8", "ql4", "ql12", "qc8", "qc5", "qc12", "qrc6", "qt3", "qdc6", "qrc4", " qc5", " ql5"], "p_bits": ["c___codes", "p___bs", "p_bs", "c___bits", "c___bs", "c___maps", "c_codes", "c_bits", "p___bits", "p___codes", "c_maps", "c_bs", "p___maps", "p_maps"], "p_codes": ["P_bits", "pmlbits", "pmlouts", "pmlcodes", "P_terms", "p_terms", "P_outs", "p_outs", "P_codes", "pmlterms"], "p_vec": ["P_ver", "p2vec", "p2vals", "p_vals", "p2buf", "P_vals", "p2ver", "P_buf", "P_vec", "p_ver", "p_buf"], "curidx": [" curidy", "curidy", "curridc", "curdz", "curridx", "curdc", " curIdc", " curidc", "curdy", "curIdz", "curdx", "curIdx", " curidz", " curIdx", "curidz", "curidc", " curIdy", "curIdc", "curridy", " curIdz", "curridz", "curIdy"], "curidx2": ["curIdex0", "curIdex1", "curidex1", "curidy2", "curidex0", "curidy1", "curidex2", "curIdex2", "curIdx0", "curidy0", "curidix0", "curIdx2", "curidix1", "curidix2", "curidx0", "curIdx1", "curidx1"], "in_int": ["in2uint", "in2int", " in2uint", " in2int", " in2ind", "in_str", "in2ind", "in2str", " in2str", " in_uint", "in_uint", "in_ind", " in_str", " in_ind"], "v_bits": ["p_fields", "v_flags", "v_fields", "v2codes", "v2bits", "v2flags", "v2fields", "p_flags"], "v_codes": [" v_code", "v__codes", "v_code", "v_values", " v_values", "v__code", "v__bits", "v__values"], "t0": ["T0", "T1", "v2", "v1", "T7", "v7", "v0", "T2"], "t1": ["tt1", "T001", "T8", " t001", "T01", "t8", "T1", " t01", "tt8", "t01", "tt01", "tt001", "t001", " t8"], "t2": ["tt256", "t256", "ttb", " t256", "t02", "T256", "tb", "T02", " tb", "tt2", "Tb", " t02", "T2", "tt02"], "t3": ["t03", "v4", "v03", "T4", "T3", "v3", " t03", "v7", "T7", "T03"], "t4": ["tt413", "tsN", "tu413", "ts413", "ts4", "tuN", "ttN", "tu4", "tt4", "t413", "tN"], "t5": ["te6", "te5", "te005", "t50", "te50", "et005", "t005", "et5", "tt005", "tt5", "et50", "tt6", "et6", "tt50"], "t6": ["tt26", "T8", "t06", "t8", "dt6", "T06", "tt06", "tt8", "dt26", "t26", "tt6", "dt8", "T26", "dt06", "T6"], "t7": ["tt13", "tt7", "tc11", "tt11", "tt4", " t13", "tc13", "tc4", " t11", "tc7", "t11", "t13"], "vec1": ["vector3", "vector5", "vector0", "vector1", "buf0", "vec5", "v5", "v1", "vec0", "buf3", "buf1", "v3", "v0", "buf5", "vec3"], "vec2": ["val1", "val5", "val4", "cv1", "cv2", " vec5", "val2", "vec4", "cv4", "vec5", "cv5", " vec4"]}}
{"project": "FFmpeg", "commit_id": "eef9f06508354d1c7d5624c1c18997e7974288f1", "target": 0, "func": "static int stream_component_open(PlayerState *is, int stream_index)\n\n{\n\n    AVFormatContext *ic = is->ic;\n\n    AVCodecContext *avctx;\n\n    AVCodec *codec;\n\n    SDL_AudioSpec wanted_spec, spec;\n\n    AVDictionary *opts;\n\n    AVDictionaryEntry *t = NULL;\n\n    int ret = 0;\n\n\n\n    if (stream_index < 0 || stream_index >= ic->nb_streams)\n\n        return -1;\n\n    avctx = ic->streams[stream_index]->codec;\n\n\n\n    opts = filter_codec_opts(codec_opts, avctx->codec_id, ic, ic->streams[stream_index], NULL);\n\n\n\n    codec = avcodec_find_decoder(avctx->codec_id);\n\n    avctx->workaround_bugs   = workaround_bugs;\n\n    avctx->idct_algo         = idct;\n\n    avctx->skip_frame        = skip_frame;\n\n    avctx->skip_idct         = skip_idct;\n\n    avctx->skip_loop_filter  = skip_loop_filter;\n\n    avctx->error_concealment = error_concealment;\n\n\n\n    if (fast)\n\n        avctx->flags2 |= AV_CODEC_FLAG2_FAST;\n\n\n\n    if (!av_dict_get(opts, \"threads\", NULL, 0))\n\n        av_dict_set(&opts, \"threads\", \"auto\", 0);\n\n    if (avctx->codec_type == AVMEDIA_TYPE_VIDEO)\n\n        av_dict_set(&opts, \"refcounted_frames\", \"1\", 0);\n\n    if (!codec ||\n\n        (ret = avcodec_open2(avctx, codec, &opts)) < 0) {\n\n        goto fail;\n\n    }\n\n    if ((t = av_dict_get(opts, \"\", NULL, AV_DICT_IGNORE_SUFFIX))) {\n\n        av_log(NULL, AV_LOG_ERROR, \"Option %s not found.\\n\", t->key);\n\n        ret =  AVERROR_OPTION_NOT_FOUND;\n\n        goto fail;\n\n    }\n\n\n\n    /* prepare audio output */\n\n    if (avctx->codec_type == AVMEDIA_TYPE_AUDIO) {\n\n        is->sdl_sample_rate = avctx->sample_rate;\n\n\n\n        if (!avctx->channel_layout)\n\n            avctx->channel_layout = av_get_default_channel_layout(avctx->channels);\n\n        if (!avctx->channel_layout) {\n\n            fprintf(stderr, \"unable to guess channel layout\\n\");\n\n            ret = AVERROR_INVALIDDATA;\n\n            goto fail;\n\n        }\n\n        if (avctx->channels == 1)\n\n            is->sdl_channel_layout = AV_CH_LAYOUT_MONO;\n\n        else\n\n            is->sdl_channel_layout = AV_CH_LAYOUT_STEREO;\n\n        is->sdl_channels = av_get_channel_layout_nb_channels(is->sdl_channel_layout);\n\n\n\n        wanted_spec.format = AUDIO_S16SYS;\n\n        wanted_spec.freq = is->sdl_sample_rate;\n\n        wanted_spec.channels = is->sdl_channels;\n\n        wanted_spec.silence = 0;\n\n        wanted_spec.samples = SDL_AUDIO_BUFFER_SIZE;\n\n        wanted_spec.callback = sdl_audio_callback;\n\n        wanted_spec.userdata = is;\n\n        if (SDL_OpenAudio(&wanted_spec, &spec) < 0) {\n\n            fprintf(stderr, \"SDL_OpenAudio: %s\\n\", SDL_GetError());\n\n            ret = AVERROR_UNKNOWN;\n\n            goto fail;\n\n        }\n\n        is->audio_hw_buf_size = spec.size;\n\n        is->sdl_sample_fmt          = AV_SAMPLE_FMT_S16;\n\n        is->resample_sample_fmt     = is->sdl_sample_fmt;\n\n        is->resample_channel_layout = avctx->channel_layout;\n\n        is->resample_sample_rate    = avctx->sample_rate;\n\n    }\n\n\n\n    ic->streams[stream_index]->discard = AVDISCARD_DEFAULT;\n\n    switch (avctx->codec_type) {\n\n    case AVMEDIA_TYPE_AUDIO:\n\n        is->audio_stream = stream_index;\n\n        is->audio_st = ic->streams[stream_index];\n\n        is->audio_buf_size  = 0;\n\n        is->audio_buf_index = 0;\n\n\n\n        /* init averaging filter */\n\n        is->audio_diff_avg_coef  = exp(log(0.01) / AUDIO_DIFF_AVG_NB);\n\n        is->audio_diff_avg_count = 0;\n\n        /* since we do not have a precise anough audio fifo fullness,\n\n           we correct audio sync only if larger than this threshold */\n\n        is->audio_diff_threshold = 2.0 * SDL_AUDIO_BUFFER_SIZE / avctx->sample_rate;\n\n\n\n        memset(&is->audio_pkt, 0, sizeof(is->audio_pkt));\n\n        packet_queue_init(&is->audioq);\n\n        SDL_PauseAudio(0);\n\n        break;\n\n    case AVMEDIA_TYPE_VIDEO:\n\n        is->video_stream = stream_index;\n\n        is->video_st = ic->streams[stream_index];\n\n\n\n        packet_queue_init(&is->videoq);\n\n        is->video_tid = SDL_CreateThread(video_thread, is);\n\n        break;\n\n    case AVMEDIA_TYPE_SUBTITLE:\n\n        is->subtitle_stream = stream_index;\n\n        is->subtitle_st = ic->streams[stream_index];\n\n        packet_queue_init(&is->subtitleq);\n\n\n\n        is->subtitle_tid = SDL_CreateThread(subtitle_thread, is);\n\n        break;\n\n    default:\n\n        break;\n\n    }\n\n\n\nfail:\n\n    av_dict_free(&opts);\n\n\n\n    return ret;\n\n}\n", "idx": 6801, "substitutes": {"is": ["was", "as", "isf", "rs", "bis", "ris", "ar", "isa", "ics", "its", "lis", "ib", "i", "cs", "ik", "isin", "os", "ip", "ps", "ms", "has", "plays", "isl", "are", "isp", "ls", "ir", "s", "tis", "ims", "Is", "iss", "isc", "ist", "ish", "iris", "IS", "us", "isu", "ais", "isi", "sis", "ism", "IC"], "stream_index": ["record_status", "stream_max", "streamNameinc", "streamingindex", "stream_point", "channel_index", "stream_long", " stream2index", "stream_Index", "channel_ind", "srcingpos", "stream_inc", "stream_ind", "streamingpoint", "record_point", "srcingpoint", "stream_condition", "stream_status", "src_point", " stream_ind", "stream2Index", "streamnindex", " stream_number", "record_condition", "src_index", "streamnpos", "path_ind", "src_pos", " stream2ind", "streamNameind", "src_directory", "stream_directory", "streamndirectory", "record_index", "stream2index", " stream2number", "path_inc", "srcingdirectory", "streamNamelong", "path_long", "srcingindex", " stream2Index", "stream_number", "streamingdirectory", "streamNameindex", "stream2ind", "stream_pos", "path_index", " stream_Index", "channel_max", "streamnpoint", "streamingpos", "stream2number"], "ic": ["ico", "ci", "ct", "ican", "it", "ics", "ctx", "pc", "eric", "ICS", "bc", "i", "ik", "aic", "fc", "ip", "util", "ric", "ica", "ec", "wic", "mic", "ick", "aci", "lc", "cc", "sic", " nic", "icing", "icc", "nic", "ici", "oc", "ix", "ac", "vc", "pic", "icer", "onic", "isc", "iat", "mc", "ia", "iac", "iu", "irc", "lic", "icon", "IC", "tc"], "avctx": ["ajcrit", "wavcmp", " avcmp", "ajcf", "avtmp", "avcp", "vrctx", "vrctl", "ajctx", "avertmp", "avtc", "ravctx", "averkj", "avcontext", "aveconn", " avcpu", "avjac", "avecf", "avectl", "avfunc", "avecp", "avefunc", " avobj", "averctx", "averobj", "avercrit", "avcmd", "averpkg", "ajfunc", "ajkj", "verloc", "afctx", "vrcb", "ajkw", "vercmd", "avcrit", "avloc", "ajcontext", "avercf", "avconn", " avcp", "avecontext", "afconn", "ravloc", "avectx", "verctx", "avetc", "avecrit", "wavctx", "ajtry", "avcf", "avcb", "wavtmp", "avctl", "avertx", "avecmd", " avkw", " avconn", "ajcpu", "avpkg", "vrtx", "wavcb", "afkw", "vertx", "avtx", "afloc", "averloc", "avcpu", "avercp", "averconn", "abcontext", " avcontext", "aftx", "avercontext", "avtxt", "aveobj", " avtx", "ajobj", " avpkg", " avjac", "wavtx", "ajloc", "vrcontext", " avtmp", "ajconn", "abloc", "aveloc", "avercmp", "averjac", "afpkg", "vrcmp", "avecpu", " avtxt", "avertxt", "abctx", "avkj", "afcmp", "avecmp", "avercmd", "ajtx", "avetx", " avtc", "avobj", " avcmd", "avtry", "avetxt", "avecb", " avkj", "ajjac", "ravtry", "ajcmp", "abtx", "aftc", "wavctl", "avcmp", "ravfunc", "avepkg", "afcontext", "avetry", "avkw"], "codec": ["odoc", "cdeca", "codect", "opec", "cryptec", "cpdec", "cmpec", "cmpoc", "corect", "cryptdec", "codcc", "codeca", "cderer", "coddec", "cdect", "cddec", "Codrc", "cmpcc", " codect", "oddec", "cpec", "opeca", "codecc", "coret", " coddec", "chopeg", "oderer", "cdec", "codeac", "chodec", "odpeg", "codet", "choect", "opdec", "cpect", "odect", "odac", "codoc", "codac", "odec", "codeoc", "cdrc", "codrc", "Codec", "Coderer", "opect", "cryptect", " codet", "cdet", "cmpac", "coreca", "crypteca", "choec", "Coddec", "corec", "codeec", "cppeg", "coderer", "odcc", "codpeg", "odrc", " codeca"], "wanted_spec": ["wanted9spec", "wanted2spec", "wanted9format", "wanted2spe", "want_format", "want_spec", "wanted_format", "wanted2format", "want_spe", "wanted_spe", "wanted9spe"], "spec": ["form", "match", "instance", "Spec", "pc", "cmp", "pec", " specification", "ra", "cs", "tag", "pos", "id", "params", "sk", "meta", "status", "config", "stream", "xml", "comment", "rule", "ident", " specs", "comp", "spe", "format", "SPEC"], "opts": ["ropcs", "OPTS", "okins", "okcs", "opTS", "iopps", "optets", " opters", "optt", "OPpt", "opttions", "optts", "cops", "optters", "okps", "iopcs", "iopts", "opcs", " optps", "oppps", "opert", "OPps", "copt", " optcs", "ioptions", "OPcs", "ropts", "copts", "optTS", "oppTS", "opercs", "OPs", "options", " optpt", "opt", " opt", "OPt", "opertions", "copcs", "oppt", "optps", "opets", "OPins", "okt", "operTS", "oppts", " optts", "operets", "okTS", "opptions", "operters", "OPts", "okts", "iopTS", "opters", "optins", "opps", "roppt", " opets", "optcs", "ropps", "opins", "ops", "operts"], "t": ["tree", "et", "ct", "it", "c", "kt", " T", "i", "T", "pt", "nt", "ta", "at", "te", "dt", "p", "d", "ent", "tm", "n", "ts", "tr", "o", "temp", "r", "w", "to", "opt", "tip", "v", "txt", "ot", "token", "tu", "not", "rt", "lt", "m", "tmp", "f", "tap", "e", "td", "j", "a", "l", "tt", "tc"]}}
{"project": "qemu", "commit_id": "aec4b054ea36c53c8b887da99f20010133b84378", "target": 1, "func": "static void keyword_literal(void)\n\n{\n\n    QObject *obj;\n\n    QBool *qbool;\n\n    QObject *null;\n\n    QString *str;\n\n\n\n    obj = qobject_from_json(\"true\", NULL);\n\n    qbool = qobject_to_qbool(obj);\n\n    g_assert(qbool);\n\n    g_assert(qbool_get_bool(qbool) == true);\n\n\n\n    str = qobject_to_json(obj);\n\n    g_assert(strcmp(qstring_get_str(str), \"true\") == 0);\n\n    QDECREF(str);\n\n\n\n    QDECREF(qbool);\n\n\n\n    obj = qobject_from_json(\"false\", NULL);\n\n    qbool = qobject_to_qbool(obj);\n\n    g_assert(qbool);\n\n    g_assert(qbool_get_bool(qbool) == false);\n\n\n\n    str = qobject_to_json(obj);\n\n    g_assert(strcmp(qstring_get_str(str), \"false\") == 0);\n\n    QDECREF(str);\n\n\n\n    QDECREF(qbool);\n\n\n\n    qbool = qobject_to_qbool(qobject_from_jsonf(\"%i\", false));\n\n    g_assert(qbool);\n\n    g_assert(qbool_get_bool(qbool) == false);\n\n    QDECREF(qbool);\n\n\n\n    /* Test that non-zero values other than 1 get collapsed to true */\n\n    qbool = qobject_to_qbool(qobject_from_jsonf(\"%i\", 2));\n\n    g_assert(qbool);\n\n    g_assert(qbool_get_bool(qbool) == true);\n\n    QDECREF(qbool);\n\n\n\n    obj = qobject_from_json(\"null\", NULL);\n\n    g_assert(obj != NULL);\n\n    g_assert(qobject_type(obj) == QTYPE_QNULL);\n\n\n\n    null = qnull();\n\n    g_assert(null == obj);\n\n\n\n    qobject_decref(obj);\n\n    qobject_decref(null);\n\n}\n", "idx": 6816, "substitutes": {"obj": ["ck", "iv", "xy", "po", "rel", "utt", "buf", "self", "ob", "ht", "addr", "inst", "og", "ind", "alt", "js", "pos", "txt", "tmp", "cur", "j", "obs", "onet", "elt", "vr", "so", "buff", "nt", "os", "rect", "pl", "el", "expr", "out", "ot", "np", "imp", "json", "oss", "et", "bj", "it", "src", "ctx", "pt", "msg", "ent", "co", "vol", "no", "bo", "o", "pkg", "attr", "oj", "org", "rt", "st", "y", "net", "res", "Obj", "object", "act", "init", "sp", "br", "cmp", "cont", "none", "sys", "con", "cmd", "ie", "obo", "err", "ref", "py", "opt", "pr", "inner", "resp", "adj", "wo", "off", "ist", "unknown", "arr", "def"], "qbool": ["quarr", " qarr", "qulocked", "requlocked", "querybo", "eqcond", "sqool", "qubol", "qjl", "dqool", "qstrong", "requfol", "dqbr", "qudebug", " qbil", "golean", "querybool", "querlock", "questlock", "iqbool", "sqflag", "questool", "eqbool", "questbyte", "qqbil", "sqbo", "qbr", "qqcond", "querool", "qolean", "eqdebug", "questuint", "qarr", "qool", "qubit", "qflag", "equint", "questbo", "qqbo", "qufl", "qualbil", "questjl", " qolean", "eqbol", "qqool", "qqbits", "qcond", "eqbo", "querybis", "sqbis", "queryfl", "sqbool", "requbo", "qlock", "queryresult", "qfl", "queststrong", "dqbyte", "ck88", "sqbil", "eqresult", "qfol", "qqresult", "qubil", "ckbool", "ckbol", "q88", "eqolean", "querjl", "querydebug", "qu88", " qbo", "querybol", "gbool", "dqbo", "eqlock", "qufol", "quool", "qqbol", "iqbol", "qquint", "querbit", "qualuint", " qbr", "questdebug", "querbool", "dquint", "questbr", "qualstrong", "querarr", "iqbil", " qlock", "qlib", " qbol", "sqdebug", "qubo", "qbil", " qlib", "qubits", "qualbool", "dqbool", "qresult", "querycond", "dqstrong", "qbis", "quolean", "requbool", "quint", "queryolean", "qubool", "gbol", "quflag", "ckbits", "eqbis", "eqool", "queryuint", "iqlock", "qqolean", "ckbo", "questfl", "ckolean", "query88", "questfol", " qool", "querbo", "qbol", "dqbis", "qbits", "qualool", "dqlib", "qujl", "qdebug", "eqfl", "qualbyte", "questlib", " qfl", "qqbool", "questbool", "qbo", "qulock", "qbit", "gbo", " qbit", "qlocked", "iqflag", "qualbo", "eqflag", "iqool", "questlocked", " qflag", "qubis", "qbyte"], "null": ["this", "all", "qual", "result", "q", "gc", "buff", "root", "empty", "it", "node", "target", "c", "native", "ctx", "none", "rel", "sys", "nt", "ob", "valid", "ail", "g", "util", "rect", "n", "un", "full", "t", "alt", "temp", "available", "id", "list", "ref", "nil", "pr", "ull", "v", "Null", "not", "port", "new", "load", "comment", "nan", "parent", "local", "test", "ill", " Null", "json", "il", "object", "unt"], "str": ["db", "Str", "form", "sp", "prefix", "dat", "ns", "its", "br", "gr", "def", "rel", "sys", "pt", "buf", "cs", "nt", "buffer", "msg", "raw", "ext", "p", "ps", "vol", "ml", "mt", "ts", "wr", "url", "tr", "usr", "t", "temp", "r", "dr", "ref", "list", "coll", "pre", "pr", "s", "out", "txt", "sl", "inner", "spec", "st", "art", "doc", "print", "rec", "comp", "fr", "j", "enc", "arr", "text", "res", "STR"]}}
{"project": "qemu", "commit_id": "093209cd681fe9fb65bd8a1c2ff711b8168bbfcd", "target": 0, "func": "static void ppc_core99_init (ram_addr_t ram_size,\n\n                             const char *boot_device,\n\n                             const char *kernel_filename,\n\n                             const char *kernel_cmdline,\n\n                             const char *initrd_filename,\n\n                             const char *cpu_model)\n\n{\n\n    CPUState *env = NULL, *envs[MAX_CPUS];\n\n    char *filename;\n\n    qemu_irq *pic, **openpic_irqs;\n\n    int unin_memory;\n\n    int linux_boot, i;\n\n    ram_addr_t ram_offset, bios_offset, vga_bios_offset;\n\n    uint32_t kernel_base, kernel_size, initrd_base, initrd_size;\n\n    PCIBus *pci_bus;\n\n    MacIONVRAMState *nvr;\n\n    int nvram_mem_index;\n\n    int vga_bios_size, bios_size;\n\n    int pic_mem_index, dbdma_mem_index, cuda_mem_index, escc_mem_index;\n\n    int ide_mem_index[3];\n\n    int ppc_boot_device;\n\n    DriveInfo *hd[MAX_IDE_BUS * MAX_IDE_DEVS];\n\n    void *fw_cfg;\n\n    void *dbdma;\n\n    uint8_t *vga_bios_ptr;\n\n    int machine_arch;\n\n\n\n    linux_boot = (kernel_filename != NULL);\n\n\n\n    /* init CPUs */\n\n    if (cpu_model == NULL)\n\n#ifdef TARGET_PPC64\n\n        cpu_model = \"970fx\";\n\n#else\n\n        cpu_model = \"G4\";\n\n#endif\n\n    for (i = 0; i < smp_cpus; i++) {\n\n        env = cpu_init(cpu_model);\n\n        if (!env) {\n\n            fprintf(stderr, \"Unable to find PowerPC CPU definition\\n\");\n\n            exit(1);\n\n        }\n\n        /* Set time-base frequency to 100 Mhz */\n\n        cpu_ppc_tb_init(env, 100UL * 1000UL * 1000UL);\n\n#if 0\n\n        env->osi_call = vga_osi_call;\n\n#endif\n\n        qemu_register_reset((QEMUResetHandler*)&cpu_reset, env);\n\n        envs[i] = env;\n\n    }\n\n\n\n    /* allocate RAM */\n\n    ram_offset = qemu_ram_alloc(NULL, \"ppc_core99.ram\", ram_size);\n\n    cpu_register_physical_memory(0, ram_size, ram_offset);\n\n\n\n    /* allocate and load BIOS */\n\n    bios_offset = qemu_ram_alloc(NULL, \"ppc_core99.bios\", BIOS_SIZE);\n\n    if (bios_name == NULL)\n\n        bios_name = PROM_FILENAME;\n\n    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);\n\n    cpu_register_physical_memory(PROM_ADDR, BIOS_SIZE, bios_offset | IO_MEM_ROM);\n\n\n\n    /* Load OpenBIOS (ELF) */\n\n    if (filename) {\n\n        bios_size = load_elf(filename, NULL, NULL, NULL,\n\n                             NULL, NULL, 1, ELF_MACHINE, 0);\n\n\n\n        qemu_free(filename);\n\n    } else {\n\n        bios_size = -1;\n\n    }\n\n    if (bios_size < 0 || bios_size > BIOS_SIZE) {\n\n        hw_error(\"qemu: could not load PowerPC bios '%s'\\n\", bios_name);\n\n        exit(1);\n\n    }\n\n\n\n    /* allocate and load VGA BIOS */\n\n    vga_bios_offset = qemu_ram_alloc(NULL, \"ppc_core99.vbios\", VGA_BIOS_SIZE);\n\n    vga_bios_ptr = qemu_get_ram_ptr(vga_bios_offset);\n\n    filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, VGABIOS_FILENAME);\n\n    if (filename) {\n\n        vga_bios_size = load_image(filename, vga_bios_ptr + 8);\n\n        qemu_free(filename);\n\n    } else {\n\n        vga_bios_size = -1;\n\n    }\n\n    if (vga_bios_size < 0) {\n\n        /* if no bios is present, we can still work */\n\n        fprintf(stderr, \"qemu: warning: could not load VGA bios '%s'\\n\",\n\n                VGABIOS_FILENAME);\n\n        vga_bios_size = 0;\n\n    } else {\n\n        /* set a specific header (XXX: find real Apple format for NDRV\n\n           drivers) */\n\n        vga_bios_ptr[0] = 'N';\n\n        vga_bios_ptr[1] = 'D';\n\n        vga_bios_ptr[2] = 'R';\n\n        vga_bios_ptr[3] = 'V';\n\n        cpu_to_be32w((uint32_t *)(vga_bios_ptr + 4), vga_bios_size);\n\n        vga_bios_size += 8;\n\n\n\n        /* Round to page boundary */\n\n        vga_bios_size = (vga_bios_size + TARGET_PAGE_SIZE - 1) &\n\n            TARGET_PAGE_MASK;\n\n    }\n\n\n\n    if (linux_boot) {\n\n        uint64_t lowaddr = 0;\n\n        int bswap_needed;\n\n\n\n#ifdef BSWAP_NEEDED\n\n        bswap_needed = 1;\n\n#else\n\n        bswap_needed = 0;\n\n#endif\n\n        kernel_base = KERNEL_LOAD_ADDR;\n\n\n\n        kernel_size = load_elf(kernel_filename, translate_kernel_address, NULL,\n\n                               NULL, &lowaddr, NULL, 1, ELF_MACHINE, 0);\n\n        if (kernel_size < 0)\n\n            kernel_size = load_aout(kernel_filename, kernel_base,\n\n                                    ram_size - kernel_base, bswap_needed,\n\n                                    TARGET_PAGE_SIZE);\n\n        if (kernel_size < 0)\n\n            kernel_size = load_image_targphys(kernel_filename,\n\n                                              kernel_base,\n\n                                              ram_size - kernel_base);\n\n        if (kernel_size < 0) {\n\n            hw_error(\"qemu: could not load kernel '%s'\\n\", kernel_filename);\n\n            exit(1);\n\n        }\n\n        /* load initrd */\n\n        if (initrd_filename) {\n\n            initrd_base = INITRD_LOAD_ADDR;\n\n            initrd_size = load_image_targphys(initrd_filename, initrd_base,\n\n                                              ram_size - initrd_base);\n\n            if (initrd_size < 0) {\n\n                hw_error(\"qemu: could not load initial ram disk '%s'\\n\",\n\n                         initrd_filename);\n\n                exit(1);\n\n            }\n\n        } else {\n\n            initrd_base = 0;\n\n            initrd_size = 0;\n\n        }\n\n        ppc_boot_device = 'm';\n\n    } else {\n\n        kernel_base = 0;\n\n        kernel_size = 0;\n\n        initrd_base = 0;\n\n        initrd_size = 0;\n\n        ppc_boot_device = '\\0';\n\n        /* We consider that NewWorld PowerMac never have any floppy drive\n\n         * For now, OHW cannot boot from the network.\n\n         */\n\n        for (i = 0; boot_device[i] != '\\0'; i++) {\n\n            if (boot_device[i] >= 'c' && boot_device[i] <= 'f') {\n\n                ppc_boot_device = boot_device[i];\n\n                break;\n\n            }\n\n        }\n\n        if (ppc_boot_device == '\\0') {\n\n            fprintf(stderr, \"No valid boot device for Mac99 machine\\n\");\n\n            exit(1);\n\n        }\n\n    }\n\n\n\n    isa_mem_base = 0x80000000;\n\n\n\n    /* Register 8 MB of ISA IO space */\n\n    isa_mmio_init(0xf2000000, 0x00800000, 1);\n\n\n\n    /* UniN init */\n\n    unin_memory = cpu_register_io_memory(unin_read, unin_write, NULL);\n\n    cpu_register_physical_memory(0xf8000000, 0x00001000, unin_memory);\n\n\n\n    openpic_irqs = qemu_mallocz(smp_cpus * sizeof(qemu_irq *));\n\n    openpic_irqs[0] =\n\n        qemu_mallocz(smp_cpus * sizeof(qemu_irq) * OPENPIC_OUTPUT_NB);\n\n    for (i = 0; i < smp_cpus; i++) {\n\n        /* Mac99 IRQ connection between OpenPIC outputs pins\n\n         * and PowerPC input pins\n\n         */\n\n        switch (PPC_INPUT(env)) {\n\n        case PPC_FLAGS_INPUT_6xx:\n\n            openpic_irqs[i] = openpic_irqs[0] + (i * OPENPIC_OUTPUT_NB);\n\n            openpic_irqs[i][OPENPIC_OUTPUT_INT] =\n\n                ((qemu_irq *)env->irq_inputs)[PPC6xx_INPUT_INT];\n\n            openpic_irqs[i][OPENPIC_OUTPUT_CINT] =\n\n                ((qemu_irq *)env->irq_inputs)[PPC6xx_INPUT_INT];\n\n            openpic_irqs[i][OPENPIC_OUTPUT_MCK] =\n\n                ((qemu_irq *)env->irq_inputs)[PPC6xx_INPUT_MCP];\n\n            /* Not connected ? */\n\n            openpic_irqs[i][OPENPIC_OUTPUT_DEBUG] = NULL;\n\n            /* Check this */\n\n            openpic_irqs[i][OPENPIC_OUTPUT_RESET] =\n\n                ((qemu_irq *)env->irq_inputs)[PPC6xx_INPUT_HRESET];\n\n            break;\n\n#if defined(TARGET_PPC64)\n\n        case PPC_FLAGS_INPUT_970:\n\n            openpic_irqs[i] = openpic_irqs[0] + (i * OPENPIC_OUTPUT_NB);\n\n            openpic_irqs[i][OPENPIC_OUTPUT_INT] =\n\n                ((qemu_irq *)env->irq_inputs)[PPC970_INPUT_INT];\n\n            openpic_irqs[i][OPENPIC_OUTPUT_CINT] =\n\n                ((qemu_irq *)env->irq_inputs)[PPC970_INPUT_INT];\n\n            openpic_irqs[i][OPENPIC_OUTPUT_MCK] =\n\n                ((qemu_irq *)env->irq_inputs)[PPC970_INPUT_MCP];\n\n            /* Not connected ? */\n\n            openpic_irqs[i][OPENPIC_OUTPUT_DEBUG] = NULL;\n\n            /* Check this */\n\n            openpic_irqs[i][OPENPIC_OUTPUT_RESET] =\n\n                ((qemu_irq *)env->irq_inputs)[PPC970_INPUT_HRESET];\n\n            break;\n\n#endif /* defined(TARGET_PPC64) */\n\n        default:\n\n            hw_error(\"Bus model not supported on mac99 machine\\n\");\n\n            exit(1);\n\n        }\n\n    }\n\n    pic = openpic_init(NULL, &pic_mem_index, smp_cpus, openpic_irqs, NULL);\n\n    if (PPC_INPUT(env) == PPC_FLAGS_INPUT_970) {\n\n        /* 970 gets a U3 bus */\n\n        pci_bus = pci_pmac_u3_init(pic);\n\n        machine_arch = ARCH_MAC99_U3;\n\n    } else {\n\n        pci_bus = pci_pmac_init(pic);\n\n        machine_arch = ARCH_MAC99;\n\n    }\n\n    /* init basic PC hardware */\n\n    pci_vga_init(pci_bus, vga_bios_offset, vga_bios_size);\n\n\n\n    escc_mem_index = escc_init(0x80013000, pic[0x25], pic[0x24],\n\n                               serial_hds[0], serial_hds[1], ESCC_CLOCK, 4);\n\n\n\n    for(i = 0; i < nb_nics; i++)\n\n        pci_nic_init_nofail(&nd_table[i], \"ne2k_pci\", NULL);\n\n\n\n    if (drive_get_max_bus(IF_IDE) >= MAX_IDE_BUS) {\n\n        fprintf(stderr, \"qemu: too many IDE bus\\n\");\n\n        exit(1);\n\n    }\n\n    dbdma = DBDMA_init(&dbdma_mem_index);\n\n\n\n    /* We only emulate 2 out of 3 IDE controllers for now */\n\n    ide_mem_index[0] = -1;\n\n    hd[0] = drive_get(IF_IDE, 0, 0);\n\n    hd[1] = drive_get(IF_IDE, 0, 1);\n\n    ide_mem_index[1] = pmac_ide_init(hd, pic[0x0d], dbdma, 0x16, pic[0x02]);\n\n    hd[0] = drive_get(IF_IDE, 1, 0);\n\n    hd[1] = drive_get(IF_IDE, 1, 1);\n\n    ide_mem_index[2] = pmac_ide_init(hd, pic[0x0e], dbdma, 0x1a, pic[0x02]);\n\n\n\n    /* cuda also initialize ADB */\n\n    if (machine_arch == ARCH_MAC99_U3) {\n\n        usb_enabled = 1;\n\n    }\n\n    cuda_init(&cuda_mem_index, pic[0x19]);\n\n\n\n    adb_kbd_init(&adb_bus);\n\n    adb_mouse_init(&adb_bus);\n\n\n\n    macio_init(pci_bus, PCI_DEVICE_ID_APPLE_UNI_N_KEYL, 0, pic_mem_index,\n\n               dbdma_mem_index, cuda_mem_index, NULL, 3, ide_mem_index,\n\n               escc_mem_index);\n\n\n\n    if (usb_enabled) {\n\n        usb_ohci_init_pci(pci_bus, -1);\n\n    }\n\n\n\n    /* U3 needs to use USB for input because Linux doesn't support via-cuda\n\n       on PPC64 */\n\n    if (machine_arch == ARCH_MAC99_U3) {\n\n        usbdevice_create(\"keyboard\");\n\n        usbdevice_create(\"mouse\");\n\n    }\n\n\n\n    if (graphic_depth != 15 && graphic_depth != 32 && graphic_depth != 8)\n\n        graphic_depth = 15;\n\n\n\n    /* The NewWorld NVRAM is not located in the MacIO device */\n\n    nvr = macio_nvram_init(&nvram_mem_index, 0x2000, 1);\n\n    pmac_format_nvram_partition(nvr, 0x2000);\n\n    macio_nvram_map(nvr, 0xFFF04000);\n\n    /* No PCI init: the BIOS will do it */\n\n\n\n    fw_cfg = fw_cfg_init(0, 0, CFG_ADDR, CFG_ADDR + 2);\n\n    fw_cfg_add_i32(fw_cfg, FW_CFG_ID, 1);\n\n    fw_cfg_add_i64(fw_cfg, FW_CFG_RAM_SIZE, (uint64_t)ram_size);\n\n    fw_cfg_add_i16(fw_cfg, FW_CFG_MACHINE_ID, machine_arch);\n\n    fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_ADDR, kernel_base);\n\n    fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_SIZE, kernel_size);\n\n    if (kernel_cmdline) {\n\n        fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_CMDLINE, CMDLINE_ADDR);\n\n        pstrcpy_targphys(\"cmdline\", CMDLINE_ADDR, TARGET_PAGE_SIZE, kernel_cmdline);\n\n    } else {\n\n        fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_CMDLINE, 0);\n\n    }\n\n    fw_cfg_add_i32(fw_cfg, FW_CFG_INITRD_ADDR, initrd_base);\n\n    fw_cfg_add_i32(fw_cfg, FW_CFG_INITRD_SIZE, initrd_size);\n\n    fw_cfg_add_i16(fw_cfg, FW_CFG_BOOT_DEVICE, ppc_boot_device);\n\n\n\n    fw_cfg_add_i16(fw_cfg, FW_CFG_PPC_WIDTH, graphic_width);\n\n    fw_cfg_add_i16(fw_cfg, FW_CFG_PPC_HEIGHT, graphic_height);\n\n    fw_cfg_add_i16(fw_cfg, FW_CFG_PPC_DEPTH, graphic_depth);\n\n\n\n    fw_cfg_add_i32(fw_cfg, FW_CFG_PPC_IS_KVM, kvm_enabled());\n\n    if (kvm_enabled()) {\n\n#ifdef CONFIG_KVM\n\n        uint8_t *hypercall;\n\n\n\n        fw_cfg_add_i32(fw_cfg, FW_CFG_PPC_TBFREQ, kvmppc_get_tbfreq());\n\n        hypercall = qemu_malloc(16);\n\n        kvmppc_get_hypercall(env, hypercall, 16);\n\n        fw_cfg_add_bytes(fw_cfg, FW_CFG_PPC_KVM_HC, hypercall, 16);\n\n        fw_cfg_add_i32(fw_cfg, FW_CFG_PPC_KVM_PID, getpid());\n\n#endif\n\n    } else {\n\n        fw_cfg_add_i32(fw_cfg, FW_CFG_PPC_TBFREQ, get_ticks_per_sec());\n\n    }\n\n\n\n    qemu_register_boot_set(fw_cfg_boot_set, fw_cfg);\n\n}\n", "idx": 6829, "substitutes": {"ram_size": ["ram_scale", "ram_length", "RAM_area", "rom_size", "RAM_offset", "ramaxysize", "ram0offset", "rom_device", "RAM_size", "rom_number", "ram_area", " ram_dim", "ram0number", "ramaxynumber", "ramaxyoffset", "ram_number", "ram_dim", "RAM_scale", "ram0device", " ram_length", "rom_offset", "ramaxydevice", "ram_device", "ram0size"], "boot_device": ["bootingdev", "start_dev", "boot_dev", "bootingdrive", "start_drive", "boot_drive", "bootingdevice", "boot_address", "bootingaddress", "start_address", "start_device"], "kernel_filename": ["kernel_uri", "kernel_target", "disk_target", "disk_file", "kernel_file", "cpu_uri", "kernelpyfile", "disk_location", "kernel_location", "cpu_fn", "kernelpytarget", "kernel_fn", "cpu_filename", "kernelpyfilename", "kernelpylocation", "disk_filename", "cpu_file"], "kernel_cmdline": ["kernel_hostname", "kernel_commandname", "kernel_initline", "kernel_initbase", "kernel_commandline", "kernel_initname", "kernel_cmdname", "kernel_hostbase", "kernel_hostline", "kernel_commandbase", "kernel_cmdbase"], "initrd_filename": ["initrd_fn", "initrb_filename", "initrd_Filename", "initrd_file", "initrb_Filename", "initrb_file", "initrb_fn"], "cpu_model": ["cpu_function", " cpu_Model", "crypt_function", "cpu_Model", "CPU_domain", "CPU_model", "cpu_rule", "cpu_link", "cpuistlink", "CPU_Model", "cpu_domain", "CPU_models", "cpuetymodels", "cpuistModel", "cpuetyinterface", "core_version", "CPU_mode", "CPU_interface", "crypt_rule", "cpu_version", " cpu_link", "cpuistmodel", "cpu_models", "core_Model", "cpuThemodel", "cpuTheModel", "cpuistmod", "cpuTheversion", "cpuetyModel", "cpu_interface", "core_model", "cpuThemode", "cpu_mod", "cpu_mode", "core_mode", " cpu_mod", "cpuetymodel", "crypt_model"], "env": ["policy", "uv", "event", "ei", "esc", "po", "ped", "h", "Ev", "buf", "eg", "ec", "dev", "cb", "environment", "t", "gear", "en", "ah", "txt", "worker", "entry", "enc", "vv", "mem", "stage", "ve", "er", "context", "eh", "server", "esp", "code", "v", "vs", "pres", "shell", "iev", "db", "ev", "et", "end", "ctx", "eni", "era", "ent", "var", "viron", "bar", "sv", "nv", "fi", "vm", "engine", "door", "init", "window", "eas", "buffer", "te", "erd", "vp", "ew", "ds", "eng", "err", "proc", "ef", "eu", "ea", "spec", "ptr", "handler", "ee", "manager", "vt", "obj", "qt", "e", "conn", "def"], "envs": ["enports", "ENVs", "Enps", "Enports", " enVs", "ENv", "revs", "ENvs", "enVs", "rev", " enports", "Envs", "EnVs", "reports", " enps", "ENps", "enps", "reVs", "Env"], "MAX_CPUS": ["MAX_CAPUS", "MAX_CPus", "MAX_CAPINS", "MAX_CPUus", "MAX_CPUs", "MAX_CPUINS", "MAX_CPINS", "MAX_CPUUs", "MAX_CPUUS", "MAX_CAPUs", "MAX_CAPus"], "filename": ["lua", "uri", "src", "metadata", "framework", "file", "files", "til", "location", "tty", "settings", "fp", "username", "river", "fil", "txt", "bite", "processor", "fn", "Filename", "driver", "disk", "fs", "fi", "family", "rir", "directory"], "pic": ["ic", "sp", "ican", "ics", "pc", "pen", "eric", "cam", "fc", "pins", "p", "ps", "pa", "pol", "picture", "mic", "pi", "peg", "pipe", "proc", "nic", "ac", "ig", "jp", "pac", "mc", "fi", "pin", "mp"], "openpic_irqs": ["openpic__ircs", "openpic__ics", "openpic__iqs", "openpic_rques", "openpic_irq", "openpic_iques", "openpic__irq", "openpic__irqs", "openpic_prqs", "openpic_rqs", "openpic_ics", "openpic__iq", "openpic_prques", "openpic_ircs", "openpic__iques", "openpic_rcs", "openpic_prq", "openpic_prcs", "openpic_iq", "openpic__irques", "openpic_irques", "openpic_rq", "openpic_iqs"], "unin_memory": ["current67memory", "current_size", "cpu67capacity", "cpu_memory", "cpu_mem", "cpu_capacity", "cpu_size", "current67size", "current_capacity", "cpu67memory", "current67capacity", "current67mem", "cpu67size", "current_memory", "current_mem", "cpu67mem"], "linux_boot": ["linux2boot", "cpu_bit", "cpu_start", "linux_start", "linux_base", "linux_bit", "linux2offset", "cpu_offset", "cpu_Boot", "cpu_loop", "cpu_boot", "cpu_base", "linux2bit", "linux_offset", "linux2base", "linux_Boot", "linux_loop"], "i": ["ini", "ij", "ei", "b", "ci", "it", "im", "c", "gi", "mi", "qi", "ip", "li", "p", "si", "g", "ami", "zi", "n", "tim", "xi", "ind", "index", "t", "hi", "pi", "multi", "bi", "me", "id", "ui", "k", "phi", "ti", "s", "v", "ims", "ix", "ai", "m", "a", "I", "batch", "y", "f", "sim", "gu", "iu", "e", "in", "j", "z", "x", "di", "ii", "l"], "ram_offset": ["ram_pos", "ram67offset", "gram_location", "mem_pos", "mem_off", "ramistoffset", "gram_offset", "ram2start", "mem_base", "ram67loc", "ramistseek", "ro_offset", "gram_start", "mem_offset", "ram67seek", "ram_location", "ram2off", "ram2position", "ramistsize", "ram2offset", "ro_loc", "ro_size", "ram_off", "ram2base", "ram2pos", "ram2location", "ram_loc", "ro_seek", "ram67size", "ram_position", "ram_base", "ram_start", "ram_seek", "gram_position", "ramistloc"], "bios_offset": ["bio_slot", "bios__address", "bio_block", "bio_address", "bios___offset", "bio_offset", "bios_block", "bios2base", "bios__block", "bios__offset", "bios2slot", "bios___slot", "bios2offset", "bios_address", "bios2address", "bios___block", "bios_slot", "bio_base", "bios___base", "bios___address", "bios_base"], "vga_bios_offset": ["vga_bio_offset", "vga_bio_set", "vga_bios_address", "vga_bio_address", "vga_bios_set", "vga_bio_size"], "kernel_base": ["kernel2base", "cpu_address", "cpu_size", "kernel_address", "kernel2address", "kernel2buffer", "cpu_base", "kernel_buffer", "cpu_buffer", "kernel2size"], "kernel_size": ["kernel_number", " kernel_number", "kernel_name", " kernel_name"], "initrd_base": ["initrdtsize", "initrd_offset", "initrdtoffset", "initrt_base", "initrt_file", "initrd_file", "initrt_offset", "initrdtfile", "initrdtbase", "initrt_size"], "initrd_size": ["initrb_Size", "initrb_size", "initrb_capacity", "initrd_capacity", "initrd_Size"], "pci_bus": ["pci__bus", "pci___BUS", "pci__BUS", "pci__boot", "pci_bs", "pki_boot", "pki_bs", "pci_boot", "pci___bs", "pci___boot", "pci__bs", "pci___bus", "pki_bus", "pki_BUS", "pci_BUS"], "nvr": ["nnVR", "nnvae", " nvp", "dvp", "dvr", "nnvp", "nnvr", " nVR", "dvae", "nVR", "dVR", "nvp", "nvae", " nvae"], "nvram_mem_index": ["nvram_memory_address", "nvram_memory_index", "nvram_mem_type", "nvram_mem2type", "nvram_mem2index", "nvram_mem2address", "nvram_memory_size", "nvram_memory_type", "nvram_mem2size", "nvram_mem_size", "nvram_mem_address"], "vga_bios_size": ["vga_biosetindex", "vga_bio_index", "vga_biosetspace", "vga_bios_space", "vga_bios_index", "vga_biosetsize", "vga_bio_space", "vga_biosetname", "vga_bio_name", "vga_bios_name", "vga_bio_size"], "bios_size": ["bios1size", "bios1SIZE", "bias_storage", "bios_SIZE", "bias_size", "bios1storage", "bias_SIZE", "bios_storage"], "pic_mem_index": ["pic_dimipaddress", "pic_memipindex", "pic_dim_address", "pic_mem_pos", "pic_dimippos", "pic_dim_column", "pic_memitypos", "pic_memityindex", "pic_memipaddress", "pic_dim_index", "pic_memipcolumn", "pic_memityaddress", "pic_dimipcolumn", "pic_mem_address", "pic_dimipindex", "pic_memitycolumn", "pic_mem_column", "pic_dim_pos", "pic_memippos"], "dbdma_mem_index": ["dbdma_memory_Index", "dbdma_memory_address", "dbdma_memory_num", "dbdma_mem_num", "dbdma_memory_index", "dbdma_mem_address", "dbdma_mem_Index"], "cuda_mem_index": ["cuda_memory_Index", "cuda_mem_device", "cuda_memory_device", "cuda_mem_address", "cuda_mem_Index", "cuda_memory_address", "cuda_memory_index"], "escc_mem_index": ["escc_memtnum", "escc_memory_index", "escc_memtoffset", "escc_memory_offset", "escc_memtindex", "escc_mem_address", "escc_memtaddress", "escc_mem_offset", "escc_mem_num", "escc_memory_num", "escc_memory_address"], "ide_mem_index": ["ide_memxinfo", "ide_memxindex", "ide_mem_address", "ide_mem_info", "ide_mem_cycle", "ide_memory_address", "ide_memxcycle", "ide_memory_info", "ide_memxaddress", "ide_memory_index", "ide_memory_cycle"], "ppc_boot_device": ["ppc_boot2address", "ppc_cpu_address", "ppc_boot2dev", "ppc_booteddev", "ppc_cpu_model", "ppc_bootedmodel", "ppc_boot_model", "ppc_cpu_dev", "ppc_boot_dev", "ppc_boot_address", "ppc_cpu_device", "ppc_bootedaddress", "ppc_boot2model", "ppc_booteddevice", "ppc_boot2device"], "hd": ["hyd", "md", "h", "dri", "ht", "dt", "dl", "bd", "sd", "gd", "ds", "hi", "HD", "dh", "dr", "him", "rh", "vd", "dd", "hs", "he", "hid", "pd", "had", "ha", "kb", "ld", "haw", "hp"], "MAX_IDE_BUS": ["MAX_IDE2BUS", "MAX_ID_FS", "MAX_IDE_BU", "MAX_IDE2BU", "MAX_ID_BUS", "MAX_ID_BU", "MAX_IDELEBU", "MAX_IDE_US", "MAX_IDELEFS", "MAX_IDE2US", "MAX_IDE2FS", "MAX_IDELEUS", "MAX_IDE_FS", "MAX_ID_US", "MAX_IDELEBUS"], "MAX_IDE_DEVS": ["MAX_IDE_INVS", "MAX_IDE_DFS", "MAX_IDE_DPS", "MAX_IDE_DVICE", "MAX_IDE_INVICE", "MAX_IDE_DEVICE", "MAX_IDE_INPS", "MAX_IDE_DESPS", "MAX_IDE_DESVS", "MAX_IDE_INFS", "MAX_IDE_DEPS", "MAX_IDE_DEFS", "MAX_IDE_DVS", "MAX_IDE_DESVICE", "MAX_IDE_DESFS"], "fw_cfg": ["hw_init", "fw_init", "hw_config", "hw2fg", "fw_config", "fw_fg", "fw2init", "hw_fg", "fw2cfg", "fw2config", "hw2init", "fw2fg", "hw2cfg", "hw2config", "hw_cfg"], "dbdma": ["dbdms", "dbdmas", "dbgme", "bdtms", "bdtma", "dbtms", "dbgma", "bdtmas", "dbgmas", "bdtme", "dbtmas", "dbsdme", "bddms", "dbsdms", "dbsdma", "dbgms", "dbsdmas", "dbtme", "bddma", "dbdme", "bddmas", "bddme", "dbtma"], "vga_bios_ptr": ["vga_bios_handle", "vga_bio_addr", "vga_biosacptr", "vga_bios__addr", "vga_bios_pointer", "vga_bios__pointer", "vga_biosacaddr", "vga_bio_ptr", "vga_biosachandle", "vga_bio_pointer", "vga_biosacpointer", "vga_bios_addr", "vga_bios__handle", "vga_bios__ptr", "vga_bio_handle"], "machine_arch": ["cpu_core", "machineableplatform", "machineablearch", "machine_archs", "machine_core", "cpu_platform", "cpu_arch", "machineablearchs", "machine_platform", "machineablecore", "cpu_archs"]}}
{"project": "qemu", "commit_id": "492c30af2567a59413c064f88eb81e1691865195", "target": 0, "func": "void DMA_run(void)\n\n{\n\n    /* XXXXX */\n\n}\n", "idx": 6838, "substitutes": {}}
{"project": "qemu", "commit_id": "f090c9d4ad5812fb92843d6470a1111c15190c4c", "target": 0, "func": "INLINE int16 extractFloat64Exp( float64 a )\n\n{\n\n\n\n    return ( a>>52 ) & 0x7FF;\n\n\n\n}\n", "idx": 6844, "substitutes": {"a": ["as", "b", "att", "c", "h", "ma", "aaa", "ta", "aa", "g", "A", "p", "d", "n", "ava", "ata", "ae", "na", "aux", "o", "r", "va", "go", "au", "acc", "m", "sa", "ac", "la", "ca", "area", "am", "aka", "ia", "j", "sta", "ua", "ao", "l", "da", "ba"]}}
{"project": "qemu", "commit_id": "185698715dfb18c82ad2a5dbc169908602d43e81", "target": 0, "func": "uint32_t helper_fcmp_un(uint32_t a, uint32_t b)\n\n{\n\n    CPU_FloatU fa, fb;\n\n    uint32_t r = 0;\n\n\n\n    fa.l = a;\n\n    fb.l = b;\n\n\n\n    if (float32_is_signaling_nan(fa.f) || float32_is_signaling_nan(fb.f)) {\n\n        update_fpu_flags(float_flag_invalid);\n\n        r = 1;\n\n    }\n\n\n\n    if (float32_is_nan(fa.f) || float32_is_nan(fb.f)) {\n\n        r = 1;\n\n    }\n\n\n\n    return r;\n\n}\n", "idx": 6852, "substitutes": {"a": ["as", "apa", "ar", "af", "c", "u", "ama", "ma", "i", "aaa", "ta", "at", "aa", "p", "A", "n", "ya", "ae", "t", "eca", "va", "anta", "r", "an", "s", "ea", "m", "sa", "ac", "la", "al", "ca", "area", "am", "f", "ia", "e", "ara", "x", "oa", "ao", "l", "da", "ba"], "b": ["bis", "ab", "eb", "pb", "c", "u", "ib", "bc", "i", "ob", "p", "base", "g", "d", "bp", "body", "n", "cb", "wb", "t", "bi", "w", "bb", "ub", "bar", "bf", "v", "be", "m", "B", "nb", "xb", "bs", "y", "f", "z", "l", "ba"], "fa": ["cf", "raf", "apa", "oa", "af", "wa", " va", "fe", "ma", "ra", " ca", "eas", " ta", "alpha", "ta", "fc", "aa", " df", "afa", "ifa", " al", "pa", "fat", "ava", " ff", "lu", "ae", "na", " af", "va", "fal", "bf", "ea", "sa", "ac", "al", "fn", "Fa", "ca", " FA", "f", "ia", "fi", "fo", "FA", "ga", "ua", "ao", "fd", "da", "ba"], "fb": ["deb", "db", "afi", "raf", "uf", "alf", "fen", "buff", "xf", "ff", "obb", "bj", "eb", "pb", "bg", "abl", "fe", "fx", "FB", "ob", "fc", "bp", "gb", "cb", "wb", "fp", "erb", "uff", "bb", "ub", "rf", "rb", "bf", "fab", "bs", "zb", "abb", "nb", "tf", "f", "fi", "facebook", "hd", "bm", "fg", "fd", "fw"]}}
{"project": "qemu", "commit_id": "b931bfbf042983f311b3b09894d8030b2755a638", "target": 0, "func": "static int vhost_user_start(VhostUserState *s)\n\n{\n\n    VhostNetOptions options;\n\n\n\n    if (vhost_user_running(s)) {\n\n        return 0;\n\n    }\n\n\n\n    options.backend_type = VHOST_BACKEND_TYPE_USER;\n\n    options.net_backend = &s->nc;\n\n    options.opaque = s->chr;\n\n\n\n    s->vhost_net = vhost_net_init(&options);\n\n\n\n    return vhost_user_running(s) ? 0 : -1;\n\n}\n", "idx": 6867, "substitutes": {"s": ["rs", "gs", "ses", "b", "less", "ns", "conf", "c", "its", "eps", "ats", "ies", "h", "i", "qs", "set", "sys", "comm", "cs", "os", "ps", "p", "g", "details", "n", "is", "ts", "ds", "es", "t", "se", "r", "js", "w", "ins", "params", "ls", "sb", "ess", "v", "ties", "stats", "ims", "m", "spec", "a", "hs", "ss", "bs", "south", "y", "sq", "obj", "S", "sts", "changes", "z", "sports", "aws", "source"], "options": ["policy", "names", "results", "weights", "times", "ption", "cp", "eps", "ables", "abilities", "values", "ats", "scope", "terms", "os", "actions", "caps", "p", "als", "ms", "details", "etc", "ports", "settings", "ts", "lets", "option", "op", "o", "Options", "ptions", "vals", "closure", "to", "allows", "opt", "ls", "services", "properties", "stats", "keys", "tags", "outs", "args", "checks", "IONS", "config", "bits", "tions", "parts", "obj", "io", "some", "flags", "e", "ssh", "params", "ions", "tools", "ops", "sequence"]}}
{"project": "FFmpeg", "commit_id": "7a206eb32f624171a35235f714d44ee9dec9abcb", "target": 0, "func": "static int alac_set_info(ALACContext *alac)\n\n{\n\n    GetByteContext gb;\n\n\n\n    bytestream2_init(&gb, alac->avctx->extradata,\n\n                     alac->avctx->extradata_size);\n\n\n\n    bytestream2_skipu(&gb, 12); // size:4, alac:4, version:4\n\n\n\n    alac->max_samples_per_frame = bytestream2_get_be32u(&gb);\n\n    if (alac->max_samples_per_frame >= UINT_MAX/4){\n\n        av_log(alac->avctx, AV_LOG_ERROR,\n\n               \"max_samples_per_frame too large\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    bytestream2_skipu(&gb, 1);  // compatible version\n\n    alac->sample_size          = bytestream2_get_byteu(&gb);\n\n    alac->rice_history_mult    = bytestream2_get_byteu(&gb);\n\n    alac->rice_initial_history = bytestream2_get_byteu(&gb);\n\n    alac->rice_limit           = bytestream2_get_byteu(&gb);\n\n    alac->channels             = bytestream2_get_byteu(&gb);\n\n    bytestream2_get_be16u(&gb); // maxRun\n\n    bytestream2_get_be32u(&gb); // max coded frame size\n\n    bytestream2_get_be32u(&gb); // average bitrate\n\n    bytestream2_get_be32u(&gb); // samplerate\n\n\n\n    return 0;\n\n}\n", "idx": 6879, "substitutes": {"alac": ["placc", "aliacl", " alAC", "malacer", "alc", "aliace", "almac", "talAc", "ellacc", "altoc", "alam", "alsac", "altade", "alace", "ayAC", "malade", "alAc", "altval", "ralacl", "calac", "malam", "talac", "elacc", "talade", "ralsac", "ralac", "caloc", "plac", "balac", "malmac", "balain", "calace", "ellac", "balacc", "malace", "aliiac", " alam", " alc", "ayact", "plc", "talacer", "eljac", " alacc", "alacl", "ellacs", " alAc", "relacl", "aliacc", "aracc", "aliAC", "maljac", "aliacs", "alact", "balacl", " alacl", " alic", " alsac", "alacs", "aliAc", " almac", "malac", "calAC", "balsac", "alAC", "alain", "calacs", "calic", "malAc", "altain", "relacc", "arac", "aloc", "calval", "baloc", "relace", "avAc", "altac", "calain", "relac", "aviac", "elljac", "avjack", "alic", "ralacs", "placl", "alade", "alacc", "relmac", " aliac", "arace", "balval", "alacer", "calact", "malacc", "ayac", "alval", " alact", " alace", "alijack", "aracl", "aljack", " aljack", "malAC", "aliac", "aljac", "malacs", "balace", "balacs", "altacer", "relam", "elac", "altAc", "elacs", " alacs", "ayic", "avac"], "gb": ["gc", "xy", " rgb", "eg", "RGB", "hub", "cb", " rg", "pg", "sb", "bridge", "gin", "maybe", "io", "GB", "DB", "gt", "csv", "gm", "eb", "managed", "g", "lib", "server", "rb", "nb", "priv", " pg", "db", "yg", "gs", "gp", "git", "bg", "gov", " GB", "msg", "tg", "sv", "attr", "uge", "dd", "mb", "cfg", "rg", "cv", "gem", "vm", "ga", "kb", "gg", "deg", "gif", "b", "grow", "buffer", "wm", "ge", "gd", "data", " db", "bb", "py", " eg", "bf", "args", "Gb", "img", "storage", "sky", "gu", "gpu"]}}
{"project": "qemu", "commit_id": "8be487d8f184f2f721cabeac559fb7a6cba18c95", "target": 1, "func": "static void sdhci_send_command(SDHCIState *s)\n\n{\n\n    SDRequest request;\n\n    uint8_t response[16];\n\n    int rlen;\n\n\n\n    s->errintsts = 0;\n\n    s->acmd12errsts = 0;\n\n    request.cmd = s->cmdreg >> 8;\n\n    request.arg = s->argument;\n\n    DPRINT_L1(\"sending CMD%u ARG[0x%08x]\\n\", request.cmd, request.arg);\n\n    rlen = sdbus_do_command(&s->sdbus, &request, response);\n\n\n\n    if (s->cmdreg & SDHC_CMD_RESPONSE) {\n\n        if (rlen == 4) {\n\n            s->rspreg[0] = (response[0] << 24) | (response[1] << 16) |\n\n                           (response[2] << 8)  |  response[3];\n\n            s->rspreg[1] = s->rspreg[2] = s->rspreg[3] = 0;\n\n            DPRINT_L1(\"Response: RSPREG[31..0]=0x%08x\\n\", s->rspreg[0]);\n\n        } else if (rlen == 16) {\n\n            s->rspreg[0] = (response[11] << 24) | (response[12] << 16) |\n\n                           (response[13] << 8) |  response[14];\n\n            s->rspreg[1] = (response[7] << 24) | (response[8] << 16) |\n\n                           (response[9] << 8)  |  response[10];\n\n            s->rspreg[2] = (response[3] << 24) | (response[4] << 16) |\n\n                           (response[5] << 8)  |  response[6];\n\n            s->rspreg[3] = (response[0] << 16) | (response[1] << 8) |\n\n                            response[2];\n\n            DPRINT_L1(\"Response received:\\n RSPREG[127..96]=0x%08x, RSPREG[95..\"\n\n                  \"64]=0x%08x,\\n RSPREG[63..32]=0x%08x, RSPREG[31..0]=0x%08x\\n\",\n\n                  s->rspreg[3], s->rspreg[2], s->rspreg[1], s->rspreg[0]);\n\n        } else {\n\n            ERRPRINT(\"Timeout waiting for command response\\n\");\n\n            if (s->errintstsen & SDHC_EISEN_CMDTIMEOUT) {\n\n                s->errintsts |= SDHC_EIS_CMDTIMEOUT;\n\n                s->norintsts |= SDHC_NIS_ERR;\n\n            }\n\n        }\n\n\n\n        if ((s->norintstsen & SDHC_NISEN_TRSCMP) &&\n\n            (s->cmdreg & SDHC_CMD_RESPONSE) == SDHC_CMD_RSP_WITH_BUSY) {\n\n            s->norintsts |= SDHC_NIS_TRSCMP;\n\n        }\n\n    }\n\n\n\n    if (s->norintstsen & SDHC_NISEN_CMDCMP) {\n\n        s->norintsts |= SDHC_NIS_CMDCMP;\n\n    }\n\n\n\n    sdhci_update_irq(s);\n\n\n\n    if (s->blksize && (s->cmdreg & SDHC_CMD_DATA_PRESENT)) {\n\n        s->data_count = 0;\n\n        sdhci_data_transfer(s);\n\n    }\n\n}\n", "idx": 6891, "substitutes": {"s": ["sw", "less", "conf", "h", "ers", "ads", "ps", "ts", "settings", "se", "t", "utils", "js", "gets", "events", "sb", "services", "xs", "ss", "south", "changes", "sports", "as", "bes", "rs", "ses", "ants", "store", "https", "os", "g", "ms", "tests", "es", "v", "stats", "m", "vs", "sis", "aws", "l", "ops", "gs", "bis", "ssl", "ns", "ats", "ies", "cs", "p", "is", "sv", "hs", "bs", "y", "sq", "fs", "S", "b", "its", "i", "set", "qs", "sys", "als", "details", "n", "ds", "ins", "ls", "ims", "views", "states", "ys", "sts"], "request": ["package", "open", "q", "setup", "call", "task", "cp", "est", "set", "store", " query", "client", "execute", "cmd", "order", "document", "pair", "first", " requesting", "import", "delete", "position", "query", "question", "record", "word", "initial", "application", "forward", "begin", "change", "complete", "req", "reset", "transform", "requ", "select", "command", "re", "project", "worker", "item", "hello", "report", "art", "message", "quest", "Request", "search", "QUEST", "test", "trip", "create", "reference", "transfer"], "response": ["present", "example", "bytes", "tree", "des", "empty", "sol", "more", "site", "model", "description", "network", "se", "value", "query", "pos", "attribute", "application", "memory", "reset", "phrase", "entry", "message", "output", "success", "next", "results", "values", "sequence", "vector", "ve", "er", "zero", "process", "es", "server", "position", "question", "out", "v", "frame", "respons", "report", "version", "collection", "json", "relation", "view", "given", "template", "connection", "no", "o", "line", "total", "route", "onse", "array", "answer", "hash", "res", "object", "all", "result", "window", "ping", "reply", "then", "get", "Response", "yes", "document", "data", "range", "list", "status", "resp", "block", "new", " Response", "cache", "sample", "search", "e", "point", "image", "python"], "rlen": ["mLen", "Relt", "rsl", "tLen", "Rlength", "rrli", "erLen", "rfin", "nrlic", "relt", "RLen", " rlength", "Rfin", "Rtl", "tfin", "rrlen", "rlin", "nrli", "nrlen", " rtl", "rLen", "rrsl", "relen", " rsl", " rlin", " rlic", "rtl", "rlength", "reLen", "erlength", "erlin", "mlen", " rfin", "rrlic", "reelt", "erlen", "mlength", "tlen", " rli", "rli", "retl", "tlength", "nrsl", " rLen", "rlic", " relt", "Rlen", "mlin"]}}
{"project": "qemu", "commit_id": "ddf21908961073199f3d186204da4810f2ea150b", "target": 0, "func": "static void test_dealloc_types(void)\n\n{\n\n    UserDefOne *ud1test, *ud1a, *ud1b;\n\n    UserDefOneList *ud1list;\n\n\n\n    ud1test = g_malloc0(sizeof(UserDefOne));\n\n    ud1test->base = g_new0(UserDefZero, 1);\n\n    ud1test->base->integer = 42;\n\n    ud1test->string = g_strdup(\"hi there 42\");\n\n\n\n    qapi_free_UserDefOne(ud1test);\n\n\n\n    ud1a = g_malloc0(sizeof(UserDefOne));\n\n    ud1a->base = g_new0(UserDefZero, 1);\n\n    ud1a->base->integer = 43;\n\n    ud1a->string = g_strdup(\"hi there 43\");\n\n\n\n    ud1b = g_malloc0(sizeof(UserDefOne));\n\n    ud1b->base = g_new0(UserDefZero, 1);\n\n    ud1b->base->integer = 44;\n\n    ud1b->string = g_strdup(\"hi there 44\");\n\n\n\n    ud1list = g_malloc0(sizeof(UserDefOneList));\n\n    ud1list->value = ud1a;\n\n    ud1list->next = g_malloc0(sizeof(UserDefOneList));\n\n    ud1list->next->value = ud1b;\n\n\n\n    qapi_free_UserDefOneList(ud1list);\n\n}\n", "idx": 6919, "substitutes": {"ud1test": ["ud01test", "ud1show", "aud1py", "aud1train", "udrictesting", "uidOncever", "ud01txt", "disk001show", "disk001txt", "udonetests", "udOncetxt", "ub1style", "ub51train", "uid1train", "ud51test", "ud1tests", "ud7txt", "disk1show", "ud1style", "ud1ver", "ud101train", "ub101test", "ud4train", "mud1test", "aud71test", "uid1ver", "ud001txt", "ub1key", "udOncetrain", "udOnetest", "ub101tests", "ud1key", "aud71train", "ud4test", "ud71test", "aud1test", "ud5train", "ub51test", "udOncever", "mud1tests", "disk1test", "disk001testing", "ud91true", "ud7py", "ud91test", "ud101tests", "ud1true", "ud4style", "ud5ver", "ud01testing", "disk1testing", "ub1tests", "ud21tests", "mud91tested", "mud1tested", "disk1txt", "uidOncetxt", "ud21tested", "aud1txt", "udricshow", "ud1py", "disk001test", "aud71txt", "ud91tests", "ud51style", "ud7train", "ud01show", "uidOncetest", "ub1test", "ud51key", "ud101style", "mud91true", "udonetested", "ud5txt", "aud71py", "ud5test", "mud91test", "ub101testing", "udonetrue", "ud101key", "ud1testing", "mud91tests", "uidOncetrain", "ud71train", "uid1txt", "ud1txt", "udontesting", "ud7testing", "ub1train", "ud91tested", "udOnetxt", "ub51key", "udontest", "udOnetrain", "ud7test", "mud1true", "ub51style", "ud71txt", "udrictest", "udonetest", "ub1testing", "ud4key", "ud101testing", "ud7tests", "udOncetest", "uid1test", "ud001test", "udOnever", "ud1train", "ud7style", "udrictxt", "ub101style", "ud101test", "ud1tested", "ud21test", "udOnepy", "ud71py", "ud001testing", "udonstyle", "udontests", "ud21true", "ud51train", "ud001show"], "ud1a": ["ud100a", "ud1an", "ub61aa", "udOnceagent", "urd1part", "urd18a", "ud13l", "ud81an", "ud10aa", "udappagent", "ud100area", "ud127a", "udOnceelement", "udappad", "urd1ia", "ud5a", "ud12a", "ud18part", "ud1element", "urd18ia", "ud01area", "ud11ar", "ud10agent", "ud127ar", "ud61a", "ud5ab", "grad01ad", "ud1ca", "ud1r", "ud12ia", "ud1ia", "ud9ai", "ub81n", "ud61ai", "ud01a", "ub81a", "ub61agent", "ud81a", "ub1area", "ud1ar", "ud18ca", "ud9agent", "udOner", "ub1aa", "grad1a", "udOnep", "ub1n", "ub81area", "ud1ab", "udOnel", "ud127attribute", "ud18ia", "ud13r", "ud1agent", "ud12ca", "ud81area", "ud1p", "ud01agent", "ud9aa", "ud61aa", "ud1ai", "ud10a", "ud01n", "ud17r", "ud13a", "ub1ai", "udOncead", "ud5attribute", "ud1part", "ud81n", "hd17r", "uu127ar", "udOneca", "grad1agent", "uu127attribute", "urd1a", "hd17p", "hd1p", "ud01element", "grad1ad", "ud12part", "hd1l", "ud100an", "udOnepart", "ud1aa", "ud1attribute", "hd1a", "hd17l", "grad1element", "grad01element", "grad01agent", "ud5ar", "ub1agent", "ud127ab", "ud17p", "uu127ab", "ub1an", "ud9a", "urd1ca", "ud17a", "udOncea", "udOnea", "ud11a", "ub61a", "ub61ai", "hd1r", "ud61agent", "ud01ad", "ud11attribute", "ud11ab", "ud100n", "ud01an", "ud18a", "ud17l", "uu1a", "ud1area", "uu1ab", "ud1ad", "urd18part", "ud10ai", "ub81an", "urd18ca", "uu1attribute", "ud13p", "udappelement", "grad01a", "ud1n", "hd17a", "udOneia", "uu1ar", "ud1l", "ub1a", "uu127a", "udappa"], "ud1b": ["ud1bin", "audOneb", "gd1bot", "udonebin", "aud1j", "dd2b", "ud1rb", "vd01reb", "ud01br", "udachebr", "ud51b", "ud2l", "dd1b", "ud11reb", "ud1reb", "ud110reb", "ud1r", "ud120cb", "ud1br", "ud2b", "udpreb", "ud3b", "udoner", "ud2a", "ud3l", "ud120reb", "udOned", "audOnej", "udonej", "ud11j", "aud1d", "ud110eb", "aud01eb", "udprebot", "ud81obj", "udi001br", "ud81a", "ud11r", "udonecb", "audOned", "udOner", "ud1bot", "ud01j", "gd1beta", "udi1b", "ud01eb", "gd51b", "ud01bin", "ud12beta", "gd51ba", "udachej", "gd1ba", "ud001b", "ud11eb", "ud12b", "vd1bin", "ud1beta", "ud01browser", "ud51bot", "udOnej", "ud001j", "udOneb", "ud120b", "dd1l", "ud3a", "ud110rb", "aud01b", "ud1d", "dd1obj", "dd2a", "ud81b", "ud110b", "ud01b", "aud1eb", "aud01rb", "vd1cb", "udachebrowser", "udi001j", "aud1reb", "gd1b", "ud51ba", "ud11rb", "ud1eb", "ud1browser", "dd2obj", "vd1reb", "udpreba", "ud12ba", "udi1j", "vd01bin", "ud3obj", "udoneb", "aud01reb", "dd2l", "ud001br", "ud1cb", "vd1b", "ud81l", "ud1ba", "udoned", "udacheb", "udi1browser", "udi001b", "aud1b", "ud01cb", "ud01reb", "ud12bot", "audOner", "ud001browser", "ud11b", "ud51beta", "vd01cb", "gd51bot", "ud1obj", "udi001browser", "ud1j", "vd01b", "ud120bin", "aud1r", "aud1rb", "ud01rb", "ud11d", "udprebeta", "gd51beta", "udi1br", "udonereb", "ud1l", "ud2obj", "dd1a"], "ud1list": ["udOnecollection", "ud51list", "ud591log", "ud6collection", "ub1List", "udOnceentry", "udtxno", "udd1list", "rod1LIST", "ud2l", "udOnelevel", "ud5LIST", "udOneall", "audOnenot", "udd1level", "ud1all", "aud591log", "aud1log", "ud11test", "ud6level", "ud11err", "xdOneline", "ud3list", "audOnelist", "rod11list", "ud10test", "ud3l", "ud11no", "ud7list", "ud591collection", "ub7l", "ud2List", "ud1LIST", "ud11detail", "ud1batch", "udOneerr", "ud11level", "ud3List", "rod1list", "ud591level", "udOnceline", "ud51log", "xdOneentry", "udOncelog", "ud11LIST", "ud11not", "aud1err", "xd1line", "udOnelist", "udOncelist", "ub7test", "udOnenot", "ud3test", "udOneline", "ud2list", "udOneentry", "ud1entry", "ub7list", "ud12list", "ud11all", "ud6batch", "ud7List", "ud5detail", "udtxlevel", "ub7List", "ud6no", "xdOnelist", "ub1test", "aud1all", "udtxbatch", "rod11test", "rod1detail", "aud1level", "ud1err", "ud12err", "ud5test", "ud1line", "rod1test", "ub1l", "ud2test", "ub1list", "rod11detail", "ud7l", "aud591level", "udOnelog", "ud6log", "ud1detail", "ud7test", "ud10LIST", "ud591list", "aud591list", "xd1entry", "ud6list", "ud11batch", "ud1not", "rod11LIST", "ud12all", "ud10list", "udtxlist", "ud1log", "ud1collection", "uddtxlevel", "ud51entry", "xdOnelog", "aud1list", "ud51line", "udd1no", "ud5list", "uddtxbatch", "ud10detail", "audOneall", "aud591collection", "udd1batch", "xd1log", "ud1List", "uddtxlist", "audOneerr", "uddtxno", "ud1level", "ud1no", "ud1l", "xd1list", "aud1collection", "ud12not", "ud11list", "aud1not"]}}
{"project": "qemu", "commit_id": "362786f14a753d8a5256ef97d7c10ed576d6572b", "target": 0, "func": "void net_checksum_calculate(uint8_t *data, int length)\n\n{\n\n    int hlen, plen, proto, csum_offset;\n\n    uint16_t csum;\n\n\n\n    if ((data[14] & 0xf0) != 0x40)\n\n\treturn; /* not IPv4 */\n\n    hlen  = (data[14] & 0x0f) * 4;\n\n    plen  = (data[16] << 8 | data[17]) - hlen;\n\n    proto = data[23];\n\n\n\n    switch (proto) {\n\n    case PROTO_TCP:\n\n\tcsum_offset = 16;\n\n\tbreak;\n\n    case PROTO_UDP:\n\n\tcsum_offset = 6;\n\n\tbreak;\n\n    default:\n\n\treturn;\n\n    }\n\n\n\n    if (plen < csum_offset+2)\n\n\treturn;\n\n\n\n    data[14+hlen+csum_offset]   = 0;\n\n    data[14+hlen+csum_offset+1] = 0;\n\n    csum = net_checksum_tcpudp(plen, proto, data+14+12, data+14+hlen);\n\n    data[14+hlen+csum_offset]   = csum >> 8;\n\n    data[14+hlen+csum_offset+1] = csum & 0xff;\n\n}\n", "idx": 6927, "substitutes": {"data": ["bytes", "chain", "empty", "dat", "att", "c", "ma", "rel", "buf", "self", "valid", "d", "add", "digital", "dev", "t", "trace", "device", "num", "batch", "current", "message", "size", "x", "da", "bin", "this", "output", "read", "next", "results", "um", "values", "join", "pad", "zero", "index", "button", "Data", "str", "board", "out", "code", "v", "video", "bits", "m", "done", "date", "version", "text", "a", "content", "update", "at", "extra", "p", "no", "len", "ata", "o", "total", "history", "r", "debug", "final", "DATA", "hash", "bus", "name", "all", "form", "result", "padding", "window", "buffer", "raw", "table", "n", "row", "input", "number", "list", "ad", "component", "block", "off", "tx", "cache", "public", "format", "def", "image", "sequence"], "length": ["end", "type", "h", "d", "p", "len", "Length", "code", "en", "v", "ength", "block", "size", "e", "l"], "hlen": ["historylen", "highlen", "hfil", " hlength", " hli", " hla", "ihden", " hcoll", "Hlen", "hwlen", "explu", "ihlength", "ten", "bhlib", "tLen", "italign", "hlf", "vlen", "plength", "hlu", "bhlen", "pen", "phlength", " hmil", "ihla", " hlib", "hwla", "ven", "khlen", " hden", "phlen", "tlen", "hwLen", "zLen", "rhLen", "rhcoll", "itfil", "vlength", "ihen", "hwlength", "vden", "hcoll", "hLen", "historyalign", "explen", "ihlen", "historymil", "vLen", "zlength", "explf", "hden", "zla", "highfil", "highmil", "bhli", "highalign", "zlen", "itmil", "rhlen", "HLen", "phen", "itlen", "highLen", "hli", "ihlib", "phden", "highlf", "hlib", "highcoll", "Hlength", "hmil", "bhla", "pLen", "khLen", "rhmil", "khden", "historyfil", " hLen", "historylu", "ihli", "hlength", "highlu", "expfil", "hla", "Hen", "halign", "historylf", "tlength", "hen"], "plen": [" Plang", " Pllen", " Plens", "PLlen", " plang", "plien", "plength", "PLear", " plens", "pollen", "polen", "persength", "iplien", " pllen", "palatten", "lpien", "Plang", "plear", "pelength", "pelen", " plun", "plens", "palenum", "plade", "Plade", "persear", "pllen", "plenum", "lpatten", "Plen", "pelear", "pellen", " Plen", "plun", "persen", "lpen", "platten", "polade", "Plun", "Plens", "lpenum", "perslen", "Pllen", "polun", " plade", "plang", "iplenum", "iplen", "iplatten", "palien", "palen", "PLen", "PLength"], "proto": ["prtype", "PROto", "ProTO", "proo", "po", "procpo", "Progo", "Protop", "prTO", "pro", "procgo", "roto", "Proocol", "rotop", "proocol", "proTO", "Proto", "Protype", "probe", "prbe", "protype", "prgo", "roco", "ropo", "Proco", "PROtype", "pocol", "prto", "protop", "pto", "Propo", "prco", "procto", "PROtop", "prtop", "procol", "propo", "prpo", "PROTO", "progo", "Probe", "Proo", "proctype", "pbe", "proco"], "csum_offset": ["csumpterror", "csum_padding", "csum_field", "csum_off", "csum___offset", "csum_position", "cssum_Offset", "cssum_style", "csum_size", "csum___style", "cssum_pointer", "csum_style", "csum_optional", "csum___Offset", "csul_Offset", "csumptoffset", "csul_position", "cssum_index", "csum_Offset", "cssum_offset", "csum_error", "csum_type", "cssum_padding", "cssum_size", "cssum_error", "cssum_slot", "csul_size", "csul_offset", "csumpttype", "csum_pointer", "csum_index", "csum___slot", "cssum_off", "cssum_type", "csum_slot", "csumptfield", "cssum_field"], "csum": ["checksul", "checksunc", "ckssum", "cussum", "cusum", " cssum", "csump", "csumer", "checkssum", "cssul", "csunc", "csul", "cksunc", "cksam", "checksam", "cksumer", "cksum", "rsump", "rsul", "checksump", "checksum", "cosul", "cssum", " csam", "cosumer", "rssum", "checksumer", "rsum", "csssum", "csam", "cosum", "cossum", "cusump", "cusul", "cssunc", " csul", "cksul"]}}
{"project": "qemu", "commit_id": "f17fd4fdf0df3d2f3444399d04c38d22b9a3e1b7", "target": 0, "func": "static void x86_cpu_parse_featurestr(const char *typename, char *features,\n\n                                     Error **errp)\n\n{\n\n    char *featurestr; /* Single 'key=value\" string being parsed */\n\n    static bool cpu_globals_initialized;\n\n    bool ambiguous = false;\n\n\n\n    if (cpu_globals_initialized) {\n\n        return;\n\n    }\n\n    cpu_globals_initialized = true;\n\n\n\n    if (!features) {\n\n        return;\n\n    }\n\n\n\n    for (featurestr = strtok(features, \",\");\n\n         featurestr;\n\n         featurestr = strtok(NULL, \",\")) {\n\n        const char *name;\n\n        const char *val = NULL;\n\n        char *eq = NULL;\n\n        char num[32];\n\n        GlobalProperty *prop;\n\n\n\n        /* Compatibility syntax: */\n\n        if (featurestr[0] == '+') {\n\n            plus_features = g_list_append(plus_features,\n\n                                          g_strdup(featurestr + 1));\n\n            continue;\n\n        } else if (featurestr[0] == '-') {\n\n            minus_features = g_list_append(minus_features,\n\n                                           g_strdup(featurestr + 1));\n\n            continue;\n\n        }\n\n\n\n        eq = strchr(featurestr, '=');\n\n        if (eq) {\n\n            *eq++ = 0;\n\n            val = eq;\n\n        } else {\n\n            val = \"on\";\n\n        }\n\n\n\n        feat2prop(featurestr);\n\n        name = featurestr;\n\n\n\n        if (g_list_find_custom(plus_features, name, compare_string)) {\n\n            error_report(\"warning: Ambiguous CPU model string. \"\n\n                         \"Don't mix both \\\"+%s\\\" and \\\"%s=%s\\\"\",\n\n                         name, name, val);\n\n            ambiguous = true;\n\n        }\n\n        if (g_list_find_custom(minus_features, name, compare_string)) {\n\n            error_report(\"warning: Ambiguous CPU model string. \"\n\n                         \"Don't mix both \\\"-%s\\\" and \\\"%s=%s\\\"\",\n\n                         name, name, val);\n\n            ambiguous = true;\n\n        }\n\n\n\n        /* Special case: */\n\n        if (!strcmp(name, \"tsc-freq\")) {\n\n            int64_t tsc_freq;\n\n\n\n            tsc_freq = qemu_strtosz_metric(val, NULL);\n\n            if (tsc_freq < 0) {\n\n                error_setg(errp, \"bad numerical value %s\", val);\n\n                return;\n\n            }\n\n            snprintf(num, sizeof(num), \"%\" PRId64, tsc_freq);\n\n            val = num;\n\n            name = \"tsc-frequency\";\n\n        }\n\n\n\n        prop = g_new0(typeof(*prop), 1);\n\n        prop->driver = typename;\n\n        prop->property = g_strdup(name);\n\n        prop->value = g_strdup(val);\n\n        prop->errp = &error_fatal;\n\n        qdev_prop_register_global(prop);\n\n    }\n\n\n\n    if (ambiguous) {\n\n        error_report(\"warning: Compatibility of ambiguous CPU model \"\n\n                     \"strings won't be kept on future QEMU versions\");\n\n    }\n\n}\n", "idx": 6935, "substitutes": {"typename": ["typtonamer", "typedow", "typpenow", "typedename", "TYpename", "TYlenames", "typpename", "typtonow", "tytonamer", "typenAME", "typtoname", "tyrenames", "tyrenename", "tylenename", "typedame", "typenename", "tytonename", "tyternamer", "tyrenAME", "TYlenAME", "tyrename", "tyternename", "TYpenename", "typerame", "TYlenename", "typerAME", "tyternow", "tylename", "tytonow", "typenames", "tylenames", "typerename", "tytername", "tylenAME", "typedamer", "typenamer", "typtonename", "TYpenAME", "typpenamer", "typerames", "typpenename", "TYpenames", "typenow", "TYlename", "tytoname"], "features": ["fields", "feat", "classes", "results", "weights", "fts", "ns", "items", "strings", "its", "values", "Features", "ints", "cs", "terms", "acts", "actions", "frames", "tests", "details", "words", "products", "ports", "rows", "eatures", "vals", "errors", "types", "mas", "events", "xs", "facts", "properties", "stats", "keys", "args", "feature", "bits", "fn", "reports", "parts", "fs", "flags", "names", "faces"], "errp": ["errpp", "diepat", "rarpat", "errpc", "ererp", " errm", "diepp", "errr", "rarp", "diep", "ererpe", "ererr", "diepc", " errpe", "errpe", "rarpp", "Erpe", "Erp", "warnpat", "warnpp", "errpat", "warnpc", " errr", "Err", "warnp", "errm", "Erm", "ererm", "rarpc"], "featurestr": ["coreStr", "featurecur", "featuresstr", "featuresSTR", "featdel", "expressionstring", "sequencearr", "jsonstr", "feat0", "sequencest", " featureSTR", "spanstr", "personcoll", "expressionstr", "teststring", "framearr", "familystr", "featureobj", "corestr", "jsonname", "spanstring", "featuresStr", " featureobj", " featurename", "featvol", "featcoll", "jsonStr", "expressionStr", "featcur", "personchain", "sequencevol", "query0", "featurestring", "featarr", "featureline", "testStr", "expressioncur", "featurebr", "featline", "featurechain", "Featurename", "sequencestr", "featurename", " feature0", "feature0", "resultstring", "testSTR", " featureline", "featurest", "familyStr", "querystr", " featurestring", "featurecoll", "Featurestr", "featurearr", "framevol", "familySTR", "remoteSTR", "teststr", "familydel", "coreobj", "featurevol", "featobj", "fingerchain", "Featurestring", "fingerarr", "featSTR", "featstr", "featureStr", " featureStr", " featurebr", "spanbr", "querystring", "remotestr", "personarr", "featst", "jsonSTR", "remoteStr", "featstring", "framestr", "featuresstring", "featureSTR", "featuredel", "framest", "featchain", "queryname", "featStr", "fingercoll", "fingerstr", "featname", "Featurearr", "remotedel", "featbr", "personstr", "resultstr", "corestring", " featurearr", "spanStr", "resultline", " featurecur", "resultStr"], "cpu_globals_initialized": ["cpu_globALS_loaded", "cpu_globALS_created", "cpu_globalls_init", "cpu_globalls_initialized", "cpu_globalsNotstarted", "cpu_globalsNotloaded", "cpu_globals_created", "cpu_globals_init", "cpu_globalls_loaded", "cpu_globalsNotinit", "cpu_globals_Initialized", "cpu_globalsNotinitialized", "cpu_globals__initialized", "cpu_globals__init", "cpu_globALS_init", "cpu_globALS_initialized", "cpu_globalls_started", "cpu_globals_started", "cpu_globALS_Initialized", "cpu_globals_loaded", "cpu_globals__loaded"], "name": ["tree", "event", "ma", "scope", "self", "order", "key", "value", "word", "pos", "comment", "nan", "parent", "mod", "test", "size", "in", "ne", "names", "loc", "path", "qual", "par", "root", "mem", "base", "ame", "missing", "old", "str", "an", "start", "code", "normal", "dim", "NAME", "part", "item", "local", "min", "info", "prefix", "type", "no", "len", "var", "label", "o", "attr", "common", "create", "ver", "Name", "admin", "call", "term", "none", "true", "nam", "raw", "ext", "cmd", "n", "group", "data", "range", "col", "id", "new", "spec", "doc", "alias", "ni", "title", "def"], "val": ["mem", "it", "type", "ctx", "def", "values", "rel", "Val", "buf", "valid", "elt", "msg", "seq", "util", "addr", "vol", "stat", "pol", "typ", "len", "var", "lib", "dev", "label", "index", "data", "vals", "range", "key", "sel", "value", "err", "col", "el", "ref", "pos", "unit", "str", "expr", "attr", "pr", "v", "dim", "req", "ret", "tx", "item", "eval", "Value", "fail", "vt", "test", "VAL", "res", "x", "ver", "cho", "loc", "vec"], "eq": ["init", "qual", "error", "match", "xy", "et", "quant", "eff", "eps", "ctx", "cmp", "ox", "offset", "rel", "fx", "rx", "alpha", "valid", "ip", "extra", "seq", "p", "ele", "cmd", "equal", "ie", "ext", "len", "zero", "aux", "pair", "iq", "ep", "sel", "err", "el", "id", "ref", "expr", "ue", "different", "ef", "req", "fun", "qq", "rt", "omp", "equ", "eval", "cond", "desc", "sq", "ident", "diff", "np", "test", "alias", "xp", "ex", "comp", "imp", "echo", "ne", "inc", "elt"], "num": ["Num", "gc", "um", "node", "mem", "ns", "def", "nr", "none", " numeric", "con", "nt", "mon", "valid", "msg", " NUM", "n", "no", "zero", "row", "index", "na", "label", "t", "multi", "nu", "number", "temp", "value", "id", "unit", "attr", "nm", "Number", "max", "dim", "NUM", "cal", "new", "fn", "nb", "local", "desc", "np", "count", "test", "sum", "param", "x", "gpu", "flag"], "prop": ["ph", "pid", "par", "feat", "cp", "po", "term", "dep", "rep", "pro", "pt", "pri", "p", "ps", "cmd", "stat", "plot", "pred", "op", "property", " Prop", "func", "key", "col", "err", "pos", "proc", "pkg", "attr", "expr", "pr", "cfg", "priv", "jp", "rop", "mod", "desc", "obj", "test", "fo", "pub", "decl", "comp", "def", "Prop"], "tsc_freq": ["tsc_feck", "tsc_feq", "tsc_reQ", "tsc_freck", "tsc_nuck", "tsc_nuz", "tsc2frez", "tsc_Freqi", "tsc_Freck", "tsc_treQ", "tsc_nuqs", "tsc_trez", "tsc_fej", "tsc_Freqs", "tsc2FreQ", "tsc2freqi", "tsc_treq", "tsc_feQ", "tsc_Frez", "tsc_freqs", "tsc_treqi", "tsc2freq", "tsc_fez", "tsc2freQ", "tsc_FreQ", "tsc_feqs", "tsc_freQ", "tsc_req", "tsc_reqs", "tsc_Freq", "tsc_nuq", "tsc_Frej", "tsc2Freq", "tsc2Frez", "tsc_freqi", "tsc2Freqi", "tsc_reck", "tsc_frej", "tsc_frez"]}}
{"project": "qemu", "commit_id": "361dcc790db8c87b2e46ab610739191ced894c44", "target": 1, "func": "static VirtIOSCSIVring *virtio_scsi_vring_init(VirtIOSCSI *s,\n\n                                               VirtQueue *vq,\n\n                                               EventNotifierHandler *handler,\n\n                                               int n)\n\n{\n\n    BusState *qbus = BUS(qdev_get_parent_bus(DEVICE(s)));\n\n    VirtioBusClass *k = VIRTIO_BUS_GET_CLASS(qbus);\n\n    VirtIOSCSIVring *r = g_slice_new(VirtIOSCSIVring);\n\n    int rc;\n\n\n\n    /* Set up virtqueue notify */\n\n    rc = k->set_host_notifier(qbus->parent, n, true);\n\n    if (rc != 0) {\n\n        fprintf(stderr, \"virtio-scsi: Failed to set host notifier (%d)\\n\",\n\n                rc);\n\n        exit(1);\n\n    }\n\n    r->host_notifier = *virtio_queue_get_host_notifier(vq);\n\n    r->guest_notifier = *virtio_queue_get_guest_notifier(vq);\n\n    aio_set_event_notifier(s->ctx, &r->host_notifier, handler);\n\n\n\n    r->parent = s;\n\n\n\n    if (!vring_setup(&r->vring, VIRTIO_DEVICE(s), n)) {\n\n        fprintf(stderr, \"virtio-scsi: VRing setup failed\\n\");\n\n        exit(1);\n\n    }\n\n    return r;\n\n}\n", "idx": 6946, "substitutes": {"s": ["rs", "service", "gs", "ses", "q", "b", "sp", "less", "src", "ns", "sr", "c", "its", "h", "i", "qs", "sys", "cs", "self", "os", "p", "ps", "g", "is", "ts", "ds", "o", "t", "es", "js", "w", "sv", "ls", "services", "sb", "v", "hs", "ss", "bs", "sq", "socket", "fs", "S", "sts", "j", "a"], "vq": ["nvpkg", "vcq", "vv", "vw", "vcv", "sw", "nvv", "pqu", " vue", "pQ", "pq", " vpkg", "vpkg", " vqu", " vw", "vrq", "vqu", "vcpkg", "vue", "piq", "sue", "vQ", "nvw", " vpe", "vcw", " vv", "vrue", "sq", "nvqu", "viq", "spe", "vrpe", "nviq", "vpe", " vQ", "vrw", "nvQ", "nvq", " viq"], "handler": ["policy", "folder", "hand", "error", "function", "event", "type", "job", "h", "band", "kh", "management", "er", "base", "behavior", "cb", "parser", "callback", "func", "server", "wrapper", "older", "hander", "handle", "handled", "command", "worker", "han", "reader", "fn", "lambda", "anger", "Handler", "manager", "message", "test", "holder"], "n": [" ns", "b", "nw", "node", "ns", "c", "h", "nr", "i", "nt", "nn", "nat", "g", "d", "p", "no", "nc", "tn", "na", "o", "t", "nu", "N", "number", "w", "nm", "cn", "num", "v", "m", "fn", " ng", "dn", "nb", "sn", "y", "count", "np", "l", "net", "j", "nl", "name", " l"], "qbus": [" squs", " qmu", "quBUS", "Qboot", "qudev", "qubus", "qboot", "qumu", "qqstate", "qqdev", " sqBUS", "qqboot", "qqbus", " sqbus", "dqbus", "qmu", "dqboot", "qBus", "Qus", "qstate", " qus", "qdev", " qdev", " qBus", "QBus", " sqmu", " qboot", "dqBus", "dqus", "Qbus", " qstate", "qBUS", " qBUS", "qus", "qustate", "quboot", "quus"], "k": ["ck", "uk", "km", "kr", "kh", "kt", "kk", "ka", "kind", "K", "ik", "ek", "ijk", "mk", "g", "ker", "ak", "ke", "kan", "kl", "kar", "wk", "key", "ikk", "ki", "kw", "kn", "sk", "kit", "kick", "aka", "sch", "ks", "kj", "j", "tk", "KR"], "r": ["rs", "vr", "result", "q", "b", "ar", "lr", "sr", "c", "kr", "u", "br", "gr", "nr", "rel", "i", "mr", "rn", "er", "p", "g", "d", "or", "tr", "usr", "rw", "err", "w", "dr", "rr", "attr", "rh", "pr", "rb", "cr", "rar", "v", "req", "rt", "m", "re", "R", "rg", "ret", "ur", "rd", "rec", "l", "fr", "j", "res", "ro", "rer", "hr"], "rc": ["ck", "act", " ro", "rs", "dc", " res", "gc", "src", "pc", "cmp", "nr", "con", "sc", "nt", "rx", "ry", "ok", "cor", "rn", "fc", " RC", "co", "nc", "ec", "yes", "row", "sync", "cb", "ce", "err", "cc", "roc", "rr", "arc", " ec", "code", "cr", "rt", " cc", "ack", "rl", "uc", "ac", "isc", "ko", "cd", "desc", "cur", "rec", "ctr", "irc", "res", "x", "ro", "RC", "inc", " cr"]}}
{"project": "qemu", "commit_id": "7d91ddd25e3a4e5008a2ac16127d51a34fd56bf1", "target": 1, "func": "void qemu_net_queue_purge(NetQueue *queue, NetClientState *from)\n\n{\n\n    NetPacket *packet, *next;\n\n\n\n    QTAILQ_FOREACH_SAFE(packet, &queue->packets, entry, next) {\n\n        if (packet->sender == from) {\n\n            QTAILQ_REMOVE(&queue->packets, packet, entry);\n\n\n            g_free(packet);\n\n        }\n\n    }\n\n}", "idx": 6951, "substitutes": {"queue": ["q", "console", "Queue", "channel", "quote", "ques", "job", "store", "buffer", "profile", "table", "archive", "connection", "required", "line", "server", "Q", "command", "question", "list", "bar", "module", "ue", "qa", "complete", "dq", "select", "frame", "port", "worker", "config", "processor", "quit", "cue", "league", "batch", "grid", "pool", "manager", "loop", "test", "que", "database", "forced", "journal", "menu", "sequence"], "from": ["about", "user", "as", "form", "without", "end", "founder", "os", "er", "with", "foreign", "or", "sent", "bound", "old", "str", "initial", "after", "to", "of", "start", "org", "component", "new", "st", "now", "owner", "From", "starting", "before", "info", "by", "fr", "origin", "star", "name", "source"], "packet": ["packup", " packel", "ppet", "packum", " Packacket", "Packacket", "octET", "ppce", "packce", " packum", "octel", "packET", "octacket", "compum", "packsacket", " packET", "Packet", "ppel", "compacket", "ppup", " packce", "packsum", "packset", "packacket", " Packet", "compel", "packageet", "packel", "packageacket", "Packel", "ppET", "PackET", "packageel", "compet", " packup", "ppacket", " packacket", "packsel", "octup", " Packce", " Packel", "packageET", "octet"], "next": ["this", "chain", "node", "window", "reply", "nr", "set", "nd", "page", " entry", "nt", "last", "er", "seq", "link", "network", "future", "line", "ner", "key", " NEXT", "after", "Next", "ng", "sec", "inner", "prev", "new", "entry", "response", "ptr", "tmp", "member", "net", "fr", "nl", "ne", "path", "sequence"]}}
{"project": "qemu", "commit_id": "3e305e4a4752f70c0b5c3cf5b43ec957881714f7", "target": 1, "func": "static ssize_t vnc_client_read_tls(gnutls_session_t *session, uint8_t *data,\n\n                                   size_t datalen)\n\n{\n\n    ssize_t ret = gnutls_read(*session, data, datalen);\n\n    if (ret < 0) {\n\n        if (ret == GNUTLS_E_AGAIN) {\n\n            errno = EAGAIN;\n\n        } else {\n\n            errno = EIO;\n\n        }\n\n        ret = -1;\n\n    }\n\n    return ret;\n\n}\n", "idx": 6953, "substitutes": {"session": ["sp", "binding", "task", "window", "site", "view", "set", "store", "state", "client", "bind", "connection", "brain", "lib", "process", "account", "se", "server", "connect", "route", "ess", "api", "sid", "shared", "common", "tab", "close", "version", "local", "parent", "test", "Session", "ession", "lock", "j", "conn"], "data": ["package", "accept", "read", "bytes", "empty", "dat", "window", "ns", "pad", "rel", "buf", "buffer", "raw", "d", "partial", " DATA", "rew", "ata", "t", "input", "Data", "mu", "ad", "new", "block", "load", "reader", "batch", "DATA", "sample", "message", "size", "text", "json", "def", "image", "da"], "datalen": ["dalize", " datalength", "dallun", " dalength", "dalen", "dalten", "daltize", "datalize", " datalize", "dalun", "datalun", "dallen", "damelun", "datalength", "damelength", "Datalun", " dalen", "Dalength", "daltength", "dalte", "damelize", "Datalize", " dale", "Dalun", "dallength", "dalle", "Datalen", "dallize", "datale", "Dalen", "damelen", " datale", "dale", " dalize", "Datalength", "dalength", "Dalize"]}}
{"project": "FFmpeg", "commit_id": "f6774f905fb3cfdc319523ac640be30b14c1bc55", "target": 1, "func": "static int slice_end(AVCodecContext *avctx, AVFrame *pict)\n\n{\n\n    Mpeg1Context *s1  = avctx->priv_data;\n\n    MpegEncContext *s = &s1->mpeg_enc_ctx;\n\n\n\n    if (!s1->mpeg_enc_ctx_allocated || !s->current_picture_ptr)\n\n        return 0;\n\n\n\n    if (s->avctx->hwaccel) {\n\n        if (s->avctx->hwaccel->end_frame(s->avctx) < 0)\n\n            av_log(avctx, AV_LOG_ERROR,\n\n                   \"hardware accelerator failed to decode picture\\n\");\n\n    }\n\n\n\n#if FF_API_XVMC\n\nFF_DISABLE_DEPRECATION_WARNINGS\n\n    if (CONFIG_MPEG_XVMC_DECODER && s->avctx->xvmc_acceleration)\n\n        ff_xvmc_field_end(s);\n\nFF_ENABLE_DEPRECATION_WARNINGS\n\n#endif /* FF_API_XVMC */\n\n\n\n    /* end of slice reached */\n\n    if (/* s->mb_y << field_pic == s->mb_height && */ !s->first_field) {\n\n        /* end of image */\n\n\n\n        ff_er_frame_end(&s->er);\n\n\n\n        ff_MPV_frame_end(s);\n\n\n\n        if (s->pict_type == AV_PICTURE_TYPE_B || s->low_delay) {\n\n            int ret = av_frame_ref(pict, &s->current_picture_ptr->f);\n\n            if (ret < 0)\n\n                return ret;\n\n            ff_print_debug_info(s, s->current_picture_ptr);\n\n        } else {\n\n            if (avctx->active_thread_type & FF_THREAD_FRAME)\n\n                s->picture_number++;\n\n            /* latency of 1 frame for I- and P-frames */\n\n            /* XXX: use another variable than picture_number */\n\n            if (s->last_picture_ptr != NULL) {\n\n                int ret = av_frame_ref(pict, &s->last_picture_ptr->f);\n\n                if (ret < 0)\n\n                    return ret;\n\n                ff_print_debug_info(s, s->last_picture_ptr);\n\n            }\n\n        }\n\n\n\n        return 1;\n\n    } else {\n\n        return 0;\n\n    }\n\n}\n", "idx": 6956, "substitutes": {"avctx": ["avermom", "ravsys", "ovtx", "avheight", "camkt", " avcmp", "wavcam", "vrctx", "camctx", "ajctx", "ravctx", "avcontext", "aveconn", "ovcontext", "ovctx", "avcam", "averheight", "avcfg", "vrconn", "avcu", "avkt", " avdt", "averctx", "vrclient", "averclient", " avclient", "afctx", "ajcam", "camtx", "avdt", "avconn", "aveheight", "avecontext", "afcam", "camcfg", "vrcu", "afconn", "avectx", "wavctx", "averdt", "ovcu", "avertx", " avconn", "avesys", "vrtx", "avmom", "avtx", "avclient", " avkt", "averconn", "ravheight", " avkl", " avcontext", "afkl", "aftx", "avercontext", "wavconn", " avtx", " avcfg", "camcmp", "wavtx", "vrcontext", "ajconn", "avsys", " avcu", "aversys", "afcmp", "ajtx", " avmom", "avetx", "ravmom", "avekl", "camcontext", "avkl", "avedt", "avcmp", "avemom", "afcfg", "avekt", "afcontext"], "pict": ["feat", "gif", "Pic", "pain", "wid", "ctx", "Pict", "eric", "cam", "phot", "fx", "phy", "fig", "pt", "pit", "ht", "seq", "riot", "virt", "rect", "hot", "stat", "picture", " fig", "pl", "phys", "pkg", "png", "txt", "pai", " pic", "shit", "pic", " picture", "sci", "img", "pas", "jp", "isch", "ksh", "hun", "Picture", "fi", "hist", "pres", "hog", "camera", " img", "capt", "act"], "s1": ["ws1", "S2", "s3", "ws2", "hs2", "s01", "hs1", "gs1", "s11", "S11", " s01", "S1", " sOne", "ws01", "wsOne", "hs3", "S3", "gs01", "gsOne", " s3", "ps1", "ps2", "s2", " s11", "sOne", " s2", "ps11", "gs2", "hs11"], "s": ["sw", "less", "conf", "c", "h", "self", "d", "ps", "ports", "ts", "t", "pers", "js", "w", "events", "sb", "ss", "changes", "j", "sports", "comments", "as", "rs", "ses", "os", "g", "ms", "es", "v", "stats", "bits", "m", "vs", "us", "aws", "a", "l", "ges", "gs", "bis", "ar", "ns", "ctx", "ats", "ies", "ags", "cs", "comm", "p", "aunts", "is", "has", "r", "sv", "hs", "bs", "y", "sq", "parts", "fs", "S", "news", "sp", "b", "its", "acs", "i", "qs", "sys", "als", "stat", "details", "n", "ds", "ins", "ls", "ess", "scl", "ims", "ties", "args", "sl", "spec", "states", "f", "sts"], "xvmc_acceleration": ["xvmc_macceleration", "xvmc_accomplATION", "xvmc_acceling", "xvmc_accomplation", "xvmc_maccelATION", "xvmc_maccelering", "xvmc_accelation", "xvmc_maccelerATION", "xvmc_acoder", "xvmc_maccelerer", "xvmc_acoding", "xvmc_accelerATION", "xvmc_macceler", "xvmc_maccelation", "xvmc_accelATION", "xvmc_macceling", "xvmc_accompling", "xvmc_acodATION", "xvmc_acceler", "xvmc_accelerer", "xvmc_accelering", "xvmc_acodation", "xvmc_accompler"], "picture_number": [" picture_position", "pictureIdnum", "pictureIdposition", " picture_num", "picture_position", " picture_no", "pictureIdnumber", "picture_no", "pictureIdno", "picture_num"]}}
{"project": "FFmpeg", "commit_id": "d82eccea2bf905cd51889954658f4e7f64876df8", "target": 1, "func": "static inline int mpeg2_fast_decode_block_non_intra(MpegEncContext *s,\n\n                                                    int16_t *block, int n)\n\n{\n\n    int level, i, j, run;\n\n    RLTable *rl = &ff_rl_mpeg1;\n\n    uint8_t * const scantable = s->intra_scantable.permutated;\n\n    const int qscale          = s->qscale;\n\n    OPEN_READER(re, &s->gb);\n\n    i = -1;\n\n\n\n    // special case for first coefficient, no need to add second VLC table\n\n    UPDATE_CACHE(re, &s->gb);\n\n    if (((int32_t)GET_CACHE(re, &s->gb)) < 0) {\n\n        level = (3 * qscale) >> 1;\n\n        if (GET_CACHE(re, &s->gb) & 0x40000000)\n\n            level = -level;\n\n        block[0] = level;\n\n        i++;\n\n        SKIP_BITS(re, &s->gb, 2);\n\n        if (((int32_t)GET_CACHE(re, &s->gb)) <= (int32_t)0xBFFFFFFF)\n\n            goto end;\n\n    }\n\n\n\n    /* now quantify & encode AC coefficients */\n\n    for (;;) {\n\n        GET_RL_VLC(level, run, re, &s->gb, rl->rl_vlc[0], TEX_VLC_BITS, 2, 0);\n\n\n\n        if (level != 0) {\n\n            i += run;\n\n            j  = scantable[i];\n\n            level = ((level * 2 + 1) * qscale) >> 1;\n\n            level = (level ^ SHOW_SBITS(re, &s->gb, 1)) - SHOW_SBITS(re, &s->gb, 1);\n\n            SKIP_BITS(re, &s->gb, 1);\n\n        } else {\n\n            /* escape */\n\n            run = SHOW_UBITS(re, &s->gb, 6) + 1; LAST_SKIP_BITS(re, &s->gb, 6);\n\n            UPDATE_CACHE(re, &s->gb);\n\n            level = SHOW_SBITS(re, &s->gb, 12); SKIP_BITS(re, &s->gb, 12);\n\n\n\n            i += run;\n\n            j  = scantable[i];\n\n            if (level < 0) {\n\n                level = ((-level * 2 + 1) * qscale) >> 1;\n\n                level = -level;\n\n            } else {\n\n                level = ((level * 2 + 1) * qscale) >> 1;\n\n            }\n\n        }\n\n\n\n        block[j] = level;\n\n        if (((int32_t)GET_CACHE(re, &s->gb)) <= (int32_t)0xBFFFFFFF)\n\n            break;\n\n        UPDATE_CACHE(re, &s->gb);\n\n    }\n\nend:\n\n    LAST_SKIP_BITS(re, &s->gb, 2);\n\n    CLOSE_READER(re, &s->gb);\n\n    s->block_last_index[n] = i;\n\n    return 0;\n\n}\n", "idx": 6972, "substitutes": {"s": ["tes", "conf", "c", "h", "ps", "d", "dev", "ts", "settings", "t", "se", "js", "events", "sb", "ss", "changes", "comments", "params", "as", "bes", "rs", "results", "os", "g", "ms", "ains", "es", "stats", "m", "vs", "serv", "a", "ops", "gs", "ssl", "sg", "times", "ns", "ats", "cs", "comm", "p", "is", "has", "r", "sv", "re", "hs", "bs", "parts", "fs", "S", "res", "rates", "b", "its", "sys", "qs", "set", "als", "details", "ds", "ins", "ls", "scl", "ims", "args", "e", "sts"], "block": ["chain", "mem", "channel", "type", "pack", "cl", "box", "field", "set", "buffer", "map", "group", "row", "label", "line", "range", "number", "bit", "w", "byte", "record", "word", "list", "ref", "unit", "blocks", "commit", "out", "ack", "frame", "load", "scan", "bl", "rec", "check", "lock", "Block", "bin"], "n": ["b", "ns", "c", "ry", "rn", "d", "g", "no", "name", "ran", "un", "line", "ner", "r", "N", "w", "en", "v", "m", "rec", "e", "lock", "z", "ne", "x", "l"], "level": ["depth", "step", "low", "h", "state", "goal", "ler", "ind", "key", "lo", "hi", "quality", "pe", "trace", "role", "layer", "priority", "loop", "test", "size", "VEL", "LE", "le", "q", "g", "ose", "zero", "index", "go", "bit", "position", "top", "command", "frame", "lvl", "volume", "version", "local", "Level", "time", "info", "length", "l", "error", "console", "cost", "type", "ale", "equal", "len", "val", "line", "total", "LC", "limit", "debug", "change", "fail", "diff", "ld", "roll", "lower", "call", "te", "group", "row", "lc", "vel", "scale", "number", "id", "where", "status", "levels", "print", "count", "point", "global", "lock", "high", "variable", "condition"], "i": ["ic", "ij", "ini", "q", "uri", "ei", "ci", "it", "im", "c", "u", "cli", "ori", "gi", "mi", "ip", "li", "p", "si", "g", "zi", "is", "xi", "index", "t", "hi", "pi", "bi", "r", "multi", "limit", "ri", "ui", "ki", "list", "phi", "ir", "start", "ti", "v", "api", "ix", "ai", "m", "I", "iat", "y", "batch", "f", "loop", "ia", "io", "iu", "e", "in", "info", "iri", "z", "x", "di", "ii", "l"], "j": ["dj", "ja", "ij", "q", "b", "it", "jj", "job", "J", "br", "rel", "g", "ind", "uj", "index", "row", "o", "bi", "jc", "r", "js", "pos", "ji", "pr", "k", "out", "v", "bs", "ret", "y", "jump", "jp", "f", "jl", "lock", "z", "res", "x", "fr", "json", "kj", "l"], "run": ["init", "update", "call", "grow", "end", "step", "rel", "set", "ra", "con", "thin", "skip", "play", "seq", "add", "round", "no", "len", "une", "ran", "un", "row", "index", "line", "pair", "range", "win", "Run", "r", "err", "go", "UN", "rc", "record", "ref", "pos", "pre", "rr", "nil", "out", "try", "change", "fun", "new", "load", "runs", "pass", "ru", "fail", "loop", "runner", "in", "lock", "roll", "running", "name", "rm", "bin"], "rl": ["vr", "rs", "raf", "gb", "ssl", "lv", "lr", "sr", "kr", "ra", "rel", "tl", "lf", "rx", "rn", "dl", "arl", "rol", "rw", "lb", "r", "rc", "rr", "ls", "rh", "rf", "lp", "rb", "rt", "rin", "rg", "RL", "hl", "ll", "nl", "ro", "l"], "scantable": ["scANTatable", "Scanttable", "ScantTable", "scantables", "scandtable", "scantsTable", "ScANTiable", "scantatable", "scANTiable", "scentable", "scenttable", "scandiable", "scentatable", "scentabe", "ScANTability", "scantiable", "scantability", " scanttable", "scanttable", "scarenttable", "scandabe", "ScANTables", "scandable", "scarentable", "Scantiable", " scantabe", "scANTable", "scannabe", " scannabe", "ScANTtable", "ScANTable", "scANTTable", "scannable", "Scantability", " scanntable", "scantsable", " scantatable", "scandables", "scarentability", "scarentiable", "Scantables", "scANTabe", " scannatable", "scantTable", "scandability", "ScANTTable", " scannable", "scantabe", "Scantable", "scannatable", "scantsables", "scANTables", "scanntable", "scantsabe", "Scantabe", "scandTable", "scANTability", "scANTtable", "ScANTabe"]}}
{"project": "FFmpeg", "commit_id": "b853cfe7eaf13b7d4ff3ceba7098544ccc049df8", "target": 0, "func": "static void stream_close(VideoState *is)\n\n{\n\n    VideoPicture *vp;\n\n    int i;\n\n    /* XXX: use a special url_shutdown call to abort parse cleanly */\n\n    is->abort_request = 1;\n\n    SDL_WaitThread(is->read_tid, NULL);\n\n    SDL_WaitThread(is->refresh_tid, NULL);\n\n    packet_queue_destroy(&is->videoq);\n\n    packet_queue_destroy(&is->audioq);\n\n    packet_queue_destroy(&is->subtitleq);\n\n\n\n    /* free all pictures */\n\n    for (i = 0; i < VIDEO_PICTURE_QUEUE_SIZE; i++) {\n\n        vp = &is->pictq[i];\n\n#if CONFIG_AVFILTER\n\n        avfilter_unref_bufferp(&vp->picref);\n\n#endif\n\n        if (vp->bmp) {\n\n            SDL_FreeYUVOverlay(vp->bmp);\n\n            vp->bmp = NULL;\n\n        }\n\n    }\n\n    SDL_DestroyMutex(is->pictq_mutex);\n\n    SDL_DestroyCond(is->pictq_cond);\n\n    SDL_DestroyMutex(is->subpq_mutex);\n\n    SDL_DestroyCond(is->subpq_cond);\n\n    SDL_DestroyCond(is->continue_read_thread);\n\n#if !CONFIG_AVFILTER\n\n    sws_freeContext(is->img_convert_ctx);\n\n#endif\n\n    av_free(is);\n\n}\n", "idx": 6997, "substitutes": {"is": ["was", "as", "rs", "isf", "ic", "bis", "ois", "ris", "ists", "it", "isa", "ns", "ics", "its", "lis", "sys", "cs", "mis", "isin", "os", "ps", "ms", "\u00eds", "has", "does", "or", "es", "isl", "are", "js", "id", "irm", "ls", "rest", "s", "tis", "ims", "Is", "iss", "bits", "vis", "bs", "isc", "ist", "isal", "ish", "parts", "iris", "fs", "IS", "us", "info", "in", "ais", "dis", "sis", "isi", "il", "news", "ism", "oss"], "vp": ["iv", "vv", "vr", "uv", "ev", "csv", "lv", "avi", "wp", "gp", "cp", "rpm", "pb", "av", "cmp", "phy", "pt", "px", "p", "verb", "cmd", "bp", "VP", "orp", "VO", "vert", "prov", "tif", "ulp", "fp", "mpeg", "pkg", "sv", "qv", "esp", "expr", "lp", "vP", "v", "video", "txt", "nv", "vg", "resp", "vs", "vc", "cv", "ptr", "jp", "tap", "vt", "dp", "conv", "xp", "vm", "VB", "tp", "pty", "tml", "mp", "vim"], "i": ["init", "ic", "asi", "ij", " bi", " multi", "ci", " ii", "it", " m", "im", "c", "u", " ni", " v", "gi", "mi", "qi", "my", "ip", "li", "p", "si", "g", "ie", "zi", "n", "iq", "ind", "xi", "index", "t", "key", "pi", "bi", "multi", "go", "me", "ui", "ki", "ji", "phi", "ti", "iter", "v", "ims", "ix", " j", "ai", "m", "I", "batch", "y", "print", "\u0438", "f", "fi", "us", "sim", "ex", "iu", "in", "point", "e", "l", "j", "x", "di", "ii", "name"]}}
{"project": "FFmpeg", "commit_id": "560b10a6c3627cccf6735170d370cf9e3d38e805", "target": 1, "func": "static void init_gain_table(COOKContext *q) {\n\n    int i;\n\n    q->gain_size_factor = q->samples_per_channel/8;\n\n    for (i=0 ; i<23 ; i++) {\n\n        q->gain_table[i] = pow((double)q->pow2tab[i+52] ,\n\n                               (1.0/(double)q->gain_size_factor));\n\n    }\n\n    memset(&q->gain_copy, 0, sizeof(COOKgain));\n\n    memset(&q->gain_current, 0, sizeof(COOKgain));\n\n    memset(&q->gain_now, 0, sizeof(COOKgain));\n\n    memset(&q->gain_previous, 0, sizeof(COOKgain));\n\n}\n", "idx": 6999, "substitutes": {"q": ["ck", "db", "cf", "form", "quant", "cp", "conf", "gm", "c", "h", "gr", "qs", "comm", "ry", "qi", "er", "p", "co", "add", "etc", "iq", "queue", "t", "Q", "r", "w", "query", "question", "pkg", "pg", "k", "ue", "qa", "eq", "out", "v", "cal", "req", "qq", "qu", "requ", "dq", "ch", "m", "config", "rl", "quit", "entry", "aq", "y", "sq", "f", "quest", "qt", "info", "pp", "hl", "check", "z", "tt"], "i": ["chain", "ei", " ii", "im", "gi", "zi", "ind", "key", "hi", "pi", " pi", " j", "I", "batch", "in", "j", "x", "\u0438", "di", "ic", " m", "yi", "mi", "my", "g", "xi", "index", "ri", "bi", "ki", "span", "ti", "out", "v", "ai", "m", "us", "info", "ci", "it", "ip", "li", "p", "ami", "is", "o", " e", " I", "try", "y", "fi", "spin", "ii", "init", "ini", "ij", "uri", "cli", " x", "oi", "client", "qi", "si", "multi", "me", "ui", "id", "phi", "ims", "ix", "status", " mi", "sim", "ex", "gu", "e", "iu", "sequence"]}}
{"project": "qemu", "commit_id": "ea9ebc2ce69198f7aca4b43652824c5d621ac978", "target": 1, "func": "static void qpa_fini_out (HWVoiceOut *hw)\n\n{\n\n    void *ret;\n\n    PAVoiceOut *pa = (PAVoiceOut *) hw;\n\n\n\n    audio_pt_lock (&pa->pt, AUDIO_FUNC);\n\n    pa->done = 1;\n\n    audio_pt_unlock_and_signal (&pa->pt, AUDIO_FUNC);\n\n    audio_pt_join (&pa->pt, &ret, AUDIO_FUNC);\n\n\n\n    if (pa->s) {\n\n        pa_simple_free (pa->s);\n\n        pa->s = NULL;\n\n    }\n\n\n\n    audio_pt_fini (&pa->pt, AUDIO_FUNC);\n\n    g_free (pa->pcm_buf);\n\n    pa->pcm_buf = NULL;\n\n}\n", "idx": 7004, "substitutes": {"hw": ["aw", "ether", "mph", "rpm", "wa", "wy", "aaaa", "phy", "aws", "wx", "whe", "xa", "ht", "we", "vp", "ew", "hub", "hz", "phys", "iw", "wk", "wu", "w", "him", "pkg", "rh", "vo", "qu", "hs", "wi", "wo", "hop", "hip", "hist", "xp", "ha", "hh", "hog", "haw", "wd", "nw", "fw"], "ret": ["gt", "result", "et", "repl", "par", "pret", "ply", "mem", "reply", "rep", "nt", "pat", "mt", "rets", "val", "aux", "alt", "vals", "pet", "ref", "rem", "txt", "ruby", "rt", "reset", "resp", "re", "reg", "tmp", "print", "RET", "vt", "Ret", "ft", "nl", "res", "arr", "rm", "elt"], "pa": ["ja", "apa", "jo", "ena", "oa", "po", "ping", "pb", "quote", "pu", "pc", "paste", "eta", "pan", "rep", "ma", "phy", "pt", "ppa", "ka", "whe", "wan", "ta", "p", "qua", "pol", "PA", "ppo", "pi", "opa", "pe", "pet", "pm", "pkg", "ap", "ada", "au", "qa", "pai", "ea", "fa", "a", "asia", "sa", "Pa", " PA", "pas", "jp", "pse", "aka", "que", "pp", "ha", "pha", "ara", "pee", "ace", "ga", "ota", "ape", "mp"]}}
{"project": "qemu", "commit_id": "a818a4b69d47ca3826dee36878074395aeac2083", "target": 0, "func": "static int scsi_device_init(SCSIDevice *s)\n\n{\n\n    SCSIDeviceClass *sc = SCSI_DEVICE_GET_CLASS(s);\n\n    if (sc->init) {\n\n        return sc->init(s);\n\n    }\n\n    return 0;\n\n}\n", "idx": 7017, "substitutes": {"s": ["rs", "gs", "sp", "b", "less", "ns", "c", "its", "ats", "h", "i", "qs", "cs", "os", "p", "d", "si", "ps", "n", "ms", "is", "ts", "sd", "ds", "t", "r", "js", "w", "sv", "ls", "sb", "v", "ims", "spec", "st", "ss", "south", "y", "sq", "S", "sts", "sports", "aws", "ysis"], "sc": ["dc", "sp", "esc", "gc", "c", "pc", "cam", "bc", "anc", "cl", "cs", "sup", "ec", "nc", "psc", "mic", "osc", "lc", "cc", "asc", "rc", "sche", "sic", "sv", "scl", "cr", "sec", "uc", "Sc", "SC", "ss", "usc", "isc", "pic", "sci", "disc", "ca", "sq", "desc", "mc", "sch", "scrib", "tc"]}}
{"project": "qemu", "commit_id": "aaa0eb75e2e56d483c89731a447c999985713b43", "target": 0, "func": "static void set_dirty_bitmap(BlockDriverState *bs, int64_t sector_num,\n\n                             int nb_sectors, int dirty)\n\n{\n\n    int64_t start, end;\n\n    unsigned long val, idx, bit;\n\n\n\n    start = sector_num / BDRV_SECTORS_PER_DIRTY_CHUNK;\n\n    end = (sector_num + nb_sectors - 1) / BDRV_SECTORS_PER_DIRTY_CHUNK;\n\n\n\n    for (; start <= end; start++) {\n\n        idx = start / (sizeof(unsigned long) * 8);\n\n        bit = start % (sizeof(unsigned long) * 8);\n\n        val = bs->dirty_bitmap[idx];\n\n        if (dirty) {\n\n            val |= 1 << bit;\n\n        } else {\n\n            val &= ~(1 << bit);\n\n        }\n\n        bs->dirty_bitmap[idx] = val;\n\n    }\n\n}\n", "idx": 7019, "substitutes": {"bs": ["bes", "rs", "gs", "bis", "b", "ns", "ubs", "eb", "pb", "its", "bos", "acs", "cks", "bc", "sys", "qs", "bsp", "cs", "bh", "ps", "ms", "bp", "ts", "uts", "ds", "BS", "hz", "aus", "js", "ls", "sb", "s", "bps", "iss", "bits", "vs", "hs", "aos", "ss", "bl", "fs", "sts", "bas", "bm", "obs", "lbs"], "sector_num": ["sector2number", "sectorationnum", "sectoritynom", "sectorationnumber", "sectorationNum", "ector_Num", "ector_on", "sector2mon", "ector_num", "sector2cum", "ector_nom", "sectorityon", "sector1num", "sectorationcum", "ector_mon", "sector_number", "sectoritynum", "ector_number", "sector1number", "sector_Num", "sector1Num", "sector_on", "ector_cum", "sector_cum", "sector1mon", "sector2Num", "sector_nom", "sector2num", "sectorityNum", "sector_mon"], "nb_sectors": ["nb_sesctors", "nb_veplanes", "nb_vegments", "nb_vectors", "nb_specs", "nb_secs", "nb_sesplanes", "nb_sellers", "nb_pellers", "nb_segments", "nb_seplanes", "nb_seors", "nb_sesors", "nb_sesllers", "nb_peplanes", "nb_vellers", "nb_spectors", "nb_spegments", "nb_speors", "nb_pectors", "nb_vecs", "nb_pecs", "nb_pegments", "nb_peors", "nb_veors"], "dirty": ["atomic", "initialized", "finished", "magic", "deep", "managed", "rounded", "clean", " Dirty", "my", "valid", "weak", "backed", "missing", "required", "locked", "need", "confirmed", "important", "always", "modified", "hidden", "checked", "draft", "dollar", "pretty", "meta", "mounted", "graded", "status", "fresh", "done", "friendly", "broken", "stable", "irty", "marked", "qualified", " dirt", "visible", "needed", "kept", "forced"], "start": ["init", "read", "sp", "match", "next", "root", "it", "step", "shift", "get", "offset", "i", "set", "pt", "Start", "client", "wind", "d", "addr", "rank", "add", "seek", "ind", "index", "first", "range", "stop", "input", "from", "import", "id", "pos", "pre", "space", "rest", "begin", "iter", "try", "gate", "be", "st", "part", "art", "entry", "ist", "starting", "axis", "print", "ish", "ST", "before", "time", "in", "check", "boot", "point", "origin", "x", "trans", "path"], "end": ["ort", "event", "ff", "END", "est", "then", "offset", "nd", "last", "until", "except", "ext", "ent", "len", "ended", "eng", "ep", "range", "bound", "stop", "append", "hend", "limit", "after", "ending", "max", "begin", "send", "ue", "en", "org", "fin", "close", "edge", "size", "ex", "e", "length", "End", "ape"], "val": [" vol", "qual", "xy", " ptr", "it", "sol", "ctx", " x", "rel", "Val", " v", " oval", "pt", " ver", " valid", "valid", "px", "prop", "als", "vol", "stat", "pol", "dev", " el", "var", "pl", "bo", " value", "vals", "rol", "ival", " Val", "value", " vec", "bal", "sel", "crit", " ty", "pr", "oval", " var", " bin", "v", "pal", "cal", "aval", "sl", "al", " lit", "ret", "tx", "eval", "lit", "serv", " arg", " tx", "bl", "vt", "VAL", "test", "point", " eval", "x", "def", "elt", " ret"], "idx": ["idxf", "ideex", "IDix", "idnex", "idsx", " idnex", " idxf", "indix", "kidindex", " idex", "edX", " idX", "indindex", "indz", "ideix", " idix", "indxf", "indx", "idsX", "idz", "kidix", "edix", "index", " idindex", "kidx", "iddx", "IDx", "idsxf", "kiddx", "IDnex", " idz", "edx", "idix", "idindex", "idX", "IDex", " iddx", "idenex", "idex", "idsex", "edz", "indX", "inddx"], "bit": ["ort", "butt", "b", "it", "git", "bot", "lot", "BIT", "offset", "set", "state", "fix", "op", "cut", "bo", "bt", "ut", "bi", "col", "bolt", "byte", "unit", "tag", "id", "bool", "pos", "board", "Bit", "word", "level", "code", "bits", "port", "ch", "block", "ac", "off", "cond", "batch", "lit", "bug", "mask", "test", "point", "lock", "format", "x", "bus", "flag", "bin"]}}
{"project": "qemu", "commit_id": "eb700029c7836798046191d62d595363d92c84d4", "target": 0, "func": "static size_t net_tx_pkt_fetch_fragment(struct NetTxPkt *pkt,\n\n    int *src_idx, size_t *src_offset, struct iovec *dst, int *dst_idx)\n\n{\n\n    size_t fetched = 0;\n\n    struct iovec *src = pkt->vec;\n\n\n\n    *dst_idx = NET_TX_PKT_FRAGMENT_HEADER_NUM;\n\n\n\n    while (fetched < pkt->virt_hdr.gso_size) {\n\n\n\n        /* no more place in fragment iov */\n\n        if (*dst_idx == NET_MAX_FRAG_SG_LIST) {\n\n            break;\n\n        }\n\n\n\n        /* no more data in iovec */\n\n        if (*src_idx == (pkt->payload_frags + NET_TX_PKT_PL_START_FRAG)) {\n\n            break;\n\n        }\n\n\n\n\n\n        dst[*dst_idx].iov_base = src[*src_idx].iov_base + *src_offset;\n\n        dst[*dst_idx].iov_len = MIN(src[*src_idx].iov_len - *src_offset,\n\n            pkt->virt_hdr.gso_size - fetched);\n\n\n\n        *src_offset += dst[*dst_idx].iov_len;\n\n        fetched += dst[*dst_idx].iov_len;\n\n\n\n        if (*src_offset == src[*src_idx].iov_len) {\n\n            *src_offset = 0;\n\n            (*src_idx)++;\n\n        }\n\n\n\n        (*dst_idx)++;\n\n    }\n\n\n\n    return fetched;\n\n}\n", "idx": 7027, "substitutes": {"pkt": [" pkg", "ppnt", "spkt", "dct", " pct", "tnt", "spct", "pnt", "facket", "paykt", "padu", "spkg", "Packet", "spdu", "pracket", "paynt", "Pnt", "payconn", "prnt", " pdu", "pakg", "fdu", "dkt", "packet", "prdu", "ppkt", "pkg", "fct", "fkt", "dkg", "prkt", "tkt", "pakt", "pct", " pnt", "tdu", "ppacket", "ppconn", "payacket", "ppdu", "dacket", "tkg", "pant", "pdu", "spacket", "Pconn", "ppct", "spnt", "pconn", " packet", "Pkt"], "src_idx": ["srcptmidv", "src_iterc", "src__idn", "src_Idindex", "src_idxc", "src_IDn", "src_IDxes", "srcptmidx", "src_iterf", "src_infov", "src_idf", "src_docf", "srcptidxc", "src_indz", "src_defx", "src_inl", "src_midx", "src__Idindex", "src_Idv", "srcptidz", "src_IDindex", "src_idex", "src_infox", "src_inpt", "src_idl", "src_defk", "src_doco", "src_docx", "src_indv", "src_Idx", "srcptmidz", "src_ink", "src_Idxf", "src_index", "src_Idy", "src_idk", "src_midv", "src_docc", "src__Idxes", "src_indexn", "src_idexc", "src_IDx", "src_idxes", "src_ideex", "src_midz", "src_idy", "src_indpt", "src_indexx", "src_pidz", "src_midxc", "src_pidex", "src_infoz", "src__idxes", "src_defl", "src_idn", "src_indexxes", "src__Idn", "src_idz", "srcptidv", "src_indo", "src_idpt", "srcptmidxc", "src_indc", "src_indk", "src_Idn", "src_pidx", "src_inx", "src_idc", "src_indl", "src_indx", "src__idx", "src_idv", "src_indf", "src_Idxes", "src_idez", "src_indxf", "src_idey", "src_indy", "src_idev", "src__idindex", "src_pidy", "src_iterx", "src__Idx", "src_infoxc", "src_defpt", "src_idxf", "src_ido", "src_idindex", "src_itero", "src_indexindex", "srcptidx"], "src_offset": ["src_len", "img_seek", "src_scroll", "src_off", "src__Offset", "src__offset", "src_Offset", "rc_len", " src_Offset", "src_reset", "src_pos", "src__len", "srcitybase", "rc_Offset", "rc_reset", "src0offset", "src_seek", "src_error", "rc_off", "src_shift", "rc_pos", "src0pos", "srcityOffset", "img_pos", "img_scroll", "rc_offset", " src_shift", "src0len", " src_off", "srcityoffset", "src__reset", "rc_extra", " src_len", "src0off", " src_error", "src_extra", "rc_base", "img_offset", "srcityextra", "src_base"], "dst": ["idv", "mst", "jpt", "dct", "pdnd", "mot", "sdot", "sddest", " dlt", "dcp", "ddv", "dslt", "pest", "iddest", "idnd", "Dct", "ddest", "dddest", "Dlt", "sdst", "dot", "dsdest", "sdcp", "ppt", "dsst", "dpt", "jst", "dsct", " dnd", "pdot", "Dv", "pdst", "dx", "jnd", "ddst", "dlt", " dx", " dot", "Dst", "Ddest", "dnd", "pst", "pdx", "Dot", "dv", "ddpt", "mcp", "Dcp", "idpt", "pnd", "dest", "jest", "mnd", "idst", " ddest", "idest", "mx", "mdest", " dct", "Dpt"], "dst_idx": ["dst_idr", "dst_ffx", "dst_ridm", "dst_idy", "dst_idxc", "dst_fpx", "dst_Idst", "dst_drxc", "dst_timex", "dst_ridx", "dst_idsx", "dst_pidci", "dst_trst", "dst_Idsw", "dst_inb", "dst_indexz", "dst_ndx", "dst_timest", "dst_indexst", "dst_Idn", "dst_idsz", "dst_ridxs", "dst_trz", "dst_idsw", "dst_idn", "dst_idst", "dst_pidz", "dst_idez", "dst_pidx", "dst_Idx", "dst_indexx", "dst_Idl", "dst_Idz", "dst_idex", "dst_midr", "dst_ndm", "dst__idn", "dst_trsw", "dst_drz", "dst_midw", "dst_idpx", "dst_idl", "dst_midn", "dst_iterst", "dst_timey", "dst_fx", "dst_inx", "dst_Idr", "dst_idz", "dst_idsr", "dst_timeh", "dst_iden", "dst__idr", "dst_idel", "dst_midm", "dst_idci", "dst_inn", "dst_piz", "dst_idfx", "dst_midx", "dst_trx", "dst_midb", "dst_ndw", "dst_iterx", "dst_pipx", "dst_idxs", "dst_ridw", "dst_itery", "dst_idsn", "dst_drci", "dst_iterh", "dst_idw", "dst_inr", "dst_pifx", "dst_midxs", "dst__idx", "dst_pix", "dst_ndxs", "dst_idsb", "dst_idb", "dst__idz", "dst_pidxc", "dst_indexsw", "dst_fz", "dst_drx", "dst_idh", "dst_idm"], "src": ["rs", "vr", "ssl", "ser", "bc", "rel", "sys", "buf", "sc", "rx", "seq", "inst", "usr", "rob", "sel", "str", "rc", "ins", "syn", "proc", "pkg", "sb", "txt", "sec", "req", "rt", "sl", "rl", "sur", "sub", "st", "usc", "sn", "tmp", "ptr", "img", "supp", "sq", "desc", "cur", "dest", "comp", "via", "hl", "source", "sels", "obs", "loc"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void lsi_ram_write(void *opaque, target_phys_addr_t addr,\n\n                          uint64_t val, unsigned size)\n\n{\n\n    LSIState *s = opaque;\n\n    uint32_t newval;\n\n    uint32_t mask;\n\n    int shift;\n\n\n\n    newval = s->script_ram[addr >> 2];\n\n    shift = (addr & 3) * 8;\n\n    mask = ((uint64_t)1 << (size * 8)) - 1;\n\n    newval &= ~(mask << shift);\n\n    newval |= val << shift;\n\n    s->script_ram[addr >> 2] = newval;\n\n}\n", "idx": 7033, "substitutes": {"opaque": ["opempty", " oposter", "paque", "oplque", "oposter", "oplay", "Opempty", "opque", "poster", " opacity", "patile", " opatile", "Oplay", "Opque", "Opacity", "opacity", " opempty", "Opaque", "oplempty", "opllay", "pacity", " opque", "opatile", " oplay", "oplaque", "Opatile", "Oposter"], "addr": ["sp", "grad", "trans", "src", "att", "wid", "asm", "ctx", "offset", "pad", "store", "state", " address", "nr", "i", "arm", "help", "at", "cmd", "add", "order", "len", "arp", "ind", "url", "index", "hw", "r", "err", "dr", "id", "pos", "inter", "ref", "attr", "align", "gate", "num", "ad", "ix", "Address", "ack", "block", "alloc", "ac", "now", "off", "tx", "ptr", "address", "ord", "ag", "obj", "hash", "adr", "arr", "work", "x", "coord", "conn", "loc", "urg"], "val": [" vol", "loc", " res", "it", "mem", " msg", "Val", " v", " oval", " mem", "valid", "p", "vol", "pol", " value", "vals", "ival", " Val", "value", "bit", "sel", "vec", "ref", "v", " aval", "al", "ul", "tx", "eval", "am", " arg", "bl", " tx", "VAL", "test", "arg", " eval", "arr", "res", "x", "elt", " ret"], "size": ["SIZE", "window", "weight", "fee", "type", "offset", "Size", "scope", "zone", "n", "len", "index", "height", "scale", "number", "unit", "pos", "space", "style", "send", "start", "max", "num", "sh", "sn", "count", "address", "message", "shape", "sum", "ize", "length", "name"], "s": ["rs", "gs", "ses", "sp", "ssl", "sw", "less", "ns", "c", "asm", "h", "i", "set", "store", "sys", "comm", "p", "g", "ps", "n", "is", "ts", "ds", "o", "t", "se", "es", "r", "js", "sv", "ls", "sb", "stats", "sl", "status", "m", "spec", "hs", "st", "ss", "sn", "bs", "y", "sq", "fs", "S", "sts", "j", "sis", "z"], "newval": ["Newval", "Newv", "nextVal", "NewVal", "nextserv", "nextval", "NEWVal", "nextvalue", "Newserv", "nexteval", "oldVal", " newv", " newserv", "nextstate", "fresheval", "newv", " newbal", "freshbal", "NEWbal", "newserv", "NEWstate", "newvalue", "Newvalue", " neweval", " newVal", "newbal", "NEWval", " newstate", "NEWeval", "freshVal", "NEWvalue", "freshval", "neweval", "newstate", "oldval", "oldvalue", " newvalue", "newVal", "oldv"], "mask": ["share", "form", "match", "window", "conf", "weight", " masked", "pack", "ma", "box", "mk", "map", "mark", "ms", "mt", "zero", "label", "key", "scale", "hide", "bit", "Mask", "module", "mac", "mount", " masks", "gate", "sk", "sign", "alph", "mb", "m", "block", "clear", "cond", "black", "tile", "allow", "shape", "filter", "sum", "ask", "flags", "hash", "lock", "hold", "acl", "flag", "miss"], "shift": ["share", " step", "half", "window", "ress", "step", "side", " align", "offset", "pad", "set", "aj", "sup", "sort", "map", "add", "seek", "ind", "index", "scale", "push", "slice", "pos", "distance", "delay", "hift", "align", "start", "handle", "ix", "sh", "transform", "shr", "sub", "Shift", "off", "sleep", "ptr", "axis", "sq", "address", "diff", "count", " shr", " offset", "hash", "length", "ctr", "j", "loc"]}}
{"project": "FFmpeg", "commit_id": "7117547298b13d6f52a20d6a62a27dc0a1c3e263", "target": 1, "func": "static int get_buffer_sao(HEVCContext *s, AVFrame *frame, const HEVCSPS *sps)\n\n{\n\n    int ret, i;\n\n\n\n    frame->width  = s->avctx->width  + 2;\n\n    frame->height = s->avctx->height + 2;\n\n    if ((ret = ff_get_buffer(s->avctx, frame, AV_GET_BUFFER_FLAG_REF)) < 0)\n\n        return ret;\n\n    for (i = 0; frame->data[i]; i++) {\n\n        int offset = frame->linesize[i] + (1 << sps->pixel_shift);\n\n        frame->data[i] += offset;\n\n    }\n\n    frame->width  = s->avctx->width;\n\n    frame->height = s->avctx->height;\n\n\n\n    return 0;\n\n}\n", "idx": 7048, "substitutes": {"s": ["rs", "gs", "ses", "less", "times", "ns", "conf", "c", "its", "ctx", "ats", "ies", "qs", "sys", "cs", "comm", "aps", "os", "ps", "g", "ms", "details", "n", "als", "is", "ts", "aunts", "ds", "ains", "fps", "js", "ins", "ls", "gets", "events", "ess", "v", "ims", "iss", "sl", "bits", "hs", "ss", "bs", "sq", "parts", "fs", "ex", "S", "sts", "aws", "mods", "ops"], "frame": ["draw", "event", "layout", "iframe", "state", "file", "picture", "queue", "ce", "trace", "w", "word", "module", "wrapper", "reset", "request", "fb", "message", "filter", "face", "render", "source", "package", "stroke", "store", "page", "base", "zone", "context", "process", "out", "video", "project", "load", "remote", "version", "info", "one", "ace", "cf", "update", "error", "console", "channel", "Frame", "view", "force", "scene", "use", "line", "total", "to", "head", "close", "response", "session", "fr", "library", "object", "cast", "rame", "form", "window", "fram", "buffer", "profile", "frames", "row", "data", "element", "list", "component", "complete", "feature", "new", "block", "front", "print", "show", "f", "point", "e", "lock", "image", "sequence"], "sps": ["sepse", "Sps", "Sss", " sss", "Spe", " sbs", " spse", "sss", "sebs", "SPS", "seps", "spse", "sPS", "cspe", " sPS", "csPS", "csps", " spe", "sePS", "sbs", "spe", "csss"], "ret": ["gt", "result", "pret", "it", "ber", "cont", "det", "ter", "nt", "ext", "mt", " Ret", "rets", "len", "no", "val", "red", "t", "alt", "r", "err", "ref", "rem", "out", "try", "v", "txt", "rt", "reset", "resp", "re", "tmp", "print", "RET", "f", "Ret", "ft", "ll", "j", "res", "def", "elt", "flag"], "i": ["init", "ic", "ij", "asi", "chain", "uri", "ini", "ci", "ei", "it", "im", "any", "u", "set", "oi", "gi", "mi", "qi", "ip", "li", "p", "si", "zi", "is", "ind", "xi", "index", "o", "key", "ri", "pi", "bi", "multi", "id", "ui", "span", "phi", "ti", "v", "ims", "ix", "ai", "m", "status", "I", "iat", "batch", "print", "f", "fi", "sim", "iu", "info", "iri", "j", "x", "di", "ni", "ii", "l"]}}
{"project": "FFmpeg", "commit_id": "662234a9a22f1cd0f0ac83b8bb1ffadedca90c0a", "target": 0, "func": "static void avc_luma_vt_16w_msa(const uint8_t *src, int32_t src_stride,\n\n                                uint8_t *dst, int32_t dst_stride,\n\n                                int32_t height)\n\n{\n\n    int32_t loop_cnt;\n\n    int16_t filt_const0 = 0xfb01;\n\n    int16_t filt_const1 = 0x1414;\n\n    int16_t filt_const2 = 0x1fb;\n\n    v16i8 src0, src1, src2, src3, src4, src5, src6, src7, src8;\n\n    v16i8 src10_r, src32_r, src54_r, src76_r, src21_r, src43_r, src65_r;\n\n    v16i8 src87_r, src10_l, src32_l, src54_l, src76_l, src21_l, src43_l;\n\n    v16i8 src65_l, src87_l;\n\n    v8i16 out0_r, out1_r, out2_r, out3_r, out0_l, out1_l, out2_l, out3_l;\n\n    v16u8 res0, res1, res2, res3;\n\n    v16i8 filt0, filt1, filt2;\n\n\n\n    filt0 = (v16i8) __msa_fill_h(filt_const0);\n\n    filt1 = (v16i8) __msa_fill_h(filt_const1);\n\n    filt2 = (v16i8) __msa_fill_h(filt_const2);\n\n\n\n    LD_SB5(src, src_stride, src0, src1, src2, src3, src4);\n\n    src += (5 * src_stride);\n\n\n\n    XORI_B5_128_SB(src0, src1, src2, src3, src4);\n\n    ILVR_B4_SB(src1, src0, src2, src1, src3, src2, src4, src3,\n\n               src10_r, src21_r, src32_r, src43_r);\n\n    ILVL_B4_SB(src1, src0, src2, src1, src3, src2, src4, src3,\n\n               src10_l, src21_l, src32_l, src43_l);\n\n\n\n    for (loop_cnt = (height >> 2); loop_cnt--;) {\n\n        LD_SB4(src, src_stride, src5, src6, src7, src8);\n\n        src += (4 * src_stride);\n\n\n\n        XORI_B4_128_SB(src5, src6, src7, src8);\n\n        ILVR_B4_SB(src5, src4, src6, src5, src7, src6, src8, src7,\n\n                   src54_r, src65_r, src76_r, src87_r);\n\n        ILVL_B4_SB(src5, src4, src6, src5, src7, src6, src8, src7,\n\n                   src54_l, src65_l, src76_l, src87_l);\n\n        out0_r = DPADD_SH3_SH(src10_r, src32_r, src54_r, filt0, filt1, filt2);\n\n        out1_r = DPADD_SH3_SH(src21_r, src43_r, src65_r, filt0, filt1, filt2);\n\n        out2_r = DPADD_SH3_SH(src32_r, src54_r, src76_r, filt0, filt1, filt2);\n\n        out3_r = DPADD_SH3_SH(src43_r, src65_r, src87_r, filt0, filt1, filt2);\n\n        out0_l = DPADD_SH3_SH(src10_l, src32_l, src54_l, filt0, filt1, filt2);\n\n        out1_l = DPADD_SH3_SH(src21_l, src43_l, src65_l, filt0, filt1, filt2);\n\n        out2_l = DPADD_SH3_SH(src32_l, src54_l, src76_l, filt0, filt1, filt2);\n\n        out3_l = DPADD_SH3_SH(src43_l, src65_l, src87_l, filt0, filt1, filt2);\n\n        SRARI_H4_SH(out0_r, out1_r, out2_r, out3_r, 5);\n\n        SAT_SH4_SH(out0_r, out1_r, out2_r, out3_r, 7);\n\n        SRARI_H4_SH(out0_l, out1_l, out2_l, out3_l, 5);\n\n        SAT_SH4_SH(out0_l, out1_l, out2_l, out3_l, 7);\n\n        PCKEV_B4_UB(out0_l, out0_r, out1_l, out1_r, out2_l, out2_r, out3_l,\n\n                    out3_r, res0, res1, res2, res3);\n\n        XORI_B4_128_UB(res0, res1, res2, res3);\n\n\n\n        ST_UB4(res0, res1, res2, res3, dst, dst_stride);\n\n        dst += (4 * dst_stride);\n\n\n\n        src10_r = src54_r;\n\n        src32_r = src76_r;\n\n        src21_r = src65_r;\n\n        src43_r = src87_r;\n\n        src10_l = src54_l;\n\n        src32_l = src76_l;\n\n        src21_l = src65_l;\n\n        src43_l = src87_l;\n\n        src4 = src8;\n\n    }\n\n}\n", "idx": 7066, "substitutes": {"src": ["iv", "rs", "loc", "ser", "sr", "tp", "cont", "sys", "sc", "rx", "sort", "addr", "inst", "stat", "seek", "ind", "sync", "usr", "tr", "std", "input", "rc", "ins", "syn", "sb", "s", "dist", "rt", "sl", "rl", "stream", "st", "sub", "sn", "serv", "img", "ptr", "scan", "ul", "supp", "cur", "dest", "ctr", "RC", "source"], "src_stride": ["src2bride", "src2strride", "src2stride", "src_strade", "src_strride", "src_trade", "src_Strride", "src_specice", "src_trride", "src2strIDE", "src_striride", "src_brude", "src_Strice", "src_Strate", "src2brride", "src_brade", "src_Strider", "src_StrIDE", "src_Stride", "src_strIDE", "src_brride", "src_strider", "src_brider", "src_brice", "src_striade", "src_specider", "src2brIDE", "src_striide", "src_strate", "src_brate", "src_strice", "src_bride", "src2strate", "src_striude", "src_strude", "src_brIDE", "src_specate", "src_nameide", "src_nameate", "src_nameIDE", "src_specide", "src_trude", "src2brate", "src_tride", "src_nameride"], "dst": ["indest", "Dput", "inest", "dest", "ddest", "dput", "inst", "Dest", " dput", " ddest", " dest", "Dst", "Ddest", "input"], "dst_stride": ["dst_tride", "dst_strend", "dst_brride", "dst_decend", "dst_bride", "dst_decide", "dst_trade", "dst_strade", "dst_trride", "dst_brend", "dst_strride", "dst_trend", "dst_brade", "dst_decade", "dst_decride"], "height": ["depth", "read", "chain", "padding", "grow", "Height", "window", "step", "shift", "buffer", "base", "rank", "std", "sty", "scale", "style", "kw", "mode", "max", "angle", "dim", "block", "count", "shape", "size", "ctr", "resolution"], "loop_cnt": ["loop_lcst", "loop_gcst", "loop_gcnt", "loop_gcpt", "loop_bcst", "loop_bctxt", "loop_cst", "loop_lcpt", "loop_ctxt", "loop_lcnt", "loop_cpt", "loop_bcpt", "loop_bcnt", "loop_lctxt", "loop_gctxt"], "src0": ["rc4", " src00", "source2", "rc00", "rc2", "sr0", "rc3", "source3", "rc1", "sr00", "source1", "src00", "rc0", "source4", "source0", "sr1"], "src1": ["rc4", "source2", "sys2", "rc2", "source01", "sys0", "src01", "rc3", "sys3", " src11", "sys1", "source3", "src11", "rc1", " src01", "source11", "source1", "rc01", "rc0", "rc11", "source4", "source0"], "src2": ["rc4", "sourceor", "source2", "srcor", " src02", "rc2", "ser2", "rc5", "rc3", "source5", "source3", "rc1", "source02", "src02", "ser02", " srcor", "rc02", "source1", "ser1", "rcor", "rc0", "ser5", "source0", "ser3", "ser4"], "src3": ["rc4", "sc5", "source2", "rc2", "rc23", "rc5", "sc3", " src23", "sc03", "rc3", "source5", "source03", "source3", "src03", "source23", "rc03", "rc0", " src03", "source4", "source0", "sc2", "src23"], "src4": ["rc4", "sc6", "inst4", "source2", "rc40", " src44", "srcN", "rc2", "src40", " src40", "rc5", "rc3", "source5", "inst04", "inst6", "sourceN", "rc6", "source3", " srcN", "source40", "sc4", "source44", "rcN", "rc04", "src04", "sc04", "source4", "src44", "inst2", "sc2", "rc44"], "src5": ["source5", "ser05", "ser65", "ser25", "src65", "source05", "src05", "src25", "ser5", "inst25", "source25", "inst65", "inst05", "inst5", "source65"], "src6": ["source6", "source7", "inst66", "inst6", "rc6", "rc66", "rc7", "inst8", "src66", "inst7", "source8", "source66", "rc8"], "src7": ["source6", "source7", "rc6", "rc7", "rc13", "source8", "src13", "rc8", " src13", "source13"], "src8": ["src9", "source7", "rc16", " src9", " src16", "src16", "rc9", "rc7", "source16", "source9", "source8", "rc8"], "src10_r": ["src10_lr", "src90_r", "src90_p", "src90_l", "src90_lr", "src10_p"], "src32_r": ["src322r", "src64_l", "src31_r", "src64_ro", "src32_ro", "src31_R", "src32_ar", "src64_ar", "src322ro", "src31_ro", "src64_r", "src32Yl", "src322R", "src32Yr", "src31_l", "src32Yar", "src32Yro", "src322l", "src32_R"], "src54_r": ["src54___rt", "src03_rt", "src54_rt", "src54___rb", "src54___r", "src54___l", "src54_rb", "src03_l", "src03_r", "src03_rb"], "src76_r": ["src76_rb", "src75_r", "src75_rc", "src76_rc", "src75_l", "src75_rb"], "src21_r": ["src32_ro", "src21_p", "src23_r", "src21_R", "src23_R", "src32_m", "src21_m", "src23_l", "src21_ro", "src23_p"], "src43_r": ["src65_h", "src43_R", "src43_rel", "src43_h", "src43_p", "src65_p"], "src65_r": ["src45_er", "src45_r", "src65_rb", "src45_l", "src65_er", "src45_rb"], "src87_r": ["src87_p", "src872p", "src97_l", "src872r", "src87_rs", "src872rs", "src97_r", "src97_rs", "src97_p", "src872l"], "src10_l": ["src10_li", "src10Timel", "src10Timeml", "src36_le", "src10Timele", "src10_le", "src36_li", "src10_ml", "src36_l", "src36_ml", "src10Timeli"], "src32_l": ["src10___r", "src32___l", "src10___el", "src32_la", "src32___la", "src10___la", "src10_el", "src32__el", "src10___l", "src32__l", "src32__r", "src32___el", "src32__la", "src10_la", "src32_el", "src32___r"], "src54_l": ["src54_lp", "src52_L", "src54___lin", "src52_lin", "src54_lin", "src52_lp", "src54___L", "src52_l", "src54___l", "src54___lp", "src54_L"], "src76_l": ["src76_le", "src76_kl", "src75_kl", "src75_le", "src76_L", "src75_L", "src75_l"], "src21_l": ["src21Pr", "src21_lb", "src21ingl", "src48inglb", "src21ingr", "src48_l", "src21inglb", "src48ingr", "src48_ls", "src21Plb", "src21_ls", "src48ingls", "src21Pl", "src21Pls", "src48_r", "src48ingl", "src48_lb", "src21ingls"], "src43_l": ["src74_l", "src43_lb", "src74_li", "src43_li", "src74_lb", "src43_L", "src74_L"], "src65_l": ["src65_h", "src20ablela", "src65ablela", "src20_m", "src20ablel", "src65ableh", "src20ableh", "src65ablem", "src65_m", "src65ablel", "src20_h", "src20_la", "src20ablem", "src65_la", "src20_l"], "src87_l": ["src77_l", "src77_ll", "src77_li", "src87_li", "src87___l", "src87_ll", "src87___r", "src87___ll", "src77_r", "src87___li"], "out0_r": ["out0_h", "out10_b", "out0_b", "out10_p", "out10_r", "out0rh", "out0rp", "out0rb", "out0_p", "out0rr", "out10_h"], "out1_r": ["out5_ro", "out1_rd", "out5_rd", "out1_dr", "out1_ro", "out5_r", "out5_dr"], "out2_r": ["out1_hr", "out1_rs", "out2_rs", "out2_hr"], "out3_r": ["out3_n", "out3_sr", "out43_r", "out367sr", "out367l", "out367n", "out43_n", "out367r", "out43_l", "out43_sr"], "out0_l": ["out0_L", "out2_m", "out2_L", "out0_n", "out2_n", "out0_m"], "out1_l": ["out3_m", "out3_b", "out1_m", "out3_w", "out1_w", "out1_b"], "out2_l": ["out1_li", "out2ptm", "out2_e", "out1_e", "out1_m", "out2_li", "out2pte", "out2ptli", "out2_m", "out2ptl"], "out3_l": ["out300j", "out3_pl", "out3___l", "out12___j", "out12_j", "out3___j", "out300la", "out300pl", "out12_la", "out12___pl", "out12___la", "out12_pl", "out3_la", "out12_l", "out3_j", "out3___pl", "out12___l", "out3___la", "out300l"], "res0": ["Res2", "Res1", "pres0", "pres1", "Res0", "pres2"], "res1": ["Res01", "crit01", "resone", "Res1", "rand8", "crit8", "res01", "randone", "Resone", "critone", "Res8", "crit1", "rand1", "rand01", "res8"], "res2": [" res8", "losstwo", "loss1", "restwo", "pres1", "loss8", "pres8", "prestwo", " restwo", "pres2", "loss2", "res8"], "res3": ["RES43", " res43", " res8", "err3", "res15", "res43", "RES3", "RES8", "RES15", "err15", "err8", " res15", "err43", "res8"], "filt0": ["filt5", "ffilter5", "flt1", "flift2", "filtration0", "fift1", "flilt1", "flift0", "filt6", "flt2", "flilt2", "fift6", "flet0", "vilt0", "flet1", "vilt1", "flt0", "felt2", "viltration0", "vilt2", "flilt0", "viltration2", "flet2", "viltration1", "fift0", "filtration1", "felt5", "viltration5", "flift6", "ffilter2", "flt6", "ffilter0", "fift2", "flilt6", "ffilter1", "felt1", "filtration5", "filtration2", "flet6", "vilt5", "flift1", "felt0"], "filt1": ["falt5", "filt5", "fil0", "fld3", " fldOne", " fld1", "fault1", "filtOne", " filt4", "faultOne", " filtOne", "filtration3", " fld3", "fond0", " fil1", " fil0", " filt3", "fault4", "filtrationOne", "fil1", "filt4", " fil5", " fil3", "filtration4", "falt0", "fld1", "fond3", "filtration1", "falt3", "fil3", "fld4", "fault3", "fond1", " filt5", " fld4", "falt1", "fldOne", "filt3", "fond5", "fil5"], "filt2": ["facilt2", "filtration22", "fault1", "vilt3", "faciltrationSecond", "fot2", "fitt1", "fitt2", "fitt3", "vaultL", "facilt22", "fittSecond", "faciltration4", "filtL", "viltL", "vault1", "fotSecond", "vilt1", "vault2", "faciltration22", "vilt2", "filt4", "faltL", "filt22", "faciltSecond", "filtration4", "fot4", "facilt4", "filtSecond", "fot22", "falt3", "fault3", "faultL", "filtrationSecond", "fault2", "fitt22", "fitt4", "falt2", "vault3", "fittL", "filtration2", "falt1", "filt3", "faciltration2"]}}
{"project": "qemu", "commit_id": "6b33f3ae8b79726ef0812597b8a83c3e82d31514", "target": 0, "func": "static int img_commit(int argc, char **argv)\n\n{\n\n    int c, ret, flags;\n\n    const char *filename, *fmt, *cache, *base;\n\n    BlockBackend *blk;\n\n    BlockDriverState *bs, *base_bs;\n\n    bool progress = false, quiet = false, drop = false;\n\n    bool writethrough;\n\n    Error *local_err = NULL;\n\n    CommonBlockJobCBInfo cbi;\n\n    bool image_opts = false;\n\n    AioContext *aio_context;\n\n\n\n    fmt = NULL;\n\n    cache = BDRV_DEFAULT_CACHE;\n\n    base = NULL;\n\n    for(;;) {\n\n        static const struct option long_options[] = {\n\n            {\"help\", no_argument, 0, 'h'},\n\n            {\"object\", required_argument, 0, OPTION_OBJECT},\n\n            {\"image-opts\", no_argument, 0, OPTION_IMAGE_OPTS},\n\n            {0, 0, 0, 0}\n\n        };\n\n        c = getopt_long(argc, argv, \"f:ht:b:dpq\",\n\n                        long_options, NULL);\n\n        if (c == -1) {\n\n            break;\n\n        }\n\n        switch(c) {\n\n        case '?':\n\n        case 'h':\n\n            help();\n\n            break;\n\n        case 'f':\n\n            fmt = optarg;\n\n            break;\n\n        case 't':\n\n            cache = optarg;\n\n            break;\n\n        case 'b':\n\n            base = optarg;\n\n            /* -b implies -d */\n\n            drop = true;\n\n            break;\n\n        case 'd':\n\n            drop = true;\n\n            break;\n\n        case 'p':\n\n            progress = true;\n\n            break;\n\n        case 'q':\n\n            quiet = true;\n\n            break;\n\n        case OPTION_OBJECT: {\n\n            QemuOpts *opts;\n\n            opts = qemu_opts_parse_noisily(&qemu_object_opts,\n\n                                           optarg, true);\n\n            if (!opts) {\n\n                return 1;\n\n            }\n\n        }   break;\n\n        case OPTION_IMAGE_OPTS:\n\n            image_opts = true;\n\n            break;\n\n        }\n\n    }\n\n\n\n    /* Progress is not shown in Quiet mode */\n\n    if (quiet) {\n\n        progress = false;\n\n    }\n\n\n\n    if (optind != argc - 1) {\n\n        error_exit(\"Expecting one image file name\");\n\n    }\n\n    filename = argv[optind++];\n\n\n\n    if (qemu_opts_foreach(&qemu_object_opts,\n\n                          user_creatable_add_opts_foreach,\n\n                          NULL, NULL)) {\n\n        return 1;\n\n    }\n\n\n\n    flags = BDRV_O_RDWR | BDRV_O_UNMAP;\n\n    ret = bdrv_parse_cache_mode(cache, &flags, &writethrough);\n\n    if (ret < 0) {\n\n        error_report(\"Invalid cache option: %s\", cache);\n\n        return 1;\n\n    }\n\n\n\n    blk = img_open(image_opts, filename, fmt, flags, writethrough, quiet);\n\n    if (!blk) {\n\n        return 1;\n\n    }\n\n    bs = blk_bs(blk);\n\n\n\n    qemu_progress_init(progress, 1.f);\n\n    qemu_progress_print(0.f, 100);\n\n\n\n    if (base) {\n\n        base_bs = bdrv_find_backing_image(bs, base);\n\n        if (!base_bs) {\n\n            error_setg(&local_err, QERR_BASE_NOT_FOUND, base);\n\n            goto done;\n\n        }\n\n    } else {\n\n        /* This is different from QMP, which by default uses the deepest file in\n\n         * the backing chain (i.e., the very base); however, the traditional\n\n         * behavior of qemu-img commit is using the immediate backing file. */\n\n        base_bs = backing_bs(bs);\n\n        if (!base_bs) {\n\n            error_setg(&local_err, \"Image does not have a backing file\");\n\n            goto done;\n\n        }\n\n    }\n\n\n\n    cbi = (CommonBlockJobCBInfo){\n\n        .errp = &local_err,\n\n        .bs   = bs,\n\n    };\n\n\n\n    aio_context = bdrv_get_aio_context(bs);\n\n    aio_context_acquire(aio_context);\n\n    commit_active_start(\"commit\", bs, base_bs, BLOCK_JOB_DEFAULT, 0,\n\n                        BLOCKDEV_ON_ERROR_REPORT, common_block_job_cb, &cbi,\n\n                        &local_err, false);\n\n    aio_context_release(aio_context);\n\n    if (local_err) {\n\n        goto done;\n\n    }\n\n\n\n    /* When the block job completes, the BlockBackend reference will point to\n\n     * the old backing file. In order to avoid that the top image is already\n\n     * deleted, so we can still empty it afterwards, increment the reference\n\n     * counter here preemptively. */\n\n    if (!drop) {\n\n        bdrv_ref(bs);\n\n    }\n\n\n\n    run_block_job(bs->job, &local_err);\n\n    if (local_err) {\n\n        goto unref_backing;\n\n    }\n\n\n\n    if (!drop && bs->drv->bdrv_make_empty) {\n\n        ret = bs->drv->bdrv_make_empty(bs);\n\n        if (ret) {\n\n            error_setg_errno(&local_err, -ret, \"Could not empty %s\",\n\n                             filename);\n\n            goto unref_backing;\n\n        }\n\n    }\n\n\n\nunref_backing:\n\n    if (!drop) {\n\n        bdrv_unref(bs);\n\n    }\n\n\n\ndone:\n\n    qemu_progress_end();\n\n\n\n    blk_unref(blk);\n\n\n\n    if (local_err) {\n\n        error_report_err(local_err);\n\n        return 1;\n\n    }\n\n\n\n    qprintf(quiet, \"Image committed.\\n\");\n\n    return 0;\n\n}\n", "idx": 7069, "substitutes": {"argc": ["argumentl", "opv", "argumentcs", " argb", "argscs", " argl", "opcs", "optc", "argcs", " argp", "argumentc", "argl", "opc", "optlc", "opp", "axv", "argumentv", "argumentlc", "axc", "optv", "argp", "argb", " arglc", "arglc", " argcs", "argumentb", "axb", "optl", "argsp", "axcs", "argsv", "argsc"], "argv": ["calw", "argsk", "calc", " argk", " argp", "targetf", "calvs", "argk", "argw", "argvs", "argsf", "Argc", "targetv", "calv", "argsvs", "argp", "Argp", " argw", " argvs", "targetk", "Argv", "argsw", "Argf", "targetc", "argf", " argf", "argsp", "argsv", "argsc"], "c": ["cf", "dc", "gc", "ct", "b", "cp", "u", "pc", "h", "ctx", "cmp", "bc", "cont", "i", "con", "cs", "fc", "d", "g", "co", "p", "n", "unc", "nc", "ec", "ind", "cb", "lc", "ce", "t", "r", "col", "cc", "rc", "arc", "k", "code", "cn", "v", "m", "uc", "ac", "cd", "count", "mc", "f", "cur", "abc", "C", "e", "z", "cu", "l", "inc", "tc"], "ret": ["result", "cont", "rel", "nt", "ext", "len", "val", "std", "usr", "fp", "alt", "rc", "out", "txt", "reset", "fin", "fun", "resp", "new", "status", "RET", "desc", "Ret", "fi", "conv", "res", "fd"], "flags": ["members", "fields", "weights", "times", "wcs", "ags", "locks", "cs", "files", "fc", "actions", "ps", "cmd", "settings", "vals", "errors", "types", "options", "events", "mode", "grades", "properties", "stats", "tags", "args", "bits", "status", "acl", "Flags", "FLAG", "states", "mask", "fs", "heads", "links", "comments", "features", "ops", "flag"], "filename": ["b", "prefix", "src", "metadata", "target", "wcs", "binary", "buf", "description", "file", "files", "buffer", "ename", "ame", "location", "url", "fp", "username", "ames", "fil", "nm", "bf", "txt", "fn", "dir", "Filename", "tmp", "f", "fs", "family", "source", "bas", "title", "name", "path"], "fmt": ["Fformat", "bformat", "Fwt", "tfancy", "fformat", "formfm", "ffm", "Fancy", "bmt", " fformat", "tfformat", " fancy", " fwt", "flt", "fancy", "tflt", "Fmt", "formlt", "bwt", "Flt", " ffm", " flt", "blt", "formformat", "fwt", "tfmt", "formmt", "Ffm"], "cache": ["depth", "ache", "dc", "chain", "cas", "prefix", "mem", "cp", "conf", "store", "cs", "client", "Cache", "file", "buffer", "path", "force", "table", "util", "temp", "ach", "position", "limit", "coll", "aches", "acher", "master", "options", "timeout", "dirty", "memory", "config", "ac", "dir", "comment", "local", "storage", "ca", "size", "format", "cu", "acl", "source", "miss"], "base": ["db", "chain", "b", "root", "prefix", "quote", "back", "based", "scope", "offset", "bottom", "state", "sys", "file", "buffer", "force", "template", "profile", "history", "key", "server", "scale", "Base", "bare", "memory", "dir", "local", "storage", "parent", "alias", "area", "size", "bas", "origin", "format", "source", "ase", "name", "path", "bin"], "blk": ["BLK", "blK", " blK", " blks", " blj", "slk", "slks", "BLk", "slj", "BLj", "blj", "BLks", "slK", "blks"], "bs": ["gs", "ubs", "its", "bos", "bc", "cs", "bh", "ps", "bp", "bd", "ts", "ds", "BS", "cb", "bi", "bb", "blocks", "sb", "outs", "vs", "ss", "bl", "fs", "sts", "bm", "obs", "bas", "lbs"], "base_bs": ["base_sb", "base_fs", " base_fs", "base_gs", " base_gs", " base_sb"], "writethrough": ["writethough", "writertough", "createthrown", "writertost", "createnthough", "writenthrough", "writetrough", "writertrough", "writenthrown", "writethost", "writethrown", "createthost", "createnthost", "createthrough", "createnthrown", "writetost", "writetrown", "writertrown", "createthough", "writenthough", "writetough", "createnthrough", "writenthost"], "local_err": ["local_error", "local___error", "localjerror", "shared_cb", "local_progress", "localjprogress", "shared_progress", "shared_error", "shared_err", "local___err", "localjcb", "local_cb", "local___progress", "localjerr", "local___cb"], "cbi": ["cbf", "bcbi", "fbid", "tbid", "fbm", "cbid", "tbm", "cbm", "tbi", "fbi", "bcbid", "fbf", "bcbm", "tbf", "bcbf"], "aio_context": ["aioopinfo", "aio_Context", "aio2Context", "aios_info", "aio2ctx", "aio2info", "aios_Context", "aio2context", "aioopcontext", "aioopctx", "aioopContext", "aios_context", "aio_info", "aio_ctx", "aios_ctx"], "long_options": ["long_values", " long2options", "long2flags", " long2flags", " long2option", " long_option", "long_option", "long67option", "long2options", " long_flags", "long2types", " long_types", "long_types", " long2types", "long_flags", "long67types", "long2values", " long2values", " long_values", "long67flags", "long67options", "long2option"], "opts": ["ropcs", "alts", "OPTS", "iopps", "opTS", "OPters", " ops", " opters", "altions", "optts", "optters", "iopcs", "iopts", "opcs", "opports", "opsts", "ioptions", "OPcs", "ropts", " opsts", "alcs", "opents", "openTS", "opens", "OPs", "options", "optports", " opTS", " opports", "OPports", "OPts", "alps", "roptions", "OPsts", "opps", "optcs", "opters", "ropps", " opcs", "ops", "opensts"]}}
{"project": "qemu", "commit_id": "b2bedb214469af55179d907a60cd67fed6b0779e", "target": 0, "func": "unsigned long setup_arg_pages(void * mh, char ** argv, char ** env)\n\n{\n\n    unsigned long stack_base, error, size;\n\n    int i;\n\n    int * stack;\n\n    int argc, envc;\n\n\n\n    /* Create enough stack to hold everything.  If we don't use\n\n     * it for args, we'll use it for something else...\n\n     */\n\n    size = stack_size;\n\n\n\n    error = target_mmap(0,\n\n                        size + qemu_host_page_size,\n\n                        PROT_READ | PROT_WRITE,\n\n                        MAP_PRIVATE | MAP_ANONYMOUS,\n\n                        -1, 0);\n\n    if (error == -1)\n\n        qerror(\"stk mmap\");\n\n\n\n    /* we reserve one extra page at the top of the stack as guard */\n\n    target_mprotect(error + size, qemu_host_page_size, PROT_NONE);\n\n\n\n    stack_base = error + size;\n\n    stack = (void*)stack_base;\n\n/*\n\n *    | STRING AREA |\n\n *    +-------------+\n\n *    |      0      |\n\n*    +-------------+\n\n *    |  apple[n]   |\n\n *    +-------------+\n\n *           :\n\n *    +-------------+\n\n *    |  apple[0]   |\n\n *    +-------------+\n\n *    |      0      |\n\n *    +-------------+\n\n *    |    env[n]   |\n\n *    +-------------+\n\n *           :\n\n *           :\n\n *    +-------------+\n\n *    |    env[0]   |\n\n *    +-------------+\n\n *    |      0      |\n\n *    +-------------+\n\n *    | arg[argc-1] |\n\n *    +-------------+\n\n *           :\n\n *           :\n\n *    +-------------+\n\n *    |    arg[0]   |\n\n *    +-------------+\n\n *    |     argc    |\n\n *    +-------------+\n\n * sp->    |      mh     | address of where the a.out's file offset 0 is in memory\n\n *    +-------------+\n\n*/\n\n    /* Construct the stack Stack grows down */\n\n    stack--;\n\n\n\n    /* XXX: string should go up there */\n\n\n\n    *stack = 0;\n\n    stack--;\n\n\n\n    /* Push the absolute path of our executable */\n\n    DPRINTF(\"pushing apple %s (0x%x)\\n\", (char*)argv[0], (int)argv[0]);\n\n    stl(stack, (int) argv[0]);\n\n\n\n    stack--;\n\n\n\n    stl(stack, 0);\n\n    stack--;\n\n\n\n    /* Get envc */\n\n    for(envc = 0; env[envc]; envc++);\n\n\n\n    for(i = envc-1; i >= 0; i--)\n\n    {\n\n        DPRINTF(\"pushing env %s (0x%x)\\n\", (char*)env[i], (int)env[i]);\n\n        stl(stack, (int)env[i]);\n\n        stack--;\n\n\n\n        /* XXX: remove that when string will be on top of the stack */\n\n        page_set_flags((int)env[i], (int)(env[i]+strlen(env[i])), PROT_READ | PAGE_VALID);\n\n    }\n\n\n\n    /* Add on the stack the interp_prefix choosen if so */\n\n    if(interp_prefix[0])\n\n    {\n\n        char *dyld_root;\n\n        asprintf(&dyld_root, \"DYLD_ROOT_PATH=%s\", interp_prefix);\n\n        page_set_flags((int)dyld_root, (int)(dyld_root+strlen(interp_prefix)+1), PROT_READ | PAGE_VALID);\n\n\n\n        stl(stack, (int)dyld_root);\n\n        stack--;\n\n    }\n\n\n\n#ifdef DONT_USE_DYLD_SHARED_MAP\n\n    {\n\n        char *shared_map_mode;\n\n        asprintf(&shared_map_mode, \"DYLD_SHARED_REGION=avoid\");\n\n        page_set_flags((int)shared_map_mode, (int)(shared_map_mode+strlen(shared_map_mode)+1), PROT_READ | PAGE_VALID);\n\n\n\n        stl(stack, (int)shared_map_mode);\n\n        stack--;\n\n    }\n\n#endif\n\n\n\n#ifdef ACTIVATE_DYLD_TRACE\n\n    char * extra_env_static[] = {\"DYLD_DEBUG_TRACE=yes\",\n\n    \"DYLD_PREBIND_DEBUG=3\", \"DYLD_UNKNOW_TRACE=yes\",\n\n    \"DYLD_PRINT_INITIALIZERS=yes\",\n\n    \"DYLD_PRINT_SEGMENTS=yes\", \"DYLD_PRINT_REBASINGS=yes\", \"DYLD_PRINT_BINDINGS=yes\", \"DYLD_PRINT_INITIALIZERS=yes\", \"DYLD_PRINT_WARNINGS=yes\" };\n\n\n\n    char ** extra_env = malloc(sizeof(extra_env_static));\n\n    bcopy(extra_env_static, extra_env, sizeof(extra_env_static));\n\n    page_set_flags((int)extra_env, (int)((void*)extra_env+sizeof(extra_env_static)), PROT_READ | PAGE_VALID);\n\n\n\n    for(i = 0; i<9; i++)\n\n    {\n\n        DPRINTF(\"pushing (extra) env %s (0x%x)\\n\", (char*)extra_env[i], (int)extra_env[i]);\n\n        stl(stack, (int) extra_env[i]);\n\n        stack--;\n\n    }\n\n#endif\n\n\n\n    stl(stack, 0);\n\n    stack--;\n\n\n\n    /* Get argc */\n\n    for(argc = 0; argv[argc]; argc++);\n\n\n\n    for(i = argc-1; i >= 0; i--)\n\n    {\n\n        DPRINTF(\"pushing arg %s (0x%x)\\n\", (char*)argv[i], (int)argv[i]);\n\n        stl(stack, (int) argv[i]);\n\n        stack--;\n\n\n\n        /* XXX: remove that when string will be on top of the stack */\n\n        page_set_flags((int)argv[i], (int)(argv[i]+strlen(argv[i])), PROT_READ | PAGE_VALID);\n\n    }\n\n\n\n    DPRINTF(\"pushing argc %d \\n\", argc);\n\n    stl(stack, argc);\n\n    stack--;\n\n\n\n    DPRINTF(\"pushing mh 0x%x \\n\", (int)mh);\n\n    stl(stack, (int) mh);\n\n\n\n    /* Stack points on the mh */\n\n    return (unsigned long)stack;\n\n}\n", "idx": 7099, "substitutes": {"mh": ["mmth", "mmhs", " mhs", "mmph", "mmh", "bmph", "bmh", "bmhs", "mph", "mth", "mhs", " mph", "bmth", " mth"], "argv": ["packvs", " argl", "cmdc", "packv", " argp", "argumentc", " argvin", "arp", "argl", "cmdv", "argsvin", "argvs", "packvin", "argumentp", "argumentv", "cmdp", "arc", "packc", "argsvs", "argsl", "argp", "argumentvs", "arvs", " argvs", "argvin", "arv", "cmdl", "argsp", "argsv", "argsc"], "env": ["conf", "ped", "buf", "nd", "vert", "ec", "dev", "environment", "gear", "en", "iter", "txt", "req", "worker", "tmp", "test", "ten", "stage", "ter", "ve", "er", "gn", "context", "server", "esp", "code", "v", "config", "vs", "desc", "priv", "np", "pres", "menu", "db", "ev", "et", "end", "ctx", "map", "dict", "var", "viron", "kw", "eq", "nv", "cv", "ver", "init", "result", "app", "call", "window", "here", "ext", "cmd", "etc", "vp", "ew", "vel", "proc", "args", "tx", "doc", "ee", "vt", "obj", "arg", "qt", "e", "global", "wd", "def"], "stack_base": ["stack2Base", "stack2base", "line_base", "ack__bal", "stack_Base", "stack_size", "stack67bal", "stack67size", "stack__size", "stack67bas", "stack__base", "ack_bas", "line_Base", "stack67base", "ack_base", "stack_buffer", " stack_buffer", " stack_size", "stack2size", "stack_bal", "line_buffer", "ack_size", "stack__bas", "stack__bal", "ack__size", "ack__bas", "ack__base", "stack2bottom", "line_bottom", "ack_bal", "stack2buffer", "stack_bas", "stack_bottom"], "error": ["success", "result", "match", "event", "empty", "type", "offset", "alpha", "force", "exc", "er", "base", "order", "rank", "no", "or", "option", "index", "total", "red", "errors", "scale", "err", "r", "rc", "ref", "ignore", "debug", "ERROR", "style", "danger", "mode", "code", "max", "change", "angle", "iso", "ack", "frame", "ror", "owner", "parse", "alias", "bug", "fail", "info", "e", "check", "length", "lock", "Error", "relation", "detail", "problem"], "size": ["large", "padding", "grow", "empty", "SIZE", "window", "fee", "sha", "shift", "Size", "scope", "g", "si", "zone", "n", "notice", "len", "network", "zero", "total", "pi", "height", "scale", "space", "style", "send", "password", "dimension", "max", "normal", "dim", "mode", "code", "small", "scroll", "percent", "sn", "south", "storage", "area", "capacity", "count", "shape", "sum", "ize", "time", "global", "length", "z", "format", "name", "speed"], "i": ["ic", "ini", "ij", "ei", "uri", "ci", " ii", "it", "im", "c", "u", "cli", "oi", "gi", "mi", "qi", "ip", "li", "p", "si", "ami", "zi", "is", "xi", "ind", "index", "o", " ti", "t", "pi", "bi", "multi", "hi", "ri", "me", "ui", "id", "ji", " I", "k", "phi", "ti", "v", "ix", " j", "ai", "m", "status", "wi", "I", "remote", "y", "fi", "sim", "gu", "iu", "e", "in", "j", "x", "\u0438", "di", "ii"], "stack": ["upper", "package", "depth", "tree", "sp", "chain", "thread", "function", "call", "wait", "window", "end", "stage", "null", "pack", "shift", "back", "scope", "set", "store", "buffer", "profile", "base", "pop", "track", "var", "context", "row", "index", "queue", "line", "history", "alt", "func", "height", "trace", "str", "push", "slice", "pos", "list", "space", "acks", "top", "mount", "level", "wall", "iter", "out", "v", "code", "where", "ack", "frame", "block", "st", "load", "scroll", "batch", "storage", "Stack", "cache", "loop", "arg", "engine", "hash", "check", "roll", "tc"], "argc": ["Argcc", "argcs", "Argc", "parc", "parcount", "argcount", " argcount", " argcc", "parcs", "parcc", "argcc", "Argcount", "Argcs", " argcs"], "envc": ["ptrcy", "enC", "terc", " envce", "evc", "portc", "varc", "envC", "ptrci", "varC", "envu", "nerc", "enl", "varuc", "terp", " envci", "evz", " envcy", "environmentcu", "portu", " envC", "nerC", "envuc", "environmentC", "envz", " envsc", "enuc", "nerci", "environmentuc", "environmentci", "nerp", "environmentp", "evC", "envsc", "terC", "environmentc", "environmentz", "evce", " envz", "portcu", "envce", "evsc", "envcu", "envl", "envci", "varl", "terci", "environmentce", "evci", "environmentl", "evcy", "ptrC", "portci", "environmentsc", "envcy", "enc", " envcu", "ptrc", "envp", "environmentu", " envu"], "dyld_root": ["dyldtoot", "dyld___index", "dyld_oot", "dyld__prefix", "dyland_prefix", "dyll_prefix", "dyld__root", "dyld_roots", "dyld__home", "dyldtparent", "dyll_home", "dyland___prefix", "dyld__parent", "dyll_root", "dyild_root", "dyll_parent", "dyland_root", "dyland_start", "dyland___start", "dyldtroot", "dyll_oot", "dyldtprefix", "dyland_index", "dyld_home", "dyld_parent", "dyland___root", "dyland___index", "dyild_oot", "dyild_parent", "dyld___prefix", "dyld___start", "dyld___root", "dyll_roots", "dyld_prefix", "dyld_index", "dyld_start", "dyild_prefix"], "shared_map_mode": ["shared_map___default", "shared_prearg", "shared_block_", "shared_pre_", "shared_map__key", "shared_map_mask", "shared_map__type", "shared_map_key", "shared_map_", "shared_map__mode", "shared_map_default", "shared_maparg", "shared_map___type", "shared_map__default", "shared_map___mask", "shared_map___mode", "shared_map_type", "shared_blockarg"]}}
{"project": "qemu", "commit_id": "10a412dab3f54439ea3d60274eb41668f7d83bd2", "target": 0, "func": "int sd_do_command(SDState *sd, SDRequest *req,\n\n                  uint8_t *response) {\n\n    uint32_t last_status = sd->card_status;\n\n    sd_rsp_type_t rtype;\n\n    int rsplen;\n\n\n\n    if (!sd->bdrv || !bdrv_is_inserted(sd->bdrv) || !sd->enable) {\n\n        return 0;\n\n    }\n\n\n\n    if (sd_req_crc_validate(req)) {\n\n        sd->card_status |= COM_CRC_ERROR;\n\n        rtype = sd_illegal;\n\n        goto send_response;\n\n    }\n\n\n\n    sd->card_status &= ~CARD_STATUS_B;\n\n    sd_set_status(sd);\n\n\n\n    if (last_status & CARD_IS_LOCKED) {\n\n        if (!cmd_valid_while_locked(sd, req)) {\n\n            sd->card_status |= ILLEGAL_COMMAND;\n\n            fprintf(stderr, \"SD: Card is locked\\n\");\n\n            rtype = sd_illegal;\n\n            goto send_response;\n\n        }\n\n    }\n\n\n\n    if (last_status & APP_CMD) {\n\n        rtype = sd_app_command(sd, *req);\n\n        sd->card_status &= ~APP_CMD;\n\n    } else\n\n        rtype = sd_normal_command(sd, *req);\n\n\n\n    if (rtype == sd_illegal) {\n\n        sd->card_status |= ILLEGAL_COMMAND;\n\n    }\n\n\n\n    sd->current_cmd = req->cmd;\n\n\n\nsend_response:\n\n    switch (rtype) {\n\n    case sd_r1:\n\n    case sd_r1b:\n\n        sd_response_r1_make(sd, response, last_status);\n\n        rsplen = 4;\n\n        break;\n\n\n\n    case sd_r2_i:\n\n        memcpy(response, sd->cid, sizeof(sd->cid));\n\n        rsplen = 16;\n\n        break;\n\n\n\n    case sd_r2_s:\n\n        memcpy(response, sd->csd, sizeof(sd->csd));\n\n        rsplen = 16;\n\n        break;\n\n\n\n    case sd_r3:\n\n        sd_response_r3_make(sd, response);\n\n        rsplen = 4;\n\n        break;\n\n\n\n    case sd_r6:\n\n        sd_response_r6_make(sd, response);\n\n        rsplen = 4;\n\n        break;\n\n\n\n    case sd_r7:\n\n        sd_response_r7_make(sd, response);\n\n        rsplen = 4;\n\n        break;\n\n\n\n    case sd_r0:\n\n    case sd_illegal:\n\n    default:\n\n        rsplen = 0;\n\n        break;\n\n    }\n\n\n\n#ifdef DEBUG_SD\n\n    if (rsplen) {\n\n        int i;\n\n        DPRINTF(\"Response:\");\n\n        for (i = 0; i < rsplen; i++)\n\n            printf(\" %02x\", response[i]);\n\n        printf(\" state %d\\n\", sd->state);\n\n    } else {\n\n        DPRINTF(\"No response %d\\n\", sd->state);\n\n    }\n\n#endif\n\n\n\n    return rsplen;\n\n}\n", "idx": 7105, "substitutes": {"sd": ["db", "draw", "form", "sp", "des", "sw", "ssl", "sg", "SD", "ell", "md", "def", "sam", "sys", "nd", "store", "sc", "d", "si", "sy", "dl", "bd", "gd", "ds", "ind", "dev", "ard", "std", "and", "se", "server", "js", "th", "san", "sv", "sb", "dll", "s", "od", "ad", "sec", "vd", "sk", "sh", "sl", "dd", "dist", "sa", "reg", "dk", "ss", "sn", "south", "amd", "cd", "sky", "desc", "mod", "pd", "sql", "sim", "hd", "decl", "td", "ld", "dis", "sta", "di", "fd", "sing"], "req": ["this", "q", "sp", "call", "task", "conf", "md", "ctx", "pro", "comm", "compl", "rx", "client", "sc", "msg", "seq", "ext", "ps", "cmd", "inv", "required", "iq", "ind", "aux", "r", "need", "js", "query", "ref", "crit", "proc", "expr", "pkg", "esp", "rb", "sec", "dist", "qq", "requ", "resp", "ack", "request", "reg", "config", "spec", "tx", "cond", "exec", "sq", "jp", "desc", "quest", "qt", "rec", "fr", "j", "res", "needed", "conn", "urg"], "response": ["output", "all", "service", "example", "result", "sp", "tree", "error", "des", "form", "window", "sol", "reply", "then", "description", "vector", "given", "ve", "os", "amount", "connection", "Response", "yes", "zero", "data", "r", "value", "trace", "rss", "pos", "application", "style", "send", "out", "v", "memory", "onse", "reset", "command", "frame", "resp", "request", "respons", "answer", "block", "entry", "version", "message", "res", "json", "definition", "def", "image", "sequence"], "rtype": ["ertype", "mrtype", "rdtype", "rrclass", "mvalue", "restyp", "rype", "rType", "regTYPE", "rotype", "rclass", "Rpe", "rrtyp", "trtry", "mrstyle", " rype", "vrtype", " rpe", " rfunction", " rtyp", "rstatus", "errype", " rtag", "erver", "vrtry", "Rtype", "trtype", "rrtry", " rclass", "errpe", " rstyle", "rstyle", "rdTYPE", "mype", "rdver", "restry", "rpe", "resype", "rvalue", " rstatus", "mrtag", "rver", "mrstatus", "rtimeout", "RType", "rfunction", "regtype", "trfunction", " rtry", " rType", "roTYPE", " rver", "regtyp", "resclass", "rtry", "rovalue", "errtype", "rdstyle", "rrstatus", "Rype", "erstyle", "rrstyle", " rtimeout", "mtype", "rTYPE", "resTYPE", "restype", "rtag", "trtimeout", "regclass", "vrtimeout", "vrfunction", " rTYPE", "rtyp", "roype", "rrtype", "mTYPE", "erclass", "erTYPE", "errType", "resvalue", "ertyp", "rrtag"], "rsplen": ["rysplag", "rspenenc", " rsplEN", " rsplize", "ryspalag", "rspalar", "rsplerent", "rysplens", "rspenoen", "rsplun", "rsflian", "csflian", "rsflen", "emssplien", "rsplens", "stsplen", "rsplerag", "rsclEN", "rspleden", " rsplun", "rspllen", "emssplen", "csflen", "csplen", "rsreplEN", "csfllen", "rsplenc", "rsplar", "rsreplen", "rsslen", "stspleener", " rsclun", "stspleen", "rspleEN", "stspleeth", "rspaloen", "rspenian", "rsPLen", "rsclen", "rspledEN", "stsplEN", "rspledun", "rspallen", "rysplien", "inspalian", "emsplen", "rspalent", "rsimplen", "rspenen", "rssplian", "rsplener", "rssplag", "rsploen", " rsclize", "rsclize", "emsplag", "rsplugeth", "rsPLlen", "rspleen", "rsclun", "inspalenc", "rsplerien", "rspalag", "rspledize", "rssplens", "ryspalens", "rsPLar", "rsfllen", "rsslener", "rsslEN", "rspalen", "inspaloen", "emssplent", "emsplien", "emsplent", "emssplag", "rsplEN", "rsplugener", "rssploen", "rspleren", "rsplag", "ryspalen", "rssplenc", "rspalian", "rsplian", "stsplener", "rsPLian", "rssplien", "rsreplize", "csflar", "rspleth", "rsflar", "rsplugen", "insplian", "rspleener", "stspleth", "ryspalien", " rsclen", "insploen", "insplenc", "stspleEN", "rysplen", "rsplugEN", "csplian", "rsplien", "insplen", "rsimplag", "rssplen", "rsreplun", " rsclEN", "rsimplien", "csplar", "rsimplens", "rsplize", "inspalen", "rspalien", "rssplent", "rspalenc", "rspleeth", "rspalens", "cspllen", "rsplent", "rssleth"]}}
{"project": "qemu", "commit_id": "9646f4927faf68e8690588c2fd6dc9834c440b58", "target": 0, "func": "void cpu_x86_cpuid(CPUX86State *env, uint32_t index, uint32_t count,\n\n                   uint32_t *eax, uint32_t *ebx,\n\n                   uint32_t *ecx, uint32_t *edx)\n\n{\n\n    X86CPU *cpu = x86_env_get_cpu(env);\n\n    CPUState *cs = CPU(cpu);\n\n    uint32_t pkg_offset;\n\n\n\n    /* test if maximum index reached */\n\n    if (index & 0x80000000) {\n\n        if (index > env->cpuid_xlevel) {\n\n            if (env->cpuid_xlevel2 > 0) {\n\n                /* Handle the Centaur's CPUID instruction. */\n\n                if (index > env->cpuid_xlevel2) {\n\n                    index = env->cpuid_xlevel2;\n\n                } else if (index < 0xC0000000) {\n\n                    index = env->cpuid_xlevel;\n\n                }\n\n            } else {\n\n                /* Intel documentation states that invalid EAX input will\n\n                 * return the same information as EAX=cpuid_level\n\n                 * (Intel SDM Vol. 2A - Instruction Set Reference - CPUID)\n\n                 */\n\n                index =  env->cpuid_level;\n\n            }\n\n        }\n\n    } else {\n\n        if (index > env->cpuid_level)\n\n            index = env->cpuid_level;\n\n    }\n\n\n\n    switch(index) {\n\n    case 0:\n\n        *eax = env->cpuid_level;\n\n        *ebx = env->cpuid_vendor1;\n\n        *edx = env->cpuid_vendor2;\n\n        *ecx = env->cpuid_vendor3;\n\n        break;\n\n    case 1:\n\n        *eax = env->cpuid_version;\n\n        *ebx = (cpu->apic_id << 24) |\n\n               8 << 8; /* CLFLUSH size in quad words, Linux wants it. */\n\n        *ecx = env->features[FEAT_1_ECX];\n\n        if ((*ecx & CPUID_EXT_XSAVE) && (env->cr[4] & CR4_OSXSAVE_MASK)) {\n\n            *ecx |= CPUID_EXT_OSXSAVE;\n\n        }\n\n        *edx = env->features[FEAT_1_EDX];\n\n        if (cs->nr_cores * cs->nr_threads > 1) {\n\n            *ebx |= (cs->nr_cores * cs->nr_threads) << 16;\n\n            *edx |= CPUID_HT;\n\n        }\n\n        break;\n\n    case 2:\n\n        /* cache info: needed for Pentium Pro compatibility */\n\n        if (cpu->cache_info_passthrough) {\n\n            host_cpuid(index, 0, eax, ebx, ecx, edx);\n\n            break;\n\n        }\n\n        *eax = 1; /* Number of CPUID[EAX=2] calls required */\n\n        *ebx = 0;\n\n        if (!cpu->enable_l3_cache) {\n\n            *ecx = 0;\n\n        } else {\n\n            *ecx = L3_N_DESCRIPTOR;\n\n        }\n\n        *edx = (L1D_DESCRIPTOR << 16) | \\\n\n               (L1I_DESCRIPTOR <<  8) | \\\n\n               (L2_DESCRIPTOR);\n\n        break;\n\n    case 4:\n\n        /* cache info: needed for Core compatibility */\n\n        if (cpu->cache_info_passthrough) {\n\n            host_cpuid(index, count, eax, ebx, ecx, edx);\n\n            *eax &= ~0xFC000000;\n\n        } else {\n\n            *eax = 0;\n\n            switch (count) {\n\n            case 0: /* L1 dcache info */\n\n                *eax |= CPUID_4_TYPE_DCACHE | \\\n\n                        CPUID_4_LEVEL(1) | \\\n\n                        CPUID_4_SELF_INIT_LEVEL;\n\n                *ebx = (L1D_LINE_SIZE - 1) | \\\n\n                       ((L1D_PARTITIONS - 1) << 12) | \\\n\n                       ((L1D_ASSOCIATIVITY - 1) << 22);\n\n                *ecx = L1D_SETS - 1;\n\n                *edx = CPUID_4_NO_INVD_SHARING;\n\n                break;\n\n            case 1: /* L1 icache info */\n\n                *eax |= CPUID_4_TYPE_ICACHE | \\\n\n                        CPUID_4_LEVEL(1) | \\\n\n                        CPUID_4_SELF_INIT_LEVEL;\n\n                *ebx = (L1I_LINE_SIZE - 1) | \\\n\n                       ((L1I_PARTITIONS - 1) << 12) | \\\n\n                       ((L1I_ASSOCIATIVITY - 1) << 22);\n\n                *ecx = L1I_SETS - 1;\n\n                *edx = CPUID_4_NO_INVD_SHARING;\n\n                break;\n\n            case 2: /* L2 cache info */\n\n                *eax |= CPUID_4_TYPE_UNIFIED | \\\n\n                        CPUID_4_LEVEL(2) | \\\n\n                        CPUID_4_SELF_INIT_LEVEL;\n\n                if (cs->nr_threads > 1) {\n\n                    *eax |= (cs->nr_threads - 1) << 14;\n\n                }\n\n                *ebx = (L2_LINE_SIZE - 1) | \\\n\n                       ((L2_PARTITIONS - 1) << 12) | \\\n\n                       ((L2_ASSOCIATIVITY - 1) << 22);\n\n                *ecx = L2_SETS - 1;\n\n                *edx = CPUID_4_NO_INVD_SHARING;\n\n                break;\n\n            case 3: /* L3 cache info */\n\n                if (!cpu->enable_l3_cache) {\n\n                    *eax = 0;\n\n                    *ebx = 0;\n\n                    *ecx = 0;\n\n                    *edx = 0;\n\n                    break;\n\n                }\n\n                *eax |= CPUID_4_TYPE_UNIFIED | \\\n\n                        CPUID_4_LEVEL(3) | \\\n\n                        CPUID_4_SELF_INIT_LEVEL;\n\n                pkg_offset = apicid_pkg_offset(cs->nr_cores, cs->nr_threads);\n\n                *eax |= ((1 << pkg_offset) - 1) << 14;\n\n                *ebx = (L3_N_LINE_SIZE - 1) | \\\n\n                       ((L3_N_PARTITIONS - 1) << 12) | \\\n\n                       ((L3_N_ASSOCIATIVITY - 1) << 22);\n\n                *ecx = L3_N_SETS - 1;\n\n                *edx = CPUID_4_INCLUSIVE | CPUID_4_COMPLEX_IDX;\n\n                break;\n\n            default: /* end of info */\n\n                *eax = 0;\n\n                *ebx = 0;\n\n                *ecx = 0;\n\n                *edx = 0;\n\n                break;\n\n            }\n\n        }\n\n\n\n        /* QEMU gives out its own APIC IDs, never pass down bits 31..26.  */\n\n        if ((*eax & 31) && cs->nr_cores > 1) {\n\n            *eax |= (cs->nr_cores - 1) << 26;\n\n        }\n\n        break;\n\n    case 5:\n\n        /* mwait info: needed for Core compatibility */\n\n        *eax = 0; /* Smallest monitor-line size in bytes */\n\n        *ebx = 0; /* Largest monitor-line size in bytes */\n\n        *ecx = CPUID_MWAIT_EMX | CPUID_MWAIT_IBE;\n\n        *edx = 0;\n\n        break;\n\n    case 6:\n\n        /* Thermal and Power Leaf */\n\n        *eax = env->features[FEAT_6_EAX];\n\n        *ebx = 0;\n\n        *ecx = 0;\n\n        *edx = 0;\n\n        break;\n\n    case 7:\n\n        /* Structured Extended Feature Flags Enumeration Leaf */\n\n        if (count == 0) {\n\n            *eax = 0; /* Maximum ECX value for sub-leaves */\n\n            *ebx = env->features[FEAT_7_0_EBX]; /* Feature flags */\n\n            *ecx = env->features[FEAT_7_0_ECX]; /* Feature flags */\n\n            if ((*ecx & CPUID_7_0_ECX_PKU) && env->cr[4] & CR4_PKE_MASK) {\n\n                *ecx |= CPUID_7_0_ECX_OSPKE;\n\n            }\n\n            *edx = 0; /* Reserved */\n\n        } else {\n\n            *eax = 0;\n\n            *ebx = 0;\n\n            *ecx = 0;\n\n            *edx = 0;\n\n        }\n\n        break;\n\n    case 9:\n\n        /* Direct Cache Access Information Leaf */\n\n        *eax = 0; /* Bits 0-31 in DCA_CAP MSR */\n\n        *ebx = 0;\n\n        *ecx = 0;\n\n        *edx = 0;\n\n        break;\n\n    case 0xA:\n\n        /* Architectural Performance Monitoring Leaf */\n\n        if (kvm_enabled() && cpu->enable_pmu) {\n\n            KVMState *s = cs->kvm_state;\n\n\n\n            *eax = kvm_arch_get_supported_cpuid(s, 0xA, count, R_EAX);\n\n            *ebx = kvm_arch_get_supported_cpuid(s, 0xA, count, R_EBX);\n\n            *ecx = kvm_arch_get_supported_cpuid(s, 0xA, count, R_ECX);\n\n            *edx = kvm_arch_get_supported_cpuid(s, 0xA, count, R_EDX);\n\n        } else {\n\n            *eax = 0;\n\n            *ebx = 0;\n\n            *ecx = 0;\n\n            *edx = 0;\n\n        }\n\n        break;\n\n    case 0xB:\n\n        /* Extended Topology Enumeration Leaf */\n\n        if (!cpu->enable_cpuid_0xb) {\n\n                *eax = *ebx = *ecx = *edx = 0;\n\n                break;\n\n        }\n\n\n\n        *ecx = count & 0xff;\n\n        *edx = cpu->apic_id;\n\n\n\n        switch (count) {\n\n        case 0:\n\n            *eax = apicid_core_offset(cs->nr_cores, cs->nr_threads);\n\n            *ebx = cs->nr_threads;\n\n            *ecx |= CPUID_TOPOLOGY_LEVEL_SMT;\n\n            break;\n\n        case 1:\n\n            *eax = apicid_pkg_offset(cs->nr_cores, cs->nr_threads);\n\n            *ebx = cs->nr_cores * cs->nr_threads;\n\n            *ecx |= CPUID_TOPOLOGY_LEVEL_CORE;\n\n            break;\n\n        default:\n\n            *eax = 0;\n\n            *ebx = 0;\n\n            *ecx |= CPUID_TOPOLOGY_LEVEL_INVALID;\n\n        }\n\n\n\n        assert(!(*eax & ~0x1f));\n\n        *ebx &= 0xffff; /* The count doesn't need to be reliable. */\n\n        break;\n\n    case 0xD: {\n\n        KVMState *s = cs->kvm_state;\n\n        uint64_t ena_mask;\n\n        int i;\n\n\n\n        /* Processor Extended State */\n\n        *eax = 0;\n\n        *ebx = 0;\n\n        *ecx = 0;\n\n        *edx = 0;\n\n        if (!(env->features[FEAT_1_ECX] & CPUID_EXT_XSAVE)) {\n\n            break;\n\n        }\n\n        if (kvm_enabled()) {\n\n            ena_mask = kvm_arch_get_supported_cpuid(s, 0xd, 0, R_EDX);\n\n            ena_mask <<= 32;\n\n            ena_mask |= kvm_arch_get_supported_cpuid(s, 0xd, 0, R_EAX);\n\n        } else {\n\n            ena_mask = -1;\n\n        }\n\n\n\n        if (count == 0) {\n\n            *ecx = 0x240;\n\n            for (i = 2; i < ARRAY_SIZE(x86_ext_save_areas); i++) {\n\n                const ExtSaveArea *esa = &x86_ext_save_areas[i];\n\n                if ((env->features[esa->feature] & esa->bits) == esa->bits\n\n                    && ((ena_mask >> i) & 1) != 0) {\n\n                    if (i < 32) {\n\n                        *eax |= 1u << i;\n\n                    } else {\n\n                        *edx |= 1u << (i - 32);\n\n                    }\n\n                    *ecx = MAX(*ecx, esa->offset + esa->size);\n\n                }\n\n            }\n\n            *eax |= ena_mask & (XSTATE_FP_MASK | XSTATE_SSE_MASK);\n\n            *ebx = *ecx;\n\n        } else if (count == 1) {\n\n            *eax = env->features[FEAT_XSAVE];\n\n        } else if (count < ARRAY_SIZE(x86_ext_save_areas)) {\n\n            const ExtSaveArea *esa = &x86_ext_save_areas[count];\n\n            if ((env->features[esa->feature] & esa->bits) == esa->bits\n\n                && ((ena_mask >> count) & 1) != 0) {\n\n                *eax = esa->size;\n\n                *ebx = esa->offset;\n\n            }\n\n        }\n\n        break;\n\n    }\n\n    case 0x80000000:\n\n        *eax = env->cpuid_xlevel;\n\n        *ebx = env->cpuid_vendor1;\n\n        *edx = env->cpuid_vendor2;\n\n        *ecx = env->cpuid_vendor3;\n\n        break;\n\n    case 0x80000001:\n\n        *eax = env->cpuid_version;\n\n        *ebx = 0;\n\n        *ecx = env->features[FEAT_8000_0001_ECX];\n\n        *edx = env->features[FEAT_8000_0001_EDX];\n\n\n\n        /* The Linux kernel checks for the CMPLegacy bit and\n\n         * discards multiple thread information if it is set.\n\n         * So don't set it here for Intel to make Linux guests happy.\n\n         */\n\n        if (cs->nr_cores * cs->nr_threads > 1) {\n\n            if (env->cpuid_vendor1 != CPUID_VENDOR_INTEL_1 ||\n\n                env->cpuid_vendor2 != CPUID_VENDOR_INTEL_2 ||\n\n                env->cpuid_vendor3 != CPUID_VENDOR_INTEL_3) {\n\n                *ecx |= 1 << 1;    /* CmpLegacy bit */\n\n            }\n\n        }\n\n        break;\n\n    case 0x80000002:\n\n    case 0x80000003:\n\n    case 0x80000004:\n\n        *eax = env->cpuid_model[(index - 0x80000002) * 4 + 0];\n\n        *ebx = env->cpuid_model[(index - 0x80000002) * 4 + 1];\n\n        *ecx = env->cpuid_model[(index - 0x80000002) * 4 + 2];\n\n        *edx = env->cpuid_model[(index - 0x80000002) * 4 + 3];\n\n        break;\n\n    case 0x80000005:\n\n        /* cache info (L1 cache) */\n\n        if (cpu->cache_info_passthrough) {\n\n            host_cpuid(index, 0, eax, ebx, ecx, edx);\n\n            break;\n\n        }\n\n        *eax = (L1_DTLB_2M_ASSOC << 24) | (L1_DTLB_2M_ENTRIES << 16) | \\\n\n               (L1_ITLB_2M_ASSOC <<  8) | (L1_ITLB_2M_ENTRIES);\n\n        *ebx = (L1_DTLB_4K_ASSOC << 24) | (L1_DTLB_4K_ENTRIES << 16) | \\\n\n               (L1_ITLB_4K_ASSOC <<  8) | (L1_ITLB_4K_ENTRIES);\n\n        *ecx = (L1D_SIZE_KB_AMD << 24) | (L1D_ASSOCIATIVITY_AMD << 16) | \\\n\n               (L1D_LINES_PER_TAG << 8) | (L1D_LINE_SIZE);\n\n        *edx = (L1I_SIZE_KB_AMD << 24) | (L1I_ASSOCIATIVITY_AMD << 16) | \\\n\n               (L1I_LINES_PER_TAG << 8) | (L1I_LINE_SIZE);\n\n        break;\n\n    case 0x80000006:\n\n        /* cache info (L2 cache) */\n\n        if (cpu->cache_info_passthrough) {\n\n            host_cpuid(index, 0, eax, ebx, ecx, edx);\n\n            break;\n\n        }\n\n        *eax = (AMD_ENC_ASSOC(L2_DTLB_2M_ASSOC) << 28) | \\\n\n               (L2_DTLB_2M_ENTRIES << 16) | \\\n\n               (AMD_ENC_ASSOC(L2_ITLB_2M_ASSOC) << 12) | \\\n\n               (L2_ITLB_2M_ENTRIES);\n\n        *ebx = (AMD_ENC_ASSOC(L2_DTLB_4K_ASSOC) << 28) | \\\n\n               (L2_DTLB_4K_ENTRIES << 16) | \\\n\n               (AMD_ENC_ASSOC(L2_ITLB_4K_ASSOC) << 12) | \\\n\n               (L2_ITLB_4K_ENTRIES);\n\n        *ecx = (L2_SIZE_KB_AMD << 16) | \\\n\n               (AMD_ENC_ASSOC(L2_ASSOCIATIVITY) << 12) | \\\n\n               (L2_LINES_PER_TAG << 8) | (L2_LINE_SIZE);\n\n        if (!cpu->enable_l3_cache) {\n\n            *edx = ((L3_SIZE_KB / 512) << 18) | \\\n\n                   (AMD_ENC_ASSOC(L3_ASSOCIATIVITY) << 12) | \\\n\n                   (L3_LINES_PER_TAG << 8) | (L3_LINE_SIZE);\n\n        } else {\n\n            *edx = ((L3_N_SIZE_KB_AMD / 512) << 18) | \\\n\n                   (AMD_ENC_ASSOC(L3_N_ASSOCIATIVITY) << 12) | \\\n\n                   (L3_N_LINES_PER_TAG << 8) | (L3_N_LINE_SIZE);\n\n        }\n\n        break;\n\n    case 0x80000007:\n\n        *eax = 0;\n\n        *ebx = 0;\n\n        *ecx = 0;\n\n        *edx = env->features[FEAT_8000_0007_EDX];\n\n        break;\n\n    case 0x80000008:\n\n        /* virtual & phys address size in low 2 bytes. */\n\n        if (env->features[FEAT_8000_0001_EDX] & CPUID_EXT2_LM) {\n\n            /* 64 bit processor, 48 bits virtual, configurable\n\n             * physical bits.\n\n             */\n\n            *eax = 0x00003000 + cpu->phys_bits;\n\n        } else {\n\n            *eax = cpu->phys_bits;\n\n        }\n\n        *ebx = 0;\n\n        *ecx = 0;\n\n        *edx = 0;\n\n        if (cs->nr_cores * cs->nr_threads > 1) {\n\n            *ecx |= (cs->nr_cores * cs->nr_threads) - 1;\n\n        }\n\n        break;\n\n    case 0x8000000A:\n\n        if (env->features[FEAT_8000_0001_ECX] & CPUID_EXT3_SVM) {\n\n            *eax = 0x00000001; /* SVM Revision */\n\n            *ebx = 0x00000010; /* nr of ASIDs */\n\n            *ecx = 0;\n\n            *edx = env->features[FEAT_SVM]; /* optional features */\n\n        } else {\n\n            *eax = 0;\n\n            *ebx = 0;\n\n            *ecx = 0;\n\n            *edx = 0;\n\n        }\n\n        break;\n\n    case 0xC0000000:\n\n        *eax = env->cpuid_xlevel2;\n\n        *ebx = 0;\n\n        *ecx = 0;\n\n        *edx = 0;\n\n        break;\n\n    case 0xC0000001:\n\n        /* Support for VIA CPU's CPUID instruction */\n\n        *eax = env->cpuid_version;\n\n        *ebx = 0;\n\n        *ecx = 0;\n\n        *edx = env->features[FEAT_C000_0001_EDX];\n\n        break;\n\n    case 0xC0000002:\n\n    case 0xC0000003:\n\n    case 0xC0000004:\n\n        /* Reserved for the future, and now filled with zero */\n\n        *eax = 0;\n\n        *ebx = 0;\n\n        *ecx = 0;\n\n        *edx = 0;\n\n        break;\n\n    default:\n\n        /* reserved values: zero */\n\n        *eax = 0;\n\n        *ebx = 0;\n\n        *ecx = 0;\n\n        *edx = 0;\n\n        break;\n\n    }\n\n}\n", "idx": 7109, "substitutes": {"env": ["uv", "event", "esc", "outer", "sw", "conf", "buf", "sc", "addr", "vert", "dev", "ec", "network", "environment", "queue", "external", "sb", "en", "ah", "txt", "req", "worker", "operator", "enc", "esm", "ve", "er", "context", "server", "code", "v", "config", "vs", "serv", "desc", "db", "ev", "peer", "et", "console", "kernel", "end", "ctx", "eni", "era", "msg", "exc", "timer", "hw", "rc", "sv", "attr", "org", "nv", "st", "cv", "vm", "net", "param", "eve", "act", "app", "window", "here", "eas", "client", "erd", "actor", "cmd", "inv", "ew", "eng", "err", "Environment", "proc", "gate", "eu", "doc", "manager", "vt", "obj", "qt", "e", "conn"], "index": ["open", "empty", "state", "valid", "addr", "order", "link", "ind", "key", "trace", "value", "connect", "pos", "level", "num", "can", "loop", "sum", "size", "x", "loc", "path", "success", "instance", "null", "page", "vector", "cycle", "base", "rank", "seed", "zero", "context", "position", "ion", "timeout", "code", "config", "frame", "date", "version", "local", "axis", "address", "info", "check", "length", "update", "error", "type", "ctx", "offset", "find", "no", "available", "delete", "limit", "change", "scroll", "fail", "shape", "hash", "init", "thread", "window", "fee", "cmp", "set", "we", "si", "insert", "location", "row", "data", "range", "height", "input", "number", "scale", "slice", "id", "initial", "list", "handle", "ix", "where", "status", "block", "Index", "alias", "ex", "unknown", "point", "lock", "conn", "condition"], "count": ["read", "depth", "c", "pack", "offset", "base", "add", "len", "Count", "ind", "process", "total", "start", "code", "max", "child", "cap", "config", "cache", "current", "size", "info", "length", "z", "name", "flag"], "eax": ["eica", "eaap", "Eaj", "ieax", "Eax", "eap", "eape", "erars", "eiake", "eeap", " eix", "eox", "eake", "ieap", "meax", "ebake", "Eox", "erax", "eaax", "ebax", "meaj", "eeaj", " eox", "eaaw", "eca", "eeax", "ears", "xears", "eiax", "eaape", "ieaw", "xeaw", "mears", "eaw", "xeax", " eaj", "ieape", "eeape", "eeau", "eaj", "ebca", "xeox", "ebix", "erox", "eix", " eake", "eeaw", "eeox", "meox", "meaw", " eca", "eau", "meau", "eraw", " eau", "eiix"], "ebx": ["evalp", "egxx", "edux", "egp", "abby", "evalux", "egix", "egy", "erbax", "erbxml", "abbt", "abbtx", "egx", "ibt", "edt", "ebp", "egax", "ebt", "abbx", "egxml", "ebxml", "ebtx", "ibxx", "erbix", "debix", "debx", "ecix", "ebax", "edix", "obtx", "debz", "egz", "ibix", "ebz", "evalx", "obx", "oby", "ecax", "edy", "ecy", "evalix", "ecxml", "ebxx", "egex", "ecz", "egt", "eby", "egtx", "ebix", "edp", "abbix", "evalt", "obt", "ebux", "debex", "ibx", "erbx", "abbz", "egux", "ebex", "evalxx", "edz", "ecex"], "ecx": ["execx", "ebv", "eeex", "ecc", "ecX", "egy", "ecxi", "egx", "ebw", "ebxi", "egxi", "epx", "eew", "ecpx", "ekwx", "epy", " ecpx", "ebtx", "ectx", "epxi", "epX", "escxi", "edw", "ebX", "ecix", "edix", " ecxi", "escx", "edxi", "execix", "egv", "ecwx", "eex", "ecv", "edc", "escwx", "ekw", "ekxi", "ekpx", "edex", "ecy", "ecw", "eexi", "eetx", "egex", "execex", "ekc", "edtx", "ebix", "egtx", "eby", "edv", "eec", "egX", " ecwx", "ekex", "execw", "ebex", "escpx", "ecex", "ekx"], "edx": ["edux", "sedux", "iedxx", "EDg", " edX", "eeex", "EDx", "eedx", "nedj", "iedg", "eexc", "edX", "enj", "eedz", "ecbit", "eedxx", "efx", "edj", "ebtx", "hedxf", "eedux", "ectx", "edxc", "edz", "eftx", "nedxf", "sedxx", "enxf", "hedx", "nedx", "ingxc", "efex", "EDxf", "enedg", "pedx", "nedz", "hedz", "enx", "sedx", "eex", "iedx", "pedux", "enedxf", "pedz", "edbit", "EDxx", "edg", "edex", "pedxx", "enz", " edxc", "ingex", "iedxf", "edxf", "edxx", "ebbit", "edtx", "hedj", "ingX", " edex", "sedz", "ingx", "ebex", "efbit", "enedx", "ecex", "eeX", "enedxx"], "cpu": ["ck", "CPU", "gc", "kernel", "cp", "c", "pu", "ctx", "pc", "tp", "ox", "prof", "cmp", "conn", "sys", "ka", "sc", "os", "util", "p", "stat", "nc", "ec", "process", "hw", "phys", "nu", "linux", "proc", "pkg", "device", "cn", "nic", "config", "processor", "cv", "pool", "socket", "cache", "np", "core", "us", "vm", "net", "cu", "gpu", "mx"], "cs": ["cf", "rs", "csv", "gs", "cas", "CS", "cells", "ars", "cp", "ns", "ubs", "c", "wcs", "ctx", "acs", "cks", "cms", "sys", "qs", "sc", "aps", "ces", "acts", "actions", "caps", "ps", "ms", "ec", "ts", "ds", "css", "cus", "utils", "cc", "js", "ins", "proc", "ls", "cn", "ras", "stats", "checks", "ims", "args", "spec", "vs", "hs", "ss", "cv", "cons", "fs", "ares", "ys", "ks", "otes", "sts", "cases", "obs", "tc", "act"], "pkg_offset": ["pkgxsize", "pkgxref", "pkg_size", " sock_ref", "pkg2size", " sock_offset", " sock_off", "pkg2off", " sock_size", "pkgxoffset", "pkg2offset", "pkgxoff", "pkg_ref", "pkg_off", "pkg2ref"]}}
{"project": "FFmpeg", "commit_id": "f929ab0569ff31ed5a59b0b0adb7ce09df3fca39", "target": 0, "func": "static void prepare_app_arguments(int *argc_ptr, char ***argv_ptr)\n\n{\n\n    char *argstr_flat;\n\n    wchar_t **argv_w;\n\n    int i, buffsize = 0, offset = 0;\n\n\n\n    if (win32_argv_utf8) {\n\n        *argc_ptr = win32_argc;\n\n        *argv_ptr = win32_argv_utf8;\n\n        return;\n\n    }\n\n\n\n    win32_argc = 0;\n\n    argv_w = CommandLineToArgvW(GetCommandLineW(), &win32_argc);\n\n    if (win32_argc <= 0 || !argv_w)\n\n        return;\n\n\n\n    /* determine the UTF-8 buffer size (including NULL-termination symbols) */\n\n    for (i = 0; i < win32_argc; i++)\n\n        buffsize += WideCharToMultiByte(CP_UTF8, 0, argv_w[i], -1,\n\n                                        NULL, 0, NULL, NULL);\n\n\n\n    win32_argv_utf8 = av_mallocz(sizeof(char *) * (win32_argc + 1) + buffsize);\n\n    argstr_flat     = (char *)win32_argv_utf8 + sizeof(char *) * (win32_argc + 1);\n\n    if (win32_argv_utf8 == NULL) {\n\n        LocalFree(argv_w);\n\n        return;\n\n    }\n\n\n\n    for (i = 0; i < win32_argc; i++) {\n\n        win32_argv_utf8[i] = &argstr_flat[offset];\n\n        offset += WideCharToMultiByte(CP_UTF8, 0, argv_w[i], -1,\n\n                                      &argstr_flat[offset],\n\n                                      buffsize - offset, NULL, NULL);\n\n    }\n\n    win32_argv_utf8[i] = NULL;\n\n    LocalFree(argv_w);\n\n\n\n    *argc_ptr = win32_argc;\n\n    *argv_ptr = win32_argv_utf8;\n\n}\n", "idx": 7111, "substitutes": {"argc_ptr": ["argv__tr", "argv_tr", "argc__tip", "argv_tip", "argci_ptr", "argc7tip", "argci_pointer", "argc_tip", "argv__pointer", "argc_pointer", "argc__pointer", "argc_tr", "argc_rect", "argc__tr", "argv__Ptr", "argc_Ptr", "argci_rect", "argc7pointer", "argv_Ptr", "argv__ptr", "argci__tr", "argci__ptr", "argc__Ptr", "argc7tr", "argv_pointer", "argci__rect", "argc__rect", "argc7ptr", "argv__tip", "argci__pointer", "argci_tr", "argc__ptr"], "argv_ptr": ["argc__pointers", "argl_pointers", "arguv_ptr", "argc_pointers", "argv__loc", "argv___dep", "arguv_fp", "argv__pointer", "argc_pointer", "argc__pointer", "argv_pointers", "argl_rep", "arguv_copy", "argl_ptr", "argv_loc", "argc_loc", "argv___ptr", "argl_pointer", "argv_dep", "argv_fp", "arguv_dep", "argv__ptr", "argv_pointer", "argv_rep", "argv_copy", "argv___fp", "argv___copy", "argv__pointers", "argc__loc", "argc__ptr"], "argstr_flat": ["argst_full", "argstring_hat", "argstring__normal", "argstr_flush", "argstr___att", "argstring_at", "argstr__normal", "argbr_lit", "argstr__full", "argStr_flat", "argStr__sat", "argstr_at", "argstring_flat", "argbr_full", "argbr__flat", "argstring__flat", "argbr__full", "argstring__hat", "argstring__at", "argbr__lit", "argbr_att", "argst_flush", "argstr__sat", "argstr_att", "argstr_lit", "argbr_flat", "argstr__hat", "argst_flat", "argStr_full", "argstr2flat", "argstr_normal", "argstr2full", "argstr_sat", "argstr_hat", "argstr__att", "argStr__flat", "argStr__full", "argbr__att", "argstr_full", "argstr2flush", "argstr___lit", "argstr__flat", "argStr_sat", "argstr___flat", "argstr___full", "argstring_normal", "argstr__at", "argstr__lit"], "argv_w": ["argv___c", "argvs_t", "argvpywt", "argv_wp", "argc_aw", "argvpywl", "argvjraw", "argv___r", "argv__W", "argv_c", "argv4aw", "argvpyw", "argv_wa", "argc_wr", "argl_wp", "argsv_sw", "argv8wl", "argv__ws", "argv_way", "argv8w", "argvjw", "argc_ws", "argvs_wt", "argv_wh", "argp_r", "argvjwh", "argvs_wl", "argv__wr", "argc_W", "argv_wt", "argvs_w", "argv4way", "argv__raw", "argc_w", "argv8wt", "argv_nw", "argv___W", "argv_aw", "argv_raw", "argl_wa", "argv_wr", "argv4w", "argv_ws", "argc_way", "argp_w", "argv___w", "argsv_w", "argl_wt", "argl_w", "argv1w", "argv_t", "argv_W", "argvpyt", "argv8t", "argv_wl", "argsv_nw", "argv4ws", "argp_W", "argv_r", "argv1nw", "argv__w", "argv1sw", "argv_sw", "argv__wh", "argp_c"], "i": ["chain", "ei", " ii", "im", "c", "gi", "zi", "ind", "t", "pi", " j", "I", "batch", "parent", "loop", "in", "j", "origin", "x", "\u0438", "di", "ic", "q", "instance", "mi", "g", "xi", "index", "ri", "bi", "ki", "ti", "v", "iii", "ai", "m", "remote", "us", "info", "l", "ci", "it", "offset", "ip", "li", "p", "ami", "is", "ski", "to", "y", "ii", "init", "ini", "ij", "uri", "cli", "oi", "qi", "si", "n", "multi", "me", "ui", "slice", "ji", "id", "phi", "ims", "ix", "status", "print", "sim", "ex", "iu", "e", "gu"]}}
{"project": "qemu", "commit_id": "a7812ae412311d7d47f8aa85656faadac9d64b56", "target": 0, "func": "static inline void gen_neon_addl_saturate(TCGv op0, TCGv op1, int size)\n\n{\n\n    switch (size) {\n\n    case 1: gen_helper_neon_addl_saturate_s32(op0, cpu_env, op0, op1); break;\n\n    case 2: gen_helper_neon_addl_saturate_s64(op0, cpu_env, op0, op1); break;\n\n    default: abort();\n\n    }\n\n}\n", "idx": 7119, "substitutes": {"op0": ["ost48", " op50", "op50", "op2", "jp0", "opt4", " op4", "jp02", "ost0", "ost2", " op2", "opt0", "top1", "hop0", "oper0", "op02", " opk", "opp6", "msg4", " op48", "top4", "cop48", "hop02", "top0", "hop6", "cmd0", "cop0", " op6", "cop2", "msg1", "hop1", "opp0", "cop50", "hopk", "opt1", "ost50", "opp1", "jp4", "oper1", "op6", "oppk", "oper4", "cmd02", "op4", "msg0", "jp1", "opk", "op48", "cmd1"], "op1": ["op01", "op2", "opt2", "pop3", " op2", "top64", " op01", " op3", "pop001", "map01", "og64", "opt6", "Op001", "pop1", "top0", "op001", " op6", "map1", "opt3", "pop6", "og1", "opt1", "op3", "map001", "Op1", "op64", "op6", "pop01", "pop2", "Op0", "og01", "pop0", "top01", "map0", " op64", "Op01", "top1", "og0"], "size": ["empty", "SIZE", "fee", "type", "shift", "Size", "offset", "scope", "zone", "body", "n", "ose", "len", "use", "index", "height", "scale", "number", "ui", "space", "style", "send", "dimension", "dim", "slot", "small", "sn", "capacity", "count", "message", "shape", "sum", "ize", "iz", "length", "sized"]}}
{"project": "FFmpeg", "commit_id": "2f996b8397ee0e646a824f3dfcbd291a114af348", "target": 0, "func": "int MP3lame_encode_frame(AVCodecContext *avctx,\n\n                     unsigned char *frame, int buf_size, void *data)\n\n{\n\n\tMp3AudioContext *s = avctx->priv_data;\n\n\tint num, i;\n\n//av_log(avctx, AV_LOG_DEBUG, \"%X %d %X\\n\", (int)frame, buf_size, (int)data);\n\n//        if(data==NULL)\n\n//            return lame_encode_flush(s->gfp, frame, buf_size);\n\n\n\n\t/* lame 3.91 dies on '1-channel interleaved' data */\n\n\tif (s->stereo) {\n\n\t\tnum = lame_encode_buffer_interleaved(s->gfp, data,\n\n\t\t\tMPA_FRAME_SIZE, frame, buf_size);\n\n\t} else {\n\n\t\tnum = lame_encode_buffer(s->gfp, data, data, MPA_FRAME_SIZE,\n\n\t\t\tframe, buf_size);\n\n\n\n/*av_log(avctx, AV_LOG_DEBUG, \"in:%d out:%d\\n\", MPA_FRAME_SIZE, num);\n\nfor(i=0; i<num; i++){\n\n    av_log(avctx, AV_LOG_DEBUG, \"%2X \", frame[i]);\n\n}*/\n\n\t}\n\n\n\n\treturn num;\n\n}\n", "idx": 7122, "substitutes": {"avctx": ["Avtxt", " avtxt", "avca", "wavcmp", " avcmp", "vca", "vcontext", " avcontext", "Avca", "vtxt", "avcontext", "avtxt", "ovcontext", "ovctx", "Avctx", "ovcmp", "ovcc", "wavctx", "wavcc", "vctx", " avca", "Avcontext", "avcmp", " avcc", "avcc", "wavcontext"], "frame": ["draw", "rame", "event", "feat", "chain", "window", "channel", "Frame", "fram", "step", "field", "file", "buffer", "scene", "force", "flow", "base", "cmd", "context", "process", "ce", "trace", "ime", "word", "id", "style", "code", "video", "component", "feature", "block", "spec", "part", "fb", "version", "cond", "f", "sample", "filter", "face", "point", "time", "fr", "image", "sequence"], "buf_size": ["buf_len", " buf2size", " buf_Size", "buf_space", "buf2space", "buf5size", "buf_Size", "bufmodsize", "bufmodspace", " buf_set", "buf5fee", " buf_width", " buf2width", "buf2width", "buf5Size", " buf_len", " buf_space", "buf2size", "buf_width", " buf_fee", "buf_fee", "buf5set", "buf2len", " buf2space", "bufmodwidth", "buf_set", "bufmodlen", " buf2len"], "data": ["this", "all", "bytes", "result", "error", "padding", "next", "empty", "window", "end", "channel", "none", "buf", "file", "buffer", "valid", "raw", "extra", "d", "p", "no", " DATA", "rew", "ata", "context", "zero", "t", "Data", "value", "str", "id", "mu", "device", "mode", "normal", "video", "block", "load", "stream", "done", "batch", "cache", "f", "DATA", "message", "sample", "size", "length", "text", "a", "def", "image", "bin"], "s": ["rs", "so", "ass", "gs", "sw", "less", "ns", "c", "http", "h", "ats", "sam", "sys", "set", "qs", "cs", "sc", "comm", "os", "ps", "p", "als", "is", "ts", "ds", "se", "t", "es", "js", "ins", "sv", "ls", "sb", "ess", "iss", "stats", "sl", "spec", "hs", "sa", "ss", "sq", "ex", "S", "sts", "z", "sis"], "num": ["Num", "result", "uf", " number", "um", " nu", "mem", "quant", "mn", "prim", "con", "comm", "mon", "valid", "nam", "n", "no", "len", "tim", "val", "un", "good", "index", "total", "perm", "nu", "number", "id", " sum", "umi", "nm", "Number", "code", "en", "dim", "NUM", "cal", "final", "m", "om", "off", "umber", "f", "pn", "sum", "sim", "check", "nom", "snap", "coord", "ver", " numb", " remain"], "i": ["ij", "b", "it", "im", "c", "mi", "ip", "p", "si", "g", "n", "index", "t", "pi", "id", "v", "ix", "ai", "m", "I", "f", "iu", "in", "j", "x", "ii", "l"]}}
{"project": "qemu", "commit_id": "53628efbc8aa7a7ab5354d24b971f4d69452151d", "target": 1, "func": "int qemu_chr_fe_read_all(CharDriverState *s, uint8_t *buf, int len)\n\n{\n\n    int offset = 0, counter = 10;\n\n    int res;\n\n\n\n    if (!s->chr_sync_read) {\n\n        return 0;\n\n    }\n\n    \n\n    if (s->replay && replay_mode == REPLAY_MODE_PLAY) {\n\n        return replay_char_read_all_load(buf);\n\n    }\n\n\n\n    while (offset < len) {\n\n        do {\n\n            res = s->chr_sync_read(s, buf + offset, len - offset);\n\n            if (res == -1 && errno == EAGAIN) {\n\n                g_usleep(100);\n\n            }\n\n        } while (res == -1 && errno == EAGAIN);\n\n\n\n        if (res == 0) {\n\n            break;\n\n        }\n\n\n\n        if (res < 0) {\n\n            if (s->replay && replay_mode == REPLAY_MODE_RECORD) {\n\n                replay_char_read_all_save_error(res);\n\n            }\n\n            return res;\n\n        }\n\n\n\n        offset += res;\n\n\n\n        if (!counter--) {\n\n            break;\n\n        }\n\n    }\n\n\n\n    if (s->replay && replay_mode == REPLAY_MODE_RECORD) {\n\n        replay_char_read_all_save_buf(buf, offset);\n\n    }\n\n    return offset;\n\n}\n", "idx": 7125, "substitutes": {"s": ["rs", "service", "gs", "ses", "sp", "ssl", "q", "b", "less", "ns", "conf", "c", "h", "ats", "sys", "set", "store", "cs", "comm", "client", "state", "os", "er", "p", "ps", "details", "n", "has", "ts", "is", "ds", "t", "se", "r", "js", "space", "sv", "ls", "sm", "sb", "ims", "stats", "sl", "spec", "hs", "st", "ss", "serv", "states", "sq", "fs", "sim", "S", "sts", "sports", "a", "source"], "buf": ["db", "bag", "cast", "bytes", "uf", "buff", "q", "b", "ff", "mem", "window", "pb", "ctx", "br", "bc", "box", "offset", "Buffer", "buffer", "raw", "seq", "p", "cmd", "bp", "cb", "queue", "wb", "data", "limit", "ref", "pos", "bar", "pkg", "Buff", "rb", "bf", "bin", "v", "lim", "cap", "iter", "orig", "block", "bs", "off", "tmp", "cv", "batch", "img", "doc", "cur", "vec"], "len": ["all", "mult", "bytes", "sp", "ln", "mem", "end", "Len", "cmp", "offset", "cl", "lf", "mid", "seq", "n", "val", "fl", "lan", "limit", "el", "ref", "pos", "list", "syn", "ls", "en", "lim", "num", "iter", "fin", "count", "L", "size", "length", "ll", "nl", "z", "il", "l", "elt", "vec"], "res": ["was", "bytes", "des", "gr", "rel", "mid", "ps", "ts", "red", "pers", "js", "pos", "RES", "req", "reset", "ret", "mask", "rez", "rs", "results", "ress", "os", "ms", "zero", "index", "es", "vals", "rss", "str", "resource", "expr", "out", "max", "respons", "serv", "conv", "pres", "vec", "error", "pc", "vers", "offset", "cs", "mr", "msg", "val", "Res", "r", "prime", "rev", "rem", "rest", "re", "reg", "response", "cond", "cons", "fs", "ver", "act", "result", "repl", "ser", " Res", "cmp", "i", "sys", "cmd", "details", "full", "func", "err", "proc", "pr", "resh", "resp", "ptr", "obj", "flags", "arr", "resolution"], "counter": ["atomic", "depth", "outer", "TER", "conf", "walker", "c", "ber", "nr", "ter", "scope", "clock", "vector", "mr", "card", "timer", "loader", "nc", "context", "pointer", "number", "repeat", "finder", "mer", "level", "timeout", "iter", "inner", "processor", "random", "controller", "frequency", "batch", "ounter", "count", "Counter", "currency", "ctr", "sequence"]}}
{"project": "FFmpeg", "commit_id": "bf2bc926f04dcdde0a22c137d08a0bb546e0179e", "target": 1, "func": "static int decode_b_picture_secondary_header(VC9Context *v)\n\n{\n\n    GetBitContext *gb = &v->s.gb;\n\n    int status;\n\n\n\n    bitplane_decoding(&v->skip_mb_plane, v);\n\n    if (status < 0) return -1;\n\n#if TRACE\n\n    if (v->mv_mode == MV_PMODE_MIXED_MV)\n\n    {\n\n        status = bitplane_decoding(&v->mv_type_mb_plane, v);\n\n        if (status < 0)\n\n            return -1;\n\n#if TRACE\n\n        av_log(v->s.avctx, AV_LOG_DEBUG, \"MB MV Type plane encoding: \"\n\n               \"Imode: %i, Invert: %i\\n\", status>>1, status&1);\n\n#endif\n\n    }\n\n\n\n    //bitplane\n\n    status = bitplane_decoding(&v->direct_mb_plane, v);\n\n    if (status < 0) return -1;\n\n#if TRACE\n\n    av_log(v->s.avctx, AV_LOG_DEBUG, \"MB Direct plane encoding: \"\n\n           \"Imode: %i, Invert: %i\\n\", status>>1, status&1);\n\n#endif\n\n\n\n    av_log(v->s.avctx, AV_LOG_DEBUG, \"Skip MB plane encoding: \"\n\n           \"Imode: %i, Invert: %i\\n\", status>>1, status&1);\n\n#endif\n\n\n\n    /* FIXME: what is actually chosen for B frames ? */\n\n    v->s.mv_table_index = get_bits(gb, 2); //but using vc9_ tables\n\n    v->cbpcy_vlc = &vc9_cbpcy_p_vlc[get_bits(gb, 2)];\n\n\n\n    if (v->dquant)\n\n    {\n\n        vop_dquant_decoding(v);\n\n    }\n\n\n\n    if (v->vstransform)\n\n    {\n\n        v->ttmbf = get_bits(gb, 1);\n\n        if (v->ttmbf)\n\n        {\n\n            v->ttfrm = get_bits(gb, 2);\n\n            av_log(v->s.avctx, AV_LOG_INFO, \"Transform used: %ix%i\\n\",\n\n                   (v->ttfrm & 2) ? 4 : 8, (v->ttfrm & 1) ? 4 : 8);\n\n        }\n\n    }\n\n    /* Epilog (AC/DC syntax) should be done in caller */\n\n    return 0;\n\n}\n", "idx": 7130, "substitutes": {"v": ["iv", "all", "vv", "vr", "uv", "ev", "detail", "b", "lv", "um", "it", "window", "sw", "ov", "c", "h", "av", "view", "vi", "i", "ve", "er", "g", "p", "inv", "vp", "var", "dev", "val", "tv", "value", "w", "sv", "qv", "rev", "k", "s", "video", "nv", "vd", "qu", "m", "vs", "V", "vc", "cv", "version", "y", "cache", "f", "vt", "current", "conv", "wire", "vm", "l", "j", "x", "ver", "env"], "gb": ["db", "gt", "gc", "gs", "gif", "csv", "bn", "sg", "gp", "gm", "eb", "git", "bg", "ctx", "bc", "phy", " GB", "eg", "px", "g", "tg", "gy", "hub", "gd", "cb", "wb", "bt", " db", "bb", "pg", "py", "attr", "sb", "rb", "bf", "vg", "mb", "cfg", "bridge", "goo", "nb", "rg", "fb", "Gb", "cv", "storage", "cd", "img", "bs", "gnu", "gu", "GB", "kb", "html", "bm", "gg", "gpu"], "status": ["gc", "sw", "wait", "wa", "note", "state", "sc", "login", "valid", "using", "add", "js", "iso", "xml", "entry", "atus", "size", "by", "x", "comments", "source", "flag", "success", "cgi", "g", "index", "str", "summary", "Status", "code", "gone", "vis", "scan", "version", "check", "html", "update", "error", "ssl", "prefix", "gl", "msg", "progress", "p", "score", "is", "use", "uses", "usage", "s", "try", "sex", "st", "fs", "res", " Status", "name", "result", "sp", "access", "ping", "i", "active", "only", "si", "stat", "details", "sync", "data", "err", "id", "list", "resp", "spec", "sim", "ex", "format"]}}
{"project": "FFmpeg", "commit_id": "0efb6106118c17308b3fdc3190f5e5bf84b01d5c", "target": 1, "func": "static int mxf_get_stream_index(AVFormatContext *s, KLVPacket *klv)\n\n{\n\n    int i;\n\n\n\n    for (i = 0; i < s->nb_streams; i++) {\n\n        MXFTrack *track = s->streams[i]->priv_data;\n\n        /* SMPTE 379M 7.3 */\n\n        if (!memcmp(klv->key + sizeof(mxf_essence_element_key), track->track_number, sizeof(track->track_number)))\n\n            return i;\n\n    }\n\n    /* return 0 if only one stream, for OP Atom files with 0 as track number */\n\n    return s->nb_streams == 1 ? 0 : -1;\n\n}\n", "idx": 7150, "substitutes": {"s": ["rs", "gs", "ses", "b", "less", "ns", "c", "its", "h", "ats", "aws", "qs", "sys", "comm", "https", "os", "p", "als", "ps", "ms", "n", "g", "is", "ts", "ds", "t", "es", "aus", "r", "w", "js", "ins", "sv", "ls", "v", "ims", "stats", "m", "spec", "hs", "ss", "bs", "sq", "f", "parts", "fs", "e", "S", "sts", "x", "a", "sports"], "klv": [" kll", "keyLV", "qll", " klc", "skvl", "keylv", "sklc", "kdl", "ktlp", "qdl", "qLV", "kvl", " kdl", "qlv", "ktlc", "ktlv", " kLV", "sklv", "sklp", " kvl", "kLV", "keydl", "klp", "klc", "ktvl", "keyll", "kll", " klp"], "i": ["chain", "ei", " multi", " ii", "im", "gi", "ind", " ti", "hi", "pi", "t", " pi", "iter", " j", "I", "batch", "in", "j", "x", "di", "ic", " ni", "mi", " si", "xi", "index", "ri", "bi", "ki", "ti", "v", "ai", "m", " info", "us", "l", " li", "ci", "it", "u", "ip", "li", "p", "o", " I", "k", "try", " iter", " it", "y", " index", "ii", "init", "ini", " is", "ij", " bi", "uri", " wi", "oi", "si", " init", "n", "iq", " err", "multi", "me", "ui", "id", "list", "ji", "phi", "ims", "ix", " mi", "print", "ish", "sim", "iu", "e", "point"], "track": ["race", "train", "form", "match", "pack", "met", "find", "store", "sort", "trak", "util", "bind", "stat", "add", "seek", "tm", "cmd", "row", "tr", "t", "follow", "r", "trace", "rack", "tag", "record", "tracking", "attr", "handle", "transform", "Track", "ack", "stream", "tab", "report", "batch", "cache", "count", "search", "trip", "info", "check", "roll", "hold", "tp", "collect"]}}
{"project": "FFmpeg", "commit_id": "f6774f905fb3cfdc319523ac640be30b14c1bc55", "target": 1, "func": "static void vc1_mc_1mv(VC1Context *v, int dir)\n\n{\n\n    MpegEncContext *s = &v->s;\n\n    H264ChromaContext *h264chroma = &v->h264chroma;\n\n    uint8_t *srcY, *srcU, *srcV;\n\n    int dxy, mx, my, uvmx, uvmy, src_x, src_y, uvsrc_x, uvsrc_y;\n\n    int v_edge_pos = s->v_edge_pos >> v->field_mode;\n\n    int i;\n\n    uint8_t (*luty)[256], (*lutuv)[256];\n\n    int use_ic;\n\n\n\n    if ((!v->field_mode ||\n\n         (v->ref_field_type[dir] == 1 && v->cur_field_type == 1)) &&\n\n        !v->s.last_picture.f.data[0])\n\n        return;\n\n\n\n    mx = s->mv[dir][0][0];\n\n    my = s->mv[dir][0][1];\n\n\n\n    // store motion vectors for further use in B frames\n\n    if (s->pict_type == AV_PICTURE_TYPE_P) {\n\n        for (i = 0; i < 4; i++) {\n\n            s->current_picture.motion_val[1][s->block_index[i] + v->blocks_off][0] = mx;\n\n            s->current_picture.motion_val[1][s->block_index[i] + v->blocks_off][1] = my;\n\n        }\n\n    }\n\n\n\n    uvmx = (mx + ((mx & 3) == 3)) >> 1;\n\n    uvmy = (my + ((my & 3) == 3)) >> 1;\n\n    v->luma_mv[s->mb_x][0] = uvmx;\n\n    v->luma_mv[s->mb_x][1] = uvmy;\n\n\n\n    if (v->field_mode &&\n\n        v->cur_field_type != v->ref_field_type[dir]) {\n\n        my   = my   - 2 + 4 * v->cur_field_type;\n\n        uvmy = uvmy - 2 + 4 * v->cur_field_type;\n\n    }\n\n\n\n    // fastuvmc shall be ignored for interlaced frame picture\n\n    if (v->fastuvmc && (v->fcm != ILACE_FRAME)) {\n\n        uvmx = uvmx + ((uvmx < 0) ? (uvmx & 1) : -(uvmx & 1));\n\n        uvmy = uvmy + ((uvmy < 0) ? (uvmy & 1) : -(uvmy & 1));\n\n    }\n\n    if (!dir) {\n\n        if (v->field_mode && (v->cur_field_type != v->ref_field_type[dir]) && v->second_field) {\n\n            srcY = s->current_picture.f.data[0];\n\n            srcU = s->current_picture.f.data[1];\n\n            srcV = s->current_picture.f.data[2];\n\n            luty  = v->curr_luty;\n\n            lutuv = v->curr_lutuv;\n\n            use_ic = v->curr_use_ic;\n\n        } else {\n\n            srcY = s->last_picture.f.data[0];\n\n            srcU = s->last_picture.f.data[1];\n\n            srcV = s->last_picture.f.data[2];\n\n            luty  = v->last_luty;\n\n            lutuv = v->last_lutuv;\n\n            use_ic = v->last_use_ic;\n\n        }\n\n    } else {\n\n        srcY = s->next_picture.f.data[0];\n\n        srcU = s->next_picture.f.data[1];\n\n        srcV = s->next_picture.f.data[2];\n\n        luty  = v->next_luty;\n\n        lutuv = v->next_lutuv;\n\n        use_ic = v->next_use_ic;\n\n    }\n\n\n\n    if (!srcY || !srcU) {\n\n        av_log(v->s.avctx, AV_LOG_ERROR, \"Referenced frame missing.\\n\");\n\n        return;\n\n    }\n\n\n\n    src_x   = s->mb_x * 16 + (mx   >> 2);\n\n    src_y   = s->mb_y * 16 + (my   >> 2);\n\n    uvsrc_x = s->mb_x *  8 + (uvmx >> 2);\n\n    uvsrc_y = s->mb_y *  8 + (uvmy >> 2);\n\n\n\n    if (v->profile != PROFILE_ADVANCED) {\n\n        src_x   = av_clip(  src_x, -16, s->mb_width  * 16);\n\n        src_y   = av_clip(  src_y, -16, s->mb_height * 16);\n\n        uvsrc_x = av_clip(uvsrc_x,  -8, s->mb_width  *  8);\n\n        uvsrc_y = av_clip(uvsrc_y,  -8, s->mb_height *  8);\n\n    } else {\n\n        src_x   = av_clip(  src_x, -17, s->avctx->coded_width);\n\n        src_y   = av_clip(  src_y, -18, s->avctx->coded_height + 1);\n\n        uvsrc_x = av_clip(uvsrc_x,  -8, s->avctx->coded_width  >> 1);\n\n        uvsrc_y = av_clip(uvsrc_y,  -8, s->avctx->coded_height >> 1);\n\n    }\n\n\n\n    srcY += src_y   * s->linesize   + src_x;\n\n    srcU += uvsrc_y * s->uvlinesize + uvsrc_x;\n\n    srcV += uvsrc_y * s->uvlinesize + uvsrc_x;\n\n\n\n    if (v->field_mode && v->ref_field_type[dir]) {\n\n        srcY += s->current_picture_ptr->f.linesize[0];\n\n        srcU += s->current_picture_ptr->f.linesize[1];\n\n        srcV += s->current_picture_ptr->f.linesize[2];\n\n    }\n\n\n\n    /* for grayscale we should not try to read from unknown area */\n\n    if (s->flags & CODEC_FLAG_GRAY) {\n\n        srcU = s->edge_emu_buffer + 18 * s->linesize;\n\n        srcV = s->edge_emu_buffer + 18 * s->linesize;\n\n    }\n\n\n\n    if (v->rangeredfrm || use_ic\n\n        || s->h_edge_pos < 22 || v_edge_pos < 22\n\n        || (unsigned)(src_x - s->mspel) > s->h_edge_pos - (mx&3) - 16 - s->mspel * 3\n\n        || (unsigned)(src_y - 1)        > v_edge_pos    - (my&3) - 16 - 3) {\n\n        uint8_t *uvbuf = s->edge_emu_buffer + 19 * s->linesize;\n\n\n\n        srcY -= s->mspel * (1 + s->linesize);\n\n        s->vdsp.emulated_edge_mc(s->edge_emu_buffer, srcY,\n\n                                 s->linesize, s->linesize,\n\n                                 17 + s->mspel * 2, 17 + s->mspel * 2,\n\n                                 src_x - s->mspel, src_y - s->mspel,\n\n                                 s->h_edge_pos, v_edge_pos);\n\n        srcY = s->edge_emu_buffer;\n\n        s->vdsp.emulated_edge_mc(uvbuf, srcU,\n\n                                 s->uvlinesize, s->uvlinesize,\n\n                                 8 + 1, 8 + 1,\n\n                                 uvsrc_x, uvsrc_y, s->h_edge_pos >> 1, v_edge_pos >> 1);\n\n        s->vdsp.emulated_edge_mc(uvbuf + 16, srcV,\n\n                                 s->uvlinesize, s->uvlinesize,\n\n                                 8 + 1, 8 + 1,\n\n                                 uvsrc_x, uvsrc_y, s->h_edge_pos >> 1, v_edge_pos >> 1);\n\n        srcU = uvbuf;\n\n        srcV = uvbuf + 16;\n\n        /* if we deal with range reduction we need to scale source blocks */\n\n        if (v->rangeredfrm) {\n\n            int i, j;\n\n            uint8_t *src, *src2;\n\n\n\n            src = srcY;\n\n            for (j = 0; j < 17 + s->mspel * 2; j++) {\n\n                for (i = 0; i < 17 + s->mspel * 2; i++)\n\n                    src[i] = ((src[i] - 128) >> 1) + 128;\n\n                src += s->linesize;\n\n            }\n\n            src  = srcU;\n\n            src2 = srcV;\n\n            for (j = 0; j < 9; j++) {\n\n                for (i = 0; i < 9; i++) {\n\n                    src[i]  = ((src[i]  - 128) >> 1) + 128;\n\n                    src2[i] = ((src2[i] - 128) >> 1) + 128;\n\n                }\n\n                src  += s->uvlinesize;\n\n                src2 += s->uvlinesize;\n\n            }\n\n        }\n\n        /* if we deal with intensity compensation we need to scale source blocks */\n\n        if (use_ic) {\n\n            int i, j;\n\n            uint8_t *src, *src2;\n\n\n\n            src = srcY;\n\n            for (j = 0; j < 17 + s->mspel * 2; j++) {\n\n                int f = v->field_mode ? v->ref_field_type[dir] : ((j + src_y - s->mspel) & 1) ;\n\n                for (i = 0; i < 17 + s->mspel * 2; i++)\n\n                    src[i] = luty[f][src[i]];\n\n                src += s->linesize;\n\n            }\n\n            src  = srcU;\n\n            src2 = srcV;\n\n            for (j = 0; j < 9; j++) {\n\n                int f = v->field_mode ? v->ref_field_type[dir] : ((j + uvsrc_y) & 1);\n\n                for (i = 0; i < 9; i++) {\n\n                    src[i]  = lutuv[f][src[i]];\n\n                    src2[i] = lutuv[f][src2[i]];\n\n                }\n\n                src  += s->uvlinesize;\n\n                src2 += s->uvlinesize;\n\n            }\n\n        }\n\n        srcY += s->mspel * (1 + s->linesize);\n\n    }\n\n\n\n    if (s->mspel) {\n\n        dxy = ((my & 3) << 2) | (mx & 3);\n\n        v->vc1dsp.put_vc1_mspel_pixels_tab[dxy](s->dest[0]    , srcY    , s->linesize, v->rnd);\n\n        v->vc1dsp.put_vc1_mspel_pixels_tab[dxy](s->dest[0] + 8, srcY + 8, s->linesize, v->rnd);\n\n        srcY += s->linesize * 8;\n\n        v->vc1dsp.put_vc1_mspel_pixels_tab[dxy](s->dest[0] + 8 * s->linesize    , srcY    , s->linesize, v->rnd);\n\n        v->vc1dsp.put_vc1_mspel_pixels_tab[dxy](s->dest[0] + 8 * s->linesize + 8, srcY + 8, s->linesize, v->rnd);\n\n    } else { // hpel mc - always used for luma\n\n        dxy = (my & 2) | ((mx & 2) >> 1);\n\n        if (!v->rnd)\n\n            s->hdsp.put_pixels_tab[0][dxy](s->dest[0], srcY, s->linesize, 16);\n\n        else\n\n            s->hdsp.put_no_rnd_pixels_tab[0][dxy](s->dest[0], srcY, s->linesize, 16);\n\n    }\n\n\n\n    if (s->flags & CODEC_FLAG_GRAY) return;\n\n    /* Chroma MC always uses qpel bilinear */\n\n    uvmx = (uvmx & 3) << 1;\n\n    uvmy = (uvmy & 3) << 1;\n\n    if (!v->rnd) {\n\n        h264chroma->put_h264_chroma_pixels_tab[0](s->dest[1], srcU, s->uvlinesize, 8, uvmx, uvmy);\n\n        h264chroma->put_h264_chroma_pixels_tab[0](s->dest[2], srcV, s->uvlinesize, 8, uvmx, uvmy);\n\n    } else {\n\n        v->vc1dsp.put_no_rnd_vc1_chroma_pixels_tab[0](s->dest[1], srcU, s->uvlinesize, 8, uvmx, uvmy);\n\n        v->vc1dsp.put_no_rnd_vc1_chroma_pixels_tab[0](s->dest[2], srcV, s->uvlinesize, 8, uvmx, uvmy);\n\n    }\n\n}\n", "idx": 7168, "substitutes": {"v": ["this", "iv", "vv", "ev", "uv", "vr", "q", "lv", "b", "it", "window", "ov", "c", "h", "av", "get", "view", "vi", "ve", "vector", "p", "g", "inv", "vol", "vp", "dev", "nov", "tv", "o", "va", "w", "sv", "rev", "qv", "video", "nv", "vd", "qu", "m", "browser", "vs", "V", "vc", "vis", "cv", "version", "y", "cache", "f", "vt", "conv", "wire", "vm", "e", "z", "x", "ver", "l"], "dir": ["init", "db", "draw", "depth", "dc", "loc", "rot", "grad", "tree", "trans", "dy", " direction", "dep", "dial", "direction", "cont", "det", "rel", "kind", "file", "d", "rect", "rad", "cmd", "table", "vol", "dt", "group", " Dir", "ind", "row", "DIR", "col", "dr", "id", "inter", " d", "dm", "Dir", "start", "ir", "mode", "iter", "dim", "dirty", "try", "tri", "driver", "dn", "ptr", "direct", "cond", "desc", "local", "manager", "directory", "dis", "di", "wd", "deg", "def", "path"], "s": ["sw", "less", "conf", "c", "http", "h", "state", "sc", "d", "ps", "ts", "settings", "t", "se", "w", "js", "sb", "services", "sav", "ss", "south", "series", "source", "as", "rs", "ses", "sam", "sort", "https", "os", "g", "ms", "stats", "m", "vs", "serv", "conv", "a", "l", "ops", "gs", "bis", "ssl", "times", "ns", "ctx", "ats", "cs", "comm", "cpp", "p", "is", "sv", "hs", "st", "bs", "sq", "session", "fs", "sql", "S", "sp", "b", "its", "sys", "qs", "als", "details", "n", "ds", "ins", "space", "ls", "status", "spec", "f", "sim", "sts"], "h264chroma": ["h264chiparea", "h265chromarea", "h264pixela", "h264pixelarea", "h264chromas", "h264chca", "h264chas", "h265chroma", "h264comA", "h264chromA", "h264cha", "h_chromas", "h264charea", "h265chromca", "h264pixelca", "h_roma", "h264romA", "h264coma", "h_chromarea", "h264chipA", "h264chromarea", "h264comarea", "h265chromas", "h264roma", "h_chroma", "h_romarea", "h264pixelas", "h_chromA", "h264chipa", "h_romA", "h_romas", "h264chromca", "h264comas", "h264romarea", "h264chipas", "h264romas"], "srcY": ["sourceZ", " srcX", " srcXY", "rcXY", "srcX", "sourceY", "sourceXY", "rcY", "sourceX", "srcXY", "srcZ", " srcZ", "rcX", "rcZ"], "srcU": ["sourceUI", "srcUV", "sourceU", "secureU", "sourceM", " srcUV", "secureUI", "srcM", "sourceUV", " srcM", "secureUV", "secureM", " srcUI", "srcUI"], "srcV": ["sourceY", " srcG", "rcV", "sourceU", "rcU", "rcY", "sourceV", "sourceG", "srcG", "rcG"], "dxy": ["nwx", "pwx", "nxy", "pwy", "dwx", "pxy", "sdxf", "dwy", "sdwx", "pxf", "sdxy", "nxf", "dxf", "sdwy", "nwy"], "mx": ["yz", "colm", "xy", "mn", "mem", "axy", "md", "MX", "ox", "phy", "ma", "wx", "sys", "rx", "mis", "mi", "mr", "mk", "wm", "px", "mes", "ms", "ml", "mt", "xx", "tm", "zx", "hz", "mic", "mie", "mmmm", "py", "mac", "xs", "yy", "txt", "memory", "mb", "m", "xml", "tx", "mm", "y", "yx", "mc", "nz", "ey", "mouse", "mys", "x", "mmm", "mp"], "my": ["vy", "ty", "colm", "fy", "mn", "Mi", "cy", "mem", "pty", "ym", "ies", "ox", "ma", "phy", "MY", "mis", "mi", " MY", "mk", "mid", "mon", "ky", "gy", "ami", "ias", "ms", "ery", "ame", "yes", "zzy", "mic", "mie", "ury", "ny", "pm", "me", "mmmm", "him", "ady", "py", "try", "memory", "sym", "why", "rey", "m", "ody", "My", "mine", "mm", "y", "ony", "sky", "omy", "am", "maybe", "ys", "mire", "MI", "mys", "TY", "mmm", "axy"], "uvmx": ["uvpy", " uVMx", "umx", " umx", "ucvox", "uvimx", "uvmware", "upmix", "ouvware", "upmware", "uVMx", "uvimy", " umy", " uvmox", "uvmix", "ouvk", "uvprx", " umrx", " uvmn", "ouvix", "uVMrx", "uvpx", "umrx", " uVMware", "ucvy", "ouvmx", "uVMy", "uvimk", "umn", "uVMn", "ouvmix", "uvx", " uVMox", " umn", " uvmware", "uvimix", " uvmrx", "ouvmk", "uvmox", "uvix", "uvmrx", "umy", "uVMware", "ucvx", "uvmk", "uvimware", "upmx", "upmk", "uvpn", "ouvmware", "uvmn", " uVMy", "uVMox", "ouvx", "uvk", "uvimox", "uvware", "ucvware"], "uvmy": ["uvpy", "uvgy", "uimy", "uumpy", "vvmis", "cvmi", "udgy", "avgy", "uummx", "vvmx", "udpy", "nvgy", "udmy", "uumis", "avy", "uuny", "uvny", "uvmis", "uummy", "uvmm", "nvmi", "uumm", "udmm", "uimis", "ummy", "ucy", "avmy", "nvy", "cvmx", "uumy", "uummm", "avmi", "ummm", "uvmi", "uugy", "cvny", "vvpy", "uvy", "udmi", "uupy", "uipy", "ucgy", "umgy", "ucmi", "ummx", "uumx", "nvmy", "udny", "vvmy", "uumi", "udmx", "uimx", "cvmy", "ucmy"], "src_x": ["src_ex", "source_x", "source_X", "source_ex", "src_X"], "src_y": ["rc_Y", "src2x", "src_my", "src2Y", "src2my", "rc_my", "src_Y", "rc_x", "src2y", "rc_y"], "uvsrc_x": ["uvsrc_ex"], "uvsrc_y": ["uvsource_x", "uvsource_y", "uvsource_Y", "uvsrc_Y", "uvsource_xy", "uvsrc_xy"], "i": ["init", "ic", "ini", "ij", "chain", "uri", "ci", "b", " ii", "it", "im", "c", "cli", "h", "gi", "mi", "qi", "ip", "li", "p", "si", "g", "zi", "is", "tim", "iq", "xi", "ind", "index", "ri", "hi", "bi", "pi", "multi", "me", "id", "ui", "ki", "ji", "phi", "ti", "iy", "ix", "ai", "m", "status", "I", "\u0438", "f", "ia", "io", "gu", "info", "in", "sim", "iu", "point", "di", "x", "ii"], "luty": ["luta", "lut", " lut", "sluta", " luti", "Luty", "sluti", "sluty", "slut", "Luti", "Luta", " luta", "Lut", "luti"], "lutuv": [" ludui", " luduu", "ludu", "lutuu", "luvuu", " lutu", "ludui", "lutui", "lUTu", "lUTuv", "luvui", "luduv", " luduv", "luvu", " lutui", " ludu", "lUTuu", "lUTui", "luduu", "luvuv", " lutuu", "lutu"], "use_ic": [" use_i", "use_i", "use2ic", "use2ac", "use2pic", " use_ac", "use2i", " use_pic", "use_ac", "use_pic"]}}
{"project": "FFmpeg", "commit_id": "7f526efd17973ec6d2204f7a47b6923e2be31363", "target": 1, "func": "static inline void RENAME(yuy2ToUV)(uint8_t *dstU, uint8_t *dstV, uint8_t *src1, uint8_t *src2, int width)\n\n{\n\n#if defined (HAVE_MMX2) || defined (HAVE_3DNOW)\n\n\tasm volatile(\n\n\t\t\"movq \"MANGLE(bm01010101)\", %%mm4\\n\\t\"\n\n\t\t\"mov %0, %%\"REG_a\"\t\t\\n\\t\"\n\n\t\t\"1:\t\t\t\t\\n\\t\"\n\n\t\t\"movq (%1, %%\"REG_a\",4), %%mm0\t\\n\\t\"\n\n\t\t\"movq 8(%1, %%\"REG_a\",4), %%mm1\t\\n\\t\"\n\n\t\t\"movq (%2, %%\"REG_a\",4), %%mm2\t\\n\\t\"\n\n\t\t\"movq 8(%2, %%\"REG_a\",4), %%mm3\t\\n\\t\"\n\n\t\tPAVGB(%%mm2, %%mm0)\n\n\t\tPAVGB(%%mm3, %%mm1)\n\n\t\t\"psrlw $8, %%mm0\t\t\\n\\t\"\n\n\t\t\"psrlw $8, %%mm1\t\t\\n\\t\"\n\n\t\t\"packuswb %%mm1, %%mm0\t\t\\n\\t\"\n\n\t\t\"movq %%mm0, %%mm1\t\t\\n\\t\"\n\n\t\t\"psrlw $8, %%mm0\t\t\\n\\t\"\n\n\t\t\"pand %%mm4, %%mm1\t\t\\n\\t\"\n\n\t\t\"packuswb %%mm0, %%mm0\t\t\\n\\t\"\n\n\t\t\"packuswb %%mm1, %%mm1\t\t\\n\\t\"\n\n\t\t\"movd %%mm0, (%4, %%\"REG_a\")\t\\n\\t\"\n\n\t\t\"movd %%mm1, (%3, %%\"REG_a\")\t\\n\\t\"\n\n\t\t\"add $4, %%\"REG_a\"\t\t\\n\\t\"\n\n\t\t\" js 1b\t\t\t\t\\n\\t\"\n\n\t\t: : \"g\" ((long)-width), \"r\" (src1+width*4), \"r\" (src2+width*4), \"r\" (dstU+width), \"r\" (dstV+width)\n\n\t\t: \"%\"REG_a\n\n\t);\n\n#else\n\n\tint i;\n\n\tfor(i=0; i<width; i++)\n\n\t{\n\n\t\tdstU[i]= (src1[4*i + 1] + src2[4*i + 1])>>1;\n\n\t\tdstV[i]= (src1[4*i + 3] + src2[4*i + 3])>>1;\n\n\t}\n\n#endif\n\n}\n", "idx": 7174, "substitutes": {"dstU": ["dgtUU", "DSTUt", "ddestUV", "dndUT", "ddestUL", "ddropUV", " dstUp", "dSTU", "DstUU", "dSTUT", " ddestUV", "dostMU", "dstUp", "dputUs", "dstMU", "DstUt", "dSTUU", "dbaseU", "DSTU", "ddestMU", " ddestUL", " dstMU", "dbaseUt", "dndUs", "dstUT", "dSTUp", "dgtUt", "dbaseUU", " dSTUp", " dSTUs", "dgtU", "dstUL", "dSTUs", "DSTUU", "DstU", " ddestU", "dostUV", "dputU", " dSTU", " dSTUT", "dstUs", "dostU", "dstUV", "dputUT", " dstUs", " ddestMU", "dndUp", " dstUT", "ddropU", "dostUL", " dstUL", "ddropUL", "dstUt", "dndU", "dputUp", "ddestU", " dstUV", "dstUU", "dSTUt", "ddropMU"], "dstV": ["dspG", "DstG", " dsetM", " dstM", "dwdVS", "dstM", "dconstM", "DndI", "dstsM", "dconstV", "dstsV", " dstVG", "DstV", "dstVS", "pdstrVT", "dsetM", "dsetV", "dwdVT", "DndP", "dwdV", "pdstG", "pdstrG", "dndVS", "dstY", "dstrG", "DstI", "dSTG", " dsetVG", "dspI", "dwdG", "dndP", "dstI", "dndV", "dstP", "pdstrV", "dsetVG", "dspP", "dSTP", "dconstVG", "dsetY", " dsetV", "pdstrVS", " dsetY", "DstP", "dconstY", " dstY", "DndG", "dndVT", "pdstVS", "dstsY", "dstG", "dstVG", "pdstV", "pdstVT", "dstrV", "dndG", "DndV", "dstsVG", "dstrVS", "dstVT", "dSTI", "dSTV", "dspV", "dndI", "dstrVT"], "src1": ["instOne", "src9", " src3", "usc0", "source2", "srcOne", "rc2", "source01", "loc1", "rc9", "loc3", "locOne", "loc2", "src0", "inst9", "src01", "rc3", " src9", "source3", "usc2", "rc1", " src01", "inst1", "rc01", "source1", "src3", "rc0", "usc1", "inst2", "rcOne", " srcOne", " src0"], "src2": ["rc4", " src3", "source2", " srcTwo", "proc0", " src02", "rc2", "rc8", "src0", "rc3", "source3", "rcTwo", "rc1", "source02", "src02", "src4", "proc2", "rc02", "source1", "sourceTwo", "src3", "rc0", "source4", " src8", "proc1", "source0", "proc8", "src8", " src4", "srcTwo", " src0"], "i": ["init", "ic", "ini", "depth", "sp", "chain", "ei", "ci", "b", " ii", "it", "cli", "oi", "gi", "mi", "qi", "ip", "li", "p", "si", "ami", "zi", "n", "is", "xi", "ind", "index", "o", "data", " ti", "key", "bi", "pi", " err", "multi", "err", "me", "ui", "id", "ki", "span", " I", "phi", "ti", " pi", "v", "ix", " j", "ai", "m", "status", "ri", "I", "batch", "print", "\u0438", "f", "sim", "gu", "iu", "point", "in", "info", "j", "di", "x", "ii", "name"]}}
{"project": "FFmpeg", "commit_id": "ba15aab4a4a296c632bd8d3428b002055109c7d1", "target": 0, "func": "static int mtv_read_header(AVFormatContext *s)\n\n{\n\n    MTVDemuxContext *mtv = s->priv_data;\n\n    AVIOContext   *pb  = s->pb;\n\n    AVStream        *st;\n\n    unsigned int    audio_subsegments;\n\n\n\n    avio_skip(pb, 3);\n\n    mtv->file_size         = avio_rl32(pb);\n\n    mtv->segments          = avio_rl32(pb);\n\n    avio_skip(pb, 32);\n\n    mtv->audio_identifier  = avio_rl24(pb);\n\n    mtv->audio_br          = avio_rl16(pb);\n\n    mtv->img_colorfmt      = avio_rl24(pb);\n\n    mtv->img_bpp           = avio_r8(pb);\n\n    mtv->img_width         = avio_rl16(pb);\n\n    mtv->img_height        = avio_rl16(pb);\n\n    mtv->img_segment_size  = avio_rl16(pb);\n\n\n\n    /* Calculate width and height if missing from header */\n\n\n\n    if(mtv->img_bpp>>3){\n\n    if(!mtv->img_width && mtv->img_height)\n\n        mtv->img_width=mtv->img_segment_size / (mtv->img_bpp>>3)\n\n                        / mtv->img_height;\n\n\n\n    if(!mtv->img_height && mtv->img_width)\n\n        mtv->img_height=mtv->img_segment_size / (mtv->img_bpp>>3)\n\n                        / mtv->img_width;\n\n    }\n\n    if(!mtv->img_height || !mtv->img_width || !mtv->img_segment_size){\n\n        av_log(s, AV_LOG_ERROR, \"width or height or segment_size is invalid and I cannot calculate them from other information\\n\");\n\n        return AVERROR(EINVAL);\n\n    }\n\n\n\n    avio_skip(pb, 4);\n\n    audio_subsegments = avio_rl16(pb);\n\n\n\n    if (audio_subsegments == 0) {\n\n        avpriv_request_sample(s, \"MTV files without audio\");\n\n        return AVERROR_PATCHWELCOME;\n\n    }\n\n\n\n    mtv->full_segment_size =\n\n        audio_subsegments * (MTV_AUDIO_PADDING_SIZE + MTV_ASUBCHUNK_DATA_SIZE) +\n\n        mtv->img_segment_size;\n\n    mtv->video_fps         = (mtv->audio_br / 4) / audio_subsegments;\n\n\n\n    // FIXME Add sanity check here\n\n\n\n    // all systems go! init decoders\n\n\n\n    // video - raw rgb565\n\n\n\n    st = avformat_new_stream(s, NULL);\n\n    if(!st)\n\n        return AVERROR(ENOMEM);\n\n\n\n    avpriv_set_pts_info(st, 64, 1, mtv->video_fps);\n\n    st->codec->codec_type      = AVMEDIA_TYPE_VIDEO;\n\n    st->codec->codec_id        = AV_CODEC_ID_RAWVIDEO;\n\n    st->codec->pix_fmt         = AV_PIX_FMT_RGB565BE;\n\n    st->codec->width           = mtv->img_width;\n\n    st->codec->height          = mtv->img_height;\n\n    st->codec->sample_rate     = mtv->video_fps;\n\n    st->codec->extradata       = av_strdup(\"BottomUp\");\n\n    st->codec->extradata_size  = 9;\n\n\n\n    // audio - mp3\n\n\n\n    st = avformat_new_stream(s, NULL);\n\n    if(!st)\n\n        return AVERROR(ENOMEM);\n\n\n\n    avpriv_set_pts_info(st, 64, 1, AUDIO_SAMPLING_RATE);\n\n    st->codec->codec_type      = AVMEDIA_TYPE_AUDIO;\n\n    st->codec->codec_id        = AV_CODEC_ID_MP3;\n\n    st->codec->bit_rate        = mtv->audio_br;\n\n    st->need_parsing           = AVSTREAM_PARSE_FULL;\n\n\n\n    // Jump over header\n\n\n\n    if(avio_seek(pb, MTV_HEADER_SIZE, SEEK_SET) != MTV_HEADER_SIZE)\n\n        return AVERROR(EIO);\n\n\n\n    return 0;\n\n\n\n}\n", "idx": 7177, "substitutes": {"s": ["as", "rs", "gs", "ses", "sp", "b", "ns", "c", "ctx", "ats", "h", "aws", "i", "set", "qs", "sys", "cs", "sc", "os", "p", "ps", "ms", "n", "is", "ts", "ds", "t", "es", "r", "js", "w", "ins", "an", "sv", "ls", "scl", "v", "stats", "m", "hs", "ss", "bs", "sq", "fs", "e", "S", "sts", "a"], "mtv": ["mtvt", "remtv", "dmvt", "mtt", "pmtar", "cmtar", "esmtw", "mtvv", "lv", "mty", "smtv", "mverb", "mdtek", "gmtt", "mantv", "mmvt", "emvv", "cmwire", "rmmobile", "gmvv", "emtk", "remvi", "remvv", "revolt", "ltt", " mTV", "wmTV", "mmtar", "armvt", "wmvt", "moduletv", "onvolt", "rmTV", "imuffy", "hmcoord", "esmtek", "bmty", "vmfont", "amver", "gmwire", "cmyout", "cmfont", "smvolt", "manvolt", "lemouch", "mmtv", "remtar", "emtv", "mtk", "onyout", "smvt", "mtif", "gmTV", "bmtv", "mailtar", "remtif", "remobile", "smmobile", "gmrss", "mvolt", "fmtemp", "esmvolt", "mattv", "manvv", "mmvi", "smtar", "reyout", "remnexus", "omvv", "mmvolt", "mintv", "mtemp", "amtw", "metfont", "esmTV", "pmtif", "mmobile", "mti", "dmtv", "mettip", "ontv", "mdtv", "hmvv", "wmti", "hmtv", "minvt", "lTV", "remvt", "amvt", "bmvt", "emfont", "miryout", "hmtemp", "modtek", "amwire", "mtg", "lemtar", "MTV", "smtk", "mantar", "esmti", "mnexus", "hmyout", "imvolt", "lemvt", "pmtek", "modti", "gmtek", "imyout", "mmtw", "mirvt", "mrss", "mTV", "emtif", "mtip", " mvolt", "Mv", "modtv", "remtek", "pmyout", "esmtip", "mirti", "rmtv", "lemty", "emwire", "mttar", "gmti", "modulev", "pmvv", "matmobile", "onvent", "Mtt", "ltv", "manvert", "vmtv", "vmverb", "mtouch", "gvt", "amyout", "mettv", "mvent", "cmtg", "gyout", "minvv", "dmvolt", "mtw", "mettw", "emmobile", "rmrss", "mvert", "wmtar", "gmvt", "myout", "rmyout", "emvt", "mdvt", "gtv", "pmtv", "wmtv", "remyout", "mtvi", "gvolt", "muffy", "mwire", "cmv", "hmvolt", "amtif", " mtek", "mdvv", "mirtv", "bmrss", "amnexus", "hmvi", "vmtar", "esmfont", "armnexus", "mmvv", "gmyout", "omtv", "armfont", "remti", "mfont", "Mti", "matwire", "hmtg", "mvt", "cmtek", "emvert", "fmyout", "remver", "remvolt", "amvolt", "armtv", "gmtar", "emvolt", "omtar", "amtv", "amvv", "smyout", "pmfont", "imtv", "rmvolt", "mvi", "mcoord", "mvv", "dmtemp", "gmtv", "retv", "imtg", "mver", "dmty", "cmtv", "smrss", "retar", "rmtek", "mtar", "cmuffy", "esmtv", "gmvolt", "matvolt", "mintek", "amtar", "wmvv", "gmfont", "emyout", "mantif", "vmtek", "dmrss", "armtar", "dmyout", "lemrss", "wmyout", "imtar", "hmuffy", "mouch", "mailtw", "vmv", "wmvolt", "mtek", "amfont", "moduleverb", "hmver", "armwire", "omtif", "Mvv", "mailtv", "mantw", "dmcoord", "hmtek", "rmvent", "hmvent", "mttv", "vmvolt", "gmv", "moduletek", "ammobile", "retk", "armvolt", "cmvolt", "emtar", "remvert", "amtek", "mmouch", "hmvt", "amvi", "mailvolt", "modvolt", "amtip", "fmcoord", "Mtv", "cmverb", "mv", "cmmobile", "gmmobile", "fmtv", "lemtv"], "pb": ["db", "peer", "uf", "gc", "buff", "lv", "bj", "um", "sp", "wp", "cp", "gp", "eb", "bot", "pc", "ctx", "pack", "pt", "buf", "ob", "buffer", "p", "pa", "bp", "typ", "vp", "cb", "pl", "wb", "fp", "erb", "lb", "pm", "ub", "bb", "pg", "pkg", "proc", "span", "sb", "pr", "py", "lp", "rb", "emb", "mb", "port", "resp", "tab", "bs", "fb", "cv", "tmp", "tf", "pool", "jp", "np", "vt", "dp", "obj", "xp", "vm", "PB", "td", "pp", "snap", "tk", "oa", "tp", "tc", "mp"], "st": ["so", "sp", "sw", "ct", "est", "sth", "sam", " ss", "sc", "mt", "std", "bt", "se", "str", "ast", "sv", "rest", "sl", "ss", "sn", "ist", "ST", "ft", "ste", "sts", "fr", "ust", "St"], "audio_subsegments": ["audio_Subbelements", "audio_subteges", "audio_Subbegments", "audio_subvements", "audio_subseges", "audio_subperselements", "audio_subsements", "audio_subbegment", "audio_subsegment", "audio_subtelements", "audio_subpersegments", "audio_subperseges", "audio_subschegs", "audio_Subseges", "audio_subschegments", "audio_Subselements", "audio_subsegs", "audio_subtements", "audio_subschements", "audio_subbelements", "audio_subvegments", "audio_subvegment", "audio_Subbegment", "audio_subbeges", "audio_Subsements", "audio_subpersegment", "audio_subtegs", "audio_subbegments", "audio_Subbements", "audio_Subbegs", "audio_Subbeges", "audio_Subsegments", "audio_subpersegs", "audio_subpersements", "audio_subtegments", "audio_subveges", "audio_subselements", "audio_subbegs", "audio_subvegs", "audio_subtegment", "audio_Subsegment", "audio_Subsegs", "audio_subschelements", "audio_subschegment", "audio_subbements"]}}
{"project": "qemu", "commit_id": "a890643958f03aaa344290700093b280cb606c28", "target": 1, "func": "static bool qht_insert__locked(struct qht *ht, struct qht_map *map,\n\n                               struct qht_bucket *head, void *p, uint32_t hash,\n\n                               bool *needs_resize)\n\n{\n\n    struct qht_bucket *b = head;\n\n    struct qht_bucket *prev = NULL;\n\n    struct qht_bucket *new = NULL;\n\n    int i;\n\n\n\n    do {\n\n        for (i = 0; i < QHT_BUCKET_ENTRIES; i++) {\n\n            if (b->pointers[i]) {\n\n                if (unlikely(b->pointers[i] == p)) {\n\n                    return false;\n\n                }\n\n            } else {\n\n                goto found;\n\n            }\n\n        }\n\n        prev = b;\n\n        b = b->next;\n\n    } while (b);\n\n\n\n    b = qemu_memalign(QHT_BUCKET_ALIGN, sizeof(*b));\n\n    memset(b, 0, sizeof(*b));\n\n    new = b;\n\n    i = 0;\n\n    atomic_inc(&map->n_added_buckets);\n\n    if (unlikely(qht_map_needs_resize(map)) && needs_resize) {\n\n        *needs_resize = true;\n\n    }\n\n\n\n found:\n\n    /* found an empty key: acquire the seqlock and write */\n\n    seqlock_write_begin(&head->sequence);\n\n    if (new) {\n\n        atomic_rcu_set(&prev->next, b);\n\n    }\n\n    b->hashes[i] = hash;\n\n    /* smp_wmb() implicit in seqlock_write_begin.  */\n\n    atomic_set(&b->pointers[i], p);\n\n    seqlock_write_end(&head->sequence);\n\n    return true;\n\n}\n", "idx": 7191, "substitutes": {"ht": ["gt", "ct", "att", "h", "bh", "help", "mt", "bt", "hw", " h", "dh", "ach", "th", "mu", "ap", "host", "handle", "v", "sh", "dq", "ch", "vt", "hip", "hm", "hd", "ld", "hold", "bm", "tt"], "map": ["policy", "header", "form", "tree", "app", "mem", "metadata", "MAP", "window", "conf", "cp", "h", "pack", "view", "maps", "image", "set", "Map", "table", "mt", "dict", "mg", "index", "pl", "list", "ap", "master", "sm", "k", "host", "man", "sh", "m", "block", "bridge", "load", "mm", "pool", "cache", "mask", "apper", "shape", "lock", "ape", "mp"], "head": ["this", "init", "header", "root", "next", "mem", "window", "run", "md", "h", "back", "HEAD", "view", "heading", "headed", "Head", "help", "cmd", "dict", "link", "index", "data", "first", "history", " HEAD", "headers", "old", "th", "top", "master", "stock", "start", "commit", "host", "ad", "ack", "block", "mit", "stream", "off", "df", "ptr", "parent", "he", "front", "doc", "cache", "before", "heads", "hd", "lock", "hold", "one", "holder", "tail", "name"], "p": ["pid", "q", "sp", "it", "wp", "cp", "ping", "pb", "c", "u", "pc", "h", "up", "pad", "rep", "ip", "g", "d", "pa", "ps", "bp", "n", "vp", "op", "o", "fp", "t", "perm", "w", "pos", "pre", "pkg", "ap", "lp", "v", "m", "part", "ptr", "jp", "np", "pp", "P", "j", "tp", "mp"], "hash": ["match", "type", "h", "shift", "cmp", "sha", " hashing", "kh", "oh", "bh", "prop", "addr", "chip", "data", " h", "key", "Hash", "height", "dh", "prime", "tag", "id", "ref", "proof", "ap", "ah", "handle", "sh", "her", "ash", "ch", "block", "ho", "address", "sum", "length", "html", "lock", "holder"], "needs_resize": ["needs_resiz", "needs_windowsize", "needs_reshiz", "needs_reizing", "needs_fixizing", "needs_resizing", "needs_reiz", "needs_reshization", "needs_oversign", "needs_oversiz", "needs_reshize", "needs_reign", "needs_resization", "needs_rensize", "needs_windowsign", "needs_oversization", "needs_oversize", "needs_resign", "needs_reization", "needs_reshign", "needs_renize", "needs_fixize", "needs_renization", "needs_windowsiz", "needs_fixign", "needs_ressize", "needs_windowsization", "needs_reshsize", "needs_reize", "needs_reshizing", "needs_fixiz", "needs_renign"], "b": ["db", "gb", "buff", "bis", "ab", "eb", "pb", "c", "ib", "h", "br", "bg", "bc", "back", "blue", "buf", "ob", "buffer", "bh", "g", "d", "base", "bp", "body", "n", "bd", "lib", "cb", "bo", "o", "bt", "t", "wb", "bound", "bi", "lb", "r", "bit", "go", "bb", "w", "bar", "sb", "rb", "s", "v", "be", "mb", "m", "bridge", "B", "bs", "nb", "fb", "batch", "y", "bl", "f", "l", "e", "j", "bm", "a", "reb", "bin"], "prev": ["header", "upper", "sp", "next", "root", "vious", "h", "br", "av", "cmp", "rel", "buf", "last", "self", "vp", "var", "first", "history", "old", "pre", "rev", "ren", "iter", "v", "orig", "vs", "adj", "tmp", "ptr", "reverse", "parent", "jump", "current", "cur", "before", "Prev", "pp", "pres", "j", "tail", "mp"], "new": ["result", "next", "created", "root", "false", "end", "pb", "h", "null", "set", "create", "self", "recent", "NEW", "g", "add", "d", "n", "New", "missing", "unique", "good", "un", "o", "first", "t", "r", "old", "w", "from", "to", "out", "normal", "different", "v", "found", "m", "fresh", "now", "parent", "current", "known", "existing", "snap", "j", "news", "other", "a", "name"], "i": ["chain", "ei", " multi", " ii", "im", "ori", "gi", "zi", "ind", " ti", "t", "pi", "hi", "iter", " j", "I", "batch", "io", "in", "j", "iri", "x", "\u0438", "di", "ic", " m", "mi", "g", "ms", "xi", "index", "ri", "bi", "ti", "v", "ai", "m", "remote", "info", "ci", "it", "ip", "li", "ami", "is", "ski", "o", " I", "s", "try", "y", "fi", "ii", "init", "ini", "ij", "uri", "client", "si", "n", "iq", "multi", "me", "ui", "id", "ji", "list", "phi", "ims", "ix", "status", "print", "sim", "ex", "iu", "e"]}}
{"project": "FFmpeg", "commit_id": "6e1b1a27a4034c578018d5042b3c8228278c4cd6", "target": 1, "func": "static int copy_packet_data(AVPacket *pkt, AVPacket *src, int dup)\n\n{\n\n    pkt->data      = NULL;\n\n    pkt->side_data = NULL;\n\n    if (pkt->buf) {\n\n        AVBufferRef *ref = av_buffer_ref(src->buf);\n\n        if (!ref)\n\n            return AVERROR(ENOMEM);\n\n        pkt->buf  = ref;\n\n        pkt->data = ref->data;\n\n    } else {\n\n        DUP_DATA(pkt->data, src->data, pkt->size, 1, ALLOC_BUF);\n\n    }\n\n#if FF_API_DESTRUCT_PACKET\n\nFF_DISABLE_DEPRECATION_WARNINGS\n\n    pkt->destruct = dummy_destruct_packet;\n\nFF_ENABLE_DEPRECATION_WARNINGS\n\n#endif\n\n    if (pkt->side_data_elems && dup)\n\n        pkt->side_data = src->side_data;\n\n    if (pkt->side_data_elems && !dup) {\n\n        return av_copy_packet_side_data(pkt, src);\n\n    }\n\n    return 0;\n\n\n\nfailed_alloc:\n\n    av_destruct_packet(pkt);\n\n    return AVERROR(ENOMEM);\n\n}\n", "idx": 7204, "substitutes": {"pkt": [" pkg", "expet", "compkat", "wpelt", "patkt", "Pkg", "padnt", "payett", "tacket", "ykg", "apkt", "expkt", "cpdu", " ppt", "pet", "gnt", "ytext", "prkt", "pakt", "patkat", "Ptext", "Pwk", "pdu", " pmsg", "gkt", "spnt", "apnt", " pett", "padwk", " pshot", "compnt", "pcht", "cpkt", "apacket", "attkt", "Pshot", "pracket", "pkgkt", "Ppt", "tkt", "cpacket", "compkt", "ppacket", "Pkat", "attnt", "Pcht", "Pelt", "spacket", " ptext", "apcht", "ppnt", " pwk", "pelt", "wpkt", "prkg", "pkgcmd", "pcmd", "paykt", "spkg", "Packet", "pacmd", "pkgnt", "Pnt", "attmsg", "ppt", "ykt", "prnt", "ppkt", "pwk", "exppt", "pkg", " pnt", "prekt", "gcht", "pett", "pkgkg", "pkat", "padkg", "pashot", "ptext", "preelt", "pmsg", "gacket", "pawk", "ppet", "spkt", "preacket", "spet", "precmd", "tnt", "tmsg", "padkt", "Pet", "pnt", "ynt", "Pmsg", "Pcmd", "compacket", " pcmd", "wpacket", " pdu", "patnt", "packet", "wpnt", "cpett", "pshot", "payacket", "patacket", "attacket", "prekg", "expacket", "paydu", "prent", " pet", " packet", "Pkt"], "src": ["iv", "SOURCE", "rs", "loc", "vr", "sp", "ser", "sr", "ctx", "cmp", "cont", "sys", "buf", "sc", "sup", "pri", "addr", "inst", "aux", "sync", "usr", "rob", "sel", "rc", "syn", "ins", "proc", "pkg", "rest", "sb", "start", "s", "sec", "sur", "rt", "ack", "rl", "inner", "st", "sub", "secure", "sn", "tmp", "img", "supp", "sq", "cur", "dest", "obj", "rec", "via", "comp", "RC", "inc", "source", "urg"], "dup": ["sep", "slef", "udping", "udP", "dopp", "drapi", "dups", "dief", "secp", "sepp", "diepp", "drap", "slepi", "udp", "Dups", "diep", "udps", "seps", " dups", "dops", "diepi", "sleps", " duP", "draf", "dupi", " duping", "Dup", "duping", "ducp", "DuP", "diecp", "draps", "duP", "docp", "dieps", "duf", "Duping", "dupp", "slep", "dop"], "ref": ["q", "uf", "mem", "conf", "eb", "af", "c", "br", "null", "cmp", "rel", "buf", "lf", "ob", "prop", "addr", "co", "use", "lib", "val", "cb", "index", "REF", "range", "alt", "r", "col", "rc", "id", "inter", "rev", "k", "grab", "ef", "req", "mb", "resp", "re", "new", "tab", "ret", "tmp", "ptr", "pool", "cache", "f", "obj", "rec", "info", "Ref", "ro", "reference", "def"]}}
{"project": "qemu", "commit_id": "aa8f057e74ae08014736a690ff41f76c756f75f1", "target": 0, "func": "static void virtio_crypto_instance_init(Object *obj)\n\n{\n\n    VirtIOCrypto *vcrypto = VIRTIO_CRYPTO(obj);\n\n\n\n    /*\n\n     * The default config_size is sizeof(struct virtio_crypto_config).\n\n     * Can be overriden with virtio_crypto_set_config_size.\n\n     */\n\n    vcrypto->config_size = sizeof(struct virtio_crypto_config);\n\n\n\n    object_property_add_link(obj, \"cryptodev\",\n\n                             TYPE_CRYPTODEV_BACKEND,\n\n                             (Object **)&vcrypto->conf.cryptodev,\n\n                             virtio_crypto_check_cryptodev_is_used,\n\n                             OBJ_PROP_LINK_UNREF_ON_RELEASE, NULL);\n\n}\n", "idx": 7213, "substitutes": {"obj": ["ck", "xy", "instance", "obb", "it", "po", "kr", "ctx", "kt", "cmp", "cont", "pt", "nt", "ob", "elt", "mk", "bh", "osi", "rect", "cmd", "inst", "typ", "ocr", "bo", "o", "hw", "t", "phys", "obo", "js", "pkg", "expr", "attr", "org", "oc", "txt", "resp", "bs", "tmp", "y", "onet", "oss", "fr", "j", "obs", "tk", "res", "Obj", "object", "act"], "vcrypto": ["vcrototo", "cvrypto", "cvryptoto", "vcredo", "vcryptionho", "VCryptoo", "VCryptho", "VCcryptho", "cvryptO", "VCryptpo", "vcrotO", "vcredoto", "vcCrypton", "vcCryptso", "vccryptso", "vccryptho", "vcryptO", "vcprotpo", "cvrotO", "vcCrypto", "cvrototo", "vccrypto", "VCcrypto", "vcCryptO", "vcCryptpo", "VCcryptoo", "vcryptoto", "vccryptpo", "VCrypto", "vcryptiono", "vcproto", "vcrotoo", "cvrypton", "vcredO", "VCcryptpo", "vcryptionoo", "VCcryptso", "vcroton", "vcryptso", "vcCryptoo", "cvroto", "vccryptoo", "vcryptho", "vcprotho", "vcredon", "vcryptoo", "vcprotoo", "VCryptso", "vcroto", "vcrotso", "vcrotpo", "vcCryptoto", "cvroton", "vcryptionpo", "vcrypton", "vcryptpo"]}}
{"project": "qemu", "commit_id": "d4c430a80f000d722bb70287af4d4c184a8d7006", "target": 0, "func": "int cpu_sh4_handle_mmu_fault(CPUState * env, target_ulong address, int rw,\n\n\t\t\t     int mmu_idx, int is_softmmu)\n\n{\n\n    target_ulong physical;\n\n    int prot, ret, access_type;\n\n\n\n    access_type = ACCESS_INT;\n\n    ret =\n\n\tget_physical_address(env, &physical, &prot, address, rw,\n\n\t\t\t     access_type);\n\n\n\n    if (ret != MMU_OK) {\n\n\tenv->tea = address;\n\n\tswitch (ret) {\n\n\tcase MMU_ITLB_MISS:\n\n\tcase MMU_DTLB_MISS_READ:\n\n\t    env->exception_index = 0x040;\n\n\t    break;\n\n\tcase MMU_DTLB_MULTIPLE:\n\n\tcase MMU_ITLB_MULTIPLE:\n\n\t    env->exception_index = 0x140;\n\n\t    break;\n\n\tcase MMU_ITLB_VIOLATION:\n\n\t    env->exception_index = 0x0a0;\n\n\t    break;\n\n\tcase MMU_DTLB_MISS_WRITE:\n\n\t    env->exception_index = 0x060;\n\n\t    break;\n\n\tcase MMU_DTLB_INITIAL_WRITE:\n\n\t    env->exception_index = 0x080;\n\n\t    break;\n\n\tcase MMU_DTLB_VIOLATION_READ:\n\n\t    env->exception_index = 0x0a0;\n\n\t    break;\n\n\tcase MMU_DTLB_VIOLATION_WRITE:\n\n\t    env->exception_index = 0x0c0;\n\n\t    break;\n\n\tcase MMU_IADDR_ERROR:\n\n\tcase MMU_DADDR_ERROR_READ:\n\n\t    env->exception_index = 0x0c0;\n\n\t    break;\n\n\tcase MMU_DADDR_ERROR_WRITE:\n\n\t    env->exception_index = 0x100;\n\n\t    break;\n\n\tdefault:\n\n\t    assert(0);\n\n\t}\n\n\treturn 1;\n\n    }\n\n\n\n    address &= TARGET_PAGE_MASK;\n\n    physical &= TARGET_PAGE_MASK;\n\n\n\n    return tlb_set_page(env, address, physical, prot, mmu_idx, is_softmmu);\n\n}\n", "idx": 7222, "substitutes": {"env": ["policy", "event", "esc", "conf", "buf", "state", "die", "see", "ec", "enter", "dev", "network", "cb", "environment", "query", "gear", "sb", "en", "ah", "txt", "worker", "estate", "entry", "cur", "operator", "esm", "vv", "store", "ve", "er", "context", "eh", "server", "code", "rb", "v", "config", "vs", "desc", "shell", "db", "ev", "et", "console", "end", "ctx", "era", "ent", "ener", "sv", "nv", "cfg", "answer", "cv", "vm", "engine", "door", "init", "window", "here", "set", "te", "erd", "cmd", "inv", "vp", "ew", "eng", "ner", "Environment", "proc", "ef", "man", "ptr", "manager", "vt", "obj", "e", "global", "conn"], "address": ["read", "service", "result", "event", "error", "type", "page", "description", "buffer", "ip", "map", "table", "addr", "order", "add", "domain", "connection", "location", "network", "context", "index", "pointer", "pair", "account", "range", "server", "r", "value", "trace", "position", "record", "resource", "attribute", "ref", "route", "password", "device", "start", "host", "memory", "Address", "command", "port", "array", "request", "object", "controller", "action", "response", "ptr", "current", "message", "eth", "shape", "length", "interface", "adr", "ase", "private", "a", "ace", "reference", "name", "path"], "rw": ["aw", "sw", "mem", "wp", "wa", "ram", "wind", "addr", "rew", "ew", "wr", "seek", "row", "wb", "hw", "r", "w", "word", "resource", "rh", "rf", "rb", "rar", "rt", "worker", "writer", "wrap", "alloc", "ptr", "wer", "rd", "write", "RW", "work", "ro", "nw"], "mmu_idx": ["mmu_indy", "mmu_isdk", "mmu__idy", "mmu__idf", "mmu_indk", "mmu__idx", "mmu_Idxf", "mmu_isdx", "mmu__midx", "mmu_midf", "mmu_idf", "mmu_indx", "mmu_Idf", "mmu__idxf", "mmu_midxf", "mmu_Idx", "mmu_indxf", "mmu_idxf", "mmu_midx", "mmu_idy", "mmu__midxf", "mmu_ridf", "mmu__midy", "mmu_ridx", "mmu_isdy", "mmu_Idy", "mmu_midy", "mmu_ridy", "mmu_idk", "mmu_ridxf", "mmu__midf", "mmu_isdxf", "mmu__idk"], "is_softmmu": ["is_softMMu", "is_hardmmcu", "is_softmodeut", "is_softmodeu", "is_hardmmut", "is_softmemu", "is_softmmcu", "is_softmcus", "is_softMMcu", "is_softmemx", "is_hardmmx", "is_softmemus", "is_softmemut", "is_softMMus", "is_softmmus", "is_softmmx", "is_softmccu", "is_softmcu", "is_softmodex", "is_hardmmus", "is_softmodeus", "is_hardmmu", "is_softmmut"], "physical": ["Physical", "read", "information", " pointer", "encrypted", "prefix", "target", "type", "native", "operation", "real", "phy", "virtual", "binary", "relative", "readable", "primary", "localhost", "path", "ip", "pure", "secondary", "p", "accessible", "vp", "network", "personal", "pointer", "total", "phone", "phys", " protocol", " reference", "server", "protected", "resource", "attribute", "external", "reported", "host", "memory", "config", "port", "basic", " hardware", "ptr", "local", "remote", "print", "restricted", "home", "current", "pn", "public", "net", "variable", "private", "tp", "reference"], "prot": ["method", "rot", "att", "channel", "pb", "type", "pc", "phy", "virtual", "pro", "primary", "ht", "iot", "ip", "prop", "pat", "p", "chron", "typ", "tif", "phys", " protocol", "ocol", "protected", "col", " proto", "ref", "pos", "rf", "password", "Prot", "port", "status", "controller", "ptr", "pattern", "version", "tf", "eth", "ft", "tech", "net", "format", "inet", "tp"], "ret": ["gt", "result", "rot", "mem", "att", "git", "reply", "back", "cont", "virtual", "ter", "nt", "elt", "ext", "p", "addr", "cmd", "mt", "virt", "rets", "len", "val", "tr", "alt", "t", "err", "rc", "ref", "inter", "rev", "rf", "rest", "pert", "out", "rt", "reset", "status", "resp", "port", "re", "response", "ptr", "lit", "RET", "pas", "jp", "vt", "Ret", "eth", "test", "nz", "sat", "ft", "hash", "tech", "res", "deg", "def", "cert"], "access_type": ["access_token", "accessuretoken", "access00type", "accessitytyp", "access_timeout", "accessuretimeout", "access00TYPE", " access_token", " access_Type", "accessureType", " access_timeout", "access_ype", "accessuretype", "Access_Type", "Access_type", "access_Type", "Access_TYPE", "accessitytimeout", " access_TYPE", "access00Type", "accessitytype", "access00ype", "access_typ", "accessityType", "accessureTYPE", " access_typ", "Access_ype", "accessuretyp", "access_TYPE"]}}
{"project": "qemu", "commit_id": "40dfc16f5fe0afb66f9436718781264dfadb6c61", "target": 1, "func": "static int virtio_blk_device_exit(DeviceState *dev)\n\n{\n\n    VirtIODevice *vdev = VIRTIO_DEVICE(dev);\n\n    VirtIOBlock *s = VIRTIO_BLK(dev);\n\n#ifdef CONFIG_VIRTIO_BLK_DATA_PLANE\n\n    remove_migration_state_change_notifier(&s->migration_state_notifier);\n\n    virtio_blk_data_plane_destroy(s->dataplane);\n\n    s->dataplane = NULL;\n\n#endif\n\n    qemu_del_vm_change_state_handler(s->change);\n\n    unregister_savevm(dev, \"virtio-blk\", s);\n\n    blockdev_mark_auto_del(s->bs);\n\n    virtio_cleanup(vdev);\n\n    return 0;\n\n}\n", "idx": 7243, "substitutes": {"dev": ["iv", "ev", "des", "prom", "mem", "att", "md", "cam", "pad", "DEV", "dem", "buf", "pro", "pt", "nt", "det", "ve", "d", "g", "cmd", "tm", "ds", "tr", "data", "hw", "w", "go", "th", "adv", "proc", "device", "env", "v", "watch", "ad", "nv", "dd", "spec", "serv", "scan", "doc", "priv", "serial", "test", "de", "hd", "dis", "ver", "Dev", "conn", "def"], "vdev": ["wdev", "vev", "vdevice", "vhw", "uvhw", "vtdi", "uvdev", "uvev", "vdi", "vtdev", " vdi", "whw", "vmdet", "vdet", "wev", "wdevice", "uvdevice", " vhw", "vtdet", " vev", "vmdev", " vdevice", " vdet", "vmdi"], "s": ["rs", "gs", "ses", "sp", "b", "sw", "ns", "c", "its", "h", "aws", "i", "qs", "cs", "self", "comm", "ps", "p", "ms", "details", "n", "g", "is", "ts", "cmd", "ds", "t", "es", "r", "js", "w", "ins", "sv", "ls", "sm", "services", "sb", "comments", "params", "v", "ims", "stats", "args", "m", "spec", "vs", "hs", "bs", "ss", "sq", "f", "fs", "S", "sts", "j", "sis", "a", "l"]}}
{"project": "qemu", "commit_id": "0479097859372a760843ad1b9c6ed3705c6423ca", "target": 1, "func": "static void pc_dimm_get_size(Object *obj, Visitor *v, const char *name,\n\n                             void *opaque, Error **errp)\n\n{\n\n    uint64_t value;\n\n    MemoryRegion *mr;\n\n    PCDIMMDevice *dimm = PC_DIMM(obj);\n\n    PCDIMMDeviceClass *ddc = PC_DIMM_GET_CLASS(obj);\n\n\n\n    mr = ddc->get_memory_region(dimm);\n\n    value = memory_region_size(mr);\n\n\n\n    visit_type_uint64(v, name, &value, errp);\n\n}\n", "idx": 7267, "substitutes": {"obj": ["vr", "xy", "bj", "instance", "po", "ctx", "h", "cont", "objects", "sys", "pt", "nt", "ob", "elt", "os", "bh", "ht", "p", "rect", "cmd", "inst", "vp", "Object", "op", "o", "hw", "t", "func", "js", "opp", "ref", "pkg", "proc", "oj", "org", "txt", "oid", "resp", "adj", "Obj", "tmp", "np", "ex", "obs", "onet", "object", "act"], "v": ["iv", "vv", "vy", "uv", "ev", "vr", "q", "b", "c", "h", "av", "vi", "p", "d", "g", "vp", "mint", "tv", "o", "t", "r", "w", "sv", "qv", "vu", "nv", "m", "V", "vc", "vs", "vis", "cv", "f", "vt", "conv", "j", "l"], "name": ["event", "prefix", "named", "type", " key", "def", "nam", "p", "ename", "ame", "n", "no", "len", "var", "property", "data", "key", "t", "str", "w", "id", "word", "attr", " NAME", "NAME", "part", "comment", "alias", "ident", "size", " Name", "info", " prefix", "names", "ni", "title", "Name", "path", " names"], "opaque": ["obcode", "obaz", "obacity", "Opcode", "Opacity", "Opaz", "opacity", "popaz", "opcode", "popacity", "popaque", "opaz", "Opaque", "popcode", "obaque"], "errp": [" errP", "errorpa", " errps", "cerps", "rrP", "errps", "cerpa", "lerps", "errpa", "errorP", "rrp", "cerp", "errorp", "rrps", "rrpa", "lerpa", "lerpad", "errP", "cerpad", " errpad", "errpad", "lerp", " errpa", "errorps"], "value": ["output", "widget", "result", "function", "type", "values", "field", " Value", "description", "buffer", "see", "vp", "val", "property", "index", "data", "total", "key", "tv", "scale", "trace", "w", "unit", "attribute", "byte", "word", "bar", "ue", "oval", "max", "checked", "memory", "port", "array", "version", "local", "Value", "address", "message", "VAL", "sum", "size", "length", "json", "VALUE"], "mr": ["rs", "vr", "mn", "lr", "rpm", "sr", "kr", "gr", "mk", "wm", "er", "mar", "cm", "mir", "mt", "ms", "ml", "ocr", "usr", "tr", "r", "pm", "mer", "rr", "rh", "pr", "rar", "mb", "m", "shr", "rl", "rg", "MR", "mc", "hm", "RM", "drm", "adr", "bm", "Mr", "hr", "rm", "mp"], "dimm": ["distimm", "edImm", "mem", " dim", "edimm", "mom", "dem", "damm", "distigm", "edem", "ddigm", " dem", "ddimm", "dim", " dImm", "digm", "ddamm", "mImm", "dImm", "distamm", "ddim", "edom", " digm", " dom", "mimm", " damm", "dom", "distim"], "ddc": ["ddca", " ddlc", "ddsca", "eedlc", "ddslc", "tdC", "dedfc", "ddsc", "dedC", "dedc", "tdc", "ddsC", "dedcs", " ddca", "ddC", "tdfc", "eedca", "ddlc", " ddcs", "eedC", "tdcs", "ddcs", "ddfc", "eedc", " ddfc", " ddC"]}}
{"project": "qemu", "commit_id": "821303f59b63ab832f0921f070db55e95bb21858", "target": 1, "func": "target_ulong spapr_rtas_call(sPAPREnvironment *spapr,\n                             uint32_t token, uint32_t nargs, target_ulong args,\n                             uint32_t nret, target_ulong rets)\n{\n    if ((token >= TOKEN_BASE)\n        && ((token - TOKEN_BASE) < TOKEN_MAX)) {\n        struct rtas_call *call = rtas_table + (token - TOKEN_BASE);\n        if (call->fn) {\n            call->fn(spapr, token, nargs, args, nret, rets);\n    hcall_dprintf(\"Unknown RTAS token 0x%x\\n\", token);\n    rtas_st(rets, 0, -3);\n    return H_PARAMETER;", "idx": 7269, "substitutes": {"spapr": ["spapsfr", "spaprc", "spiprar", "spampR", "sparpr", "spapsrs", "spipR", " spiprc", " spipR", " spiprs", "spipr", "spamprc", " spapR", " spiprar", "sparpR", "spapfr", " spaprc", "spapsR", "spaperc", " spaprar", "spiprs", " spaprs", "sparpfr", "spapeR", "spampr", "spaprar", "sparprs", "spaper", "spaperar", " spipfr", "spamprar", "spiprc", "spipfr", "spapR", " spipr", "spaprs", " spapfr", "spapsr"], "token": ["header", "tree", "event", "error", "padding", "function", "node", "window", "target", "type", "note", "kt", "oken", "field", "offset", "none", "ok", "template", "year", "table", "typ", "tn", "notice", "seed", "no", "len", "data", "t", "wt", "Token", "key", "input", "number", "position", "callback", "word", "value", "password", "normal", "kn", "txt", "reset", "block", "TN", "random", "date", "now", "frequency", "batch", "TO", "KEN", "local", "WT", "topic", "rule", "serial", "message", "before", "prototype", "ask", "atom", "time", "format", "tick", "trigger"], "nargs": ["pnfull", " nrows", "cnarg", "cnfull", "sngs", "pnarg", "pnrows", "snvals", " ngs", "nfull", " narg", "pnargs", "cnrows", " nvals", "cnargs", "Nvals", " nfull", "narg", "snargs", "Narg", "nrows", "Nargs", "snarg", "ngs", "Ngs", "nvals"], "args": ["rs", "fields", "gs", "names", "ars", "ants", "ns", "uments", "ctx", "ags", "aws", "qs", "cs", "terms", "files", "ps", "frames", "ms", "ts", "ds", "aux", "arms", "vals", "js", "ands", "ens", "ins", "ids", "gets", "xs", "Args", "ras", "stats", "keys", "ams", "uns", "doc", "fs", "ems", "arg", "flags", "ais", "groups", "arr", "params"], "nret": ["Npret", " npret", " Nreturn", "Nrets", "nreturn", "Nalt", " nrets", "npret", "nnalt", " nreturn", " nalt", " Nrets", "Nret", "nrets", " Nret", "Nreturn", " Npret", "nnreturn", "nalt", "nnrets", "nnret"], "rets": ["rs", "fields", "gs", "ses", "results", "uds", "fts", "ns", "ants", "uments", "its", "ints", "values", "urs", "qs", "cs", "nt", "als", "mt", "ts", "rows", "aux", "uts", "vals", "errors", "types", "ls", "events", "ties", "ras", "outs", "keys", "rt", "secret", "ret", "states", "RET", "vt", "fs", "sts", "res", "arr", "alls", "def", "lists"], "call": ["all", "draw", "cast", "update", "form", "node", "ell", "c", "dial", "run", "back", "find", " cal", "con", "execute", "table", "co", "add", "use", "circ", "row", "label", "t", "ALL", "col", "contact", "push", "word", "ref", "list", "send", "commit", "Call", "cal", "cell", "block", "frame", "ac", "load", "close", "build", "eval", "local", "exec", "make", "f", "can", "rec", "check", "roll", "ll", "create", "def"]}}
{"project": "qemu", "commit_id": "afa46c468acc18914c2773538f1b088c507766ee", "target": 0, "func": "static int32_t scsi_send_command(SCSIRequest *req, uint8_t *cmd)\n\n{\n\n    SCSIGenericState *s = DO_UPCAST(SCSIGenericState, qdev, req->dev);\n\n    SCSIGenericReq *r = DO_UPCAST(SCSIGenericReq, req, req);\n\n    int ret;\n\n\n\n    if (cmd[0] != REQUEST_SENSE && req->lun != s->qdev.lun) {\n\n        DPRINTF(\"Unimplemented LUN %d\\n\", req->lun);\n\n        scsi_req_build_sense(&r->req, SENSE_CODE(LUN_NOT_SUPPORTED));\n\n        scsi_req_complete(&r->req, CHECK_CONDITION);\n\n        return 0;\n\n    }\n\n\n\n    if (-1 == scsi_req_parse(&r->req, cmd)) {\n\n        BADF(\"Unsupported command length, command %x\\n\", cmd[0]);\n\n        scsi_command_complete(r, -EINVAL);\n\n        return 0;\n\n    }\n\n    scsi_req_fixup(&r->req);\n\n\n\n    DPRINTF(\"Command: lun=%d tag=0x%x len %zd data=0x%02x\", lun, tag,\n\n            r->req.cmd.xfer, cmd[0]);\n\n\n\n#ifdef DEBUG_SCSI\n\n    {\n\n        int i;\n\n        for (i = 1; i < r->req.cmd.len; i++) {\n\n            printf(\" 0x%02x\", cmd[i]);\n\n        }\n\n        printf(\"\\n\");\n\n    }\n\n#endif\n\n\n\n    if (r->req.cmd.xfer == 0) {\n\n        if (r->buf != NULL)\n\n            qemu_free(r->buf);\n\n        r->buflen = 0;\n\n        r->buf = NULL;\n\n        ret = execute_command(s->bs, r, SG_DXFER_NONE, scsi_command_complete);\n\n        if (ret < 0) {\n\n            scsi_command_complete(r, ret);\n\n            return 0;\n\n        }\n\n        return 0;\n\n    }\n\n\n\n    if (r->buflen != r->req.cmd.xfer) {\n\n        if (r->buf != NULL)\n\n            qemu_free(r->buf);\n\n        r->buf = qemu_malloc(r->req.cmd.xfer);\n\n        r->buflen = r->req.cmd.xfer;\n\n    }\n\n\n\n    memset(r->buf, 0, r->buflen);\n\n    r->len = r->req.cmd.xfer;\n\n    if (r->req.cmd.mode == SCSI_XFER_TO_DEV) {\n\n        r->len = 0;\n\n        return -r->req.cmd.xfer;\n\n    } else {\n\n        return r->req.cmd.xfer;\n\n    }\n\n}\n", "idx": 7315, "substitutes": {"req": ["conf", "http", "gr", "pro", "rel", "buf", "ps", "dev", "ind", "perm", "query", "tag", "crit", "sem", "qq", "request", "pub", "jp", "cur", "j", "q", "task", "mem", "nt", "alg", "good", "expr", "esp", "out", "grab", "desc", "require", "decl", "comp", "ctr", "urg", "quick", "dep", "md", "ctx", "comm", "msg", "seq", "progress", "p", "pkg", "rr", "attr", "eq", "org", "dq", "cfg", "reg", "tek", "cond", "sq", "res", "deg", "init", "term", "cmp", "rep", "wx", "inv", "iq", "aux", "err", "ref", "pr", "dist", "requ", "resp", "tx", "gz", "ptr", "quest", "qt", "rec", "needed"], "cmd": ["ck", "xy", "grad", "att", "det", "buf", "nd", "ind", "cb", "t", "js", "crit", "txt", "qq", "ch", "om", "batch", "cat", "cur", "xp", "com", "gt", "cy", "mem", "cookie", "good", "op", "str", "dx", "control", "send", "code", "normal", "command", "cd", "exec", "desc", "comp", "check", "ctr", "text", "urg", "quick", "ct", "md", "ctx", "phy", "comm", "msg", "force", "seq", "prop", "mt", "dict", "std", "adv", "pkg", "mac", "kw", "try", "cfg", "dq", "quit", "cond", "Cmd", "news", "act", "init", "cod", "form", "call", "cp", "term", "cmp", "cont", "help", "raw", "ext", "opt", "dist", "args", "fun", "vc", "tab", "now", "off", "wo", "tx", "arg", "wd"], "s": ["rs", "so", "q", "sp", "gs", "b", "sw", "ns", "sr", "c", "h", "sys", "set", "store", "sc", "os", "er", "p", "ps", "g", "n", "ts", "sd", "ds", "t", "se", "js", "str", "ls", "sb", "stats", "sh", "sl", "m", "spec", "hs", "bs", "ss", "sn", "serv", "sq", "S", "j", "res", "a", "l"], "r": ["kr", "c", "gr", "h", "rel", "self", "d", "or", "t", "w", "cr", "R", "j", "ro", "this", "rs", "vr", "q", "lr", "nr", "er", "g", "rw", "str", "rb", "v", "m", "item", "rer", "l", "error", "ar", "it", "sr", "rx", "ry", "mr", "p", "var", "usr", "o", "tr", "dr", "rc", "rr", "rem", "attr", "k", "rest", "rar", "rt", "re", "reg", "response", "fr", "res", "hr", "b", "br", "n", "err", "ref", "rh", "pr", "rl", "f", "rd", "obj", "rec", "e"], "ret": ["gt", "result", "mem", "Return", "reply", "back", "ter", "nt", "ext", "pat", "dt", " Ret", "mt", "rets", "len", "tn", "no", "val", "std", "usr", "tr", "alt", "t", "err", "str", "dr", "ref", "inter", "rem", "out", "try", "num", "rt", "reset", "status", "resp", "re", "print", "RET", "jp", "f", "Ret", "nz", "ft", "arg", "conv", "j", "res", " RET", "deg", "def", "elt", "flag"], "i": ["init", "ic", "ini", "ci", "b", "it", "cli", "gi", "mi", "qi", "li", "p", "si", "ami", "zi", "n", "ms", "is", "iq", "xi", "ind", "index", "t", "key", "bi", "multi", "pi", "me", "ui", "id", "span", "mac", "phi", "ti", "v", "ims", "ix", " j", "ai", "m", "PI", "I", "y", "count", "\u0438", "us", "io", "sim", "info", "ex", "MI", "point", "j", "z", "in", "x", "di", "ii"]}}
{"project": "qemu", "commit_id": "fc6c9257c6dd47316a1c55d356bcd89bdc5fd642", "target": 0, "func": "void ip6_input(struct mbuf *m)\n\n{\n\n    struct ip6 *ip6;\n\n\n\n    DEBUG_CALL(\"ip6_input\");\n\n    DEBUG_ARG(\"m = %lx\", (long)m);\n\n    DEBUG_ARG(\"m_len = %d\", m->m_len);\n\n\n\n    if (m->m_len < sizeof(struct ip6)) {\n\n        goto bad;\n\n    }\n\n\n\n    ip6 = mtod(m, struct ip6 *);\n\n\n\n    if (ip6->ip_v != IP6VERSION) {\n\n        goto bad;\n\n    }\n\n\n\n    /* check ip_ttl for a correct ICMP reply */\n\n    if (ip6->ip_hl == 0) {\n\n        /*icmp_send_error(m, ICMP_TIMXCEED,ICMP_TIMXCEED_INTRANS, 0,\"ttl\");*/\n\n        goto bad;\n\n    }\n\n\n\n    /*\n\n     * Switch out to protocol's input routine.\n\n     */\n\n    switch (ip6->ip_nh) {\n\n    case IPPROTO_TCP:\n\n        /*tcp_input(m, hlen, (struct socket *)NULL);*/\n\n        break;\n\n    case IPPROTO_UDP:\n\n        /*udp_input(m, hlen);*/\n\n        break;\n\n    case IPPROTO_ICMPV6:\n\n        icmp6_input(m);\n\n        break;\n\n    default:\n\n        m_free(m);\n\n    }\n\n    return;\n\nbad:\n\n    m_free(m);\n\n}\n", "idx": 7324, "substitutes": {"m": ["q", "b", "imm", "gm", "im", "managed", "c", "h", "ma", "i", "em", "mat", "M", "mi", "mr", "msg", "mk", "wm", "p", "g", "cm", "mt", "ms", "n", "d", "tm", "mut", "o", "perm", "t", "r", "trace", "mu", "dm", "sm", "k", "nm", "v", "man", "mb", "mm", "am", "y", "mc", "mod", "f", "hm", "vm", "z", "bm", "j", "esm", "mx", "l", "rm", "mp"], "ip6": [" ip8", " ipnet", "ipp64", "ipp16", "order3", " ip2", "lathttps", " siphttps", " sip3", "ipp3", "int64", "order63", "ep16", "ip16", "IP64", "order6", "cliphttps", "ipp6", "ep8", "ep6", "IP06", " ip16", " sipcan", "ip06", "ep64", " ip4", " ipac", "ip2", "ep2", "int06", "lat64", "ippcan", "IP3", "int6", " sip6", "ipp2", "ipcan", "ip4", "ep4", "ipp63", "ip3", "lat6", "int16", "IPhttps", "ep06", "clip4", "IP6", "ep3", "IPac", "p16", "latcan", "clip6", "IP8", "ipnet", " iphttps", "p8", "IP4", "IPnet", " sip64", "p6", "ip64", "clipnet", "ip8", "ipac", "IP16", "ipphttps", "iphttps", "ip63", "p3", " ip3", " sip63", "IP2", "ippac"]}}
{"project": "qemu", "commit_id": "677ef6230b603571ae05125db469f7b4c8912a77", "target": 0, "func": "void fork_start(void)\n\n{\n\n    pthread_mutex_lock(&tcg_ctx.tb_ctx.tb_lock);\n\n    pthread_mutex_lock(&exclusive_lock);\n\n    mmap_fork_start();\n\n}\n", "idx": 7326, "substitutes": {}}
{"project": "qemu", "commit_id": "2f859f80c2077e00237ea1dfae2523ebd8377f5f", "target": 0, "func": "static int write_dump_pages(DumpState *s)\n\n{\n\n    int ret = 0;\n\n    DataCache page_desc, page_data;\n\n    size_t len_buf_out, size_out;\n\n#ifdef CONFIG_LZO\n\n    lzo_bytep wrkmem = NULL;\n\n#endif\n\n    uint8_t *buf_out = NULL;\n\n    off_t offset_desc, offset_data;\n\n    PageDescriptor pd, pd_zero;\n\n    uint8_t *buf;\n\n    int endian = s->dump_info.d_endian;\n\n    GuestPhysBlock *block_iter = NULL;\n\n    uint64_t pfn_iter;\n\n\n\n    /* get offset of page_desc and page_data in dump file */\n\n    offset_desc = s->offset_page;\n\n    offset_data = offset_desc + sizeof(PageDescriptor) * s->num_dumpable;\n\n\n\n    prepare_data_cache(&page_desc, s, offset_desc);\n\n    prepare_data_cache(&page_data, s, offset_data);\n\n\n\n    /* prepare buffer to store compressed data */\n\n    len_buf_out = get_len_buf_out(s->page_size, s->flag_compress);\n\n    if (len_buf_out == 0) {\n\n        dump_error(s, \"dump: failed to get length of output buffer.\\n\");\n\n        goto out;\n\n    }\n\n\n\n#ifdef CONFIG_LZO\n\n    wrkmem = g_malloc(LZO1X_1_MEM_COMPRESS);\n\n#endif\n\n\n\n    buf_out = g_malloc(len_buf_out);\n\n\n\n    /*\n\n     * init zero page's page_desc and page_data, because every zero page\n\n     * uses the same page_data\n\n     */\n\n    pd_zero.size = cpu_convert_to_target32(s->page_size, endian);\n\n    pd_zero.flags = cpu_convert_to_target32(0, endian);\n\n    pd_zero.offset = cpu_convert_to_target64(offset_data, endian);\n\n    pd_zero.page_flags = cpu_convert_to_target64(0, endian);\n\n    buf = g_malloc0(s->page_size);\n\n    ret = write_cache(&page_data, buf, s->page_size, false);\n\n    g_free(buf);\n\n    if (ret < 0) {\n\n        dump_error(s, \"dump: failed to write page data(zero page).\\n\");\n\n        goto out;\n\n    }\n\n\n\n    offset_data += s->page_size;\n\n\n\n    /*\n\n     * dump memory to vmcore page by page. zero page will all be resided in the\n\n     * first page of page section\n\n     */\n\n    while (get_next_page(&block_iter, &pfn_iter, &buf, s)) {\n\n        /* check zero page */\n\n        if (is_zero_page(buf, s->page_size)) {\n\n            ret = write_cache(&page_desc, &pd_zero, sizeof(PageDescriptor),\n\n                              false);\n\n            if (ret < 0) {\n\n                dump_error(s, \"dump: failed to write page desc.\\n\");\n\n                goto out;\n\n            }\n\n        } else {\n\n            /*\n\n             * not zero page, then:\n\n             * 1. compress the page\n\n             * 2. write the compressed page into the cache of page_data\n\n             * 3. get page desc of the compressed page and write it into the\n\n             *    cache of page_desc\n\n             *\n\n             * only one compression format will be used here, for\n\n             * s->flag_compress is set. But when compression fails to work,\n\n             * we fall back to save in plaintext.\n\n             */\n\n             size_out = len_buf_out;\n\n             if ((s->flag_compress & DUMP_DH_COMPRESSED_ZLIB) &&\n\n                    (compress2(buf_out, (uLongf *)&size_out, buf, s->page_size,\n\n                    Z_BEST_SPEED) == Z_OK) && (size_out < s->page_size)) {\n\n                pd.flags = cpu_convert_to_target32(DUMP_DH_COMPRESSED_ZLIB,\n\n                                                   endian);\n\n                pd.size  = cpu_convert_to_target32(size_out, endian);\n\n\n\n                ret = write_cache(&page_data, buf_out, size_out, false);\n\n                if (ret < 0) {\n\n                    dump_error(s, \"dump: failed to write page data.\\n\");\n\n                    goto out;\n\n                }\n\n#ifdef CONFIG_LZO\n\n            } else if ((s->flag_compress & DUMP_DH_COMPRESSED_LZO) &&\n\n                    (lzo1x_1_compress(buf, s->page_size, buf_out,\n\n                    (lzo_uint *)&size_out, wrkmem) == LZO_E_OK) &&\n\n                    (size_out < s->page_size)) {\n\n                pd.flags = cpu_convert_to_target32(DUMP_DH_COMPRESSED_LZO,\n\n                                                   endian);\n\n                pd.size  = cpu_convert_to_target32(size_out, endian);\n\n\n\n                ret = write_cache(&page_data, buf_out, size_out, false);\n\n                if (ret < 0) {\n\n                    dump_error(s, \"dump: failed to write page data.\\n\");\n\n                    goto out;\n\n                }\n\n#endif\n\n#ifdef CONFIG_SNAPPY\n\n            } else if ((s->flag_compress & DUMP_DH_COMPRESSED_SNAPPY) &&\n\n                    (snappy_compress((char *)buf, s->page_size,\n\n                    (char *)buf_out, &size_out) == SNAPPY_OK) &&\n\n                    (size_out < s->page_size)) {\n\n                pd.flags = cpu_convert_to_target32(\n\n                                        DUMP_DH_COMPRESSED_SNAPPY, endian);\n\n                pd.size  = cpu_convert_to_target32(size_out, endian);\n\n\n\n                ret = write_cache(&page_data, buf_out, size_out, false);\n\n                if (ret < 0) {\n\n                    dump_error(s, \"dump: failed to write page data.\\n\");\n\n                    goto out;\n\n                }\n\n#endif\n\n            } else {\n\n                /*\n\n                 * fall back to save in plaintext, size_out should be\n\n                 * assigned to s->page_size\n\n                 */\n\n                pd.flags = cpu_convert_to_target32(0, endian);\n\n                size_out = s->page_size;\n\n                pd.size = cpu_convert_to_target32(size_out, endian);\n\n\n\n                ret = write_cache(&page_data, buf, s->page_size, false);\n\n                if (ret < 0) {\n\n                    dump_error(s, \"dump: failed to write page data.\\n\");\n\n                    goto out;\n\n                }\n\n            }\n\n\n\n            /* get and write page desc here */\n\n            pd.page_flags = cpu_convert_to_target64(0, endian);\n\n            pd.offset = cpu_convert_to_target64(offset_data, endian);\n\n            offset_data += size_out;\n\n\n\n            ret = write_cache(&page_desc, &pd, sizeof(PageDescriptor), false);\n\n            if (ret < 0) {\n\n                dump_error(s, \"dump: failed to write page desc.\\n\");\n\n                goto out;\n\n            }\n\n        }\n\n    }\n\n\n\n    ret = write_cache(&page_desc, NULL, 0, true);\n\n    if (ret < 0) {\n\n        dump_error(s, \"dump: failed to sync cache for page_desc.\\n\");\n\n        goto out;\n\n    }\n\n    ret = write_cache(&page_data, NULL, 0, true);\n\n    if (ret < 0) {\n\n        dump_error(s, \"dump: failed to sync cache for page_data.\\n\");\n\n        goto out;\n\n    }\n\n\n\nout:\n\n    free_data_cache(&page_desc);\n\n    free_data_cache(&page_data);\n\n\n\n#ifdef CONFIG_LZO\n\n    g_free(wrkmem);\n\n#endif\n\n\n\n    g_free(buf_out);\n\n\n\n    return ret;\n\n}\n", "idx": 7327, "substitutes": {"s": ["sw", "ctl", "less", "conf", "c", "http", "h", "state", "self", "d", "ps", "dev", "ts", "settings", "t", "se", "js", "w", "sb", "ss", "south", "changes", "source", "as", "rs", "so", "ses", "sam", "store", "os", "er", "g", "ms", "es", "an", "v", "stats", "bits", "m", "vs", "serv", "local", "us", "sis", "aws", "a", "l", "gs", "ns", "comm", "cs", "p", "is", "sv", "sm", "hs", "bs", "y", "sq", "parts", "fs", "sql", "S", "b", "its", "cont", "i", "set", "sys", "qs", "stat", "details", "n", "ds", "func", "_", "list", "ls", "ims", "args", "status", "spec", "ptr", "sim", "ex", "sts", "def"], "page_desc": ["pageNameesc", "page_spec", "meta_desc", "pageNamedesc", "pageKeyesc", "pageNamespec", "pageNameinfo", "page_trans", "pageingdesc", "pageKeydesc", " page_spec", "pagelogtrans", "page_esc", "meta_cd", "pageingdes", "pageingtrans", "page_info", "pagelogdes", "pageingcd", "meta_trans", "pagelogcd", "page_cd", "pageKeyinfo", " page_info", "meta_des", "page_des", " page_esc", "pagelogdesc", "pageKeyspec"], "page_data": ["row_cache", "row_data", "pageNamedesc", " page_size", "meta_def", "page_content", "meta_info", "meta_data", "row_def", "row_info", "page_size", "pagelyinfo", "page_cache", "page_info", "pagelydef", " page_content", "pageNamesize", "pagelyiter", "pageNamedata", "pagelydata", "meta_iter", "page_iter", "pageNamecontent", "page_def"], "len_buf_out": ["len_buf2err", "len_bufaxyouts", "len_buf_in", "len_uf_ou", "len_buf2in", "len_buf_ou", "len_buffer_outs", "len_buf_err", "len_buf2out", "len_buf_Out", "len_bufaxyin", "len_buf3ou", "len_buf3out", "len_bufaxyout", "len_buffer_out", "len_uf_in", "len_buf_output", "len_uf_outs", "len_buf3in", "len_buf2output", "len_uf_Out", "len_uf_output", "len_buf_outs", "len_bufaxysize", "len_buffer_in", "len_uf_out", "len_buf_size", "len_uf_err", "len_buf3Out", "len_uf_size"], "size_out": ["sizevalbin", "size_OUT", " size_OUT", " size_in", "sizevalin", "size_bin", " size_bin", "sizevalOUT", "size_in", "sizevalout"], "buf_out": ["bufswin", "bufswout", "buffer_tmp", "buf_in", "buffer_no", "buf_no", "buffer_OUT", "buf_OUT", "buffer_out", "buf_Out", "buf_tmp", "buffer_in", "bufswtmp", "buffer_Out", "bufswOut"], "offset_desc": ["offset_des", "Offset_description", "offset_sc", "offset2data", "offset67desc", "offset_dc", "offset67description", "Offset_des", "offset_ind", "offset_meta", "offsetptcomp", "Offset_sc", "Offset_Desc", "link_dc", "offset67meta", "offset__comp", " offset_dir", "offset2dir", "offset__esc", "offset_description", "offset_Desc", "offset___Desc", "offset2ind", "offset_esc", "offset__dc", " offset_ind", "Offset_desc", "offset___des", "Offset_info", "offset___meta", "offset___info", "link_comp", "offset__desc", "offset_dir", "link_esc", "offset_info", "offset67Desc", "offsetptesc", "link_desc", "offset___description", "offset2desc", "offset_comp", "offsetptdesc", "offsetptdc", "offset___desc", "offset___sc", "Offset_meta"], "offset_data": ["start_size", "datajinfo", "offsetjoff", "start_num", "offset_num", "offset__size", "offsetmmbuf", "offsetYsize", "position_data", "offsetmmdata", "offset_bytes", "position_dat", "offset_index", "offset_no", "offsetmmdesc", "datajdata", "start_data", "position_value", "datajdat", "offset_name", "offset__bytes", "offsetYindex", "off_name", "offsetjdata", "data_data", " offset_bytes", " offset_size", "offsetmmname", "offsetYdata", "offsetYnum", "offset_size", "offset_dat", "datajoff", "data_dat", "data_off", "start_index", " offset__no", "offset_info", "offset__data", "position_desc", "offsetjdat", " offset_no", "off_data", "offset_off", "data_info", "offset_buf", "offsetjinfo", " offset__bytes", " offset__size", " offset__data", "off_buf", "offset__no", "off_desc", "offset_value"], "pd": ["pid", " cd", " pci", " pdf", "md", "pt", " pt", "PDF", " md", " df", " td", "ps", "p", " pr", " sd", "bd", " pts", "ds", " db", " cp", "PD", "bf", "pdf", " dd", "dd", " dw", " ps", " PD", " pg"], "pd_zero": ["pd_reset", "pd_global", "pdMfinal", "dd_leader", "edd_module", "pd_fee", "pdamzero", "pd_module", "pdJleader", "pdjmodule", "pdjneutral", "pd_leader", "edd_zero", "pd_free", "sd_zero", "pdMtotal", "pd_user", "sdMzero", "pdodoreglobal", "sdMinfo", "sdMfinal", "pdodoreneutral", "pd_total", "dd_reset", "pd__final", "pdJzero", "pd__info", "pdjfree", "pdaminfo", "pdamfinal", "sd_info", "pd_final", "pd_neutral", "pdMzero", "pc_user", "dd_global", "dd_zero", "pd_info", "pd__total", "pc_zero", "pc_fee", "edd_free", "sdMtotal", "edd_neutral", "pdodorezero", "pdjzero", "sd_final", "dd_neutral", "pdamtotal", "pdMinfo", "sd_total", "pd__zero", "pdJreset"], "buf": ["db", "boxes", "bytes", "result", "uf", "buff", "b", "ff", "mem", "window", "BU", "br", "cam", "bc", "box", "page", "Buffer", "buffer", "msg", "raw", "bed", "seq", "cmd", "len", "cb", "queue", "wb", "data", "rw", "err", "w", "vec", "ref", "bar", "mu", "pkg", "Buff", "pos", "blocks", "rb", "iter", "out", "v", "txt", "cap", "mates", "block", "bs", "ret", "tmp", "cv", "img", "batch", "doc", "cache", "ptr", "broad", "bin"], "block_iter": ["block_iterator", " block_iterator", "block_ip", "block_map", "block___gen", "block2gen", "block2iter", " block_map", "block2map", " block_ip", "block___iterator", " block_gen", "block___ip", "block_gen", "block___iter", "block2iterator"], "pfn_iter": ["pnn_iterator", "pwn_iter", "pfn_num", "pwn2init", "pfn___ser", "pwn_init", "pfn___iter", "pfn___index", "pfn___num", "pwn2ser", "pfn___init", "pfn_iterator", "pnn_num", "pfn___iterator", "pfn_ser", "pnn_index", "pfn2iter", "pnn_iter", "pwn2iter", "pfn_init", "pfn2ser", "pfn_index", "pfn2init", "pwn_ser"]}}
{"project": "qemu", "commit_id": "d516f74c99b1a2c289cfba0bacf125cbc9b681e3", "target": 0, "func": "static void do_ext_interrupt(CPUS390XState *env)\n\n{\n\n    S390CPU *cpu = s390_env_get_cpu(env);\n\n    uint64_t mask, addr;\n\n    LowCore *lowcore;\n\n    ExtQueue *q;\n\n\n\n    if (!(env->psw.mask & PSW_MASK_EXT)) {\n\n        cpu_abort(CPU(cpu), \"Ext int w/o ext mask\\n\");\n\n    }\n\n\n\n    lowcore = cpu_map_lowcore(env);\n\n\n\n    if (env->pending_int & INTERRUPT_EXT_CLOCK_COMPARATOR) {\n\n        lowcore->ext_int_code = cpu_to_be16(EXT_CLOCK_COMP);\n\n        lowcore->cpu_addr = 0;\n\n        env->pending_int &= ~INTERRUPT_EXT_CLOCK_COMPARATOR;\n\n    } else if (env->pending_int & INTERRUPT_EXT_CPU_TIMER) {\n\n        lowcore->ext_int_code = cpu_to_be16(EXT_CPU_TIMER);\n\n        lowcore->cpu_addr = 0;\n\n        env->pending_int &= ~INTERRUPT_EXT_CPU_TIMER;\n\n    } else if (env->pending_int & INTERRUPT_EXT_SERVICE) {\n\n        g_assert(env->ext_index >= 0);\n\n        /*\n\n         * FIXME: floating IRQs should be considered by all CPUs and\n\n         *        shuld not get cleared by CPU reset.\n\n         */\n\n        q = &env->ext_queue[env->ext_index];\n\n        lowcore->ext_int_code = cpu_to_be16(q->code);\n\n        lowcore->ext_params = cpu_to_be32(q->param);\n\n        lowcore->ext_params2 = cpu_to_be64(q->param64);\n\n        lowcore->cpu_addr = cpu_to_be16(env->core_id | VIRTIO_SUBCODE_64);\n\n        env->ext_index--;\n\n        if (env->ext_index == -1) {\n\n            env->pending_int &= ~INTERRUPT_EXT_SERVICE;\n\n        }\n\n    } else {\n\n        g_assert_not_reached();\n\n    }\n\n\n\n    mask = be64_to_cpu(lowcore->external_new_psw.mask);\n\n    addr = be64_to_cpu(lowcore->external_new_psw.addr);\n\n    lowcore->external_old_psw.mask = cpu_to_be64(get_psw_mask(env));\n\n    lowcore->external_old_psw.addr = cpu_to_be64(env->psw.addr);\n\n\n\n    cpu_unmap_lowcore(lowcore);\n\n\n\n    DPRINTF(\"%s: %\" PRIx64 \" %\" PRIx64 \"\\n\", __func__,\n\n            env->psw.mask, env->psw.addr);\n\n\n\n    load_psw(env, mask, addr);\n\n}\n", "idx": 7332, "substitutes": {"env": ["uv", "event", "esc", "ei", "outer", "conf", "die", "eg", "dev", "ec", "enter", "cb", "environment", "queue", "t", "gear", "en", "ah", "worker", "dn", "enc", "esm", "vv", "forge", "ve", "er", "context", "eh", "server", "v", "config", "vs", "exec", "desc", "tk", "shell", "db", "ev", "peer", "export", "console", "end", "ctx", "era", "msg", "ent", "ae", "hw", "sv", "eq", "org", "nv", "cfg", "answer", "response", "cv", "vm", "engine", "net", "eve", "door", "chart", "window", "here", "eas", "erd", "te", "cmd", "inv", "ie", "vp", "ew", "eng", "ner", "err", "qv", "gate", "args", "doc", "ee", "manager", "vt", "obj", "qt", "e", "global", "conn"], "cpu": ["CPU", "gc", "sp", "node", "cp", "c", "pu", "pc", "ctx", "tp", "cam", "sys", "ka", "clock", "ip", "p", "base", "mx", "chip", "hz", "process", "total", "hw", "nu", "proc", "mu", "cn", "num", "ork", "port", "alloc", "cache", "np", "aco", "jp", "core", "vm", "net", "cu", "gpu", "conn"], "mask": ["ck", "open", "match", "magic", "mn", "window", "weight", "conf", "type", " masked", "pack", "box", "offset", "set", "state", "mk", "miss", "map", "cmd", "use", "tr", "perm", "key", "bit", "tag", "id", "Mask", "module", "pkg", "mac", "master", "qa", "code", " Mask", "handle", "mode", "cap", "sk", "bits", "sign", "feature", "m", "ch", "ack", "clear", "block", "batch", "alias", "cache", "address", "count", "nz", "shape", "filter", "size", "ask", "flags", "check", "hash", "lock", "info", "sum", "mx", " masks", "name", "flag"], "addr": ["ar", "mem", "ress", "src", "ctx", "offset", "pad", "sys", "store", "arm", "mk", "ip", "arch", "map", "cmd", "mt", "seek", "arp", "on", "alt", "phys", "err", "dr", "tag", "pos", "pkg", "attr", "rr", "align", "mac", "gate", "host", "ad", "ix", "ai", "ack", "port", "art", "ptr", "iat", "arity", "alias", "address", "eth", "hash", "adr", "hop", "loc", "act"], "lowcore": ["leftore", "shortgate", "lowport", "highrate", "lowce", "lowerCore", "slowrate", "lowcache", "lowerready", "highcrypt", "slowcycle", "shortcore", "slowcpu", "leftcenter", "lowercycle", "slowcache", "lowcode", " lowcpu", "slowCore", "levelgate", "lowercache", "highready", "lowcrypt", " lowrate", "littlecache", "lowconn", "littlescore", "loCore", "deepcpu", "deeprate", "lowercpu", "lowerscore", "lowready", "lowCore", "flowconn", "highcpu", "lowworker", "deepore", "littleore", "lowerserver", "deepcore", "lightcore", "slowcore", "lowercore", "flowcore", "levelcore", "highcore", "slowce", "slowready", "leftscore", "flowrow", "lightore", " lowserver", "deepscore", "slowport", " lowce", " lowscore", "leftserver", "littleworker", "lowcpu", "hardore", " lowconn", "slowcode", "Lowcore", "lowrate", "leftrate", "lowerstore", "deepcycle", " lowcache", "slowserver", "slowgate", "littlestore", "lowore", "lowerore", "locore", "leveldisk", "lowercode", " lowworker", "lowdisk", "slowore", "loce", "lowcenter", " lowstore", "deepserver", "Lowrow", " lowCore", "littlecore", " lowcrypt", " lowrow", "levelore", "Lowconn", "slowdisk", "slowscore", "highore", "highcode", "levelport", "shortport", "hardscore", "levelrate", " lowore", "lowgate", "levelcache", "loserver", "lightcenter", "lowserver", "shortdisk", "leftcore", "hardcore", "lowscore", "lightrate", "lowstore", "lowrow", " lowcenter", "hardcrypt", "highscore", "highworker", "lowcycle"], "q": ["ck", "quer", "quant", "it", "conf", "qs", "ve", "qi", "msg", "seq", "p", "g", "d", "inv", "cmd", "flow", "iq", "queue", "t", "r", "Q", "w", "query", "pkg", "qv", "ue", "k", "qa", "eq", "v", "req", "qq", "qu", "dq", "requ", "ch", "m", "cv", "aq", "y", "sq", "cache", "f", "quest", "que", "qt", "e", "z", "j"], "ext_index": ["ext_ind", "extPIndex", "external2number", "extPindex", "extpoIndex", "external_Index", "ext8index", "ext2number", "external2Index", "external_switch", "ext8Index", "external_number", "extgrindex", "Ext_Index", "ext8ind", "Ext_ind", "extgrnumber", "ext_num", "external_index", "extgrind", "external2index", "extposwitch", "Ext_index", "extpoindex", "ext_Index", "ext_int", "external2num", "Ext_int", "ext8int", "ext2Index", "external_num", "ext2num", "extPnum", "ext_number", "ext2index", "extPnumber", "extgrIndex", "ext_switch", "external_ind"]}}
{"project": "qemu", "commit_id": "4be746345f13e99e468c60acbd3a355e8183e3ce", "target": 0, "func": "static void verdex_init(MachineState *machine)\n\n{\n\n    const char *cpu_model = machine->cpu_model;\n\n    PXA2xxState *cpu;\n\n    DriveInfo *dinfo;\n\n    int be;\n\n    MemoryRegion *address_space_mem = get_system_memory();\n\n\n\n    uint32_t verdex_rom = 0x02000000;\n\n    uint32_t verdex_ram = 0x10000000;\n\n\n\n    cpu = pxa270_init(address_space_mem, verdex_ram, cpu_model ?: \"pxa270-c0\");\n\n\n\n    dinfo = drive_get(IF_PFLASH, 0, 0);\n\n    if (!dinfo && !qtest_enabled()) {\n\n        fprintf(stderr, \"A flash image must be given with the \"\n\n                \"'pflash' parameter\\n\");\n\n        exit(1);\n\n    }\n\n\n\n#ifdef TARGET_WORDS_BIGENDIAN\n\n    be = 1;\n\n#else\n\n    be = 0;\n\n#endif\n\n    if (!pflash_cfi01_register(0x00000000, NULL, \"verdex.rom\", verdex_rom,\n\n                               dinfo ? blk_bs(blk_by_legacy_dinfo(dinfo)) : NULL,\n\n                               sector_len, verdex_rom / sector_len,\n\n                               2, 0, 0, 0, 0, be)) {\n\n        fprintf(stderr, \"qemu: Error registering flash memory.\\n\");\n\n        exit(1);\n\n    }\n\n\n\n    /* Interrupt line of NIC is connected to GPIO line 99 */\n\n    smc91c111_init(&nd_table[0], 0x04000300,\n\n                    qdev_get_gpio_in(cpu->gpio, 99));\n\n}\n", "idx": 7334, "substitutes": {"machine": ["mill", "instance", "power", "node", "task", "computer", "hard", "model", "dem", "state", "domain", "connection", "link", "network", "monitor", "process", "server", "me", "linux", "module", "dm", "device", "achine", "host", "memory", "component", "iso", "m", "frame", "config", "handler", "session", "mc", "Machine", "manager", "sim", "vm", "net", "shell"], "cpu_model": ["pu_id", "pu_Model", "cpu_id", "cpu2type", " cpu_models", "cpu2Model", "cpu2model", "cpu_config", " cpu_mode", "pu_type", "pu_mode", "cpu2config", " cpu_Model", "pu_model", "cpu2mode", "cpu2id", "cpu_mode", "cpu_type", "cpu_models", "cpu_Model", "pu_config"], "cpu": ["CPU", "gc", "setup", "copy", "node", "mem", "gp", "cp", "cum", "c", "pu", "pc", "ctx", "cli", "prof", "clock", "p", "util", "chip", "hz", "xi", "process", "hw", "phys", "ilo", "linux", "proc", "device", "nic", "achine", "memory", "pai", "bean", "processor", "frame", "pool", "disk", "cache", "np", "core", "vm", "boot", "cu", "gpu", "mx", "computer"], "dinfo": ["DINFO", "lINFO", "Dfo", " ddata", "dinf", "dINFO", "dfo", "pdinfo", "pdInfo", "rfo", "ddata", " dfo", "sdinfo", "pdINFO", "linfo", "sdfo", "sdInfo", "pdinformation", "Dinfo", "rINFO", "linf", "Ddata", " dinf", "rinfo", "dinformation", "rInfo", "rinformation", "Dinf", "lfo", "Dinformation", "DInfo", "sddata", " dINFO", " dInfo", "dInfo", "lInfo", "rinf"], "be": ["bes", " probe", "ine", "ate", "b", " Bo", "it", "enable", "end", "ble", "eb", "br", " ne", "fe", " bo", " BE", "ve", "ob", "te", "we", "obe", "BE", "use", "ge", "ke", "or", "ae", "Be", "beat", " Be", "ce", "se", "bo", "ere", "ed", "are", "scale", "ue", " je", "ot", "abe", "itte", "st", "ze", " b", "\u662f", "he", "ide", "de", "e", "by", "oe", "z", "one", "ne", "cho", " pe", "le"], "address_space_mem": ["address_space_map", "address_system_memory", "address_space2map", "address_system_mem", "address_system_reg", "address_system_map", "address_space2reg", "address_space2mem", "address_space_reg", "address_space_memory"]}}
{"project": "qemu", "commit_id": "e3737b820b45e54b059656dc3f914f895ac7a88b", "target": 1, "func": "static int bochs_open(BlockDriverState *bs, QDict *options, int flags,\n                      Error **errp)\n{\n    BDRVBochsState *s = bs->opaque;\n    uint32_t i;\n    struct bochs_header bochs;\n    int ret;\n    bs->read_only = 1; // no write support yet\n    ret = bdrv_pread(bs->file, 0, &bochs, sizeof(bochs));\n    if (ret < 0) {\n        return ret;\n    if (strcmp(bochs.magic, HEADER_MAGIC) ||\n        strcmp(bochs.type, REDOLOG_TYPE) ||\n        strcmp(bochs.subtype, GROWING_TYPE) ||\n\t((le32_to_cpu(bochs.version) != HEADER_VERSION) &&\n\t(le32_to_cpu(bochs.version) != HEADER_V1))) {\n        error_setg(errp, \"Image not in Bochs format\");\n        return -EINVAL;\n    if (le32_to_cpu(bochs.version) == HEADER_V1) {\n        bs->total_sectors = le64_to_cpu(bochs.extra.redolog_v1.disk) / 512;\n    } else {\n        bs->total_sectors = le64_to_cpu(bochs.extra.redolog.disk) / 512;\n    s->catalog_size = le32_to_cpu(bochs.catalog);\n    s->catalog_bitmap = g_malloc(s->catalog_size * 4);\n    ret = bdrv_pread(bs->file, le32_to_cpu(bochs.header), s->catalog_bitmap,\n                     s->catalog_size * 4);\n    if (ret < 0) {\n        goto fail;\n    for (i = 0; i < s->catalog_size; i++)\n\tle32_to_cpus(&s->catalog_bitmap[i]);\n    s->data_offset = le32_to_cpu(bochs.header) + (s->catalog_size * 4);\n    s->bitmap_blocks = 1 + (le32_to_cpu(bochs.bitmap) - 1) / 512;\n    s->extent_blocks = 1 + (le32_to_cpu(bochs.extent) - 1) / 512;\n    s->extent_size = le32_to_cpu(bochs.extent);\n    if (s->catalog_size < bs->total_sectors / s->extent_size) {\n        error_setg(errp, \"Catalog size is too small for this disk size\");\n        ret = -EINVAL;\n        goto fail;\n    qemu_co_mutex_init(&s->lock);\n    return 0;\nfail:\n    g_free(s->catalog_bitmap);\n    return ret;", "idx": 7347, "substitutes": {"bs": ["asis", "boxes", "bes", "rs", "gs", "bis", "b", "blog", "ubs", "ns", "pb", "bos", "its", "ats", "bc", "cks", "locks", "qs", "sys", "cs", "os", "bh", "ps", "als", "bp", "is", "ts", "uts", "ds", "BS", "fps", "es", "bi", "aus", "js", "bb", "ls", "sb", "bps", "ubis", "outs", "bits", "las", "vs", "hs", "aos", "ss", "bl", "fs", "sts", "bm", "obs", "bas", "lbs"], "options": ["styles", "times", "ption", "bos", "values", "os", "ps", "details", "settings", "ts", "option", "o", "Options", "ptions", "data", "vals", "es", "stats", "tags", "meta", "keys", "args", "config", "limits", "fs", "params", "ops"], "flags": ["fields", "ns", "ags", "kind", "files", "ps", "cmd", "ts", "settings", "ds", "vals", "types", "mode", "Flag", "tags", "args", "bits", "status", "FLAG", "Flags", "mask", "fs", "res", "features", " flag", "flag"], "errp": [" errP", " erp", "Erpb", "dieP", "rrP", " errm", "ErP", "rrpb", "diep", "errpa", "errpb", "rrp", " errpe", "errpe", "Erp", " erpe", " erpa", "errP", " erP", "rrm", "diepe", "errm", " errpb", "Erm", " errpa", "diepa"], "s": ["less", "ers", "h", "ps", "ts", "js", "sb", "services", "ss", "changes", "as", "rs", "ses", " ss", "store", "os", "ms", "es", "stats", "bits", "m", "sa", "vs", "l", "gs", "bis", "ssl", "ns", "ats", "ies", "cs", "comm", "actions", "is", "sv", "hs", "sq", "fs", "S", "sp", "b", "eps", "its", "acs", "cont", "sys", "qs", "als", "details", "n", "ds", "func", "ins", "ls", "ims", "args", "sl", "states", "obj", "sts"], "i": ["ic", "ini", " bi", "uri", "ci", "b", " ii", "ei", "it", "im", "c", "u", "pc", "cli", "ma", "oi", "gi", "mi", "qi", "ip", "li", "p", "si", "ami", " si", "zi", "n", "is", "xi", "ind", "o", " ti", "t", "bi", "pi", "multi", "key", "me", "ui", "ki", "ji", " I", "ti", "v", "ims", "ix", " j", "ai", "m", "wi", " mi", "I", "y", "\u0438", "sim", "gu", "iu", "io", "j", "x", "di", "ii"], "bochs": [" bochsb", "bochtts", "boichs", "oochis", "brochts", "oochnds", "bochnstats", "bochnss", "Bochtjs", "boichts", "oochds", "boachds", "roechts", "bochanjs", "Bochts", "oochnls", "bochains", "bochns", "bachedains", "oochnis", "bocmdts", "bochtjs", "oochss", "rochs", "boechjs", "bochsb", "fochns", "boachis", "bouthls", "oochs", "boochi", "muchds", "brochtts", "bochi", "bochedjs", "fochis", "bachedjs", "bouths", "foochjs", "bachains", "brochls", "bochnS", "bochS", "bachjs", "muochs", "brochti", "boiahjs", "muochts", "boCHjs", "bochms", "bochedains", "foachis", "fochnis", "boachls", "rochms", "boechis", "roechms", "bochnabs", "boochds", "bochis", "boechts", "bochnrs", "boachstats", "bochtls", "bochans", "boCHs", "bochti", "muochds", "bachs", "muochabs", "muchts", "bochnms", "bochedns", "bochtries", "bochts", "bochnls", "bochanS", " boechsb", " bochjs", "bokhs", "bochnjs", "ooachs", "brochs", " boechts", "bochds", "fochs", "ooochs", "boochries", "boochabs", "bokhsb", "fochnds", "brochtls", "oochns", "ooochries", " bochts", "boichms", "oochjs", "boechls", "bacheds", "boechms", "ooachjs", "bouthss", " boechjs", "boochrs", "oochnss", "bochstats", "muchis", "boCHis", "oochstats", "boCHds", "bochnis", "boochjs", "foochns", "muochis", "bochtS", "boochis", "fochjs", "boachjs", "muchs", "boiahstats", "ooachstats", "bochnds", "bochrs", "bochries", "Bochjs", "BochtS", "boCHts", "boechss", "muochjs", "boechs", "foachls", "bocmds", "boachs", "fochds", "bochjs", "boochts", "bocheds", "boCHsb", "bochnns", "fochrs", "bachedls", "foochs", "bocmdabs", "boechains", "ooochjs", "Bochs", "muchabs", "bokhts", "boechsb", "bochedls", " boechs", "boiahs", "bachls", "brochi", "boochns", "muchjs", "boochs", "foochrs", "oochls", "rochts", "bochtrs", "bocmdds", "bochls", "bochabs", "fochls", "bokhjs", "bochss", "foachs", "BochS", "roechs", "bochnts", "boochls", "bochnains", "boechi", "oochries"], "ret": ["gt", "result", "cert", "mem", "att", "ber", "reply", "back", "get", "cont", "mel", "ter", "det", "set", "nt", "ry", "dt", "cmd", "mt", " Ret", " alt", "rets", "fit", "len", "val", "ez", "del", "tr", "usr", "alt", "t", "err", "after", "inter", "rem", "code", "iter", "try", "out", "txt", "rt", "reset", "fin", "resp", "re", "status", "reg", "lit", "print", "RET", "tf", "Ret", "ft", "arg", "net", "ll", "res", " RET", "vet", "deg", "def", "rm", "elt"]}}
{"project": "FFmpeg", "commit_id": "3b9a913db4d303a0305a80de496b1933cba8980f", "target": 1, "func": "offset_t url_fseek(ByteIOContext *s, offset_t offset, int whence)\n\n{\n\n    offset_t offset1;\n\n    offset_t pos= s->pos - (s->write_flag ? 0 : (s->buf_end - s->buffer));\n\n\n\n    if (whence != SEEK_CUR && whence != SEEK_SET)\n\n        return -EINVAL;\n\n\n\n    if (whence == SEEK_CUR) {\n\n        offset1 = pos + (s->buf_ptr - s->buffer);\n\n        if (offset == 0)\n\n            return offset1;\n\n        offset += offset1;\n\n    }\n\n    offset1 = offset - pos;\n\n    if (!s->must_flush &&\n\n        offset1 >= 0 && offset1 < (s->buf_end - s->buffer)) {\n\n        /* can do the seek inside the buffer */\n\n        s->buf_ptr = s->buffer + offset1;\n\n    } else {\n\n        if (!s->seek)\n\n            return -EPIPE;\n\n\n\n#ifdef CONFIG_MUXERS\n\n        if (s->write_flag) {\n\n            flush_buffer(s);\n\n            s->must_flush = 1;\n\n        } else\n\n#endif //CONFIG_MUXERS\n\n        {\n\n            s->buf_end = s->buffer;\n\n        }\n\n        s->buf_ptr = s->buffer;\n\n        if (s->seek(s->opaque, offset, SEEK_SET) == (offset_t)-EPIPE)\n\n            return -EPIPE;\n\n        s->pos = offset;\n\n    }\n\n    s->eof_reached = 0;\n\n    return offset;\n\n}\n", "idx": 7351, "substitutes": {"s": ["sw", "less", "c", "http", "h", "state", "self", "ps", "ports", "ts", "t", "se", "js", "events", "sb", "xs", "services", "ss", "south", "changes", "sports", "comments", "as", "rs", "service", "ses", "sam", "https", "os", "er", "g", "ms", "es", "v", "stats", "m", "vs", "serv", "a", "aws", "ops", "gs", "bis", "times", "ns", "ats", "ies", "ags", "cs", "comm", "p", "is", "sv", "hs", "bs", "y", "sq", "parts", "fs", "S", "b", "its", "acs", "i", "qs", "sys", "set", "als", "stat", "details", "n", "ds", "ins", "ls", "ims", "ties", "spec", "states", "sts"], "offset": ["addr", "pointer", "fp", "key", "t", "trace", "pos", "reset", " offsets", "size", "origin", "loc", "eta", "ta", "adjusted", "base", "ms", "OFF", "op", "zero", "option", "index", "bound", "bit", "position", "top", "timeout", "start", "port", "address", "before", "Offset", "length", "a", "l", "oss", "original", "et", "error", "end", "shift", "field", "skip", "extra", "p", "no", "ed", "o", "total", "to", "align", "style", "oid", "scroll", "optional", "sp", "padding", "term", "i", "set", "buffer", "amount", "location", "seek", "ref", "slot", "meta", "off", "ptr", "cache", "count", "f", "point", "e"], "whence": ["nevercer", "wherecer", " whences", "whenCE", "Whenace", "whencent", " whenced", "whences", "neverce", "whenze", "taince", "wherece", "tainCE", " whenace", " whencer", "Whence", " whencent", "tainces", "wheze", "WhenCE", "freecent", " whenCE", "whereze", "wheced", "freeces", "tainace", "neverces", "wheCE", "nevercent", "funze", "whenced", "whece", "Whences", "funce", "funcer", "whereced", "whecer", "freece", "freecer", "whenace", " whenze", "whencer", "funCE"], "offset1": ["pointerOne", "Offset3", "position1", " offsetOnce", "offsetOne", "attribute001", "slot0", "position01", "offset001", "offsetOnce", "positionId", "attribute0", "offone", "pointer001", " offset2", "address01", " offset0", "Offset1", "indexOnce", "Offset2", "offsetId", "positionOne", " offset001", "index0", "slot1", "off1", "slotone", "attribute4", "positionone", "offset0", " offset01", "offset01", "pointerOnce", " offsetId", " offset4", "offset4", "offset2", "index1", "Offset0", "offsetone", "offOne", "pointer1", "pointer4", "z3", "address1", "address0", "addressone", "slotOne", "offset3", "indexOne", "OffsetId", "attribute1", " offsetOne", " offsetone", "pointer0", "z1", "position2", "position0"]}}
{"project": "qemu", "commit_id": "18b21a2f83a26c3d6a9e7f0bdc4e8eb2b177e8f6", "target": 0, "func": "void ppc_translate_init(void)\n\n{\n\n    int i;\n\n    char* p;\n\n    size_t cpu_reg_names_size;\n\n    static int done_init = 0;\n\n\n\n    if (done_init)\n\n        return;\n\n\n\n    cpu_env = tcg_global_reg_new_ptr(TCG_AREG0, \"env\");\n\n\n\n    p = cpu_reg_names;\n\n    cpu_reg_names_size = sizeof(cpu_reg_names);\n\n\n\n    for (i = 0; i < 8; i++) {\n\n        snprintf(p, cpu_reg_names_size, \"crf%d\", i);\n\n        cpu_crf[i] = tcg_global_mem_new_i32(TCG_AREG0,\n\n                                            offsetof(CPUState, crf[i]), p);\n\n        p += 5;\n\n        cpu_reg_names_size -= 5;\n\n    }\n\n\n\n    for (i = 0; i < 32; i++) {\n\n        snprintf(p, cpu_reg_names_size, \"r%d\", i);\n\n        cpu_gpr[i] = tcg_global_mem_new(TCG_AREG0,\n\n                                        offsetof(CPUState, gpr[i]), p);\n\n        p += (i < 10) ? 3 : 4;\n\n        cpu_reg_names_size -= (i < 10) ? 3 : 4;\n\n#if !defined(TARGET_PPC64)\n\n        snprintf(p, cpu_reg_names_size, \"r%dH\", i);\n\n        cpu_gprh[i] = tcg_global_mem_new_i32(TCG_AREG0,\n\n                                             offsetof(CPUState, gprh[i]), p);\n\n        p += (i < 10) ? 4 : 5;\n\n        cpu_reg_names_size -= (i < 10) ? 4 : 5;\n\n#endif\n\n\n\n        snprintf(p, cpu_reg_names_size, \"fp%d\", i);\n\n        cpu_fpr[i] = tcg_global_mem_new_i64(TCG_AREG0,\n\n                                            offsetof(CPUState, fpr[i]), p);\n\n        p += (i < 10) ? 4 : 5;\n\n        cpu_reg_names_size -= (i < 10) ? 4 : 5;\n\n\n\n        snprintf(p, cpu_reg_names_size, \"avr%dH\", i);\n\n#ifdef HOST_WORDS_BIGENDIAN\n\n        cpu_avrh[i] = tcg_global_mem_new_i64(TCG_AREG0,\n\n                                             offsetof(CPUState, avr[i].u64[0]), p);\n\n#else\n\n        cpu_avrh[i] = tcg_global_mem_new_i64(TCG_AREG0,\n\n                                             offsetof(CPUState, avr[i].u64[1]), p);\n\n#endif\n\n        p += (i < 10) ? 6 : 7;\n\n        cpu_reg_names_size -= (i < 10) ? 6 : 7;\n\n\n\n        snprintf(p, cpu_reg_names_size, \"avr%dL\", i);\n\n#ifdef HOST_WORDS_BIGENDIAN\n\n        cpu_avrl[i] = tcg_global_mem_new_i64(TCG_AREG0,\n\n                                             offsetof(CPUState, avr[i].u64[1]), p);\n\n#else\n\n        cpu_avrl[i] = tcg_global_mem_new_i64(TCG_AREG0,\n\n                                             offsetof(CPUState, avr[i].u64[0]), p);\n\n#endif\n\n        p += (i < 10) ? 6 : 7;\n\n        cpu_reg_names_size -= (i < 10) ? 6 : 7;\n\n    }\n\n\n\n    cpu_nip = tcg_global_mem_new(TCG_AREG0,\n\n                                 offsetof(CPUState, nip), \"nip\");\n\n\n\n    cpu_msr = tcg_global_mem_new(TCG_AREG0,\n\n                                 offsetof(CPUState, msr), \"msr\");\n\n\n\n    cpu_ctr = tcg_global_mem_new(TCG_AREG0,\n\n                                 offsetof(CPUState, ctr), \"ctr\");\n\n\n\n    cpu_lr = tcg_global_mem_new(TCG_AREG0,\n\n                                offsetof(CPUState, lr), \"lr\");\n\n\n\n    cpu_xer = tcg_global_mem_new(TCG_AREG0,\n\n                                 offsetof(CPUState, xer), \"xer\");\n\n\n\n    cpu_reserve = tcg_global_mem_new(TCG_AREG0,\n\n                                     offsetof(CPUState, reserve), \"reserve\");\n\n\n\n    cpu_fpscr = tcg_global_mem_new_i32(TCG_AREG0,\n\n                                       offsetof(CPUState, fpscr), \"fpscr\");\n\n\n\n    cpu_access_type = tcg_global_mem_new_i32(TCG_AREG0,\n\n                                             offsetof(CPUState, access_type), \"access_type\");\n\n\n\n    /* register helpers */\n\n#define GEN_HELPER 2\n\n#include \"helper.h\"\n\n\n\n    done_init = 1;\n\n}\n", "idx": 7360, "substitutes": {"i": ["ei", " multi", " ii", "im", "gi", "zi", "ind", " ti", "hi", "pi", " j", "I", "batch", "io", "in", "j", "iri", "di", "\u0438", "x", "this", "ic", "q", "mi", "my", "er", " si", "xi", "index", "ri", "bi", "go", "ki", "ti", "v", "ai", "m", "remote", "ia", "us", "info", "ci", "it", "ip", "li", "ami", "is", "dr", "to", "mac", " I", "try", "y", "sql", " Xi", "ii", "ini", "ij", " bi", "uri", "cli", "set", "none", "oi", "qi", "si", "n", "iq", "multi", "me", "ui", "id", "ji", "list", "ims", "ix", "status", " mi", "sim", "ex", "iu", "point", "ni"], "p": ["policy", "post", "pid", "q", "sp", "b", "it", "wp", "cp", "ping", "pb", "c", "pc", "h", "br", "up", "pad", "set", "pt", "rep", "at", "ip", "progress", "g", "ps", "d", "bp", "n", "pa", "vp", "php", "op", "pl", "o", "fp", "t", "perm", "pi", "ep", "r", "pe", "pos", "pre", "pkg", "pg", "ap", "pr", "lp", "out", "v", "port", "m", "part", "y", "pool", "jp", "np", "f", "cache", "dp", "xp", "pp", "P", "point", "imp", "j", "lock", "x", "a", "tp", "l"], "cpu_reg_names_size": ["cpu_reg_name_sum", "cpu_reg_names_name", "cpu_reg_names_Size", "cpu_reg_names_SIZE", "cpu_reg_names_space", "cpu_reg_names_scale", "cpu_reg_names_sum", "cpu_reg_files_size", "cpu_reg_name_Size", "cpu_reg_files_ize", "cpu_reg_files_length", "cpu_reg_name_space", "cpu_reg_files_SIZE", "cpu_reg_files_type", "cpu_reg_names_count", "cpu_reg_name_SIZE", "cpu_reg_files_name", "cpu_reg_names_length", "cpu_reg_names_type", "cpu_reg_names_style", "cpu_reg_names_ize", "cpu_reg_files_Size", "cpu_reg_name_size"]}}
{"project": "qemu", "commit_id": "7d08d85645def18eac2a9d672c1868a35e0bcf79", "target": 0, "func": "static void gen_mtfsfi(DisasContext *ctx)\n\n{\n\n    int bf, sh;\n\n    TCGv_i64 t0;\n\n    TCGv_i32 t1;\n\n\n\n    if (unlikely(!ctx->fpu_enabled)) {\n\n        gen_exception(ctx, POWERPC_EXCP_FPU);\n\n        return;\n\n    }\n\n    bf = crbD(ctx->opcode) >> 2;\n\n    sh = 7 - bf;\n\n    /* NIP cannot be restored if the memory exception comes from an helper */\n\n    gen_update_nip(ctx, ctx->nip - 4);\n\n    gen_reset_fpstatus();\n\n    t0 = tcg_const_i64(FPIMM(ctx->opcode) << (4 * sh));\n\n    t1 = tcg_const_i32(1 << sh);\n\n    gen_helper_store_fpscr(cpu_env, t0, t1);\n\n    tcg_temp_free_i64(t0);\n\n    tcg_temp_free_i32(t1);\n\n    if (unlikely(Rc(ctx->opcode) != 0)) {\n\n        tcg_gen_trunc_tl_i32(cpu_crf[1], cpu_fpscr);\n\n        tcg_gen_shri_i32(cpu_crf[1], cpu_crf[1], FPSCR_OX);\n\n    }\n\n    /* We can raise a differed exception */\n\n    gen_helper_float_check_status(cpu_env);\n\n}\n", "idx": 7380, "substitutes": {"ctx": ["ck", "this", "cf", "dc", "loc", "gc", "ct", "ctl", "prefix", "gp", "cp", "kt", "pc", "cmp", "bc", "anc", "kh", "wx", "ka", "cl", "sc", "nt", "comm", "fc", "p", " cx", "cmd", "cm", "dl", "co", "tm", "nc", "context", "cb", "ind", "lc", "hw", "history", "kl", "cc", "xc", "crit", "pkg", "pg", "kw", "txt", "req", "rt", "ork", "cfg", "resp", "jac", "cpu", "tx", "ca", "jp", "np", "mc", "obj", "xp", "ctr", "ctrl", "cu", "tp", "conn", "today", "tc", "act"], "bf": ["db", "cf", "gb", "uf", "b", "bn", "ff", "xf", "bol", "pb", "eb", "bg", "bc", "buf", "BF", "FB", "lf", "bsp", "bh", "fc", "bp", "bd", "cb", "bt", "lb", " kb", "bb", "sb", "rb", "mb", "fab", "nb", "bs", "fb", "ptr", "tf", "sq", "sf", "bl", "f", "ft", "kb", "bm", "fg"], "sh": ["ph", "gh", "sp", "SH", "sw", "how", "igh", "kh", "shift", "sha", "h", "cl", "sc", "cs", "bh", "si", "sy", "sd", "se", "tw", "ly", "sv", "broad", "sm", "sb", "style", "Sh", "s", "scl", "sk", "sl", "resh", "shr", "hs", "ho", "ss", "sn", "sq", "sf", "wh", "ksh", "sch", "size", "she", "ssh", "shell", "shi"], "t0": ["T8", "T1", "T000", "ts0", " t3", " T1", " tZero", "t000", " t000", "TZero", "t8", "wt0", " T3", " t9", "tZero", "t9", "wtau", "T9", "wt1", "p1", " T0", "Tau", " t8", "t3", "wt000", "ts1", "T0", "p3", "ts8", "p0", "wt9", " tau", "tau", "tsZero"], "t1": ["dt2", " t001", "T1", " table", "i2", "t001", "tsOne", "ot1", "p001", "t8", "table", "dt1", "ot4", "dt001", " tOne", "iable", "p2", "i1", "p1", "tOne", "otable", "T2", " t8", "ot2", " t4", "ts1", "T0", "ts2", "p0", "i4", "t2", "dt8", "t4", "TOne", "p8", " t2"]}}
{"project": "qemu", "commit_id": "1e356fc14beaa3ece6c0e961bd479af58be3198b", "target": 1, "func": "void os_mem_prealloc(int fd, char *area, size_t memory, Error **errp)\n\n{\n\n    int i;\n\n    size_t pagesize = getpagesize();\n\n\n\n    memory = (memory + pagesize - 1) & -pagesize;\n\n    for (i = 0; i < memory / pagesize; i++) {\n\n        memset(area + pagesize * i, 0, 1);\n\n    }\n\n}\n", "idx": 7393, "substitutes": {"fd": ["pid", " pointer", " channel", " pid", " stream", "file", "fc", " io", " df", "d", " sd", "dev", "fp", " af", " db", "id", " fs", " handle", " d", " f", " file", "stream", "dir", "ptr", " dst", "fi", "FD", " output", " path"], "area": ["region", "aria", "prefix", "window", " areas", "ma", "ra", "page", "ka", "buffer", "ta", "aa", "base", "zone", "ica", "ata", "row", "range", "va", "are", "section", "ref", "space", "arc", "code", "angle", "rea", "array", "dir", "ca", "alias", "address", "aka", "ia", "storage", "size", "Area", "ha", "format", "a"], "memory": ["bytes", "gc", "function", "region", "power", "mem", "Memory", "metadata", "window", "age", " Memory", "margin", "radius", "ma", "page", "ram", "description", "mi", "buffer", "secondary", "map", "ami", "RAM", "location", "network", "pointer", "data", "history", "maximum", "value", "position", "record", "resource", "me", "usage", "balance", "mode", "mb", "m", "volume", "now", "imei", "storage", "cache", "address", "capacity", "message", "ia", "size", "length", "write", "database", "bm", "library", "mx", "reference", "media"], "errp": [" errP", "errh", "errP", "ErP", " errps", " errh", "Erh", "Errorp", "Erp", "Errorh", "ErrorP", "Erps", "Errorps", "errps"], "i": ["init", "ic", "ini", "asi", "ij", " bi", "ei", "ci", " ii", "it", " m", "ity", "im", "cli", " x", " v", "oi", "gi", "mi", "qi", "client", "ip", "li", "si", "zi", "n", "xi", "ind", "index", " ti", "key", "pi", " e", "bi", "multi", "ri", "ui", "ki", "ji", " I", "phi", "ti", "v", "ims", "ix", " j", "ai", "m", " mi", "I", "batch", "y", "\u0438", "fi", "sim", "iu", "MI", "j", "x", "di", "ii", "l", "sequence"]}}
{"project": "FFmpeg", "commit_id": "4029f05c8b0943a5446f254142d5e2bfedb50a0d", "target": 1, "func": "static int cuvid_decode_frame(AVCodecContext *avctx, void *data, int *got_frame, AVPacket *avpkt)\n\n{\n\n    CuvidContext *ctx = avctx->priv_data;\n\n    AVHWDeviceContext *device_ctx = (AVHWDeviceContext*)ctx->hwdevice->data;\n\n    AVCUDADeviceContext *device_hwctx = device_ctx->hwctx;\n\n    CUcontext dummy, cuda_ctx = device_hwctx->cuda_ctx;\n\n    AVFrame *frame = data;\n\n    CUVIDSOURCEDATAPACKET cupkt;\n\n    AVPacket filter_packet = { 0 };\n\n    AVPacket filtered_packet = { 0 };\n\n    CUdeviceptr mapped_frame = 0;\n\n    int ret = 0, eret = 0;\n\n\n\n    if (ctx->bsf && avpkt->size) {\n\n        if ((ret = av_packet_ref(&filter_packet, avpkt)) < 0) {\n\n            av_log(avctx, AV_LOG_ERROR, \"av_packet_ref failed\\n\");\n\n            return ret;\n\n        }\n\n\n\n        if ((ret = av_bsf_send_packet(ctx->bsf, &filter_packet)) < 0) {\n\n            av_log(avctx, AV_LOG_ERROR, \"av_bsf_send_packet failed\\n\");\n\n            av_packet_unref(&filter_packet);\n\n            return ret;\n\n        }\n\n\n\n        if ((ret = av_bsf_receive_packet(ctx->bsf, &filtered_packet)) < 0) {\n\n            av_log(avctx, AV_LOG_ERROR, \"av_bsf_receive_packet failed\\n\");\n\n            return ret;\n\n        }\n\n\n\n        avpkt = &filtered_packet;\n\n    }\n\n\n\n    ret = CHECK_CU(cuCtxPushCurrent(cuda_ctx));\n\n    if (ret < 0) {\n\n        av_packet_unref(&filtered_packet);\n\n        return ret;\n\n    }\n\n\n\n    memset(&cupkt, 0, sizeof(cupkt));\n\n\n\n    if (avpkt->size) {\n\n        cupkt.payload_size = avpkt->size;\n\n        cupkt.payload = avpkt->data;\n\n\n\n        if (avpkt->pts != AV_NOPTS_VALUE) {\n\n            cupkt.flags = CUVID_PKT_TIMESTAMP;\n\n            if (avctx->pkt_timebase.num && avctx->pkt_timebase.den)\n\n                cupkt.timestamp = av_rescale_q(avpkt->pts, avctx->pkt_timebase, (AVRational){1, 10000000});\n\n            else\n\n                cupkt.timestamp = avpkt->pts;\n\n        }\n\n    } else {\n\n        cupkt.flags = CUVID_PKT_ENDOFSTREAM;\n\n    }\n\n\n\n    ret = CHECK_CU(cuvidParseVideoData(ctx->cuparser, &cupkt));\n\n\n\n    av_packet_unref(&filtered_packet);\n\n\n\n    if (ret < 0) {\n\n        if (ctx->internal_error)\n\n            ret = ctx->internal_error;\n\n        goto error;\n\n    }\n\n\n\n    if (av_fifo_size(ctx->frame_queue)) {\n\n        CUVIDPARSERDISPINFO dispinfo;\n\n        CUVIDPROCPARAMS params;\n\n        unsigned int pitch = 0;\n\n        int offset = 0;\n\n        int i;\n\n\n\n        av_fifo_generic_read(ctx->frame_queue, &dispinfo, sizeof(CUVIDPARSERDISPINFO), NULL);\n\n\n\n        memset(&params, 0, sizeof(params));\n\n        params.progressive_frame = dispinfo.progressive_frame;\n\n        params.second_field = 0;\n\n        params.top_field_first = dispinfo.top_field_first;\n\n\n\n        ret = CHECK_CU(cuvidMapVideoFrame(ctx->cudecoder, dispinfo.picture_index, &mapped_frame, &pitch, &params));\n\n        if (ret < 0)\n\n            goto error;\n\n\n\n        if (avctx->pix_fmt == AV_PIX_FMT_CUDA) {\n\n            ret = av_hwframe_get_buffer(ctx->hwframe, frame, 0);\n\n            if (ret < 0) {\n\n                av_log(avctx, AV_LOG_ERROR, \"av_hwframe_get_buffer failed\\n\");\n\n                goto error;\n\n            }\n\n\n\n            ret = ff_decode_frame_props(avctx, frame);\n\n            if (ret < 0) {\n\n                av_log(avctx, AV_LOG_ERROR, \"ff_decode_frame_props failed\\n\");\n\n                goto error;\n\n            }\n\n\n\n            for (i = 0; i < 2; i++) {\n\n                CUDA_MEMCPY2D cpy = {\n\n                    .srcMemoryType = CU_MEMORYTYPE_DEVICE,\n\n                    .dstMemoryType = CU_MEMORYTYPE_DEVICE,\n\n                    .srcDevice     = mapped_frame,\n\n                    .dstDevice     = (CUdeviceptr)frame->data[i],\n\n                    .srcPitch      = pitch,\n\n                    .dstPitch      = frame->linesize[i],\n\n                    .srcY          = offset,\n\n                    .WidthInBytes  = FFMIN(pitch, frame->linesize[i]),\n\n                    .Height        = avctx->coded_height >> (i ? 1 : 0),\n\n                };\n\n\n\n                ret = CHECK_CU(cuMemcpy2D(&cpy));\n\n                if (ret < 0)\n\n                    goto error;\n\n\n\n                offset += avctx->coded_height;\n\n            }\n\n        } else if (avctx->pix_fmt == AV_PIX_FMT_NV12) {\n\n            AVFrame *tmp_frame = av_frame_alloc();\n\n            if (!tmp_frame) {\n\n                av_log(avctx, AV_LOG_ERROR, \"av_frame_alloc failed\\n\");\n\n                ret = AVERROR(ENOMEM);\n\n                goto error;\n\n            }\n\n\n\n            tmp_frame->format        = AV_PIX_FMT_CUDA;\n\n            tmp_frame->hw_frames_ctx = av_buffer_ref(ctx->hwframe);\n\n            tmp_frame->data[0]       = (uint8_t*)mapped_frame;\n\n            tmp_frame->linesize[0]   = pitch;\n\n            tmp_frame->data[1]       = (uint8_t*)(mapped_frame + avctx->coded_height * pitch);\n\n            tmp_frame->linesize[1]   = pitch;\n\n            tmp_frame->width         = avctx->width;\n\n            tmp_frame->height        = avctx->height;\n\n\n\n            ret = ff_get_buffer(avctx, frame, 0);\n\n            if (ret < 0) {\n\n                av_log(avctx, AV_LOG_ERROR, \"ff_get_buffer failed\\n\");\n\n                av_frame_free(&tmp_frame);\n\n                goto error;\n\n            }\n\n\n\n            ret = av_hwframe_transfer_data(frame, tmp_frame, 0);\n\n            if (ret) {\n\n                av_log(avctx, AV_LOG_ERROR, \"av_hwframe_transfer_data failed\\n\");\n\n                av_frame_free(&tmp_frame);\n\n                goto error;\n\n            }\n\n\n\n            av_frame_free(&tmp_frame);\n\n        } else {\n\n            ret = AVERROR_BUG;\n\n            goto error;\n\n        }\n\n\n\n        frame->width = avctx->width;\n\n        frame->height = avctx->height;\n\n        if (avctx->pkt_timebase.num && avctx->pkt_timebase.den)\n\n            frame->pts = av_rescale_q(dispinfo.timestamp, (AVRational){1, 10000000}, avctx->pkt_timebase);\n\n        else\n\n            frame->pts = dispinfo.timestamp;\n\n\n\n        /* CUVIDs opaque reordering breaks the internal pkt logic.\n\n         * So set pkt_pts and clear all the other pkt_ fields.\n\n         */\n\n        frame->pkt_pts = frame->pts;\n\n        av_frame_set_pkt_pos(frame, -1);\n\n        av_frame_set_pkt_duration(frame, 0);\n\n        av_frame_set_pkt_size(frame, -1);\n\n\n\n        frame->interlaced_frame = !dispinfo.progressive_frame;\n\n\n\n        if (!dispinfo.progressive_frame)\n\n            frame->top_field_first = dispinfo.top_field_first;\n\n\n\n        *got_frame = 1;\n\n    } else {\n\n        *got_frame = 0;\n\n    }\n\n\n\nerror:\n\n    if (mapped_frame)\n\n        eret = CHECK_CU(cuvidUnmapVideoFrame(ctx->cudecoder, mapped_frame));\n\n\n\n    eret = CHECK_CU(cuCtxPopCurrent(&dummy));\n\n\n\n    if (eret < 0)\n\n        return eret;\n\n    else\n\n        return ret;\n\n}\n", "idx": 7398, "substitutes": {"avctx": ["averthread", "avereq", "afthread", " avconn", "avca", "avcmd", "afctx", "afcb", "afcmp", "aveca", " avcmp", "avecmp", "avreq", "avtx", "awctx", "Avcmd", "hwconn", "awcfg", "awthread", "awcmp", "avercfg", "hwcontext", "avecfg", " avcmd", "avconn", " avcontext", "aftx", "Avcfg", "avecb", "hwctx", "avecontext", "avcontext", "afcmd", "wavca", "afconn", "Avctx", "avthread", " avtx", "avectx", "wavcfg", "wavctx", "hwtx", "averreq", "avcmp", " avcfg", "Avcontext", "afcfg", "avcb", "avcfg", "averca", "afcontext", "wavreq", "averctx", "avercmp", " avcb"], "data": ["package", "share", "read", "bytes", "form", "present", "padding", "next", "empty", "dat", "window", "type", "native", "pad", "feed", "scope", "buf", "rel", "buffer", "raw", "extra", "d", "p", "table", "group", " DATA", "rew", "ata", "context", "pointer", "t", "r", "value", "Data", "input", "record", "id", "to", "ref", "module", "mu", "device", "out", "ad", "video", "block", "m", "load", "action", "response", "version", "tx", "cache", "f", "DATA", "message", "size", "info", "in", "length", "one", "format", "class", "text", "res", "name", "image", "bin"], "got_frame": ["got2frames", "got___frames", "generated_channel", "generated___data", "got___data", "got__frames", "got__channel", "generated___frame", "got_frames", "got2channel", "got_channel", "got__data", "generated_data", "generated___channel", "generated_frames", "got_data", "got2frame", "got___frame", "got2data", "generated___frames", "generated_frame", "got___channel", "got__frame"], "avpkt": ["avemelt", "avcpacket", "avnpkin", "ajpkgacket", "avpkgct", "wavcpkt", "wavpct", "avpodacket", "avwpnt", "avewpkt", "avewpacket", " avcpet", " avcpkt", "avdpet", "wavcpkin", "avopoint", "avnpkt", "avepkt", "avpnt", "avpkgacket", "avppacket", "avpkgkt", "avpayct", "wavwpct", "avcnt", "avppkt", "avpett", " avpelt", "wavcpacket", "avewpet", "wavpacket", "wavwpacket", "avcce", "avwkt", "avpodkt", " avcpct", " avcpoint", "wavpkt", "avnpacket", "avepelt", "avpayet", "avwpct", "ajpct", "wavpkin", "ajpkgct", "avwpkt", "avppct", "ajpkt", "afppett", "avcpkt", "avemkt", "afppct", "avpet", "avckt", "avcpnt", "avnpnt", " avpoint", "avcet", "avpaykt", "avcpelt", "avpkg", "avdpacket", "avcpet", "avcpkin", "wavcpet", "avpce", "avmacket", "avmkg", "avnpet", "afpct", "avnpett", " avpacket", " avpet", "avwpacket", " avcpacket", "avpoint", "wavwpkt", "avepce", "avppett", "avppnt", "avdpce", "afpett", "avepacket", "avPelt", "avpkget", "wavpnt", "wavpet", "avPett", "avewpce", "wavwpnt", "avopkt", "ajpacket", "avwpce", "avcacket", "avepet", "afppkt", "avpelt", "avcct", "afpkt", "avopet", "avwpet", "avwacket", "avPct", " avcpelt", "avPkt", "avPet", "avpodkg", "avpacket", "afppnt", " avpct", "avPnt", "avcelt", "avmelt", "avcpct", "avmkt", "avwkg", "avemkg", "avpodelt", "avpct", "avwelt", "avpayoint", "avemacket", "avPacket", "avcpoint", "avnpct", "avdpkt", "avpkin", "avpkgkin", "avopct", "avepkg", "ajpkgkt", "afpnt"], "ctx": ["ck", "this", "cf", "dc", "loc", "gc", "setup", "ct", "ctl", "prefix", "cp", "conf", "cmp", "cam", "bc", "mom", "wx", "sys", "scope", "nt", "util", "cm", "cmd", "addr", "tm", "context", "cb", "hw", "lc", "func", "xc", "cc", "pkg", "proc", "module", "kw", "timeout", "txt", "handle", "req", "jac", "config", "cfg", "ac", "tx", "cv", "desc", "jp", "np", "mc", "obj", "qt", "Context", "acl", "conn", "abc", "tc", "act"], "device_ctx": ["devicepypkg", "device_req", "window_tx", "device_cp", "dev_pkg", "device_tx", "dev_req", "devicepyobj", "devicepyreq", "devicepyctx", "window_ctx", "window_cp", "dev_obj", "device_obj", "device_pkg", "dev_ctx", "window_obj"], "device_hwctx": ["device_iwaddr", "device_fwobj", "device_sysobj", "device2hwobj", "device_iwpkg", "device2fwpkg", "device_sysctx", "device_hwtx", "device_auxaddr", "device_iwcontext", "device_hwpkg", "device_iwobj", "device2fwctx", "device_fwtx", "device_auxctx", "device2hwpkg", "device2hwcontext", "device_hwaddr", "device_fwcontext", "device_fwpkg", "device_syspkg", "device_hwobj", "device_fwaddr", "device_hwcontext", "device_fwctx", "device_syscontext", "device2fwcontext", "device_iwtx", "device2fwobj", "device_iwctx", "device_auxcontext", "device2hwctx", "device_auxtx"], "dummy": ["sdalloc", "sdummy", "dalloc", "dcalloc", "Dalloc", "dup", "dumper", "dcumper", "dcup", "Dup", "sdup", "dcummy", "sdumper", "Dumper", "Dummy"], "frame": ["draw", "error", "event", "chain", "window", "channel", "Frame", "state", "msg", "flow", "base", "cmd", "context", "row", "process", "trace", "reason", "component", "command", "block", "action", "response", "message", "point", "image", "sequence"], "cupkt": ["casqt", "cpqt", " cupiat", "wpcht", "uccet", "caskt", "wpkg", "sockw", "wpkt", "cupiat", "vpkt", "uccnt", "etchupkt", "cmpunct", "camkt", "sociat", "cupqt", "camqt", "ucccht", "ucckt", "cupunct", "camak", "cpunct", "vpkg", "cupkw", "cpkt", "rapqt", "cmpkid", "etchupunct", "etchupet", "cpelt", "rapkg", "uccqt", "cmpqt", "cupak", " cupett", "uccelt", "sockt", "vpqt", "cmpkg", "cmpkt", "rapkt", "cupkid", "cupnt", "wpkid", "wpett", "camkg", "wpnt", "wpet", "wpiat", "rapak", "cupett", "cmpcht", "caskg", "ucckid", "cmpnt", "casak", " cupkw", "cmpelt", "etchupelt", "cupet", "cpet", "cupcht", "cupelt", "vpet", "cupkg", "socett", "wpkw", "wpqt", "cmpet"]}}
{"project": "qemu", "commit_id": "30ca440eec9fe1d7eec5a48addac656438778278", "target": 0, "func": "static void hotplug(void)\n\n{\n\n    qtest_start(\"-device virtio-net-pci\");\n\n\n\n    qpci_plug_device_test(\"virtio-net-pci\", \"net1\", PCI_SLOT_HP, NULL);\n\n    qpci_unplug_acpi_device_test(\"net1\", PCI_SLOT_HP);\n\n\n\n    test_end();\n\n}\n", "idx": 7420, "substitutes": {}}
{"project": "FFmpeg", "commit_id": "1d16a1cf99488f16492b1bb48e023f4da8377e07", "target": 0, "func": "static void ff_h264_idct8_add_sse2(uint8_t *dst, int16_t *block, int stride)\n\n{\n\n    __asm__ volatile(\n\n        \"movdqa   0x10(%1), %%xmm1 \\n\"\n\n        \"movdqa   0x20(%1), %%xmm2 \\n\"\n\n        \"movdqa   0x30(%1), %%xmm3 \\n\"\n\n        \"movdqa   0x50(%1), %%xmm5 \\n\"\n\n        \"movdqa   0x60(%1), %%xmm6 \\n\"\n\n        \"movdqa   0x70(%1), %%xmm7 \\n\"\n\n        H264_IDCT8_1D_SSE2(%%xmm0, %%xmm1, %%xmm2, %%xmm3, %%xmm4, %%xmm5, %%xmm6, %%xmm7)\n\n        TRANSPOSE8(%%xmm4, %%xmm1, %%xmm7, %%xmm3, %%xmm5, %%xmm0, %%xmm2, %%xmm6, (%1))\n\n        \"paddw          %4, %%xmm4 \\n\"\n\n        \"movdqa     %%xmm4, 0x00(%1) \\n\"\n\n        \"movdqa     %%xmm2, 0x40(%1) \\n\"\n\n        H264_IDCT8_1D_SSE2(%%xmm4, %%xmm0, %%xmm6, %%xmm3, %%xmm2, %%xmm5, %%xmm7, %%xmm1)\n\n        \"movdqa     %%xmm6, 0x60(%1) \\n\"\n\n        \"movdqa     %%xmm7, 0x70(%1) \\n\"\n\n        \"pxor       %%xmm7, %%xmm7 \\n\"\n\n        STORE_DIFF_8P(%%xmm2, (%0),      %%xmm6, %%xmm7)\n\n        STORE_DIFF_8P(%%xmm0, (%0,%2),   %%xmm6, %%xmm7)\n\n        STORE_DIFF_8P(%%xmm1, (%0,%2,2), %%xmm6, %%xmm7)\n\n        STORE_DIFF_8P(%%xmm3, (%0,%3),   %%xmm6, %%xmm7)\n\n        \"lea     (%0,%2,4), %0 \\n\"\n\n        STORE_DIFF_8P(%%xmm5, (%0),      %%xmm6, %%xmm7)\n\n        STORE_DIFF_8P(%%xmm4, (%0,%2),   %%xmm6, %%xmm7)\n\n        \"movdqa   0x60(%1), %%xmm0 \\n\"\n\n        \"movdqa   0x70(%1), %%xmm1 \\n\"\n\n        STORE_DIFF_8P(%%xmm0, (%0,%2,2), %%xmm6, %%xmm7)\n\n        STORE_DIFF_8P(%%xmm1, (%0,%3),   %%xmm6, %%xmm7)\n\n        :\"+r\"(dst)\n\n        :\"r\"(block), \"r\"((x86_reg)stride), \"r\"((x86_reg)3L*stride), \"m\"(ff_pw_32)\n\n    );\n\n}\n", "idx": 7428, "substitutes": {"dst": ["dht", "fht", "fsrc", "idbl", "idht", "Dbl", "Dsrc", "dsrc", "idst", "Dst", "dbl", "idsrc", "fst", "fbl", "Dht"], "block": ["chain", "mem", "type", "pack", "cl", "set", "buf", "buffer", "no", "len", "row", "data", "kl", "byte", "ref", "blocks", "device", "kw", "start", "load", "tx", "mm", "bl", "obj", "length", "lock", "Block", "bin"], "stride": ["strope", "strride", " strice", "collide", "collride", "dride", "collice", "drope", "drice", "collope", " strope", "drride", "strice", " strride"]}}
{"project": "qemu", "commit_id": "3a51dee658b9cc781acd57dd11bffbd1e402f93d", "target": 0, "func": "static void ide_identify(IDEState *s)\n\n{\n\n    uint16_t *p;\n\n    unsigned int oldsize;\n\n\n\n    memset(s->io_buffer, 0, 512);\n\n    p = (uint16_t *)s->io_buffer;\n\n    stw(p + 0, 0x0040);\n\n    stw(p + 1, s->cylinders); \n\n    stw(p + 3, s->heads);\n\n    stw(p + 4, 512 * s->sectors); /* sectors */\n\n    stw(p + 5, 512); /* sector size */\n\n    stw(p + 6, s->sectors); \n\n    stw(p + 20, 3); /* buffer type */\n\n    stw(p + 21, 512); /* cache size in sectors */\n\n    stw(p + 22, 4); /* ecc bytes */\n\n    padstr((uint8_t *)(p + 27), \"QEMU HARDDISK\", 40);\n\n#if MAX_MULT_SECTORS > 1    \n\n    stw(p + 47, MAX_MULT_SECTORS);\n\n#endif\n\n    stw(p + 48, 1); /* dword I/O */\n\n    stw(p + 49, 1 << 9); /* LBA supported, no DMA */\n\n    stw(p + 51, 0x200); /* PIO transfer cycle */\n\n    stw(p + 52, 0x200); /* DMA transfer cycle */\n\n    stw(p + 54, s->cylinders);\n\n    stw(p + 55, s->heads);\n\n    stw(p + 56, s->sectors);\n\n    oldsize = s->cylinders * s->heads * s->sectors;\n\n    stw(p + 57, oldsize);\n\n    stw(p + 58, oldsize >> 16);\n\n    if (s->mult_sectors)\n\n        stw(p + 59, 0x100 | s->mult_sectors);\n\n    stw(p + 60, s->nb_sectors);\n\n    stw(p + 61, s->nb_sectors >> 16);\n\n    stw(p + 80, (1 << 1) | (1 << 2));\n\n    stw(p + 82, (1 << 14));\n\n    stw(p + 83, (1 << 14));\n\n    stw(p + 84, (1 << 14));\n\n    stw(p + 85, (1 << 14));\n\n    stw(p + 86, 0);\n\n    stw(p + 87, (1 << 14));\n\n}\n", "idx": 7430, "substitutes": {"s": ["as", "rs", "gs", "bis", "ses", "b", "results", "sw", "less", "ns", "ants", "c", "its", "h", "ats", "aws", "i", "qs", "sys", "comm", "cs", "os", "ps", "g", "als", "ms", "n", "is", "ts", "details", "ds", "o", "t", "se", "es", "r", "js", "ins", "an", "sv", "ls", "events", "sb", "v", "ims", "stats", "m", "hs", "vs", "ss", "bs", "y", "sq", "parts", "ans", "e", "S", "sts", "changes", "z", "sports", "a", "l", "ops"], "p": ["post", "pid", "sp", "q", "b", "power", "ar", "it", "wp", "cp", "ping", "pb", "c", "pc", "h", "br", "up", "pad", "i", "pro", "pt", "at", "ip", "er", "progress", "ps", "g", "pa", "bp", "n", "d", "vp", "php", "op", "perm", "fp", "t", "pers", "pi", "r", "pe", "w", "pre", "pkg", "proc", "pg", "ap", "pr", "lp", "v", "port", "m", "per", "jp", "np", "f", "dp", "xp", "pp", "P", "point", "j", "x", "tp", "mp"], "oldsize": ["oldcapacity", "oldercapacity", " Oldcap", "Oldsize", " oldSIZE", "oldcap", " olddim", "lowsize", "hardsize", "olderSIZE", "oldSize", "olderscale", "olddim", "olderdim", "hardcache", "oldspace", "oldersy", " oldspace", "Olddim", " oldcache", "oldSIZE", "oldercap", "olderspace", " Oldsize", "oldscale", " oldcap", "oldercache", "oldcache", "OldSIZE", " Oldsy", "olderSize", "lowspace", "oldersize", " oldSize", " oldsy", "lowcapacity", " oldscale", "lowSize", "hardscale", " OldSize", " oldcapacity", "oldsy"]}}
{"project": "FFmpeg", "commit_id": "7ec9c5ce8a753175244da971fed9f1e25aef7971", "target": 0, "func": "static int encode_apng(AVCodecContext *avctx, AVPacket *pkt,\n\n                       const AVFrame *pict, int *got_packet)\n\n{\n\n    PNGEncContext *s = avctx->priv_data;\n\n    int ret;\n\n    int enc_row_size;\n\n    size_t max_packet_size;\n\n    APNGFctlChunk fctl_chunk = {0};\n\n\n\n    if (pict && avctx->codec_id == AV_CODEC_ID_APNG && s->color_type == PNG_COLOR_TYPE_PALETTE) {\n\n        uint32_t checksum = ~av_crc(av_crc_get_table(AV_CRC_32_IEEE_LE), ~0U, pict->data[1], 256 * sizeof(uint32_t));\n\n\n\n        if (avctx->frame_number == 0) {\n\n            s->palette_checksum = checksum;\n\n        } else if (checksum != s->palette_checksum) {\n\n            av_log(avctx, AV_LOG_ERROR,\n\n                   \"Input contains more than one unique palette. APNG does not support multiple palettes.\\n\");\n\n            return -1;\n\n        }\n\n    }\n\n\n\n    enc_row_size    = deflateBound(&s->zstream, (avctx->width * s->bits_per_pixel + 7) >> 3);\n\n    max_packet_size =\n\n        AV_INPUT_BUFFER_MIN_SIZE + // headers\n\n        avctx->height * (\n\n            enc_row_size +\n\n            (4 + 12) * (((int64_t)enc_row_size + IOBUF_SIZE - 1) / IOBUF_SIZE) // fdAT * ceil(enc_row_size / IOBUF_SIZE)\n\n        );\n\n    if (max_packet_size > INT_MAX)\n\n        return AVERROR(ENOMEM);\n\n\n\n    if (avctx->frame_number == 0) {\n\n        if (!pict)\n\n            return AVERROR(EINVAL);\n\n\n\n        s->bytestream = avctx->extradata = av_malloc(FF_MIN_BUFFER_SIZE);\n\n        if (!avctx->extradata)\n\n            return AVERROR(ENOMEM);\n\n\n\n        ret = encode_headers(avctx, pict);\n\n        if (ret < 0)\n\n            return ret;\n\n\n\n        avctx->extradata_size = s->bytestream - avctx->extradata;\n\n\n\n        s->last_frame_packet = av_malloc(max_packet_size);\n\n        if (!s->last_frame_packet)\n\n            return AVERROR(ENOMEM);\n\n    } else if (s->last_frame) {\n\n        ret = ff_alloc_packet2(avctx, pkt, max_packet_size, 0);\n\n        if (ret < 0)\n\n            return ret;\n\n\n\n        memcpy(pkt->data, s->last_frame_packet, s->last_frame_packet_size);\n\n        pkt->size = s->last_frame_packet_size;\n\n        pkt->pts = pkt->dts = s->last_frame->pts;\n\n    }\n\n\n\n    if (pict) {\n\n        s->bytestream_start =\n\n        s->bytestream       = s->last_frame_packet;\n\n        s->bytestream_end   = s->bytestream + max_packet_size;\n\n\n\n        // We're encoding the frame first, so we have to do a bit of shuffling around\n\n        // to have the image data write to the correct place in the buffer\n\n        fctl_chunk.sequence_number = s->sequence_number;\n\n        ++s->sequence_number;\n\n        s->bytestream += 26 + 12;\n\n\n\n        ret = apng_encode_frame(avctx, pict, &fctl_chunk, &s->last_frame_fctl);\n\n        if (ret < 0)\n\n            return ret;\n\n\n\n        fctl_chunk.delay_num = 0; // delay filled in during muxing\n\n        fctl_chunk.delay_den = 0;\n\n    } else {\n\n        s->last_frame_fctl.dispose_op = APNG_DISPOSE_OP_NONE;\n\n    }\n\n\n\n    if (s->last_frame) {\n\n        uint8_t* last_fctl_chunk_start = pkt->data;\n\n        uint8_t buf[26];\n\n\n\n        AV_WB32(buf + 0, s->last_frame_fctl.sequence_number);\n\n        AV_WB32(buf + 4, s->last_frame_fctl.width);\n\n        AV_WB32(buf + 8, s->last_frame_fctl.height);\n\n        AV_WB32(buf + 12, s->last_frame_fctl.x_offset);\n\n        AV_WB32(buf + 16, s->last_frame_fctl.y_offset);\n\n        AV_WB16(buf + 20, s->last_frame_fctl.delay_num);\n\n        AV_WB16(buf + 22, s->last_frame_fctl.delay_den);\n\n        buf[24] = s->last_frame_fctl.dispose_op;\n\n        buf[25] = s->last_frame_fctl.blend_op;\n\n        png_write_chunk(&last_fctl_chunk_start, MKTAG('f', 'c', 'T', 'L'), buf, 26);\n\n\n\n        *got_packet = 1;\n\n    }\n\n\n\n    if (pict) {\n\n        if (!s->last_frame) {\n\n            s->last_frame = av_frame_alloc();\n\n            if (!s->last_frame)\n\n                return AVERROR(ENOMEM);\n\n        } else if (s->last_frame_fctl.dispose_op != APNG_DISPOSE_OP_PREVIOUS) {\n\n            if (!s->prev_frame) {\n\n                s->prev_frame = av_frame_alloc();\n\n                if (!s->prev_frame)\n\n                    return AVERROR(ENOMEM);\n\n\n\n                s->prev_frame->format = pict->format;\n\n                s->prev_frame->width = pict->width;\n\n                s->prev_frame->height = pict->height;\n\n                if ((ret = av_frame_get_buffer(s->prev_frame, 32)) < 0)\n\n                    return ret;\n\n            }\n\n\n\n            // Do disposal, but not blending\n\n            memcpy(s->prev_frame->data[0], s->last_frame->data[0],\n\n                   s->last_frame->linesize[0] * s->last_frame->height);\n\n            if (s->last_frame_fctl.dispose_op == APNG_DISPOSE_OP_BACKGROUND) {\n\n                uint32_t y;\n\n                uint8_t bpp = (s->bits_per_pixel + 7) >> 3;\n\n                for (y = s->last_frame_fctl.y_offset; y < s->last_frame_fctl.y_offset + s->last_frame_fctl.height; ++y) {\n\n                    size_t row_start = s->last_frame->linesize[0] * y + bpp * s->last_frame_fctl.x_offset;\n\n                    memset(s->prev_frame->data[0] + row_start, 0, bpp * s->last_frame_fctl.width);\n\n                }\n\n            }\n\n        }\n\n\n\n        av_frame_unref(s->last_frame);\n\n        ret = av_frame_ref(s->last_frame, (AVFrame*)pict);\n\n        if (ret < 0)\n\n            return ret;\n\n\n\n        s->last_frame_fctl = fctl_chunk;\n\n        s->last_frame_packet_size = s->bytestream - s->bytestream_start;\n\n    } else {\n\n        av_frame_free(&s->last_frame);\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 7448, "substitutes": {"avctx": ["abcv", "avctr", "afconf", "avcp", "navjac", "ajctx", "averconf", " avcv", "apctr", "savcu", "avcontext", "aveconn", "avjac", "avcv", "avct", "avecp", "apctx", "avcu", " avobj", "averctx", " avctr", "averobj", "ajcu", "avcmd", "averpkg", "afctx", "avejac", "savctx", "avercookie", "avect", " avct", "aveconf", "wavjac", "avcrit", "aptx", "ajcontext", "avconn", "afcp", " avcrit", "avecontext", "avcookie", "navtx", "navctx", "afconn", "verctx", "avectx", "avecrit", "wavctx", "averkl", "avertx", "avconf", "wavcontext", "avecmd", "navct", " avcookie", "navcontext", " avconn", "avpkg", "vertx", "avtx", "vercontext", "abtxt", "avercp", "abcontext", "averconn", "avecu", " avkl", " avcontext", "aftx", "avercu", "avercontext", "avtxt", "aveobj", " avtx", " avjac", "ajcmd", "wavtx", "ajconn", "avectr", "averjac", "afpkg", " avtxt", "avertxt", "avercv", "abctx", " avcu", "avercmd", "ajtx", "avetx", "abcookie", "avobj", "savcontext", "avkl", "abconn", "abtx", "savconn", "verconn", "navcrit", "abkl", "avepkg", "afcontext", "apcontext"], "pkt": [" pkg", "packet", "ppkt", "apkg", "pkg", "apqt", "apacket", "ppqt", " pqt", "apkt", "pqt", "ppkg", "ppacket", " packet"], "pict": ["feat", "fen", "jpg", "mot", "quant", "gif", "ct", "hum", "avi", "Pic", "pain", "pen", "Pict", "kt", "cam", "eric", "phot", "phy", " img", "fig", "anim", "comm", "pit", "photo", "qi", "agic", "virt", "p", "prop", "fat", "stat", "Fi", "picture", " pictures", "phys", "png", "plain", "pai", " pic", "pic", " picture", "sci", "img", "pas", "jit", "isch", "Picture", " feat", "pres", "photos", "cheat", "pty", "capt", "image", "act"], "got_packet": ["got___packel", "got_pel", "got_pets", "got_packsel", "got_peter", "got_ppet", "got_ppets", "got_packset", "got_pet", "got___packsel", "got_packeter", "got___packset", "got___packets", "got_ppel", "got___packeter", "got___packsets", "got_packsets", "got_packseter", "got_packel", "got_ppeter", "got___packseter", "got___packet", "got_packets"], "s": ["sw", "less", "conf", "c", "h", "state", "sc", "ps", "ports", "ts", "settings", "pers", "utils", "js", "w", "sb", "services", "ss", "sports", "scripts", "rs", "so", "ses", "sam", "store", "https", "os", "g", "es", "v", "stats", "m", "sa", "sac", "sis", "aws", "l", "gs", "ssl", "sg", "ns", "ctx", "ats", "cs", "p", "aunts", "is", "sd", "sv", "sm", "hs", "st", "bs", "sq", "fs", "S", "news", "sp", "b", "its", "i", "sys", "set", "qs", "als", "n", "ds", "ls", "ess", "scl", "ims", "sh", "spec", "sts"], "ret": ["gt", "result", "match", "gc", "mem", "it", "Return", "ber", "get", "cont", "ter", "nt", "ext", "cmd", "mt", "rets", "len", "val", "tr", "usr", "alt", "t", "err", "value", "ref", "inter", "rev", "rem", "out", "try", "rt", "fin", "reset", "resp", "re", "fun", "final", "status", "print", "RET", "tf", "fail", "f", "Ret", "conv", "ft", "ll", "res", " RET", "arr", "deg", "elt", "flag"], "enc_row_size": ["enc_col_Size", "enc_col_size", "enc_pixel_len", "enc_rowxoffset", "enc_rows_size", "enc_col_len", "enc_row_len", "enc_rowxsize", "enc_row_SIZE", "enc_row_name", "enc_pixel_size", "enc_pixel_SIZE", "enc_rows_SIZE", "enc_rows_offset", "enc_rowxname", "enc_row_Size", "enc_row_max", "enc_rows_name", "enc_row2size", "enc_rowxSIZE", "enc_row2SIZE", "enc_col_name", "enc_col_SIZE", "enc_row2name", "enc_row2Size", "enc_col_max", "enc_row_offset"], "max_packet_size": ["max_packet_SIZE", "CT", "max_packets_SIZE", "max_packets_count", "max_packets_size", "max_packets_Size", "max_packet_scale", "max_packet_count", "max_packet_Size", "max_packacket_SIZE", "max_packet_length", "max_packacket_size", "max_packacket_scale", "max_packets_length", "max_packacket_Size", "_"]}}
{"project": "qemu", "commit_id": "d62b5dea30284eacd88055bb08db7c295655945f", "target": 0, "func": "BlockDriverAIOCB *bdrv_aio_readv(BlockDriverState *bs, int64_t sector_num,\n\n                                 QEMUIOVector *qiov, int nb_sectors,\n\n                                 BlockDriverCompletionFunc *cb, void *opaque)\n\n{\n\n    BlockDriver *drv = bs->drv;\n\n    BlockDriverAIOCB *ret;\n\n\n\n    trace_bdrv_aio_readv(bs, sector_num, nb_sectors, opaque);\n\n\n\n    if (!drv)\n\n        return NULL;\n\n    if (bdrv_check_request(bs, sector_num, nb_sectors))\n\n        return NULL;\n\n\n\n    ret = drv->bdrv_aio_readv(bs, sector_num, qiov, nb_sectors,\n\n                              cb, opaque);\n\n\n\n    if (ret) {\n\n\t/* Update stats even though technically transfer has not happened. */\n\n\tbs->rd_bytes += (unsigned) nb_sectors * BDRV_SECTOR_SIZE;\n\n\tbs->rd_ops ++;\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 7449, "substitutes": {"bs": ["boxes", "bes", "rs", "gb", "gs", "bis", "b", "bn", "bec", "blog", "ubs", "ns", "pb", "eb", "its", "bos", "irms", "acs", "cks", "bc", "sys", "qs", "bsp", "cs", "bh", "ps", "als", "ms", "bp", "bd", "ts", "is", "ds", "BS", "hz", "css", "vals", "aus", "js", "bb", "ls", "sb", "bf", "bps", "ims", "ubis", "outs", "bits", "vs", "hs", "aos", "fs", "sts", "ctr", "bm", "obs", "bas", "lbs"], "sector_num": ["sector2number", " sector_hom", "pixel_hom", " sector_tim", "sector_number", " sector_number", "sectoretyhom", "sector_tim", "sector_int", "sectorixint", "pixel_num", " sector_no", "sector2mon", "sectorixhom", "sector_hom", "sector_no", "sectorixnum", "sectoretyno", "sector_mon", "sectorixdec", "sector_Num", "pixel_dec", "sector2Num", " sector_Num", "sector_dec", " sector_mon", "sectoretymon", "sectoretynum", "pixel_int", "sector2num"], "qiov": ["aqiov", " qiev", " qiva", "qiva", "aqiva", " kiov", " qiop", "qiev", " kiosity", "Qiev", " kiev", "Qiop", "qiour", "qiosity", "aqovi", " kiop", " qiour", "qqovi", "qqiov", " qovi", "Qiosity", "qiop", "qqiva", "qqiour", " qiosity", "Qiov", "aqiour", "qovi"], "nb_sectors": ["nb_vegments", "nb_scheriers", "nb_seves", "nb_pevers", "nb_scheors", "nb_veurers", "nb_temlements", "nb_bellers", "nb_speriers", "nb_vectors", "nb_suivers", "nb_severs", "nb_sellers", "nb_selements", "nb_segments", "nb_temors", "nb_nectors", "nb_spegments", "nb_temctors", "nb_psegments", "nb_speors", "nb_psectors", "nb_peors", "nb_schevers", "nb_seivers", "nb_neriers", "nb_spevers", "nb_suors", "nb_vellers", "nb_parsellers", "nb_parseurers", "nb_spectors", "nb_beurers", "nb_neves", "nb_velements", "nb_veves", "nb_pectors", "nb_pegments", "nb_seurers", "nb_veivers", "nb_sullers", "nb_pseors", "nb_nelements", "nb_psevers", "nb_schectors", "nb_spellers", "nb_nevers", "nb_seors", "nb_begments", "nb_parsectors", "nb_bectors", "nb_parsegments", "nb_neors", "nb_speivers", "nb_suctors", "nb_temves", "nb_veors", "nb_seriers"], "cb": ["ck", "db", "cf", "gb", "cp", "conf", "eb", "pb", "c", "job", "ctx", "bc", "fc", "dt", "cm", "cmd", "bp", "unc", "nc", "bt", "func", "callback", "cc", "bb", "rb", "bf", "cr", "fun", "cfg", "fn", "CB", "nb", "cv", "cd", "conv", "ctr", "ctrl", "tc"], "opaque": ["supponymous", "imacity", "opesc", "obaques", "paque", "suppque", "topaque", "impa", "ppa", "oppaques", "opque", "hopque", "obacity", "hopaque", "opaques", "imally", "oppaque", "obaque", "pesc", "imaque", "suppula", "hoponymous", "topque", "oppesc", "toponymous", "paques", "topula", "opacity", "suppaque", "hopally", "hopacity", "pacity", "pally", "oponymous", "opula", "oppa", "obesc", "hopula", "oppacity", "opally", "hoppa"], "drv": ["drb", "DRv", "drix", "srb", "drh", "srv", " drw", "driiver", "drV", " drh", "Drb", "trv", "DRw", "drva", "drih", " drx", "Drvr", " drV", "DRva", "srj", " drj", "driva", "driV", "trx", "trh", "srvr", "drj", "driw", " drb", "drw", "drij", "drvr", "driver", "DRV", " drva", "Drw", " driver", "Drv", " drvr", "drx", "drivr", "driv", "srw", "triver"], "ret": ["gt", "leg", "result", "repl", "pret", "ert", "it", "back", "cont", "ter", "det", "nt", "elt", "at", "rect", "backed", "mt", " Ret", "rets", "len", "val", "tr", "usr", "red", "alt", "t", "err", "pet", "ref", "bool", "rev", "rem", "out", "plain", "rt", "reset", "lt", "resp", "re", "final", "status", "report", "tmp", "lit", "print", "RET", "pas", "jp", "f", "cat", "Ret", "ft", "arg", "sat", "ll", "j", "res", " RET", "got", "def", "rm", "cert", "flag"], "rd_ops": ["ptrvbytes", "ptr_ops", "rdpoops", "rdvops", "ptrvhops", "rdvhops", "rd__ops", "ptrvops", "rd__hops", "rd_bits", "ptr_hops", "rdvbits", "rdpobytes", "ptr_bits", "ptrvbits", "rdpobits", "rd__bits", "rdvbytes", "rd__bytes", "rd_hops", "ptr_bytes", "rdpohops", "rd_bytes"]}}
{"project": "qemu", "commit_id": "56b4a42a2e0ae74cee629abcb82993e79deeb356", "target": 0, "func": "static void migrate_set_downtime(QTestState *who, const char *value)\n\n{\n\n    QDict *rsp;\n\n    gchar *cmd;\n\n\n\n    cmd = g_strdup_printf(\"{ 'execute': 'migrate_set_downtime',\"\n\n                          \"'arguments': { 'value': %s } }\", value);\n\n    rsp = qtest_qmp(who, cmd);\n\n    g_free(cmd);\n\n    g_assert(qdict_haskey(rsp, \"return\"));\n\n    QDECREF(rsp);\n\n}\n", "idx": 7458, "substitutes": {"who": ["which", "hel", " wo", "how", " Who", "WH", "wid", "WHO", " whom", "both", "wat", "whe", "compl", "what", "good", "WHERE", "mail", "fil", "Who", " WHO", "that", "why", "where", "well", "hu", "wo", "What", "wh", " wh", "someone", " which", "stro", "because", "yo", "hop", "since", "you", "kill"], "value": ["widget", "content", "update", "node", "pain", "type", "place", "values", "field", "set", " Value", "vp", "val", "property", "label", "data", "key", "unit", "attribute", "ue", "v", "change", "new", "now", "hello", "Value", "rule", "format", "text", "VALUE", "json", "name"], "rsp": ["rrsp", "srSP", "rtp", "srsp", "rsesp", "rrsc", " rpl", "srresp", " rtp", " rsc", " rosp", "RSP", "rresp", "rrpt", "Rsp", " rresp", "rrtp", " resp", "rssp", "Rresp", " rSP", "Rosp", "resp", "srosp", "Rtp", "rrsm", " rpt", "rsm", "rosp", "Rpl", "rsc", "rrSP", " rsm", "rpl", "rsSP", "Rsc", "rspt", "rrpl", "Rsm", "rSP", "rpt"], "cmd": ["content", "gt", "cf", "buff", "ct", "call", "ctl", "mem", "cp", "c", "md", "ctx", "cmp", "buf", "comm", "msg", "mk", "help", "prop", "ext", "bind", "mt", "urg", "cut", "cb", "ind", "key", "func", "col", "str", "pkg", "control", "send", "txt", "handle", "req", "fun", "command", "cfg", "ch", "dq", "ptr", "batch", "cd", "exec", "cat", "obj", "ctr", "Cmd", "text", "def", "miss"]}}
{"project": "qemu", "commit_id": "90e26f5aacd265257f7de58ee59f72dc36dff40e", "target": 0, "func": "target_ulong do_arm_semihosting(CPUARMState *env)\n\n{\n\n    ARMCPU *cpu = arm_env_get_cpu(env);\n\n    CPUState *cs = CPU(cpu);\n\n    target_ulong args;\n\n    target_ulong arg0, arg1, arg2, arg3;\n\n    char * s;\n\n    int nr;\n\n    uint32_t ret;\n\n    uint32_t len;\n\n#ifdef CONFIG_USER_ONLY\n\n    TaskState *ts = cs->opaque;\n\n#else\n\n    CPUARMState *ts = env;\n\n#endif\n\n\n\n    if (is_a64(env)) {\n\n        /* Note that the syscall number is in W0, not X0 */\n\n        nr = env->xregs[0] & 0xffffffffU;\n\n        args = env->xregs[1];\n\n    } else {\n\n        nr = env->regs[0];\n\n        args = env->regs[1];\n\n    }\n\n\n\n    switch (nr) {\n\n    case TARGET_SYS_OPEN:\n\n        GET_ARG(0);\n\n        GET_ARG(1);\n\n        GET_ARG(2);\n\n        s = lock_user_string(arg0);\n\n        if (!s) {\n\n            /* FIXME - should this error code be -TARGET_EFAULT ? */\n\n            return (uint32_t)-1;\n\n        }\n\n        if (arg1 >= 12) {\n\n            unlock_user(s, arg0, 0);\n\n            return (uint32_t)-1;\n\n        }\n\n        if (strcmp(s, \":tt\") == 0) {\n\n            int result_fileno = arg1 < 4 ? STDIN_FILENO : STDOUT_FILENO;\n\n            unlock_user(s, arg0, 0);\n\n            return result_fileno;\n\n        }\n\n        if (use_gdb_syscalls()) {\n\n            ret = arm_gdb_syscall(cpu, arm_semi_cb, \"open,%s,%x,1a4\", arg0,\n\n                                  (int)arg2+1, gdb_open_modeflags[arg1]);\n\n        } else {\n\n            ret = set_swi_errno(ts, open(s, open_modeflags[arg1], 0644));\n\n        }\n\n        unlock_user(s, arg0, 0);\n\n        return ret;\n\n    case TARGET_SYS_CLOSE:\n\n        GET_ARG(0);\n\n        if (use_gdb_syscalls()) {\n\n            return arm_gdb_syscall(cpu, arm_semi_cb, \"close,%x\", arg0);\n\n        } else {\n\n            return set_swi_errno(ts, close(arg0));\n\n        }\n\n    case TARGET_SYS_WRITEC:\n\n        {\n\n          char c;\n\n\n\n          if (get_user_u8(c, args))\n\n              /* FIXME - should this error code be -TARGET_EFAULT ? */\n\n              return (uint32_t)-1;\n\n          /* Write to debug console.  stderr is near enough.  */\n\n          if (use_gdb_syscalls()) {\n\n                return arm_gdb_syscall(cpu, arm_semi_cb, \"write,2,%x,1\", args);\n\n          } else {\n\n                return write(STDERR_FILENO, &c, 1);\n\n          }\n\n        }\n\n    case TARGET_SYS_WRITE0:\n\n        if (!(s = lock_user_string(args)))\n\n            /* FIXME - should this error code be -TARGET_EFAULT ? */\n\n            return (uint32_t)-1;\n\n        len = strlen(s);\n\n        if (use_gdb_syscalls()) {\n\n            return arm_gdb_syscall(cpu, arm_semi_cb, \"write,2,%x,%x\",\n\n                                   args, len);\n\n        } else {\n\n            ret = write(STDERR_FILENO, s, len);\n\n        }\n\n        unlock_user(s, args, 0);\n\n        return ret;\n\n    case TARGET_SYS_WRITE:\n\n        GET_ARG(0);\n\n        GET_ARG(1);\n\n        GET_ARG(2);\n\n        len = arg2;\n\n        if (use_gdb_syscalls()) {\n\n            arm_semi_syscall_len = len;\n\n            return arm_gdb_syscall(cpu, arm_semi_cb, \"write,%x,%x,%x\",\n\n                                   arg0, arg1, len);\n\n        } else {\n\n            s = lock_user(VERIFY_READ, arg1, len, 1);\n\n            if (!s) {\n\n                /* FIXME - should this error code be -TARGET_EFAULT ? */\n\n                return (uint32_t)-1;\n\n            }\n\n            ret = set_swi_errno(ts, write(arg0, s, len));\n\n            unlock_user(s, arg1, 0);\n\n            if (ret == (uint32_t)-1)\n\n                return -1;\n\n            return len - ret;\n\n        }\n\n    case TARGET_SYS_READ:\n\n        GET_ARG(0);\n\n        GET_ARG(1);\n\n        GET_ARG(2);\n\n        len = arg2;\n\n        if (use_gdb_syscalls()) {\n\n            arm_semi_syscall_len = len;\n\n            return arm_gdb_syscall(cpu, arm_semi_cb, \"read,%x,%x,%x\",\n\n                                   arg0, arg1, len);\n\n        } else {\n\n            s = lock_user(VERIFY_WRITE, arg1, len, 0);\n\n            if (!s) {\n\n                /* FIXME - should this error code be -TARGET_EFAULT ? */\n\n                return (uint32_t)-1;\n\n            }\n\n            do {\n\n                ret = set_swi_errno(ts, read(arg0, s, len));\n\n            } while (ret == -1 && errno == EINTR);\n\n            unlock_user(s, arg1, len);\n\n            if (ret == (uint32_t)-1)\n\n                return -1;\n\n            return len - ret;\n\n        }\n\n    case TARGET_SYS_READC:\n\n       /* XXX: Read from debug console. Not implemented.  */\n\n        return 0;\n\n    case TARGET_SYS_ISTTY:\n\n        GET_ARG(0);\n\n        if (use_gdb_syscalls()) {\n\n            return arm_gdb_syscall(cpu, arm_semi_cb, \"isatty,%x\", arg0);\n\n        } else {\n\n            return isatty(arg0);\n\n        }\n\n    case TARGET_SYS_SEEK:\n\n        GET_ARG(0);\n\n        GET_ARG(1);\n\n        if (use_gdb_syscalls()) {\n\n            return arm_gdb_syscall(cpu, arm_semi_cb, \"lseek,%x,%x,0\",\n\n                                   arg0, arg1);\n\n        } else {\n\n            ret = set_swi_errno(ts, lseek(arg0, arg1, SEEK_SET));\n\n            if (ret == (uint32_t)-1)\n\n              return -1;\n\n            return 0;\n\n        }\n\n    case TARGET_SYS_FLEN:\n\n        GET_ARG(0);\n\n        if (use_gdb_syscalls()) {\n\n            return arm_gdb_syscall(cpu, arm_semi_flen_cb, \"fstat,%x,%x\",\n\n                                   arg0, arm_flen_buf(cpu));\n\n        } else {\n\n            struct stat buf;\n\n            ret = set_swi_errno(ts, fstat(arg0, &buf));\n\n            if (ret == (uint32_t)-1)\n\n                return -1;\n\n            return buf.st_size;\n\n        }\n\n    case TARGET_SYS_TMPNAM:\n\n        /* XXX: Not implemented.  */\n\n        return -1;\n\n    case TARGET_SYS_REMOVE:\n\n        GET_ARG(0);\n\n        GET_ARG(1);\n\n        if (use_gdb_syscalls()) {\n\n            ret = arm_gdb_syscall(cpu, arm_semi_cb, \"unlink,%s\",\n\n                                  arg0, (int)arg1+1);\n\n        } else {\n\n            s = lock_user_string(arg0);\n\n            if (!s) {\n\n                /* FIXME - should this error code be -TARGET_EFAULT ? */\n\n                return (uint32_t)-1;\n\n            }\n\n            ret =  set_swi_errno(ts, remove(s));\n\n            unlock_user(s, arg0, 0);\n\n        }\n\n        return ret;\n\n    case TARGET_SYS_RENAME:\n\n        GET_ARG(0);\n\n        GET_ARG(1);\n\n        GET_ARG(2);\n\n        GET_ARG(3);\n\n        if (use_gdb_syscalls()) {\n\n            return arm_gdb_syscall(cpu, arm_semi_cb, \"rename,%s,%s\",\n\n                                   arg0, (int)arg1+1, arg2, (int)arg3+1);\n\n        } else {\n\n            char *s2;\n\n            s = lock_user_string(arg0);\n\n            s2 = lock_user_string(arg2);\n\n            if (!s || !s2)\n\n                /* FIXME - should this error code be -TARGET_EFAULT ? */\n\n                ret = (uint32_t)-1;\n\n            else\n\n                ret = set_swi_errno(ts, rename(s, s2));\n\n            if (s2)\n\n                unlock_user(s2, arg2, 0);\n\n            if (s)\n\n                unlock_user(s, arg0, 0);\n\n            return ret;\n\n        }\n\n    case TARGET_SYS_CLOCK:\n\n        return clock() / (CLOCKS_PER_SEC / 100);\n\n    case TARGET_SYS_TIME:\n\n        return set_swi_errno(ts, time(NULL));\n\n    case TARGET_SYS_SYSTEM:\n\n        GET_ARG(0);\n\n        GET_ARG(1);\n\n        if (use_gdb_syscalls()) {\n\n            return arm_gdb_syscall(cpu, arm_semi_cb, \"system,%s\",\n\n                                   arg0, (int)arg1+1);\n\n        } else {\n\n            s = lock_user_string(arg0);\n\n            if (!s) {\n\n                /* FIXME - should this error code be -TARGET_EFAULT ? */\n\n                return (uint32_t)-1;\n\n            }\n\n            ret = set_swi_errno(ts, system(s));\n\n            unlock_user(s, arg0, 0);\n\n            return ret;\n\n        }\n\n    case TARGET_SYS_ERRNO:\n\n#ifdef CONFIG_USER_ONLY\n\n        return ts->swi_errno;\n\n#else\n\n        return syscall_err;\n\n#endif\n\n    case TARGET_SYS_GET_CMDLINE:\n\n        {\n\n            /* Build a command-line from the original argv.\n\n             *\n\n             * The inputs are:\n\n             *     * arg0, pointer to a buffer of at least the size\n\n             *               specified in arg1.\n\n             *     * arg1, size of the buffer pointed to by arg0 in\n\n             *               bytes.\n\n             *\n\n             * The outputs are:\n\n             *     * arg0, pointer to null-terminated string of the\n\n             *               command line.\n\n             *     * arg1, length of the string pointed to by arg0.\n\n             */\n\n\n\n            char *output_buffer;\n\n            size_t input_size;\n\n            size_t output_size;\n\n            int status = 0;\n\n#if !defined(CONFIG_USER_ONLY)\n\n            const char *cmdline;\n\n#endif\n\n            GET_ARG(0);\n\n            GET_ARG(1);\n\n            input_size = arg1;\n\n            /* Compute the size of the output string.  */\n\n#if !defined(CONFIG_USER_ONLY)\n\n            cmdline = semihosting_get_cmdline();\n\n            if (cmdline == NULL) {\n\n                cmdline = \"\"; /* Default to an empty line. */\n\n            }\n\n            output_size = strlen(cmdline) + 1; /* Count terminating 0. */\n\n#else\n\n            unsigned int i;\n\n\n\n            output_size = ts->info->arg_end - ts->info->arg_start;\n\n            if (!output_size) {\n\n                /* We special-case the \"empty command line\" case (argc==0).\n\n                   Just provide the terminating 0. */\n\n                output_size = 1;\n\n            }\n\n#endif\n\n\n\n            if (output_size > input_size) {\n\n                 /* Not enough space to store command-line arguments.  */\n\n                return -1;\n\n            }\n\n\n\n            /* Adjust the command-line length.  */\n\n            if (SET_ARG(1, output_size - 1)) {\n\n                /* Couldn't write back to argument block */\n\n                return -1;\n\n            }\n\n\n\n            /* Lock the buffer on the ARM side.  */\n\n            output_buffer = lock_user(VERIFY_WRITE, arg0, output_size, 0);\n\n            if (!output_buffer) {\n\n                return -1;\n\n            }\n\n\n\n            /* Copy the command-line arguments.  */\n\n#if !defined(CONFIG_USER_ONLY)\n\n            pstrcpy(output_buffer, output_size, cmdline);\n\n#else\n\n            if (output_size == 1) {\n\n                /* Empty command-line.  */\n\n                output_buffer[0] = '\\0';\n\n                goto out;\n\n            }\n\n\n\n            if (copy_from_user(output_buffer, ts->info->arg_start,\n\n                               output_size)) {\n\n                status = -1;\n\n                goto out;\n\n            }\n\n\n\n            /* Separate arguments by white spaces.  */\n\n            for (i = 0; i < output_size - 1; i++) {\n\n                if (output_buffer[i] == 0) {\n\n                    output_buffer[i] = ' ';\n\n                }\n\n            }\n\n        out:\n\n#endif\n\n            /* Unlock the buffer on the ARM side.  */\n\n            unlock_user(output_buffer, arg0, output_size);\n\n\n\n            return status;\n\n        }\n\n    case TARGET_SYS_HEAPINFO:\n\n        {\n\n            target_ulong retvals[4];\n\n            uint32_t limit;\n\n            int i;\n\n\n\n            GET_ARG(0);\n\n\n\n#ifdef CONFIG_USER_ONLY\n\n            /* Some C libraries assume the heap immediately follows .bss, so\n\n               allocate it using sbrk.  */\n\n            if (!ts->heap_limit) {\n\n                abi_ulong ret;\n\n\n\n                ts->heap_base = do_brk(0);\n\n                limit = ts->heap_base + ARM_ANGEL_HEAP_SIZE;\n\n                /* Try a big heap, and reduce the size if that fails.  */\n\n                for (;;) {\n\n                    ret = do_brk(limit);\n\n                    if (ret >= limit) {\n\n                        break;\n\n                    }\n\n                    limit = (ts->heap_base >> 1) + (limit >> 1);\n\n                }\n\n                ts->heap_limit = limit;\n\n            }\n\n\n\n            retvals[0] = ts->heap_base;\n\n            retvals[1] = ts->heap_limit;\n\n            retvals[2] = ts->stack_base;\n\n            retvals[3] = 0; /* Stack limit.  */\n\n#else\n\n            limit = ram_size;\n\n            /* TODO: Make this use the limit of the loaded application.  */\n\n            retvals[0] = limit / 2;\n\n            retvals[1] = limit;\n\n            retvals[2] = limit; /* Stack base */\n\n            retvals[3] = 0; /* Stack limit.  */\n\n#endif\n\n\n\n            for (i = 0; i < ARRAY_SIZE(retvals); i++) {\n\n                bool fail;\n\n\n\n                if (is_a64(env)) {\n\n                    fail = put_user_u64(retvals[i], arg0 + i * 8);\n\n                } else {\n\n                    fail = put_user_u32(retvals[i], arg0 + i * 4);\n\n                }\n\n\n\n                if (fail) {\n\n                    /* Couldn't write back to argument block */\n\n                    return -1;\n\n                }\n\n            }\n\n            return 0;\n\n        }\n\n    case TARGET_SYS_EXIT:\n\n        if (is_a64(env)) {\n\n            /* The A64 version of this call takes a parameter block,\n\n             * so the application-exit type can return a subcode which\n\n             * is the exit status code from the application.\n\n             */\n\n            GET_ARG(0);\n\n            GET_ARG(1);\n\n\n\n            if (arg0 == ADP_Stopped_ApplicationExit) {\n\n                ret = arg1;\n\n            } else {\n\n                ret = 1;\n\n            }\n\n        } else {\n\n            /* ARM specifies only Stopped_ApplicationExit as normal\n\n             * exit, everything else is considered an error */\n\n            ret = (args == ADP_Stopped_ApplicationExit) ? 0 : 1;\n\n        }\n\n        gdb_exit(env, ret);\n\n        exit(ret);\n\n    case TARGET_SYS_SYNCCACHE:\n\n        /* Clean the D-cache and invalidate the I-cache for the specified\n\n         * virtual address range. This is a nop for us since we don't\n\n         * implement caches. This is only present on A64.\n\n         */\n\n        if (is_a64(env)) {\n\n            return 0;\n\n        }\n\n        /* fall through -- invalid for A32/T32 */\n\n    default:\n\n        fprintf(stderr, \"qemu: Unsupported SemiHosting SWI 0x%02x\\n\", nr);\n\n        cpu_dump_state(cs, stderr, fprintf, 0);\n\n        abort();\n\n    }\n\n}\n", "idx": 7462, "substitutes": {"env": ["event", "esc", "sw", "conf", "scope", "self", "addr", "ec", "enter", "dev", "cb", "environment", "w", "js", "pg", "en", "req", "worker", "entry", "cur", "enc", "this", "wp", "neck", "er", "context", "server", "esp", "rb", "v", "config", "vs", "vis", "serv", "desc", "shell", "ev", "et", "end", "ctx", "msg", "timer", "viron", "hw", "pkg", "sv", "org", "nv", "cfg", "cv", "param", "eve", "oa", "init", "app", "window", "cp", "wcs", "here", "cmd", "inv", "vp", "ew", "eng", "err", "proc", "ptr", "vt", "obj", "e", "conn", "nw"], "cpu": ["ck", "lua", "CPU", "gc", "sp", "cum", "cp", "rpm", "pu", "pc", "ctx", "tp", "dylib", "cli", "sys", "ka", "clock", "sc", " CPU", "os", "p", "util", "mx", "nc", "aux", "hz", "process", "hw", "t", "nu", "ilo", "linux", "proc", "pkg", "device", "cn", "nic", "ruby", "apache", "alloc", "jp", "np", "aco", "core", "us", "gnu", "vm", "boot", "cu", "gpu", "conn", "tc"], "cs": ["ck", "cf", "rs", "gs", "CS", "ct", "cp", "ns", "wcs", "pc", "ctx", "acs", "cks", "sys", "sc", "aps", "ps", "ms", "nc", "ec", "ds", "cus", "css", "cc", "ins", "ls", "cn", "vs", "hs", "bs", "ss", "cons", "fs", "ys", "ks", "sts", "tc"], "args": ["rs", "gs", "names", "ars", "att", "ns", "ants", "items", "ags", "locks", "qs", "actions", "ms", "tn", "rows", "ds", "aux", "arms", "vals", "aus", "js", "err", "ins", "Args", "ims", "ras", "abis", "bits", "els", "fn", "vs", "uns", "limits", " arg", "ig", "parts", "fs", "arg", "flags", "ks", "pres", "j", "res", "arr", "params"], "arg0": ["block0", "tag5", "args3", "doc1", " arg000", "tag4", "argument3", "arg5", "member06", "args2", "ret000", "ret2", "args0", "ret0", "Arg000", "block1", "tag1", "arg4", "argument0", "block2", " arg5", "ret1", "Arg5", "args06", "member1", "agg1", "arg06", "Arg2", "Arg0", " arg4", "Arg1", "tag0", "argument1", "doc0", "args1", "arg000", " arg08", "doc4", "agg08", "Arg3", "member08", " arg06", "agg0", "arg08", "argument5", "member0", "doc5", "member2", "argument2"], "arg1": ["args3", "argument3", "args2", "prop0", "prop1", "args0", "argument0", "date1", "date0", "Arg2", "Arg0", "prop2", "Arg1", "argument1", "date3", "args1", "prop3", "argument2"], "arg2": ["tag02", "tag5", "args3", "doc2", "tag2", "arg02", "argument3", "arg5", "args2", "date2", "doc6", "args0", "argument0", "doc02", "date6", "date5", "argument1", "tag6", "args1", "arg6", "date02", "doc5", "argument2"], "arg3": [" arg03", "arg4", "Arg4", "Arg03", "tag2", "Arg2", "Arg3", "tag3", " arg4", "tag03", "tag4", "arg03"], "s": ["rs", "gs", "b", "ssl", "sg", "less", "tes", "ns", "its", "strings", "ats", "u", "h", "sam", "qs", "sys", "g", "p", "ms", "ps", "n", "is", "ds", "t", "r", "str", "js", "ins", "space", "sv", "ls", "gets", "sb", "scl", "v", "txt", "stats", "ims", "sl", "m", "spec", "hs", "ss", "bs", "sq", "f", "fs", "obj", "sql", "us", "S", "sts", "aws"], "nr": ["about", " ns", "nir", "sr", "kr", " nm", "gr", " ne", "gov", "radius", "ter", " ni", "nor", "aaa", "mr", " hr", "rn", "er", "n", "tn", "nc", "wr", "or", " nib", "cb", "usr", " nos", " sidx", "tr", "ner", "uj", "r", "err", "Ni", " NR", "number", "nick", "rr", " inval", "nm", "ng", "nos", "rar", "num", "nv", "ours", "nb", "byter", "sn", "ptr", "arity", "our", "np", "nz", " resid", "NR", " intr", "nah", "nar", "ctr", "adr", "nl", "ni", " yr", "hr", "nw"], "ret": ["gt", "success", "result", "gc", "mem", "it", "end", "ter", "nt", "ry", "ext", "mt", " Ret", "rets", "val", "url", "row", "tr", "data", "usr", "alt", "vals", "t", "err", "dr", "ref", "out", "try", "rt", "reset", "status", "lt", "re", "resp", "new", "lit", "RET", "jump", "pas", "Ret", "obj", "arg", "hash", "net", "j", "nl", "res", " RET", "arr", "ne", "def", "rm", "elt", "flag"], "len": ["bytes", "mem", "Len", "offset", "rel", "seq", "lib", "ran", "alt", "lan", "vec", "syn", "ref", "rev", "ls", "en", "fun", "fin", "size", "flags", "length", "ll", "nl", "trans", "l", "elt", "flag", "bin"], "ts": ["gt", "rs", "gs", "tes", "ns", "ics", "ats", "Ts", "os", "TS", "ps", "als", "ms", "mt", "tn", "uts", "ds", "t", "js", "ens", "ins", "ls", "tz", "stats", "rt", "hs", "vs", "bs", "ss", "vt", "fs", "ys", "us", "sts", "tc", "tp", "ops"]}}
{"project": "FFmpeg", "commit_id": "1f28a991effadc64acd6915805b989ab43500f08", "target": 0, "func": "static int decode_unregistered_user_data(H264SEIUnregistered *h, GetBitContext *gb,\n\n                                         void *logctx, int size)\n\n{\n\n    uint8_t *user_data;\n\n    int e, build, i;\n\n\n\n    if (size < 16 || size >= INT_MAX - 16)\n\n        return AVERROR_INVALIDDATA;\n\n\n\n    user_data = av_malloc(16 + size + 1);\n\n    if (!user_data)\n\n        return AVERROR(ENOMEM);\n\n\n\n    for (i = 0; i < size + 16; i++)\n\n        user_data[i] = get_bits(gb, 8);\n\n\n\n    user_data[i] = 0;\n\n    e = sscanf(user_data + 16, \"x264 - core %d\", &build);\n\n    if (e == 1 && build > 0)\n\n        h->x264_build = build;\n\n    if (e == 1 && build == 1 && !strncmp(user_data+16, \"x264 - core 0000\", 16))\n\n        h->x264_build = 67;\n\n\n\n    if (strlen(user_data + 16) > 0)\n\n        av_log(logctx, AV_LOG_DEBUG, \"user data:\\\"%s\\\"\\n\", user_data + 16);\n\n\n\n    av_free(user_data);\n\n    return 0;\n\n}\n", "idx": 7471, "substitutes": {"h": ["b", "c", "http", "comm", "self", "oh", "uh", "ht", "help", "bh", "p", "ec", "hz", "eh", "hw", "hi", "history", "r", "dh", "w", "th", "rh", "host", "v", "ah", "m", "hs", "he", "ih", "f", "hm", "hist", "hd", "hl", "hash", "uth", "H", "hh", "hr", "hp"], "gb": ["db", "gt", "yg", "gc", "gif", "gs", "gm", "pb", "bg", " GB", "eg", "gy", "tg", "g", "universal", "hub", "ge", "cb", "wb", "gow", "bb", "pg", "py", "sb", "rb", "bf", "vg", "mb", "cfg", "nb", "rg", "fb", "Gb", "img", "GB", "kb", "gg"], "logctx": ["launchcoord", "plotwork", "logcontext", "logjac", "Logcoord", "LOGcontext", " logcontext", "launchctx", "plotcontext", "logwork", "logcoord", "LOGwork", "plotjac", " logcc", " logwork", "Logcontext", "Logcc", " logjac", "LOGctx", "logcc", " logcoord", "plotctx", "LOGjac", "launchcc", "Logctx", "launchcontext"], "size": ["large", "bytes", "sw", "empty", "SIZE", "power", "fee", "c", "type", "shift", "Size", "offset", "ffff", "year", "g", "body", "n", "len", "use", "data", "ce", "range", "height", "scale", "number", "position", "space", "sized", "send", "s", "max", "num", "v", "code", "sh", "small", "scroll", "m", "ze", "now", "sn", "south", "capacity", "count", "cache", "message", "shape", "sum", "ize", "too", "length", "time", "z", "format", "x", "name"], "user_data": ["form1data", "user_Data", "User_val", "user_result", "userPData", "usermydata", "user_len", "userPlen", "User_DATA", "user1data", "user_dat", "open_Data", "user_ata", "User_index", "user_log", "form1Data", "userptDATA", "userptdat", "user_DATA", "userptlog", "user1dat", "user_more", "User_cache", "usa_result", "usermyData", "user_area", "user1buffer", "User_Data", " user_len", "userListindex", "usereddata", "user_da", "User_list", "userPdata", "usa_data", " user_DATA", "user1Data", "user_index", "User_data", "userptresult", " user_length", " user_more", "open_data", "usermylen", "usaptdata", "form1dat", "userListDATA", "useredarea", "user_length", "user_list", "usaptresult", "form_data", " user_list", "user_next", "form_Data", "User_buffer", " user_ata", "usermylength", "user_buffer", "form_buffer", "useredata", "userListcache", "open_next", "form1buffer", "form_dat", "open_ata", "usa_log", "User_da", "user_val", "userPlength", "userptdata", "user_cache", " user_Data", " user_dat", "usaptlog", "userListdata", " user_area"], "e": ["ev", "event", "et", "ei", "ate", "error", "eff", "it", "end", "eb", "est", "c", "eps", "EEE", "fe", "te", "er", "we", "d", "g", "eg", "ie", "ent", "ec", "ge", "ae", "ed", "ep", "eng", "element", "se", "t", "es", "r", "pe", "err", "ere", "me", "el", "en", "ef", "complete", "eu", "ze", "eval", "ee", "de", "eeee", "oe", "E", "ne", "l", "le"], "build": ["all", "success", "b", "ff", "building", "BU", "false", "type", "pack", "c", "boost", "d", "p", "g", "add", "util", "round", "good", "use", "lib", "link", "n", "dev", "no", "or", "uild", "se", "construct", "pe", "th", "Build", "ship", "bf", "v", "be", "sl", "dd", "load", "ac", "built", "make", "count", "f", "fail", "test", "builder", "length", "ld", "j", "create", "l"], "i": ["ic", "ini", "ij", "chain", "q", "ci", "b", "it", "im", "c", "u", "oi", "gi", "mi", "qi", "ip", "li", "p", "si", "zi", "is", "ind", "index", "o", "t", "pi", "multi", "bi", "r", "id", "ui", "ji", "phi", "ti", "s", "v", "ims", "ix", "ai", "m", "port", "PI", "I", "batch", "y", "io", "sim", "iu", "in", "point", "j", "x", "di", "ni", "ii", "l"]}}
{"project": "FFmpeg", "commit_id": "ae21776207e8a2bbe268e7c9e203f7599dd87ddb", "target": 0, "func": "void avfilter_filter_samples(AVFilterLink *link, AVFilterBufferRef *samplesref)\n\n{\n\n    void (*filter_samples)(AVFilterLink *, AVFilterBufferRef *);\n\n    AVFilterPad *dst = link->dstpad;\n\n    int i;\n\n\n\n    FF_DPRINTF_START(NULL, filter_samples); ff_dlog_link(NULL, link, 1);\n\n\n\n    if (!(filter_samples = dst->filter_samples))\n\n        filter_samples = avfilter_default_filter_samples;\n\n\n\n    /* prepare to copy the samples if the buffer has insufficient permissions */\n\n    if ((dst->min_perms & samplesref->perms) != dst->min_perms ||\n\n        dst->rej_perms & samplesref->perms) {\n\n\n\n        av_log(link->dst, AV_LOG_DEBUG,\n\n               \"Copying audio data in avfilter (have perms %x, need %x, reject %x)\\n\",\n\n               samplesref->perms, link->dstpad->min_perms, link->dstpad->rej_perms);\n\n\n\n        link->cur_buf = avfilter_default_get_audio_buffer(link, dst->min_perms,\n\n                                                          samplesref->audio->nb_samples);\n\n        link->cur_buf->pts                = samplesref->pts;\n\n        link->cur_buf->audio->sample_rate = samplesref->audio->sample_rate;\n\n\n\n        /* Copy actual data into new samples buffer */\n\n        for (i = 0; samplesref->data[i]; i++)\n\n            memcpy(link->cur_buf->data[i], samplesref->data[i], samplesref->linesize[0]);\n\n\n\n        avfilter_unref_buffer(samplesref);\n\n    } else\n\n        link->cur_buf = samplesref;\n\n\n\n    filter_samples(link, link->cur_buf);\n\n}\n", "idx": 7472, "substitutes": {"link": ["share", "open", "chain", "ln", "way", "rel", "self", "d", "flow", "light", "dev", "network", "url", "lo", "connect", "let", "query", "tag", "device", "entry", "parent", "loop", "test", "le", "loc", "source", "flag", "path", "download", "task", "page", "lib", "go", "command", "frame", "port", "load", "mit", "stream", "scan", "local", "Link", "info", "pp", "check", "relation", "l", "db", "ssl", "type", "ink", "skip", "play", "map", "li", "ml", "label", "line", "mail", "route", "style", "dd", "flex", "disk", "ld", "library", "all", "thread", "sp", "match", "call", "lay", "linked", "pack", "set", "mark", "dl", "lc", "slave", "me", "id", "list", "drive", "handle", "block", "e", "ment", "lock", "tool", "def"], "samplesref": ["sordsref", " samplesreference", "sizesrel", " samplesRef", "spleskb", "Samplesreference", "sonesob", "sentsrel", "sampsef", " sampsref", "sordsrel", "splesREF", "sentsif", "splesRef", "Samplesrev", " sampsreference", "sonentsrev", " samplesrange", "sordsreference", "Sampsval", "sonentseb", "sonesrange", "sonentsref", "sonesref", "samplesif", "sourcesef", "samplesval", " sampskb", "Sampsrange", " sampslf", "sonentsRef", " samplesrel", "sourcesbr", "sizesRef", "sentsref", "sampsreference", "sourcesreference", "sonesrel", "sonentsbr", " sampsbr", "sonentskb", "sampsrev", "Samplesval", " sampsrel", "Samplesold", "samplesrev", " sampsRef", "sampsval", "simsreference", "sentslf", "sourcesRef", "simsold", "sourcesrel", "sentseb", "splesval", "SampsREF", "Sampsrel", "Sampleseb", "sampsrange", "samplesREF", "Samplesrel", "sampsob", "sonesreference", "sampsbr", "sourcesob", "splesef", "Sampsreference", "sampsold", "sampleslf", " samplesbr", "samplesef", "samplesRef", "Samplesef", " sampleskb", "sonentsreference", "Sampsif", " sampsob", "sampslf", "simsref", "sordsrange", "sizesref", "sampleseb", "samplesbr", "Sampsref", "sampsrel", "sampskb", "sizesif", " sampleslf", "samplesreference", "sentsreference", "SampsRef", "sonesval", "sampsif", "sonesREF", "sordslf", "Sampsrev", "sordsRef", " samplesob", "samplesrange", "sordsrev", "sourcesold", " sampsrange", "sentsob", "sampsref", "samplesold", "SamplesRef", "sonentsrel", "SamplesREF", "sampseb", "Sampseb", "sampleskb", "splesreference", "sourcesref", "samplesrel", "Samplesref", "sentsRef", "sentsrange", "Samplesif", "sampsRef", "simsRef", "Samplesrange", "sonentsrange", "Sampsold", "Sampsef", "sizesob", "samplesob", "splesref", "sampsREF"], "filter_samples": ["filter_examps", "filter_commamples", "filter_packs", "filter_Sources", "filter_unsources", "filter_unsamps", "filter_tvals", "filter___nources", "filter_mamples", "filter_commample", "filter_sets", "filter_svals", "filter_vamps", "filter_vamp", "filter_Samples", "filter_pamples", "filter_gizes", "filter_mizes", "filter_Sample", "filter_examples", "filter_nources", "filter_damps", "filter_unsets", "filter_spamps", "filter_gamps", "filter_vizes", "filter_tents", "filter_exents", "filter_samps", "filter_exources", "filter_Samps", "filter_sents", "filter_spamples", "filter_mamps", "filter_vamples", "filter___samples", "filter___sources", "filter_nets", "filter_commources", "filter_damples", "filter_tamples", "filter_spvals", "filter___namples", "filter_Sacks", "filter_dents", "filter_gvals", "filter_unsamples", "filter___sample", "filter_gamples", "filter_tizes", "filter_sources", "filter_sample", "filter_pamps", "filter_exacks", "filter___samps", "filter_samp", "filter_sizes", "filter_nample", "filter_namples", "filter_spizes", "filter_sacks", "filter_tets", "filter_tamps", "filter_commamps", "filter_mamp", "filter_tamp", "filter_tources", "filter_pources", "filter_namps", "filter___namps", "filter___nample"], "dst": ["dsut", " detc", " dut", "dsp", "adost", "fest", "sst", "dldest", "sddest", "sdut", "dletc", " dlt", "idistant", "dsost", "sest", "idost", "lot", "Dsp", "sdlt", "sost", " distant", " dtd", "idest", "ddest", "sdst", "dot", "adst", "dsst", "fsp", "sdest", "fst", "lsp", "fdest", "letc", " dsp", "dut", "addest", "Dest", "dsot", "dost", "lst", "dlt", " dot", " dest", "detc", "dsistant", "dlst", "adtd", "ldest", "Ddest", "dsest", "Dst", "sdsp", "lest", "lut", "Dost", "dest", "lost", "adut", "adlt", "dtd", " dost", "dlsp", "idst", " ddest", "ltd", "distant"], "i": ["chain", " multi", " ii", "gi", "zi", "ind", " ti", "key", "pi", " pi", " j", "I", "batch", "in", "j", "x", "\u0438", "di", " l", "ic", " m", " ni", "mi", "g", " si", "xi", "index", "bi", "ki", "span", "ti", "ai", "m", " info", "us", " p", "info", " li", "ci", "it", " v", "ip", "li", "p", "o", " e", "mac", " I", "s", " iter", "y", " index", " k", "ii", "init", "ij", " bi", " di", "cli", " x", "si", " pos", "multi", "me", "ui", "slice", "ji", "list", "phi", "ims", "ix", " mi", "sim", " c", "iu", " count", " port"]}}
{"project": "qemu", "commit_id": "d85937e683f6ff4d68293cb24c780fb1f6820d2c", "target": 0, "func": "static qemu_irq *ppce500_init_mpic(PPCE500Params *params, MemoryRegion *ccsr,\n\n                                   qemu_irq **irqs)\n\n{\n\n    qemu_irq *mpic;\n\n    DeviceState *dev;\n\n    SysBusDevice *s;\n\n    int i, j, k;\n\n\n\n    mpic = g_new(qemu_irq, 256);\n\n    dev = qdev_create(NULL, \"openpic\");\n\n    qdev_prop_set_uint32(dev, \"nb_cpus\", smp_cpus);\n\n    qdev_prop_set_uint32(dev, \"model\", params->mpic_version);\n\n    qdev_init_nofail(dev);\n\n    s = SYS_BUS_DEVICE(dev);\n\n\n\n    k = 0;\n\n    for (i = 0; i < smp_cpus; i++) {\n\n        for (j = 0; j < OPENPIC_OUTPUT_NB; j++) {\n\n            sysbus_connect_irq(s, k++, irqs[i][j]);\n\n        }\n\n    }\n\n\n\n    for (i = 0; i < 256; i++) {\n\n        mpic[i] = qdev_get_gpio_in(dev, i);\n\n    }\n\n\n\n    memory_region_add_subregion(ccsr, MPC8544_MPIC_REGS_OFFSET,\n\n                                s->mmio[0].memory);\n\n\n\n    return mpic;\n\n}\n", "idx": 7480, "substitutes": {"params": ["members", "as", "par", "gs", "results", "points", "conf", "ctx", "eters", "phy", "cms", "terms", "AMS", "caps", "ps", "p", "pins", "details", "settings", "pi", "types", "services", "properties", "sym", "args", "tags", "ams", "config", "spec", "m", "phis", "mm", "parts", "posts", "param", "changes", "json", "ops"], "ccsr": ["ckSR", " actr", "cfsr", "scsr", "cfSR", " acsur", "cksr", "mcsr", "iscsur", "cctr", "ccSR", " acspr", "iscrs", "ccspr", "cksur", "mcsur", "iscsr", "ccsur", "iscSR", " acsr", "scsur", "mctr", "ckrs", "mcspr", "ccrs", "scspr", "cfrs", "cfsur", "sctr"], "irqs": ["irtqu", "irgs", "pirqs", " irq", " irgs", "pirqu", "irq", "irtdds", " irws", "irtq", "irws", "ierdds", "irtqs", "pireries", "irteries", "ireries", "pirq", "ierws", "irdds", "iergs", " ireries", "ierqs", "irtws", "irqu", "irtgs", " irdds", " irqu"], "mpic": ["peIC", "mpric", "marpic", "miac", "piac", "ppics", "pik", "MPics", "mpiac", "opIC", "mpico", "ompIC", "marik", "maric", " mpik", "peico", "mirc", "ompic", "opic", "mpIC", "mic", "marric", "opicon", "pirc", "MPico", "mpicon", " mpiac", " mpirc", "mpirc", "ompicon", "ppIC", "mac", "ppic", "MPicon", "pric", "peic", "mpics", "pic", "MPIC", "mppic", "ppico", " mpac", "mpik", "pac", "opik", "mpac", "MPic", "peics", "MPik", " mpric", " mppic", "ompik"], "dev": ["db", "ev", "form", "des", "mem", "devices", "window", "md", "h", "av", "cam", "pad", "DEV", "sys", "dem", "pro", "det", "ve", "raw", "d", "g", "p", "cmd", "n", "sd", "var", "ds", "priv", "eng", "tr", "data", "hw", "w", "go", "adv", "js", "debug", "device", "out", "ow", "v", "DE", "vo", "dist", "desc", "Device", "dd", "gpu", "new", "off", "doc", "sky", "disk", "rent", "serial", "obj", "test", "de", "gu", "info", "development", "dis", "res", "ver", "Dev", "def", "develop"], "s": ["rs", "sp", "gs", "ssl", "sw", "sg", "b", "ns", "c", "h", "sys", "cs", "os", "ps", "g", "p", "d", "n", "is", "sd", "ts", "ds", "es", "t", "js", "w", "sv", "sb", "v", "sym", "stats", "sl", "m", "hs", "ss", "bs", "serv", "local", "storage", "socket", "fs", "S", "sts", "a"], "i": ["this", "ic", "ini", "ij", "chain", "ei", "uri", "ci", " ii", "it", "im", "cli", "oi", "gi", "mi", "qi", "at", "ip", "er", "li", "ami", "si", "p", "ie", "zi", "n", "is", "iq", "xi", "ind", "index", "o", "ri", "hi", "bi", "pi", "multi", "me", "id", "ui", "ji", "ki", "phi", "ti", "v", "ims", "iy", "ix", "ai", "m", "status", "I", "remote", "y", "us", "iu", "point", "in", "by", "e", "di", "\u0438", "x", "ii"], "j": ["dj", "ja", "ev", "ij", "q", "b", "bj", "jo", "it", "att", "jj", "c", "u", "job", "J", "br", "kh", "note", "kid", "pt", "aj", "msg", "g", "p", "si", "n", "uj", "o", "jc", "js", "str", "el", "ji", "pr", "ng", "oj", "try", "v", "jac", "m", "adj", "bs", "y", "jump", "jp", "jit", "je", "obj", "jl", "e", "by", "kj", "z", "fr", "json", "ii", "l"], "k": ["ck", "q", "uk", "km", "conf", "c", "kr", "kh", "kk", "ku", "kid", "kind", "ka", "K", "ik", "ek", "ok", "mk", "g", "p", "n", "ke", "o", "kl", "key", "wk", "ki", "unk", "kw", "kn", "v", "sk", "m", "dk", "ko", "ks", "kj", "z", "isk"]}}
{"project": "qemu", "commit_id": "33577b47c64435fcc2a1bc01c7e82534256f1fc3", "target": 0, "func": "CharDriverState *qemu_chr_new(const char *label, const char *filename, void (*init)(struct CharDriverState *s))\n\n{\n\n    const char *p;\n\n    CharDriverState *chr;\n\n    QemuOpts *opts;\n\n    Error *err = NULL;\n\n\n\n    if (strstart(filename, \"chardev:\", &p)) {\n\n        return qemu_chr_find(p);\n\n    }\n\n\n\n    opts = qemu_chr_parse_compat(label, filename);\n\n    if (!opts)\n\n        return NULL;\n\n\n\n    chr = qemu_chr_new_from_opts(opts, init, &err);\n\n    if (err) {\n\n        error_report_err(err);\n\n    }\n\n    if (chr && qemu_opt_get_bool(opts, \"mux\", 0)) {\n\n        qemu_chr_fe_claim_no_fail(chr);\n\n        monitor_init(chr, MONITOR_USE_READLINE);\n\n    }\n\n    return chr;\n\n}\n", "idx": 7481, "substitutes": {"label": ["loc", "layout", "node", "prefix", "target", "type", "abl", "color", "rel", "description", "msg", "bind", "link", "location", "name", "LAB", "data", "key", "hide", "value", "el", "tag", "id", "Label", "module", "lab", "handle", "leaf", "els", "cell", "lit", "local", "alias", "desc", "bl", "abel", "info", "format", "title", "l", "path"], "filename": ["output", "uri", "prefix", "src", "metadata", "asm", "pen", "description", "file", "files", "rn", "til", "cmd", "location", "vp", "data", "fp", "kl", "username", "input", "str", "fil", "nil", "png", "nm", "attr", "s", "txt", "v", "rl", "fn", "Filename", "driver", "f", "fs", "family", "l", "subject", "source", "text", "json", "tp", "title", "name", "path"], "init": ["update", "initialized", "ic", "call", "it", "c", "late", "up", "i", "set", "buf", " fn", "ok", "msg", "base", "cmd", "bind", "seed", "n", "cb", "fp", "js", "initial", "id", "start", "iter", "reset", "Init", "new", "load", "alloc", "iat", "info", "gen", "create", "conn", "act", "bin"], "p": ["pid", "par", "q", "sp", "wp", "cp", "pb", "c", "pc", "rep", "i", "pt", "ip", "progress", "ps", "pa", "d", "bp", "n", "g", "vp", "pat", "perm", "fp", "t", "r", "pos", "pre", "pkg", "ap", "pr", "lp", "s", "v", "m", "part", "pic", "jp", "np", "f", "P", "pp", "j", "tp", "l", "path"], "chr": [" chor", "chra", "echro", "Chr", "electrc", "chro", "Chdr", " chtr", " chra", "electrt", "Chrt", "chsr", "chrc", "schsr", "chor", "echsr", "ichrc", "chedr", "electr", "cheror", " chro", "qtr", "echr", "ichr", "chedar", "hrs", "chnrt", "Char", "ichro", "hrc", " chdr", "ichsr", "chera", "cht", "qr", "chedtr", "hrt", "chrt", "chero", "chebr", "chet", "schr", " chbr", "echtr", "Chrc", "electrs", "chnar", "chtr", "cherro", " chrt", "chndr", "cherr", "qbr", "chetr", "Chrs", "chnr", "chedro", "schar", "cherra", "cher", "chdr", "cheor", "chrs", "schrc", "chbr", "qt", "ichtr", " cht", "ichar", "hr", "echrc", "echar"], "opts": ["optrs", "iopps", " ops", " opters", "opttions", "optts", "optters", "iopts", "otts", "opks", "optents", "opte", "OPtions", "opsts", "operrs", "optsts", " opsts", "ports", " opks", "ottions", "OPrs", "otents", " options", "opents", "OPs", "options", " opps", "optars", "oprs", "OPks", "opertions", "optpt", "optps", "otte", " opte", "oppt", "iopte", "porsts", " oppt", "OPts", " oprs", " opents", "porpt", "opers", "optks", " opars", "opps", "opters", "opars", "porters", "optte", "iopars", "ops", "operts"], "err": ["ev", "eor", "error", "ns", "Er", "conf", "fee", "kr", "eps", "gr", "eas", "sys", "buf", "aaa", "mr", "msg", "er", "die", "rn", "erd", "norm", "riot", "timer", "notice", "or", "cb", "usr", "erb", "errors", "r", "js", "rr", "attr", "pr", "out", "iter", "cr", "txt", "cfg", "resp", "ch", "gz", "cer", "obj", "test", "e", "oe", "fr", "arr", "res", "warn", "elt"]}}
{"project": "qemu", "commit_id": "7873df408dd44eb92840b108211d5aa5db7db526", "target": 0, "func": "static int net_init_tap_one(const NetdevTapOptions *tap, NetClientState *peer,\n\n                            const char *model, const char *name,\n\n                            const char *ifname, const char *script,\n\n                            const char *downscript, const char *vhostfdname,\n\n                            int vnet_hdr, int fd)\n\n{\n\n    TAPState *s;\n\n\n\n    s = net_tap_fd_init(peer, model, name, fd, vnet_hdr);\n\n    if (!s) {\n\n        close(fd);\n\n        return -1;\n\n    }\n\n\n\n    if (tap_set_sndbuf(s->fd, tap) < 0) {\n\n        return -1;\n\n    }\n\n\n\n    if (tap->has_fd || tap->has_fds) {\n\n        snprintf(s->nc.info_str, sizeof(s->nc.info_str), \"fd=%d\", fd);\n\n    } else if (tap->has_helper) {\n\n        snprintf(s->nc.info_str, sizeof(s->nc.info_str), \"helper=%s\",\n\n                 tap->helper);\n\n    } else {\n\n        snprintf(s->nc.info_str, sizeof(s->nc.info_str),\n\n                 \"ifname=%s,script=%s,downscript=%s\", ifname, script,\n\n                 downscript);\n\n\n\n        if (strcmp(downscript, \"no\") != 0) {\n\n            snprintf(s->down_script, sizeof(s->down_script), \"%s\", downscript);\n\n            snprintf(s->down_script_arg, sizeof(s->down_script_arg),\n\n                     \"%s\", ifname);\n\n        }\n\n    }\n\n\n\n    if (tap->has_vhost ? tap->vhost :\n\n        vhostfdname || (tap->has_vhostforce && tap->vhostforce)) {\n\n        int vhostfd;\n\n\n\n        if (tap->has_vhostfd) {\n\n            vhostfd = monitor_handle_fd_param(cur_mon, vhostfdname);\n\n            if (vhostfd == -1) {\n\n                return -1;\n\n            }\n\n        } else {\n\n            vhostfd = -1;\n\n        }\n\n\n\n        s->vhost_net = vhost_net_init(&s->nc, vhostfd,\n\n                                      tap->has_vhostforce && tap->vhostforce);\n\n        if (!s->vhost_net) {\n\n            error_report(\"vhost-net requested but could not be initialized\");\n\n            return -1;\n\n        }\n\n    } else if (tap->has_vhostfd || tap->has_vhostfds) {\n\n        error_report(\"vhostfd= is not valid without vhost\");\n\n        return -1;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 7490, "substitutes": {"tap": ["ctl", "att", "pan", "wat", "tar", "wan", "tim", "php", "peak", "t", "comb", "opa", "trace", "tag", " tapped", "pai", "transform", "hap", "apache", "tmp", "tun", "cat", "socket", "apt", "flag", "raf", "buff", "wp", "ta", "typ", "op", "tif", "ap", "tu", "config", "parse", "dp", "td", "tk", "db", "submit", "tp", "phy", "ip", "map", "p", "tg", "pa", "trap", "Tap", "tr", "pot", "ga", "snap", "sp", "eat", "pb", "ping", "lat", "rep", "kat", "cmd", "tm", "vp", "wt", "tw", "each", "tip", "cap", "tf", "lag", "amp", "pin", "format", "TP", "conn", "capt", "tc"], "peer": ["vr", "pid", "sp", "ssl", "instance", "node", "channel", "target", "pc", "ger", "ctx", "pro", "ter", "client", "self", "buffer", "er", "p", "ker", "connection", "nc", "network", "context", "server", "pe", "el", "proc", "camera", "port", "owner", "ptr", "parent", "pool", "socket", "handler", "eth", "net", "tp", "conn"], "model": ["policy", "channel", "type", "file", "base", "domain", "link", "dev", "network", "label", "server", "pe", "models", "el", "entity", "module", "dm", "sm", "device", "style", "mode", "layer", "man", "port", "command", "m", "config", "brand", "controller", "action", "version", "owner", "member", "address", "mod", "serial", "size", "Model", "ver", "image"], "name": ["filename", "channel", "named", "type", "file", "nam", "ename", "ame", "n", "no", "dev", "data", "key", "el", "id", "nm", "normal", "host", "cap", "NAME", "part", "action", "version", "local", "alias", "address", "mod", "size", "info", "family", "net", "format", "names", "title", "Name", "path"], "ifname": ["IfName", "ifame", "tifName", "tifno", "poolnames", "tifn", "ifnames", "tifid", "poolno", " ifno", "poolid", "ifn", "ifno", "Ifname", "tifnames", " ifid", "Ifame", "ifid", "IFName", " ifn", "poolname", "IFname", " ifnames", "tifname", "tifame", " ifName", "ifName", " ifame", "IFn"], "script": ["region", "type", "set", "sc", "description", "file", "buffer", "template", "profile", "cmd", "program", "dev", "sd", "lib", "option", "js", "tag", "id", "pipe", "attr", "control", "style", "timeout", "png", "password", "sh", "fun", "command", "driver", "comment", "action", "exec", "address", "test", "sql", "size", "info", "td", "tc", "shell", "scripts", "source", "cript"], "downscript": [" downscripts", "DOWNscripts", "upscripts", "Downscripts", "upscript", "subscript", "subfunction", "downscripts", " downScript", " downtemplate", "Downstyle", "upScript", "DOWNstyle", " downcommand", "downtemplate", "DOWNScript", "Downfunction", "upfunction", "dropscript", "upcommand", "DOWNscript", "Downcommand", "Downscript", "subcommand", "upstyle", "downstyle", "droptemplate", "DOWNcommand", "dropScript", "subscripts", "uptemplate", "downfunction", " downstyle", "dropstyle", "downScript", "downcommand"], "vhostfdname": ["vhostdirName", "vHostFDlen", "vhostfcname", "vbindFDnum", "vbindFDName", "vhostfcno", "vhostfpName", "vhostfName", "vhostfppath", "vhostFDlen", "vhostFDno", "vHostFDName", "vhostfnum", "vhostfpno", "vHostfdlen", "vhostdirlen", "vhostFDnum", "vHostfdName", "vhostfname", "vhostfno", "vhostFDName", "vhostfdName", "vhostfpname", "vbindFDno", "vhostfdnum", "vhostfcnum", "vHostfdname", "vbindfdno", "vhostFDname", "vhostfdlen", "vbindfdname", "vhostfilename", "vhostfileName", "vhostfcpath", "vbindFDname", "vhostdirname", "vhostFDpath", "vhostfcName", "vHostFDname", "vhostfdno", "vbindfdnum", "vbindfdName", "vhostfdpath", "vhostfilelen"], "vnet_hdr": ["vnet_phdr", "vnet_phint", "vnet_hhld", "vnet_hhDR", "vnet_wpar", "vnet_thr", "vnet_phrd", "vnet_hrd", "vnet_phr", "vnet_hhdr", "vnet_wld", "vnet_wDR", "vnet_hld", "vnet_thint", "vnet_thrd", "vnet_thdr", "vnet_wdr", "vnet_hhpar", "vnet_hr", "vnet_hpar", "vnet_hDR", "vnet_hint"], "fd": ["db", "cf", "pid", "ff", "fm", "dat", "ctl", "window", "buf", "ffff", "file", "buffer", "fc", "d", "dt", "addr", "dl", "connection", "bd", "sd", "gd", "ds", "fl", "cb", "data", "fp", " fid", "pipe", "ud", "bf", "handle", "fed", "fin", "dd", "df", "stream", "fn", "dir", "port", "writer", "fb", "ptr", "socket", "handler", "f", "FD", "fi", "fs", "rd", "io", "pd", "size", "td", "hd", "ld", "conn"], "s": ["styles", "des", "sw", "less", "sol", "c", "ps", "ports", "ts", "t", "js", "gets", "sb", "services", "ss", "south", "socket", "changes", "j", "series", "sports", "as", "rs", "service", "csv", "ses", "sam", "store", "https", "os", "g", "ms", "tests", "es", "stats", "tags", "m", "vs", "aws", "gs", "ssl", "sg", "ns", "ats", "ies", "comm", "p", "is", "sv", "sm", "hs", "bs", "y", "sq", "fs", "sql", "S", "sp", "b", "sys", "qs", "set", "als", "details", "n", "ds", "sync", "ins", "ls", "ties", "sym", "sl", "spec", "sn", "states", "sts", "tools"], "vhostfd": ["vehostpid", "vbindfi", "vestarfp", "valuehostFD", " vhostFD", "vestarfin", "vhostpid", "svhostfin", "svheadfin", "vlocalhostfin", "vHostFD", "vportpd", "vcertfd", "vheadfs", "evhostfl", "vostfp", "evhostflo", "vserverfd", "vstarfd", " vHostfi", "vehostfp", "vehostfin", "evostfd", "valuehostfd", "vHostfi", "evostfl", "evostfp", "valuelocalhostfin", "evhostfp", "valuelocalhostpd", "vhostpd", "vportfd", "valuehostpd", "valuelocalhostFD", " vhostfi", "vestarpid", "svheadfd", "vtargetfin", "vbarflo", "evhostfd", " vhostfc", "vportfin", "vheadfd", "vhostfi", "svheadd", "vserverfin", "vbarfp", "vbindfc", "vbindfin", "vcertfs", "vcertd", "vostfd", "vheadd", "vhostfin", "vostfl", "vhostfl", "vtargetfd", "vstorefp", "vhostFD", "vlocalhostfd", "vportfi", "vlocalhostpid", "vlocalhostfp", "vhostfs", "vlocalhostpd", "valuehostfin", "vserverfp", "vlocalhostFD", "vcertfin", "vhostfp", "vehostfd", "vportFD", "vtargetd", "vstoreflo", "valuelocalhostfd", "vbindpd", "vportfc", " vHostfc", "vstarpid", "vbindFD", "vstarfp", "vhostd", "evostflo", "vbarfd", "vhostfc", "vhostflo", " vHostfd", " vHostFD", "vserverpid", "vstorefd", "svhostfd", "vbarfl", "vostflo", "vHostfd", "vstarfin", "vHostfc", "svhostd", "vbindfd", "svheadfs", "vtargetfs", "vstorefl", "vestarfd", "vheadfin", "svhostfs"]}}
{"project": "qemu", "commit_id": "3dc6f8693694a649a9c83f1e2746565b47683923", "target": 0, "func": "int qdev_prop_check_globals(void)\n\n{\n\n    GList *l;\n\n    int ret = 0;\n\n\n\n    for (l = global_props; l; l = l->next) {\n\n        GlobalProperty *prop = l->data;\n\n        ObjectClass *oc;\n\n        DeviceClass *dc;\n\n        if (prop->used) {\n\n            continue;\n\n        }\n\n        if (!prop->user_provided) {\n\n            continue;\n\n        }\n\n        oc = object_class_by_name(prop->driver);\n\n        oc = object_class_dynamic_cast(oc, TYPE_DEVICE);\n\n        if (!oc) {\n\n            error_report(\"Warning: global %s.%s has invalid class name\",\n\n                       prop->driver, prop->property);\n\n            ret = 1;\n\n            continue;\n\n        }\n\n        dc = DEVICE_CLASS(oc);\n\n        if (!dc->hotpluggable && !prop->used) {\n\n            error_report(\"Warning: global %s.%s=%s not used\",\n\n                       prop->driver, prop->property, prop->value);\n\n            ret = 1;\n\n            continue;\n\n        }\n\n    }\n\n    return ret;\n\n}\n", "idx": 7491, "substitutes": {"l": ["all", "b", "lv", "ln", "ol", "c", "u", "lin", "i", "lf", "tl", "li", "g", "p", "dl", "ml", "fl", "pl", "lc", "kl", "t", "o", "lo", "lb", "lang", "el", "list", "ls", "lp", "v", "sl", "rl", "m", "lt", "al", "la", "ul", "lit", "local", "bl", "L", "jl", "hl", "ld", "ll", "nl", "z", "il", "acl", "j", "loc"], "prop": ["ph", "post", "feat", "att", "cp", "conf", "pb", "dep", "term", "rep", "pro", "rel", "pt", "buf", "prot", "msg", "ps", "p", "cmd", "pick", "prov", "typ", "pred", "op", "property", "perm", "key", "col", "str", "opp", "tag", "pos", "err", "proc", "pkg", "attr", "opt", "pr", "properties", "grab", "req", "cfg", "prev", "spec", "resp", "tab", "per", "tmp", "lit", "priv", "jp", "supp", "desc", "rop", "test", "arg", "pp", "comp", "decl", "j", "def", "loc", "Prop"], "oc": ["ico", "oco", "mot", "voc", "c", "pc", "ox", "bc", "orc", "ob", "ok", "ocal", "oci", "co", "OC", "ocation", "unc", "ec", "toc", "ocr", "or", "og", "orp", "osc", "o", "ock", "rc", "roc", "ocate", "arc", "soc", "nic", "org", "ot", "oid", "uc", "ac", "alloc", "isc", "mc", "aco", "obj", "erc", "oca", "oe", "oot", "ocated", "yo", "ro", "ost", "ocon", "loc", "oss"], "dc": ["db", "cf", "loc", "gc", "mn", "cp", "c", "pc", "cam", "bc", "cmp", "sc", "fc", "DC", "d", "dt", "cmd", "ec", "bd", "nc", "lc", "cc", "dr", "rc", "dm", "device", "dd", "df", "dq", "ac", "driver", "dk", "vc", "cd", "doc", "disc", "cca", "mc", "dp", "de", "di", "cu", "tc"]}}
{"project": "qemu", "commit_id": "1ea879e5580f63414693655fcf0328559cdce138", "target": 0, "func": "static int qesd_init_out (HWVoiceOut *hw, audsettings_t *as)\n\n{\n\n    ESDVoiceOut *esd = (ESDVoiceOut *) hw;\n\n    audsettings_t obt_as = *as;\n\n    int esdfmt = ESD_STREAM | ESD_PLAY;\n\n    int err;\n\n    sigset_t set, old_set;\n\n\n\n    sigfillset (&set);\n\n\n\n    esdfmt |= (as->nchannels == 2) ? ESD_STEREO : ESD_MONO;\n\n    switch (as->fmt) {\n\n    case AUD_FMT_S8:\n\n    case AUD_FMT_U8:\n\n        esdfmt |= ESD_BITS8;\n\n        obt_as.fmt = AUD_FMT_U8;\n\n        break;\n\n\n\n    case AUD_FMT_S32:\n\n    case AUD_FMT_U32:\n\n        dolog (\"Will use 16 instead of 32 bit samples\\n\");\n\n\n\n    case AUD_FMT_S16:\n\n    case AUD_FMT_U16:\n\n    deffmt:\n\n        esdfmt |= ESD_BITS16;\n\n        obt_as.fmt = AUD_FMT_S16;\n\n        break;\n\n\n\n    default:\n\n        dolog (\"Internal logic error: Bad audio format %d\\n\", as->fmt);\n\n        goto deffmt;\n\n\n\n    }\n\n    obt_as.endianness = AUDIO_HOST_ENDIANNESS;\n\n\n\n    audio_pcm_init_info (&hw->info, &obt_as);\n\n\n\n    hw->samples = conf.samples;\n\n    esd->pcm_buf = audio_calloc (AUDIO_FUNC, hw->samples, 1 << hw->info.shift);\n\n    if (!esd->pcm_buf) {\n\n        dolog (\"Could not allocate buffer (%d bytes)\\n\",\n\n               hw->samples << hw->info.shift);\n\n        return -1;\n\n    }\n\n\n\n    esd->fd = -1;\n\n    err = pthread_sigmask (SIG_BLOCK, &set, &old_set);\n\n    if (err) {\n\n        qesd_logerr (err, \"pthread_sigmask failed\\n\");\n\n        goto fail1;\n\n    }\n\n\n\n    esd->fd = esd_play_stream (esdfmt, as->freq, conf.dac_host, NULL);\n\n    if (esd->fd < 0) {\n\n        qesd_logerr (errno, \"esd_play_stream failed\\n\");\n\n        goto fail2;\n\n    }\n\n\n\n    if (audio_pt_init (&esd->pt, qesd_thread_out, esd, AUDIO_CAP, AUDIO_FUNC)) {\n\n        goto fail3;\n\n    }\n\n\n\n    err = pthread_sigmask (SIG_SETMASK, &old_set, NULL);\n\n    if (err) {\n\n        qesd_logerr (err, \"pthread_sigmask(restore) failed\\n\");\n\n    }\n\n\n\n    return 0;\n\n\n\n fail3:\n\n    if (close (esd->fd)) {\n\n        qesd_logerr (errno, \"%s: close on esd socket(%d) failed\\n\",\n\n                     AUDIO_FUNC, esd->fd);\n\n    }\n\n    esd->fd = -1;\n\n\n\n fail2:\n\n    err = pthread_sigmask (SIG_SETMASK, &old_set, NULL);\n\n    if (err) {\n\n        qesd_logerr (err, \"pthread_sigmask(restore) failed\\n\");\n\n    }\n\n\n\n fail1:\n\n    qemu_free (esd->pcm_buf);\n\n    esd->pcm_buf = NULL;\n\n    return -1;\n\n}\n", "idx": 7498, "substitutes": {"hw": ["aw", "sw", "nw", "wp", "ether", "war", "rpm", "igh", "wy", "wcs", "ctx", "htt", "phy", "aws", "eas", "wx", "whe", "wan", "ht", "wind", "mx", "vp", "ew", "hub", "hz", "arp", "rew", "wn", "ww", "olf", "iw", "wk", "aus", "rw", "wu", "dh", "w", "rack", "him", "shake", "pkg", "each", "rh", "kw", "MW", "ow", "ipp", "sh", "hap", "hs", "wi", "usr", "ich", "wo", "hop", "home", "hm", "xp", "hd", "ha", "hl", "ews", "hh", "hog", "haw", "wd", " HW", "igm", "fw"], "as": ["rs", "aw", "asi", "ass", "asa", "ar", "ars", "asm", "acs", "aws", "ra", "ias", "os", "ms", "ak", "is", "ts", "has", "As", "ay", "jas", "aux", "aus", "ach", "asha", "ast", "an", "au", "s", "ras", "asy", "ams", "las", "sa", "asar", "ac", "aos", "bs", "asia", "nas", "am", "pas", "AS", "us", "ais", "ase", "a"], "esd": ["gesn", "esg", "sesd", "vesdo", "essds", "essdh", "easdc", "easda", "gesd", " esdh", " espid", " esdl", "esdo", "essn", "besdi", "gesl", "sespid", "vesd", "etsda", "besds", "esn", "essl", "sesdc", "sesda", "easd", "esda", "vesds", "besd", "bespid", " esdi", "epsd", "sesdi", "sesds", "bessd", " esdo", "besg", "sessd", "esdl", " esg", "gesdat", "esds", "sesg", "epsdl", "epssd", "esdh", "epsds", "esdat", "essdat", "esl", "cesl", " essd", "etsdc", "espid", "etssd", "esdi", "etsd", " esds", "esdc", "eassd", "essdo", "cesd", "sesdl", "cesn", "cesdat", "vesdh", "essd"], "err": ["ev", "eor", "error", "dy", "orer", "Er", "kr", "cli", "br", "cmp", "ox", "nr", "i", "buf", "sys", "eas", "ter", "mr", "msg", "exc", "rn", "er", "erd", "timer", "notice", "or", "cb", "usr", "ner", "ere", "r", "rss", "dr", "rc", "str", "rr", "attr", " ec", "rb", "iter", "cr", "txt", "yr", "try", "cfg", "resp", "ch", "gz", "priv", "bug", "cer", " Err", "test", "ex", " intr", "e", "fr", "Error", "res", "ver", "spr", "arr"], "set": ["read", "cast", "et", "sp", "gc", "sw", "dat", "end", "conf", "c", "ctx", "get", "store", "con", "sc", "valid", "g", "stat", "add", "sd", "Set", "sync", "sets", "col", "san", "sm", "sb", "start", "out", "en", "change", "sk", "reset", "status", "new", "m", "st", "ch", "ac", "clear", "config", "scan", "local", "iat", "test", "size", "gen", "ex", "check", "ver", "SET", "loc"], "old_set": ["old_SET", "old___add", "old_Set", "old2set", "old___block", " old_SET", "old___SET", " old_block", "old2SET", "old___Set", "old_block", "old_add", "old___set", "old2add", " old_add", " old_Set"]}}
{"project": "qemu", "commit_id": "03a63484a6978f68caff087bbaabcd1d383563af", "target": 1, "func": "static void monitor_find_completion(const char *cmdline)\n\n{\n\n    const char *cmdname;\n\n    char *args[MAX_ARGS];\n\n    int nb_args, i, len;\n\n    const char *ptype, *str;\n\n    const mon_cmd_t *cmd;\n\n    const KeyDef *key;\n\n\n\n    parse_cmdline(cmdline, &nb_args, args);\n\n#ifdef DEBUG_COMPLETION\n\n    for(i = 0; i < nb_args; i++) {\n\n        monitor_printf(cur_mon, \"arg%d = '%s'\\n\", i, (char *)args[i]);\n\n    }\n\n#endif\n\n\n\n    /* if the line ends with a space, it means we want to complete the\n\n       next arg */\n\n    len = strlen(cmdline);\n\n    if (len > 0 && qemu_isspace(cmdline[len - 1])) {\n\n        if (nb_args >= MAX_ARGS)\n\n            return;\n\n        args[nb_args++] = qemu_strdup(\"\");\n\n    }\n\n    if (nb_args <= 1) {\n\n        /* command completion */\n\n        if (nb_args == 0)\n\n            cmdname = \"\";\n\n        else\n\n            cmdname = args[0];\n\n        readline_set_completion_index(cur_mon->rs, strlen(cmdname));\n\n        for(cmd = mon_cmds; cmd->name != NULL; cmd++) {\n\n            cmd_completion(cmdname, cmd->name);\n\n        }\n\n    } else {\n\n        /* find the command */\n\n        for(cmd = mon_cmds; cmd->name != NULL; cmd++) {\n\n            if (compare_cmd(args[0], cmd->name))\n\n                goto found;\n\n        }\n\n        return;\n\n    found:\n\n        ptype = next_arg_type(cmd->args_type);\n\n        for(i = 0; i < nb_args - 2; i++) {\n\n            if (*ptype != '\\0') {\n\n                ptype = next_arg_type(ptype);\n\n                while (*ptype == '?')\n\n                    ptype = next_arg_type(ptype);\n\n            }\n\n        }\n\n        str = args[nb_args - 1];\n\n        if (*ptype == '-' && ptype[1] != '\\0') {\n\n            ptype += 2;\n\n        }\n\n        switch(*ptype) {\n\n        case 'F':\n\n            /* file completion */\n\n            readline_set_completion_index(cur_mon->rs, strlen(str));\n\n            file_completion(str);\n\n            break;\n\n        case 'B':\n\n            /* block device name completion */\n\n            readline_set_completion_index(cur_mon->rs, strlen(str));\n\n            bdrv_iterate(block_completion_it, (void *)str);\n\n            break;\n\n        case 's':\n\n            /* XXX: more generic ? */\n\n            if (!strcmp(cmd->name, \"info\")) {\n\n                readline_set_completion_index(cur_mon->rs, strlen(str));\n\n                for(cmd = info_cmds; cmd->name != NULL; cmd++) {\n\n                    cmd_completion(str, cmd->name);\n\n                }\n\n            } else if (!strcmp(cmd->name, \"sendkey\")) {\n\n                char *sep = strrchr(str, '-');\n\n                if (sep)\n\n                    str = sep + 1;\n\n                readline_set_completion_index(cur_mon->rs, strlen(str));\n\n                for(key = key_defs; key->name != NULL; key++) {\n\n                    cmd_completion(str, key->name);\n\n                }\n\n            } else if (!strcmp(cmd->name, \"help|?\")) {\n\n                readline_set_completion_index(cur_mon->rs, strlen(str));\n\n                for (cmd = mon_cmds; cmd->name != NULL; cmd++) {\n\n                    cmd_completion(str, cmd->name);\n\n                }\n\n            }\n\n            break;\n\n        default:\n\n            break;\n\n        }\n\n    }\n\n    for(i = 0; i < nb_args; i++)\n\n        qemu_free(args[i]);\n\n}\n", "idx": 7521, "substitutes": {"cmdline": ["commnet", "mdlines", " cmdlines", "cmdnet", "commandnet", "commandtype", "mdname", "Cmdname", "commandline", "commline", "CmdLine", "cmdLine", " cmdtype", "cmdlines", " cmdLine", "mdnet", "commandname", "mdline", "commandlines", "commandLine", "commLine", "Cmdline", "mdtype", "mdLine", "cmdtype"], "cmdname": ["ctrname", "commandnames", " cmdlen", " cmdnames", "cmdtitle", "commname", "Cmdnames", " cmdName", "cdNAME", "mdn", "msgName", " cmdn", "mdname", "Cmdname", "mdName", "msgname", "ctrno", "mddefault", "commandline", " cmdtitle", "commline", "cdname", "mdNAME", "commdefault", "cdn", "msgtitle", "cmdn", "ctrnames", "commandname", "Cmdlen", "cmdName", "mdnames", "mdlen", "mdline", "cmdno", "ctrline", "commandno", " cmddefault", "cmdlen", "msgline", "CmdName", " cmdNAME", "cmdnames", "cmdNAME", "commName", "cmddefault", "mdtitle", "mdno"], "args": ["rs", "gs", "names", "results", "points", "ars", "ns", "items", "orders", "strings", "uments", "md", "values", "ags", "aws", "qs", "cs", "terms", "files", "actions", "ps", "ms", "tests", "details", "words", "lines", "ts", "rows", "aux", "vals", "types", "js", "pos", "atts", "options", "xs", "Args", "s", "ras", "stats", "keys", "images", "bits", "ims", "ams", "array", "vs", "limits", "ig", "parts", "fs", "arg", "flags", "posts", "changes", "arr", "params"], "MAX_ARGS": ["MAX_PARG", "MAX_ARTS", "MAX_WARG", "MAX_REG", "MAX_PARGS", "MAX_PARMS", "MAX_ASG", "MAX_WARMS", "MAX_REGS", "MAX_REGV", "MAX_ASMS", "MAX_WARGS", "MAX_ASGS", "MAX_ARG", "MAX_ASYS", "MAX_RETS", "MAX_PARYS", "MAX_PARGV", "MAX_ASTS", "MAX_WARYS", "MAX_ARYS", "MAX_ARMS", "MAX_ARGV", "MAX_ASGV", "MAX_PARTS"], "nb_args": ["nv___args", "nb_amps", "nb_mails", "NB_params", "nb_gs", "nu_changes", "bn_bots", "nv_options", "nr_args", "nbjsamps", "nu_args", "NB_arg", "nv_cats", "bnPlimits", "nb____amps", "nb____args", "nb___args", "bnPargs", "nr_states", "nb__values", "nb_Args", "nb_aux", "nb_results", "bn_args", "nb__params", "nr_aux", "nbjsoptions", "nb___limits", "NB_parts", "nb__apps", "db_args", "nb___amps", "nb_cats", "NB_Args", "nb_options", "nb_apps", "nb__arg", "nb___results", "nb_limits", "nb__bytes", "nv_args", "nv___cats", "nv_amps", "nb_flags", "nb_parts", "nb_changes", "nb__mails", "bnPbots", "nu_flags", "NB_bytes", "bn_results", "nb_params", "nbjsargs", "nr_gs", "nbjscats", "nbPlimits", "db_values", "nb__bots", "nbPargs", "db_mails", "nbPresults", "nb__vals", "nb___cats", "nb__Args", "db_bots", "nv___options", "NB_args", "nu_params", "nb_states", "nb___flags", "nb_bots", "nb__args", "nb___apps", "nb_arg", "nb____cats", "NB_vals", "nb___bots", "nb___options", "bnPresults", "nb__flags", "nb____options", "NB_apps", "nb_bytes", "nb_values", "nv___amps", "nbPbots", "bn_limits", "nb_vals", "NB_flags", "nb___vals"], "i": ["init", "ic", "ini", "ij", "ei", "ci", "it", "im", "c", "u", "cli", "oi", "gi", "mi", "qi", "ip", "li", "p", "si", "g", "ie", "zi", "n", "ami", "is", "ind", "xi", "index", "ri", "hi", "pi", "bi", "multi", "me", "ui", "id", "ki", "ji", "list", "phi", "ti", "try", "iter", "v", "ims", "ix", "ai", "m", "I", "y", "f", "fi", "us", "sim", "io", "iu", "e", "in", "gu", "j", "iri", "info", "di", "\u0438", "x", "ii", "l"], "len": ["loc", "bytes", "ln", "lis", "Len", "cl", "cmp", "lf", "ail", "mid", "li", "lon", "dl", "ml", "n", "val", "del", "pl", "line", "kl", "lc", "full", "lan", "Length", "el", "lig", "pos", "list", "limit", "ls", "lp", "lim", "en", "sl", "fin", "fun", "lt", "lit", "L", "size", "length", "ld", "ll", "nl", "z", "il", "l", "elt", "vec"], "ptype": ["mintotype", " ptotype", "epttype", "ptrype", "monttype", "ototype", "ntotype", "apttype", " pttype", "ptiff", "ptask", " ptyp", "pointotype", "typpe", "otask", "cttype", "iptotype", "pttype", "vetotype", "ptyp", "ptrotype", "ctpe", "istyp", "pretip", "ctype", "ptpe", "otyp", "iptype", " ptask", "petype", "eptyp", "eptime", "aptyp", "isttype", "vettype", "typotype", "montpe", "mintype", "mintpe", "iptpe", "aptotype", "iptyp", "petpe", "montotype", "ptryp", "pointime", "ctip", "petyp", "istype", "pointtype", "eptotype", "petotype", "typype", "aptype", "pltype", "eptype", "pretype", "otiff", "aptiff", "vetype", "minttype", "typyp", "pretotype", "aptpe", "otype", " ptip", "vetyp", "ctyp", "montask", "montyp", "istotype", "plime", "ipttype", "ptip", "prettype", "ptriff", "ctotype", "plotype", "montype", "ptime", "ntype", "istpe", "nttype", "ntyp", "pointype", "plype", "ptotype", "eptpe"], "str": ["Str", "rs", "read", "sp", "b", "trans", "prefix", "ns", "br", "buf", "file", "buffer", "msg", "raw", "seq", "p", "vol", "mt", "n", "inst", "ocr", "tr", "data", "t", "r", "err", "dr", "pos", "list", "pr", "s", "out", "STR", "txt", "cr", "sec", "ch", "st", "part", "print", "f", "cur", "obj", "fr", "ctr", "arr", "text", "res", "name"], "cmd": ["ck", "c", "kt", "nd", "add", "cb", "dm", "that", "cr", "txt", "req", "qq", "ch", "om", "batch", "cat", "cur", "gt", "cy", "mem", "job", "clean", "nt", "mk", "good", "op", "go", "send", "start", "normal", "command", "load", "dir", "cd", "exec", "desc", "comp", "check", "ctr", "quick", "cf", "update", "ct", "md", "ctx", "phy", "find", "comm", "msg", "dict", "del", "std", "pkg", "try", "cfg", "dq", "quit", "cond", "Cmd", "news", "name", "rm", "init", "cod", "form", "call", "window", "cp", "cli", "cl", "cmp", "sys", "ok", "help", "raw", "ext", "bind", "col", "proc", "mode", "handle", "fun", "resp", "kick", "obj", "qt", "conn", "def"], "key": ["ck", "Key", "prefix", "type", "ctx", "KEY", "kind", "mk", " Key", "link", "ke", "val", "index", "data", "col", "value", "tag", "id", "attr", "k", "code", "token", "keys", "doc", "obj", "def"]}}
{"project": "qemu", "commit_id": "10a412dab3f54439ea3d60274eb41668f7d83bd2", "target": 0, "func": "static void sd_response_r1_make(SDState *sd,\n\n                                uint8_t *response, uint32_t last_status)\n\n{\n\n    uint32_t mask = CARD_STATUS_B ^ ILLEGAL_COMMAND;\n\n    uint32_t status;\n\n\n\n    status = (sd->card_status & ~mask) | (last_status & mask);\n\n    sd->card_status &= ~CARD_STATUS_C | APP_CMD;\n\n\n\n    response[0] = (status >> 24) & 0xff;\n\n    response[1] = (status >> 16) & 0xff;\n\n    response[2] = (status >> 8) & 0xff;\n\n    response[3] = (status >> 0) & 0xff;\n\n}\n", "idx": 7556, "substitutes": {"sd": ["draw", "service", "dds", "sg", "SD", "md", "sam", "sys", "store", "sc", "d", "si", "sy", "dl", "bd", "gd", "ds", "ind", "ard", "se", "sv", "sb", "style", "s", "od", "sec", "vd", "sk", "sh", "dd", "sa", "dk", "ss", "sn", "south", "cd", "storage", "sky", "pd", "sim", "hd", "dash", "td", "ld", "dis", "sta", "sing"], "response": ["output", "all", "result", "error", "tree", "next", "window", "channel", "reply", "view", "vector", "ve", "buffer", "template", "profile", "display", "connection", "Response", "network", "environment", "value", "position", "query", "question", "attribute", "list", "route", "application", "api", "onse", "reset", "frame", "array", "resp", "request", "answer", "block", "volume", "entry", "version", "respons", "cache", "message", "collection", "e", "point", "database", "res", "relation", "reference", "image", "object", "transfer", "sequence"], "last_status": [" last___msg", "last___msg", "last___Status", "last2status", "last_Status", " last_stat", "last2Status", "last_message", "last2msg", "last_msg", " last_msg", " last___status", "last___stat", " last___stat", " last_Status", "last___message", " last___message", "last_stat", "last2stat", " last_message", "last___status"], "status": ["success", "service", "result", "error", "match", "gc", "sp", "wait", "magic", "trans", "ping", "type", "i", "set", "active", "state", "description", "sc", "login", "msg", "valid", "progress", "stat", "details", "score", "sync", "index", "data", "uses", "value", "str", "admin", "id", "reason", "code", "Status", "s", "summary", "iso", "command", "sex", "request", "spec", "xml", "resp", "version", "report", "message", "check", "health", "res", "params", "name", "flag", "sequence"]}}
{"project": "FFmpeg", "commit_id": "5674d4b0a35a34b75e3533a8580e0b5a0a8895a7", "target": 0, "func": "static int mpc8_decode_frame(AVCodecContext * avctx,\n\n                            void *data, int *data_size,\n\n                            AVPacket *avpkt)\n\n{\n\n    const uint8_t *buf = avpkt->data;\n\n    int buf_size = avpkt->size;\n\n    MPCContext *c = avctx->priv_data;\n\n    GetBitContext gb2, *gb = &gb2;\n\n    int i, j, k, ch, cnt, res, t;\n\n    Band *bands = c->bands;\n\n    int off;\n\n    int maxband, keyframe;\n\n    int last[2];\n\n\n\n    keyframe = c->cur_frame == 0;\n\n\n\n    if(keyframe){\n\n        memset(c->Q, 0, sizeof(c->Q));\n\n        c->last_bits_used = 0;\n\n    }\n\n    init_get_bits(gb, buf, buf_size * 8);\n\n    skip_bits(gb, c->last_bits_used & 7);\n\n\n\n    if(keyframe)\n\n        maxband = mpc8_get_mod_golomb(gb, c->maxbands + 1);\n\n    else{\n\n        maxband = c->last_max_band + get_vlc2(gb, band_vlc.table, MPC8_BANDS_BITS, 2);\n\n        if(maxband > 32) maxband -= 33;\n\n    }\n\n    c->last_max_band = maxband;\n\n\n\n    /* read subband indexes */\n\n    if(maxband){\n\n        last[0] = last[1] = 0;\n\n        for(i = maxband - 1; i >= 0; i--){\n\n            for(ch = 0; ch < 2; ch++){\n\n                last[ch] = get_vlc2(gb, res_vlc[last[ch] > 2].table, MPC8_RES_BITS, 2) + last[ch];\n\n                if(last[ch] > 15) last[ch] -= 17;\n\n                bands[i].res[ch] = last[ch];\n\n            }\n\n        }\n\n        if(c->MSS){\n\n            int mask;\n\n\n\n            cnt = 0;\n\n            for(i = 0; i < maxband; i++)\n\n                if(bands[i].res[0] || bands[i].res[1])\n\n                    cnt++;\n\n            t = mpc8_get_mod_golomb(gb, cnt);\n\n            mask = mpc8_get_mask(gb, cnt, t);\n\n            for(i = maxband - 1; i >= 0; i--)\n\n                if(bands[i].res[0] || bands[i].res[1]){\n\n                    bands[i].msf = mask & 1;\n\n                    mask >>= 1;\n\n                }\n\n        }\n\n    }\n\n    for(i = maxband; i < c->maxbands; i++)\n\n        bands[i].res[0] = bands[i].res[1] = 0;\n\n\n\n    if(keyframe){\n\n        for(i = 0; i < 32; i++)\n\n            c->oldDSCF[0][i] = c->oldDSCF[1][i] = 1;\n\n    }\n\n\n\n    for(i = 0; i < maxband; i++){\n\n        if(bands[i].res[0] || bands[i].res[1]){\n\n            cnt = !!bands[i].res[0] + !!bands[i].res[1] - 1;\n\n            if(cnt >= 0){\n\n                t = get_vlc2(gb, scfi_vlc[cnt].table, scfi_vlc[cnt].bits, 1);\n\n                if(bands[i].res[0]) bands[i].scfi[0] = t >> (2 * cnt);\n\n                if(bands[i].res[1]) bands[i].scfi[1] = t & 3;\n\n            }\n\n        }\n\n    }\n\n\n\n    for(i = 0; i < maxband; i++){\n\n        for(ch = 0; ch < 2; ch++){\n\n            if(!bands[i].res[ch]) continue;\n\n\n\n            if(c->oldDSCF[ch][i]){\n\n                bands[i].scf_idx[ch][0] = get_bits(gb, 7) - 6;\n\n                c->oldDSCF[ch][i] = 0;\n\n            }else{\n\n                t = get_vlc2(gb, dscf_vlc[1].table, MPC8_DSCF1_BITS, 2);\n\n                if(t == 64)\n\n                    t += get_bits(gb, 6);\n\n                bands[i].scf_idx[ch][0] = ((bands[i].scf_idx[ch][2] + t - 25) & 0x7F) - 6;\n\n            }\n\n            for(j = 0; j < 2; j++){\n\n                if((bands[i].scfi[ch] << j) & 2)\n\n                    bands[i].scf_idx[ch][j + 1] = bands[i].scf_idx[ch][j];\n\n                else{\n\n                    t = get_vlc2(gb, dscf_vlc[0].table, MPC8_DSCF0_BITS, 2);\n\n                    if(t == 31)\n\n                        t = 64 + get_bits(gb, 6);\n\n                    bands[i].scf_idx[ch][j + 1] = ((bands[i].scf_idx[ch][j] + t - 25) & 0x7F) - 6;\n\n                }\n\n            }\n\n        }\n\n    }\n\n\n\n    for(i = 0, off = 0; i < maxband; i++, off += SAMPLES_PER_BAND){\n\n        for(ch = 0; ch < 2; ch++){\n\n            res = bands[i].res[ch];\n\n            switch(res){\n\n            case -1:\n\n                for(j = 0; j < SAMPLES_PER_BAND; j++)\n\n                    c->Q[ch][off + j] = (av_lfg_get(&c->rnd) & 0x3FC) - 510;\n\n                break;\n\n            case 0:\n\n                break;\n\n            case 1:\n\n                for(j = 0; j < SAMPLES_PER_BAND; j += SAMPLES_PER_BAND / 2){\n\n                    cnt = get_vlc2(gb, q1_vlc.table, MPC8_Q1_BITS, 2);\n\n                    t = mpc8_get_mask(gb, 18, cnt);\n\n                    for(k = 0; k < SAMPLES_PER_BAND / 2; k++, t <<= 1)\n\n                        c->Q[ch][off + j + k] = (t & 0x20000) ? (get_bits1(gb) << 1) - 1 : 0;\n\n                }\n\n                break;\n\n            case 2:\n\n                cnt = 6;//2*mpc8_thres[res]\n\n                for(j = 0; j < SAMPLES_PER_BAND; j += 3){\n\n                    t = get_vlc2(gb, q2_vlc[cnt > 3].table, MPC8_Q2_BITS, 2);\n\n                    c->Q[ch][off + j + 0] = mpc8_idx50[t];\n\n                    c->Q[ch][off + j + 1] = mpc8_idx51[t];\n\n                    c->Q[ch][off + j + 2] = mpc8_idx52[t];\n\n                    cnt = (cnt >> 1) + mpc8_huffq2[t];\n\n                }\n\n                break;\n\n            case 3:\n\n            case 4:\n\n                for(j = 0; j < SAMPLES_PER_BAND; j += 2){\n\n                    t = get_vlc2(gb, q3_vlc[res - 3].table, MPC8_Q3_BITS, 2) + q3_offsets[res - 3];\n\n                    c->Q[ch][off + j + 1] = t >> 4;\n\n                    c->Q[ch][off + j + 0] = (t & 8) ? (t & 0xF) - 16 : (t & 0xF);\n\n                }\n\n                break;\n\n            case 5:\n\n            case 6:\n\n            case 7:\n\n            case 8:\n\n                cnt = 2 * mpc8_thres[res];\n\n                for(j = 0; j < SAMPLES_PER_BAND; j++){\n\n                    t = get_vlc2(gb, quant_vlc[res - 5][cnt > mpc8_thres[res]].table, quant_vlc[res - 5][cnt > mpc8_thres[res]].bits, 2) + quant_offsets[res - 5];\n\n                    c->Q[ch][off + j] = t;\n\n                    cnt = (cnt >> 1) + FFABS(c->Q[ch][off + j]);\n\n                }\n\n                break;\n\n            default:\n\n                for(j = 0; j < SAMPLES_PER_BAND; j++){\n\n                    c->Q[ch][off + j] = get_vlc2(gb, q9up_vlc.table, MPC8_Q9UP_BITS, 2);\n\n                    if(res != 9){\n\n                        c->Q[ch][off + j] <<= res - 9;\n\n                        c->Q[ch][off + j] |= get_bits(gb, res - 9);\n\n                    }\n\n                    c->Q[ch][off + j] -= (1 << (res - 2)) - 1;\n\n                }\n\n            }\n\n        }\n\n    }\n\n\n\n    ff_mpc_dequantize_and_synth(c, maxband, data, avctx->channels);\n\n\n\n    c->cur_frame++;\n\n\n\n    c->last_bits_used = get_bits_count(gb);\n\n    if(c->cur_frame >= c->frames)\n\n        c->cur_frame = 0;\n\n    *data_size =  MPC_FRAME_SIZE * 2 * avctx->channels;\n\n\n\n    return c->cur_frame ? c->last_bits_used >> 3 : buf_size;\n\n}\n", "idx": 7558, "substitutes": {"avctx": ["cvctx", "AVctx", " avcmp", "avtx", "avecfg", "cvcontext", "evcfg", " avcontext", "AVtx", "evctx", "avecontext", "avcontext", "cvcmp", "avectl", "avectx", " avtx", "evcontext", "avcmp", " avcfg", "evctl", "cvtx", " avctl", "avcfg", "avctl", "AVcmp", "AVcontext"], "data": ["read", "bytes", "b", "empty", "dat", "window", "pad", "buffer", "raw", "map", "d", "p", "body", "ata", "input", "Data", "r", "value", "mu", "bits", "frame", "block", "m", "batch", "area", "DATA", "message", "size", "length", "text", "a", "def", "bin"], "data_size": ["buf_length", "buf_len", "buf_Size", "buf_size", "data_length", "data_Size", "data_len"], "avpkt": [" avpth", "avjpacket", "avdkt", " avPud", "avpdu", "avppkt", "avjpmit", "avbpacket", "avbpkt", "avjpth", " avPpt", " avPct", " avPkt", "avPqt", "avppt", "avbpqt", "avPct", " avPmit", "avPkt", " avpacket", "avdacket", "avpqt", "avpacket", " avpct", "avpppt", " avPdu", "avPth", "avPud", " avpdu", "avPmit", " avpud", "avnpkt", "avddu", " avpqt", " avpmit", "avpmit", "avpud", "avppqt", " avppt", "avpct", "avjpud", "avjpct", "avPdu", "avdud", "avjpkt", "avbppt", "avnpmit", "avPacket", "avnpct", "avpth", " avPqt", "avPpt", "avppacket", " avPth", "avnpth", "avjpdu", " avPacket"], "buf": ["db", "read", "bytes", "uf", "buff", "b", "dat", "mem", "pb", "ctx", "br", "buffer", "raw", "p", "cmd", "cb", "queue", "wb", "rw", "r", "rc", "rb", "v", "txt", "mb", "nb", "tmp", "cv", "img", "fb", "xff", "bl", "cur", "arr", "vec"], "c": ["this", "cf", "dc", "chain", "gc", "ci", "ct", "b", "call", "cp", "conf", "ctx", "h", "pc", "cmp", "bc", "cont", "cl", "cam", "anc", "con", "cs", "sc", "fc", "p", "g", "cm", "co", "etc", "ec", "nc", "cb", "lc", "ce", "r", "cc", "rc", "coll", "cn", "cr", "v", "cal", "m", "ac", "config", "cv", "cd", "ca", "cache", "mc", "f", "cur", "C", "e", "comp", "l", "enc", "com", "cu", "ctrl", "abc", "tc"], "gb2": ["cb1", "sb12", "gb5", "gb1", "gb3", "mb12", "gb12", "cb3", "mb2", "sb5", "db3", "cb5", "cb12", "bg1", "db2", "mb5", "sb2", "cb2", "bg3", "bg2", "db1"], "gb": ["db", "gt", "bytes", "uf", "buff", "gc", "b", "gs", "gif", "csv", "jpg", "gm", "eb", "bg", "ib", "band", "phy", "buffer", "eg", "g", "tg", "bd", "hub", "gd", "cb", "bt", "wb", "bb", "pg", "py", "sb", "rb", "bits", "mb", "cfg", "goo", "nb", "rg", "tmp", "cv", "fb", "gz", "storage", "img", "gnu", "GB", "kb", "bm", "gg", "gpu"], "i": ["init", "ic", "ij", "ini", "q", "ei", "ci", "b", "it", "im", "cli", "h", "ik", "gi", "mi", "qi", "mk", "ip", "li", "p", "si", "ami", "ie", "zi", "n", "is", "xi", "ind", "index", "o", "hi", "bi", "pi", "r", "multi", "ui", "id", "ki", "ji", "phi", "ti", "v", "ix", "ai", "m", "I", "y", "print", "ish", "\u0438", "io", "iu", "e", "info", "x", "di", "ni", "ii", "l"], "j": ["dj", "ij", "q", "it", "jj", "job", "J", "rel", "aj", "g", "n", "uj", "index", "o", "bi", "jc", "js", "pos", "ji", "v", "m", "jump", "jp", "kj", "z", "json", "l"], "k": ["ck", "q", "km", "kh", "kk", "kid", "ka", "kind", "K", "ik", "ek", "ok", "mk", "g", "p", "ak", "ke", "o", "key", "w", "ki", "v", "sk", "m", "ko", "kj", "z"], "ch": ["ph", "gh", "q", "sp", "CH", "cy", "cp", "channel", "ble", "chn", "kh", "h", "cl", "cha", "sc", "ek", "ry", "cs", "Ch", "ht", "ip", "zh", "ech", "chron", "chat", "chip", "ind", "ay", "history", "cht", "height", "col", "tch", "ach", "th", "el", "chid", "che", "ah", "chu", "sh", "sk", "qu", "yet", "cell", "och", "ich", "tx", "ca", "y", "he", "sky", "count", "wh", "isch", "chan", "sch", "through", "ex", "hl", "html", "cho", "hr", "chi"], "cnt": ["lcNT", "ncnt", "acnd", "cct", "Crt", " ccount", "cNT", "Cct", "Cnt", "ncount", " cNT", " cnd", "uncnt", "ccount", "Count", "acount", "ncrt", "CNT", "account", " crt", "uncount", "lcnt", " cct", "ncct", "Ccount", "lccount", "acct", "uncnd", "crt", "count", "acnt", "lcct", "cnd", " count", "uncct"], "res": ["resources", "rates", "rs", "success", "result", "chain", "results", "ress", "rep", "rel", "sys", "os", "raw", "seq", "progress", "ps", "ms", "val", "Res", "vals", "range", "r", "err", "rss", "rc", "ref", "rev", "rem", "rest", "max", "ras", "RES", "req", "reset", "bits", "resp", "re", "prev", "reg", "ret", "tx", "cons", "hash", "pres", "def", "resolution"], "t": ["type", "T", "pt", "nt", "ta", "te", "dt", "p", "tg", "g", "tm", "typ", "n", "ts", "tr", "o", "total", "wt", "r", "ti", "txt", "ot", "tz", "tu", "rt", "m", "ret", "tf", "y", "f", "tp", "tt", "tc"], "bands": ["members", "boxes", "gs", "classes", "dds", "cells", "devices", "rooms", "band", "objects", "balls", "missions", "cats", "apps", "files", "bys", "pins", "artifacts", "frames", "bright", "words", "products", "banks", "tones", "bars", "models", "ands", "lights", "tracks", "blocks", "bats", "plugins", "planes", " couples", "bps", "boards", "images", "tags", "phones", "bits", "asters", "dos", "codes", "archs", "bs", "states", "hands", "reports", "parts", "heads", "videos", "versions", "groups", " brokers", "photos", "rings", "ions", "chains", "lists"], "off": ["error", "ff", "eff", "low", "Off", "offset", " out", "ok", "raw", "cmd", "no", "OFF", "op", "on", "o", " af", "from", "w", "pos", "out", "offs", "command", "new", "f", " offset", "of", "miss"], "maxband": ["axbands", "starBand", "newband", " maxdisk", "maximumiband", "sumbridge", "maximumdisk", "powerbin", "maxbin", "finalBand", "axcloud", " maxiband", "sumband", "Maxband", "maximumbrid", " maxfilter", "maximumband", "largestbridge", "starband", "finalbin", "highbridge", "maxdisk", " maxBand", "highband", "oxbands", " maxbrid", "Maxbridge", "finalbands", "newline", "starbin", "maxbands", "finalband", "newnode", "summan", "maximumBand", "highline", "powerdisk", "largestband", " maxbridge", "starfilter", "highnode", "axbin", "maxbrid", "highiband", "maxline", "hugeband", "highBand", "maximumline", "sumBand", "oxband", "newdisk", "axband", "highbrid", " maxcloud", " maxbands", "maxcloud", "axBand", "maxfilter", "highdisk", "hugebin", "highman", "hugeBand", "maxman", "powerBand", "maximumnode", "oxcloud", "largestBand", "oxBand", "Maxbands", "maximumbin", "hugefilter", "maxiband", "maxbridge", "MaxBand", " maxbin", " maxman", "powerband", "maxnode", "maxBand"], "keyframe": ["popframe", " keyFrame", "powerframe", "keychannel", " keystroke", "mainframes", " keysequence", " keyfram", "Keystroke", "mainfram", "keyfram", "KEYchannel", "popchain", " keychain", "powerframes", " keychannel", "Keyfram", "keysequence", "keystroke", "linkfram", "Keysequence", "Keyframe", "powerchannel", "powerFrame", "mainframe", "mainstroke", "KEYframe", "keyframes", "KEYFrame", " keyframes", "popfram", "KEYfram", "linkframes", "keyFrame", "popframes", "powersequence", "KeyFrame", "linkframe", "linkchain", "keychain", "powerfram", "Keyframes"], "last": ["all", "cast", "next", "never", "end", "highest", "est", "any", "def", "both", "based", "scope", "nd", "worst", "bottom", "only", "sort", "largest", "sold", " lasts", "best", "same", "base", " Last", "good", "no", "used", "total", "full", "first", "history", "slave", "old", "push", "ands", "ast", "list", "rest", "style", "master", "max", "out", "pretty", "shared", "final", "prev", "las", "st", "asts", "most", "stable", "now", "reverse", "build", "cache", "show", "count", "before", " LAST", "needed", "latest", "since", "lower", "Last"], "mask": ["result", "eff", " cond", "weight", "box", "offset", " clear", "ok", "miss", "map", "no", "zero", "key", "Mask", "max", "num", "correct", "final", "m", "clear", "cond", "batch", "ask", "info", "lock", " masks", "flag"], "cur_frame": ["cur_state", "cur__state", "cur___state", "cur___bit", "cur_bit", "cur___image", "cur__bit", "current_image", "current_state", "cur_image", "cur___frame", "cur__image", "cur__frame", "current_bit", "current_frame"]}}
{"project": "qemu", "commit_id": "da57febfed7bad11be79f047b59719c38abd0712", "target": 0, "func": "DeviceState *qdev_try_create(BusState *bus, const char *name)\n\n{\n\n    DeviceState *dev;\n\n\n\n    if (object_class_by_name(name) == NULL) {\n\n        return NULL;\n\n    }\n\n    dev = DEVICE(object_new(name));\n\n    if (!dev) {\n\n        return NULL;\n\n    }\n\n\n\n    if (!bus) {\n\n        bus = sysbus_get_default();\n\n    }\n\n\n\n    qdev_set_parent_bus(dev, bus);\n\n    qdev_prop_set_globals(dev);\n\n\n\n    return dev;\n\n}\n", "idx": 7579, "substitutes": {"bus": ["db", "cast", "hand", "chain", "b", " BUS", "c", "ctx", "back", "bc", "box", "BUS", "sys", "buf", "state", "nt", "os", "util", "base", "Bus", "vol", "lib", "aux", "used", "bo", "cus", "func", "bu", "phys", "bolt", "pos", "bar", "board", "proc", "mount", "device", "gate", "host", "handle", "book", "port", "block", "bridge", "driver", "bs", "cat", "bug", "loop", "test", "us", "serial", "boot", "lock", "stick", "def", "loc"], "name": ["filename", "prefix", "mem", "named", "term", "type", "c", "lat", "file", "nam", "ame", "n", "no", "len", "label", "data", "key", "value", "str", "w", "id", "word", "Name", "nm", "code", "cap", "new", "m", "NAME", "part", "parent", "alias", "ident", "family", "class", "names", "title", "path"], "dev": ["db", "ev", "des", "app", "sw", "dat", "mem", "devices", "usb", "any", "dep", "av", "cam", "pad", "pro", "DEV", "dem", "buf", "ve", "nt", "prop", "d", "cmd", "sd", "del", "val", "tr", "data", "hw", "ach", "go", "th", "w", "proc", "device", "out", "ow", "normal", "v", "DE", "Device", "dd", "gpu", "final", "ch", "dn", "serv", "tmp", "scan", "ptr", "local", "doc", "priv", "disk", "current", "cur", "test", "obj", "de", "gu", "tech", "development", "stick", "enc", "res", "di", "ver", "Dev", "conn", "def"]}}
{"project": "qemu", "commit_id": "31478f26ab4ed82d35b763bbf259810d0c8b44e1", "target": 1, "func": "Visitor *qobject_input_visitor_new_keyval(QObject *obj)\n\n{\n\n    QObjectInputVisitor *v = qobject_input_visitor_base_new(obj);\n\n\n\n    v->visitor.type_int64 = qobject_input_type_int64_keyval;\n\n    v->visitor.type_uint64 = qobject_input_type_uint64_keyval;\n\n    v->visitor.type_bool = qobject_input_type_bool_keyval;\n\n    v->visitor.type_str = qobject_input_type_str;\n\n    v->visitor.type_number = qobject_input_type_number_keyval;\n\n    v->visitor.type_any = qobject_input_type_any;\n\n    v->visitor.type_null = qobject_input_type_null;\n\n    v->visitor.type_size = qobject_input_type_size_keyval;\n\n\n\n    return &v->visitor;\n\n}\n", "idx": 7590, "substitutes": {"obj": ["xy", "it", "po", "gov", "pt", "comm", "nt", "ob", "ht", "bh", "os", "rect", "cmd", "og", "bo", "o", "hw", "obo", "js", "bb", "ref", "opt", "attr", "pr", "oj", "org", "txt", "ot", "resp", "bs", "tmp", "onet", "oss", "j", "obs", "Obj", "object", "act"], "v": ["iv", "vv", "ev", "uv", "vy", "lv", "b", "ov", "u", "av", "get", "vi", "em", "ve", "g", "inv", "etc", "vp", "dev", "val", "nov", "tv", "pi", "value", "w", "sv", "qv", "en", "env", "nv", "qu", "m", "ch", "V", "vc", "vis", "vs", "om", "st", "cv", "version", "y", "f", "vt", "conv", "wire", "vm", "e", "j", "z", "x", "ver", "l"]}}
{"project": "qemu", "commit_id": "187337f8b0ec0813dd3876d1efe37d415fb81c2e", "target": 1, "func": "void *pl080_init(uint32_t base, qemu_irq irq, int nchannels)\n\n{\n\n    int iomemtype;\n\n    pl080_state *s;\n\n\n\n    s = (pl080_state *)qemu_mallocz(sizeof(pl080_state));\n\n    iomemtype = cpu_register_io_memory(0, pl080_readfn,\n\n                                       pl080_writefn, s);\n\n    cpu_register_physical_memory(base, 0x00000fff, iomemtype);\n\n    s->base = base;\n\n    s->irq = irq;\n\n    s->nchannels = nchannels;\n\n    /* ??? Save/restore.  */\n\n    return s;\n\n}\n", "idx": 7596, "substitutes": {"base": ["padding", "b", "root", "prefix", "it", "type", "c", "h", "null", "based", "i", "set", "offset", "state", "relative", "file", "buffer", " bases", "p", "pa", "bp", "use", "zero", "index", "total", "bound", "range", "key", "se", "scale", "Base", "pe", "position", "bit", "id", "ref", "k", "balance", "start", "max", "out", "v", "memory", "bid", "bare", "handle", "reset", "bf", "mb", "m", "frame", "cpu", "birth", "local", "y", "area", "address", "f", "size", "l", "bas", "ase", "x", "name"], "irq": ["iraqi", "ibrq", " drch", " drqi", "iroqs", "irqi", "iraq", "irch", "iriqu", " drq", "ibrqu", " ireq", "irv", "iroq", " ireqi", "iriq", " cirqu", "irqs", "iriv", " cirq", "iroqu", "ireq", " circh", "iraqs", "iroqi", "riv", " irequ", "irick", "irequ", "iraqu", "riq", "irck", "irqu", " drqu", "ireqs", "riqu", "ibrck", "ireqi", " irech", "ibrv", "rick", " cirqi"], "nchannels": ["nquars", "nquannels", " nChannels", " narchars", "nchunks", " narchannels", "ncunks", "Nchans", " nchunks", "nChords", "nChaps", "nChannels", "nachans", " nChars", " nchans", "nchords", "nachunks", "narchunks", "nachars", "ncans", "nachannels", " narchans", "Nchaps", "nnannels", "NChords", "nquunks", "nchusters", "narchans", "narchannels", "nnaps", " nChunks", "nnans", " nChusters", "nnords", "nChunks", "ncannels", " nchars", "nquusters", "nachords", "nchaps", "ncars", "nChars", "nachaps", "nachusters", "NChans", "NChaps", "nChans", "nChusters", "narchars", "Nchannels", "nchans", "NChannels", "Nchords", " nchusters", " narchunks", "nchars"], "iomemtype": ["olyneemtype", "iomiemcat", "iomemtypes", "olynemtype", "iomemcat", "iomemstypes", "olyneemrole", "iomomtype", "iomeminposition", "iomemekind", "iamEMkind", "iomEmtype", "iomEMType", "iomeminrole", "iomimerbase", "iomeemcat", "iomiemrole", "olyneembase", "iomemype", "iomemetype", "iomemstype", "ioticemposition", "iamemkind", "olynembase", "iomeminype", "iamemType", "iomomposition", "iamEMType", "ioticemintype", "iomemetypes", "iamEMtype", "iamEMtypes", "iomemrole", "iamemtype", "iomomrole", "iomemkind", "iomemposition", "iomEMtypes", "iomEMtype", "iomiembase", "olynemrole", "iomembase", "iomemeType", "ioticeminposition", "iomemType", "ioticeminype", "ioticemype", "iomeemrole", "iomEmrole", "iomemintype", "iomEmposition", "ioticemrole", "iomiemtype", "iomimercat", "ioticemtype", "iomimertype", "olynemcat", "olyneemcat", "iomemskind", "iomemsType", "ioticeminrole", "iomomype", "iomeembase", "iomimerrole", "iamemtypes", "iomEMkind", "iomeemtype", "iomEmype"], "s": ["single", "rs", "so", "gs", "ses", "bis", "b", " is", "ings", "ns", "c", "its", "save", "h", "ats", "ers", "ies", "i", "qs", "set", "sys", "cs", "self", "os", "p", "g", "ps", "details", "n", "is", "ts", "ports", "ds", "o", "se", "t", "pers", "es", "r", "js", "w", "ins", "ears", "an", "sv", "ls", "gets", "sb", "services", "v", "stats", "sl", "status", "m", "spec", "st", "ss", "bs", "y", "sq", "f", "fs", "e", "S", "sts", "z", "j", "sports", "a", "l", "source"]}}
{"project": "FFmpeg", "commit_id": "596b5c488fa1d40f114a64d3b73e1863cab073fb", "target": 0, "func": "static av_cold void init_coef_vlc(VLC *vlc, uint16_t **prun_table,\n\n                                  float **plevel_table, uint16_t **pint_table,\n\n                                  const CoefVLCTable *vlc_table)\n\n{\n\n    int n                        = vlc_table->n;\n\n    const uint8_t  *table_bits   = vlc_table->huffbits;\n\n    const uint32_t *table_codes  = vlc_table->huffcodes;\n\n    const uint16_t *levels_table = vlc_table->levels;\n\n    uint16_t *run_table, *level_table, *int_table;\n\n    float *flevel_table;\n\n    int i, l, j, k, level;\n\n\n\n    init_vlc(vlc, VLCBITS, n, table_bits, 1, 1, table_codes, 4, 4, 0);\n\n\n\n    run_table    = av_malloc(n * sizeof(uint16_t));\n\n    level_table  = av_malloc(n * sizeof(uint16_t));\n\n    flevel_table = av_malloc(n * sizeof(*flevel_table));\n\n    int_table    = av_malloc(n * sizeof(uint16_t));\n\n    i            = 2;\n\n    level        = 1;\n\n    k            = 0;\n\n    while (i < n) {\n\n        int_table[k] = i;\n\n        l            = levels_table[k++];\n\n        for (j = 0; j < l; j++) {\n\n            run_table[i]    = j;\n\n            level_table[i]  = level;\n\n            flevel_table[i] = level;\n\n            i++;\n\n        }\n\n        level++;\n\n    }\n\n    *prun_table   = run_table;\n\n    *plevel_table = flevel_table;\n\n    *pint_table   = int_table;\n\n    av_free(level_table);\n\n}\n", "idx": 7598, "substitutes": {"vlc": ["vlpc", "plci", "nlpc", "vrc", "rlt", "plpc", "flc", "vrci", "pll", "vlcc", "flcs", "vlcs", "plc", "vll", "nll", "vlci", "vrl", "flt", "nlci", "wlcs", "wlt", "wlcc", "nlc", "vrpc", "rlcc", "flcc", "vlt", "rlcs", "rlc", "wlc"], "prun_table": ["prange___tree", "prange___table", "prun___tree", "prun_list", "prun__list", "prange_TABLE", "prun__table", "prange_table", "pruncstable", "pruncsdatabase", "prange___TABLE", "prun___list", "prun___TABLE", "prunc_list", "prunstable", "prun2list", "prun_tab", "prunc_database", "prunsdatabase", "pruncstab", "prun2tree", "prunslist", "prange_tree", "prunstab", "prun_tree", "prun_database", "prange_list", "prun2table", "prun___table", "prange___list", "prunc_tab", "pruncslist", "prun__database", "prun__tab", "prunc_table", "prun_TABLE", "prun2TABLE"], "plevel_table": ["pleVEL_TABLE", "plevelitystable", "plevel___TABLE", "pleep_table", "plevel___table", "plevel___tree", "pleVEL_tree", "plevel_TABLE", "pleep_TABLE", "pleVEL_table", "plevelitytable", "pleVEL_stable", "plevel_tab", "plevel_tree", "plevelityTABLE", "plevel___stable", "pleep_tab", "plevel_stable", "plevelitytab", "pleep_stable"], "pint_table": ["pind_tab", "pind_table", "pint__table", "pint2table", "pint_TABLE", "pint__TABLE", "pind_cache", "pint_tab", "pint_list", "pint2data", "pint_cache", "pint2tab", "pint__cache", "pind_data", "pind_TABLE", "pint2TABLE", "pint__list", "pind_list", "pint_data"], "vlc_table": ["vlcf_server", "vlxcpytable", "vlxcpywindow", "vlc_buffer", "vlxc_internal", "vlc_cache", "vlac_table", "vlcs_TABLE", "vlxcpytotal", "vlc_tab", "vlac_target", "vlxcpyinternal", "vlc_target", "vlcf_tree", "vlc_tree", "vlcf_tab", "vlxc_table", "vlcpywindow", "vlc_internal", "vlcpytotal", "vlcpytable", "vlac_tree", "vlcf_table", "vlac_tab", "vlcs_cache", "vlac_buffer", "vlac_t", "vlcs_tab", "vlc_t", "vlc_server", "vlxc_window", "vlc_total", "vlcs_table", "vlc_TABLE", "vlcpyinternal", "vlxc_total", "vlc_window"], "table_bits": ["table_plugins", "buffer_keys", "table___bits", "buffer_limits", "table_flags", "table___codes", "table_keys", "table___plugins", " table_plugins", " table_flags", "table_limits", "table___flags", "buffer_bits", "buffer_flags"], "table_codes": ["binary___details", "binary_names", "tree_codes", "binary___names", "binary___checks", "tree_properties", "table_names", "table_cells", "tree_bits", "tablemopcells", "table___details", "treemopproperties", "table___names", "table___codes", "binary_checks", "binary___codes", "tree_cells", "treemopbits", "table_details", "tablemopcodes", "binary_details", "tablemopchecks", "tablemopdetails", "tablemopproperties", "treemopcells", "table_properties", "table_checks", "table___checks", "tablemopbits", "treemopcodes", "tablemopnames", "binary_codes"], "levels_table": ["levels8database", "levelsaloption", "levels00top", " levels_file", "levels00option", "levels_database", "levels_file", "lights_top", "levels8file", "levelsalpoint", " levels_database", "lights_point", "lights_table", "levelsaltable", "levels_top", "levels_option", "levels_point", "levelsaltop", "levels00point", " levels_tab", "levels_tab", "lights_option", "levels8tab", "levels00table", "levels8table"], "run_table": ["rungcase", "runalllist", "runallentry", " run64source", "return_list", "run_entry", " run64to", "runalcase", "runetlist", "runglist", " run_case", "runinglist", "runingsource", "ruingsource", "run_file", "returnetlist", " run_to", "runalsource", " run_source", "run_case", "rungtable", " run_list", "ru_list", "run_list", "run64to", " run_file", "run_to", "ru_table", "ruingtype", "run_source", "ruinglist", "runettable", "runetentry", "run64table", "returnetentry", "runingtype", "run64list", "return_table", "runallist", "return_storage", "runetstorage", "runalto", "run_type", " run64table", "runallstorage", "ruingtable", "runalfile", " run64list", "ru_source", "runalltable", "returnettable", "run_storage", "ru_type", "runaltable", "run64source", "returnetstorage", "rungfile", "return_entry", "runingtable"], "level_table": ["leveltinternal", "level__table", "role64table", "vel_list", "level__container", "level67body", "level67table", "level_list", "level64stable", "level__cache", "level64list", "role_body", "level64able", "level64table", "lvl67table", "level_tree", "lvl67container", "level_internal", "lvl_system", "level__collection", "lvl67system", "int__container", "levelttree", "levellytable", "lvl_tree", "level64body", "level_index", "level_cache", "int__table", "level67internal", "level_collection", "levellytree", "levellycontainer", "level67tree", "lvl67tree", "levellysystem", "int_container", "leveltcontainer", "role64index", "level32cache", "level32container", "vel_able", "level_stable", "vel_table", "int_collection", "level64index", "lvl_container", "level_container", "level67system", "role_internal", "leveltindex", "int_cache", "role64internal", "level67container", "level32table", "vel_stable", "int__cache", "level_body", "leveltsystem", "level32collection", "int__collection", "levelttable", "role64body", "level64internal", "level_system", "lvl_table", "leveltbody", "level67index", "role_table", "role_index", "level_able"], "int_table": ["ints_scope", "int_tree", "intablewindow", "intacinternal", "intiletable", "intxable", "string10sequence", "string_table", "intitytable", "int10able", "intAable", "rint_container", "intpttree", "string_sequence", "int10table", "intvalwindow", "int_internal", "intvalscope", "run_module", "intitymodule", "intilelist", "rint_list", "intitydict", "int2module", "intableable", "int_able", "intxwindow", "intilecontainer", "int_list", "int2list", "rint_table", "string_able", "intsvalable", "run_list", "ints_able", "int_module", "intptcontainer", "intiletree", "intacsequence", "intvaltable", "int10internal", "int2table", "ints_table", "ints_window", "int_container", "string10able", "int10sequence", "intAsequence", "int_dict", "int2dict", "intitylist", "run_dict", "string_internal", "int_scope", "intabletable", "intsvaltable", "intxtable", "intxscope", "intsvalscope", "string10table", "int_window", "intablescope", "intactable", "intptlist", "intpttable", "intvalable", "int_sequence", "intsvalwindow", "intacable", "intAinternal", "string10internal", "intAtable", "rint_tree"], "flevel_table": ["frun_list", "flevellytable", "flevel1table", "fleveledentry", "frun2table", "flevelermaster", "frun_table", "frun_collection", "flevel67index", "flevel2list", "frun32public", "frun32TABLE", "flevelertable", "fprint_internal", "fall_table", "flevel_list", "flevel_internal", "flvl_table", "flevel67buffer", "flevel67total", "frun32collection", "flevelaltotal", "flevel_total", "flvl_index", "flevelerlist", "flvl_total", "frun2master", "flevel2master", "flevel_tab", "flevellycollection", "flevel_master", "fleveledtab", "flevel_entry", "frun2tab", "frun_master", "fall_array", "frun_TABLE", "flevel1entry", "fleveledtable", "fprint_table", "flevel_buffer", "fall_list", "frun32table", "flevel_collection", "flevel67table", "flevel1tab", "flevel_index", "flevel2table", "flevellyTABLE", "flevel32public", "flevel_array", "fleveledinternal", "flevelaltable", "flevel32table", "fall_tab", "flevelertab", "frun_tab", "flevelalindex", "flevelalbuffer", "fprint_entry", "flevel_public", "flvl_buffer", "frun2list", "fprint_tab", "flevel32collection", "flevel32TABLE", "frun_public", "flevellypublic", "flevel_TABLE", "flevel1internal", "flevel2tab"], "i": ["ic", "ij", "ini", "depth", "ei", "ci", "b", " ii", "it", "im", "u", "h", "ik", "mi", "qi", "ip", "li", "p", "si", "g", "ie", "zi", "n", "is", "xi", "index", "o", "key", "ri", "pi", "bi", "r", "hi", "ui", "ki", "phi", "ti", "ir", "v", "ix", "ai", "m", "I", "y", "f", "iu", "e", "in", "info", "x", "di", "ii"], "l": ["q", "ln", "ell", "lr", "cl", "lin", "tl", "li", "p", "ml", "n", "len", "lu", "fl", "pl", "lc", "kl", "lo", "el", "ly", "ls", "lp", "v", "sl", "la", "ul", "lit", "L", "hl", "ll", "nl", "il", "z", "le"], "j": ["ph", "dj", "ja", "ij", "q", "b", "bj", "jo", "it", "jj", "job", "J", "br", "pt", "aj", "p", "g", "n", "uj", "bo", "o", "jas", "key", "row", "r", "jc", "js", "ji", "py", "ng", "try", "v", "m", "y", "jump", "jp", "je", "f", "obj", "jl", "e", "kj", "z", "fr", "json", "x", "other"], "k": ["ck", "ic", "q", "km", "it", "kr", "kh", "kk", "ku", "kid", "ka", "kind", "K", "ik", "ek", "sc", "ijk", "mk", "p", "g", "n", "ak", "ark", "ke", "index", "o", "kl", "key", "wk", "t", "r", "id", "ki", "kw", "v", "sk", "m", "ko", "y", "ask", "ks", "kj", "z", "tk"], "level": ["depth", "error", "node", "cost", "type", "state", "mi", "p", "g", "co", "len", "val", "label", "index", "pl", "full", "lo", "key", "vel", "kl", "col", "pe", "fl", "id", "list", "role", "v", "where", "status", "levels", "m", "lvl", "volume", "local", "print", "fail", "Level", "count", "f", "test", "loop", "fi", "L", "info", "point", "length", "roll", "z", "wl", "le"]}}
{"project": "FFmpeg", "commit_id": "d7b2bb5391bf55e8f9421bff7feb4c1fddfac4bf", "target": 0, "func": "static inline int parse_nal_units(AVCodecParserContext *s,\n\n                                  AVCodecContext *avctx,\n\n                                  const uint8_t *buf, int buf_size)\n\n{\n\n    H264ParseContext *p = s->priv_data;\n\n    const uint8_t *buf_end = buf + buf_size;\n\n\n\n    H2645NAL nal = { NULL };\n\n\n\n    unsigned int pps_id;\n\n    unsigned int slice_type;\n\n    int state = -1, got_reset = 0;\n\n    int field_poc[2];\n\n    int ret;\n\n\n\n    /* set some sane default values */\n\n    s->pict_type         = AV_PICTURE_TYPE_I;\n\n    s->key_frame         = 0;\n\n    s->picture_structure = AV_PICTURE_STRUCTURE_UNKNOWN;\n\n\n\n    ff_h264_sei_uninit(&p->sei);\n\n\n\n    if (!buf_size)\n\n        return 0;\n\n\n\n    for (;;) {\n\n        const SPS *sps;\n\n        int src_length, consumed;\n\n        buf = avpriv_find_start_code(buf, buf_end, &state);\n\n        if (buf >= buf_end)\n\n            break;\n\n        --buf;\n\n        src_length = buf_end - buf;\n\n        switch (state & 0x1f) {\n\n        case H264_NAL_SLICE:\n\n        case H264_NAL_IDR_SLICE:\n\n            // Do not walk the whole buffer just to decode slice header\n\n            if ((state & 0x1f) == H264_NAL_IDR_SLICE || ((state >> 5) & 0x3) == 0) {\n\n                /* IDR or disposable slice\n\n                 * No need to decode many bytes because MMCOs shall not be present. */\n\n                if (src_length > 60)\n\n                    src_length = 60;\n\n            } else {\n\n                /* To decode up to MMCOs */\n\n                if (src_length > 1000)\n\n                    src_length = 1000;\n\n            }\n\n            break;\n\n        }\n\n\n\n        consumed = ff_h2645_extract_rbsp(buf, src_length, &nal);\n\n        if (consumed < 0)\n\n            break;\n\n\n\n        ret = init_get_bits(&nal.gb, nal.data, nal.size * 8);\n\n        if (ret < 0)\n\n            goto fail;\n\n        get_bits1(&nal.gb);\n\n        nal.ref_idc = get_bits(&nal.gb, 2);\n\n        nal.type    = get_bits(&nal.gb, 5);\n\n\n\n        switch (nal.type) {\n\n        case H264_NAL_SPS:\n\n            ff_h264_decode_seq_parameter_set(&nal.gb, avctx, &p->ps);\n\n            break;\n\n        case H264_NAL_PPS:\n\n            ff_h264_decode_picture_parameter_set(&nal.gb, avctx, &p->ps,\n\n                                                 nal.size_bits);\n\n            break;\n\n        case H264_NAL_SEI:\n\n            ff_h264_sei_decode(&p->sei, &nal.gb, &p->ps, avctx);\n\n            break;\n\n        case H264_NAL_IDR_SLICE:\n\n            s->key_frame = 1;\n\n\n\n            p->poc.prev_frame_num        = 0;\n\n            p->poc.prev_frame_num_offset = 0;\n\n            p->poc.prev_poc_msb          =\n\n            p->poc.prev_poc_lsb          = 0;\n\n        /* fall through */\n\n        case H264_NAL_SLICE:\n\n            get_ue_golomb(&nal.gb);  // skip first_mb_in_slice\n\n            slice_type   = get_ue_golomb_31(&nal.gb);\n\n            s->pict_type = ff_h264_golomb_to_pict_type[slice_type % 5];\n\n            if (p->sei.recovery_point.recovery_frame_cnt >= 0) {\n\n                /* key frame, since recovery_frame_cnt is set */\n\n                s->key_frame = 1;\n\n            }\n\n            pps_id = get_ue_golomb(&nal.gb);\n\n            if (pps_id >= MAX_PPS_COUNT) {\n\n                av_log(avctx, AV_LOG_ERROR,\n\n                       \"pps_id %u out of range\\n\", pps_id);\n\n                goto fail;\n\n            }\n\n            if (!p->ps.pps_list[pps_id]) {\n\n                av_log(avctx, AV_LOG_ERROR,\n\n                       \"non-existing PPS %u referenced\\n\", pps_id);\n\n                goto fail;\n\n            }\n\n            p->ps.pps = (const PPS*)p->ps.pps_list[pps_id]->data;\n\n            if (!p->ps.sps_list[p->ps.pps->sps_id]) {\n\n                av_log(avctx, AV_LOG_ERROR,\n\n                       \"non-existing SPS %u referenced\\n\", p->ps.pps->sps_id);\n\n                goto fail;\n\n            }\n\n            p->ps.sps = (SPS*)p->ps.sps_list[p->ps.pps->sps_id]->data;\n\n\n\n            sps = p->ps.sps;\n\n\n\n            p->poc.frame_num = get_bits(&nal.gb, sps->log2_max_frame_num);\n\n\n\n            s->coded_width  = 16 * sps->mb_width;\n\n            s->coded_height = 16 * sps->mb_height;\n\n            s->width        = s->coded_width  - (sps->crop_right + sps->crop_left);\n\n            s->height       = s->coded_height - (sps->crop_top   + sps->crop_bottom);\n\n            if (s->width <= 0 || s->height <= 0) {\n\n                s->width  = s->coded_width;\n\n                s->height = s->coded_height;\n\n            }\n\n\n\n            switch (sps->bit_depth_luma) {\n\n            case 9:\n\n                if (sps->chroma_format_idc == 3)      s->format = AV_PIX_FMT_YUV444P9;\n\n                else if (sps->chroma_format_idc == 2) s->format = AV_PIX_FMT_YUV422P9;\n\n                else                                  s->format = AV_PIX_FMT_YUV420P9;\n\n                break;\n\n            case 10:\n\n                if (sps->chroma_format_idc == 3)      s->format = AV_PIX_FMT_YUV444P10;\n\n                else if (sps->chroma_format_idc == 2) s->format = AV_PIX_FMT_YUV422P10;\n\n                else                                  s->format = AV_PIX_FMT_YUV420P10;\n\n                break;\n\n            case 8:\n\n                if (sps->chroma_format_idc == 3)      s->format = AV_PIX_FMT_YUV444P;\n\n                else if (sps->chroma_format_idc == 2) s->format = AV_PIX_FMT_YUV422P;\n\n                else                                  s->format = AV_PIX_FMT_YUV420P;\n\n                break;\n\n            default:\n\n                s->format = AV_PIX_FMT_NONE;\n\n            }\n\n\n\n            avctx->profile = ff_h264_get_profile(sps);\n\n            avctx->level   = sps->level_idc;\n\n\n\n            if (sps->frame_mbs_only_flag) {\n\n                p->picture_structure = PICT_FRAME;\n\n            } else {\n\n                if (get_bits1(&nal.gb)) { // field_pic_flag\n\n                    p->picture_structure = PICT_TOP_FIELD + get_bits1(&nal.gb); // bottom_field_flag\n\n                } else {\n\n                    p->picture_structure = PICT_FRAME;\n\n                }\n\n            }\n\n\n\n            if (nal.type == H264_NAL_IDR_SLICE)\n\n                get_ue_golomb(&nal.gb); /* idr_pic_id */\n\n            if (sps->poc_type == 0) {\n\n                p->poc.poc_lsb = get_bits(&nal.gb, sps->log2_max_poc_lsb);\n\n\n\n                if (p->ps.pps->pic_order_present == 1 &&\n\n                    p->picture_structure == PICT_FRAME)\n\n                    p->poc.delta_poc_bottom = get_se_golomb(&nal.gb);\n\n            }\n\n\n\n            if (sps->poc_type == 1 &&\n\n                !sps->delta_pic_order_always_zero_flag) {\n\n                p->poc.delta_poc[0] = get_se_golomb(&nal.gb);\n\n\n\n                if (p->ps.pps->pic_order_present == 1 &&\n\n                    p->picture_structure == PICT_FRAME)\n\n                    p->poc.delta_poc[1] = get_se_golomb(&nal.gb);\n\n            }\n\n\n\n            /* Decode POC of this picture.\n\n             * The prev_ values needed for decoding POC of the next picture are not set here. */\n\n            field_poc[0] = field_poc[1] = INT_MAX;\n\n            ff_h264_init_poc(field_poc, &s->output_picture_number, sps,\n\n                             &p->poc, p->picture_structure, nal.ref_idc);\n\n\n\n            /* Continue parsing to check if MMCO_RESET is present.\n\n             * FIXME: MMCO_RESET could appear in non-first slice.\n\n             *        Maybe, we should parse all undisposable non-IDR slice of this\n\n             *        picture until encountering MMCO_RESET in a slice of it. */\n\n            if (nal.ref_idc && nal.type != H264_NAL_IDR_SLICE) {\n\n                got_reset = scan_mmco_reset(s, &nal.gb, avctx);\n\n                if (got_reset < 0)\n\n                    goto fail;\n\n            }\n\n\n\n            /* Set up the prev_ values for decoding POC of the next picture. */\n\n            p->poc.prev_frame_num        = got_reset ? 0 : p->poc.frame_num;\n\n            p->poc.prev_frame_num_offset = got_reset ? 0 : p->poc.frame_num_offset;\n\n            if (nal.ref_idc != 0) {\n\n                if (!got_reset) {\n\n                    p->poc.prev_poc_msb = p->poc.poc_msb;\n\n                    p->poc.prev_poc_lsb = p->poc.poc_lsb;\n\n                } else {\n\n                    p->poc.prev_poc_msb = 0;\n\n                    p->poc.prev_poc_lsb =\n\n                        p->picture_structure == PICT_BOTTOM_FIELD ? 0 : field_poc[0];\n\n                }\n\n            }\n\n\n\n            if (sps->pic_struct_present_flag) {\n\n                switch (p->sei.picture_timing.pic_struct) {\n\n                case SEI_PIC_STRUCT_TOP_FIELD:\n\n                case SEI_PIC_STRUCT_BOTTOM_FIELD:\n\n                    s->repeat_pict = 0;\n\n                    break;\n\n                case SEI_PIC_STRUCT_FRAME:\n\n                case SEI_PIC_STRUCT_TOP_BOTTOM:\n\n                case SEI_PIC_STRUCT_BOTTOM_TOP:\n\n                    s->repeat_pict = 1;\n\n                    break;\n\n                case SEI_PIC_STRUCT_TOP_BOTTOM_TOP:\n\n                case SEI_PIC_STRUCT_BOTTOM_TOP_BOTTOM:\n\n                    s->repeat_pict = 2;\n\n                    break;\n\n                case SEI_PIC_STRUCT_FRAME_DOUBLING:\n\n                    s->repeat_pict = 3;\n\n                    break;\n\n                case SEI_PIC_STRUCT_FRAME_TRIPLING:\n\n                    s->repeat_pict = 5;\n\n                    break;\n\n                default:\n\n                    s->repeat_pict = p->picture_structure == PICT_FRAME ? 1 : 0;\n\n                    break;\n\n                }\n\n            } else {\n\n                s->repeat_pict = p->picture_structure == PICT_FRAME ? 1 : 0;\n\n            }\n\n\n\n            if (p->picture_structure == PICT_FRAME) {\n\n                s->picture_structure = AV_PICTURE_STRUCTURE_FRAME;\n\n                if (sps->pic_struct_present_flag) {\n\n                    switch (p->sei.picture_timing.pic_struct) {\n\n                    case SEI_PIC_STRUCT_TOP_BOTTOM:\n\n                    case SEI_PIC_STRUCT_TOP_BOTTOM_TOP:\n\n                        s->field_order = AV_FIELD_TT;\n\n                        break;\n\n                    case SEI_PIC_STRUCT_BOTTOM_TOP:\n\n                    case SEI_PIC_STRUCT_BOTTOM_TOP_BOTTOM:\n\n                        s->field_order = AV_FIELD_BB;\n\n                        break;\n\n                    default:\n\n                        s->field_order = AV_FIELD_PROGRESSIVE;\n\n                        break;\n\n                    }\n\n                } else {\n\n                    if (field_poc[0] < field_poc[1])\n\n                        s->field_order = AV_FIELD_TT;\n\n                    else if (field_poc[0] > field_poc[1])\n\n                        s->field_order = AV_FIELD_BB;\n\n                    else\n\n                        s->field_order = AV_FIELD_PROGRESSIVE;\n\n                }\n\n            } else {\n\n                if (p->picture_structure == PICT_TOP_FIELD)\n\n                    s->picture_structure = AV_PICTURE_STRUCTURE_TOP_FIELD;\n\n                else\n\n                    s->picture_structure = AV_PICTURE_STRUCTURE_BOTTOM_FIELD;\n\n                s->field_order = AV_FIELD_UNKNOWN;\n\n            }\n\n\n\n            av_freep(&nal.rbsp_buffer);\n\n            return 0; /* no need to evaluate the rest */\n\n        }\n\n        buf += consumed;\n\n    }\n\n    /* didn't find a picture! */\n\n    av_log(avctx, AV_LOG_ERROR, \"missing picture in access unit\\n\");\n\nfail:\n\n    av_freep(&nal.rbsp_buffer);\n\n    return -1;\n\n}\n", "idx": 7609, "substitutes": {"s": ["as", "rs", "styles", "sp", "gs", "ses", "b", "src", "ns", "c", "its", "h", "ats", "ies", "i", "qs", "cs", "os", "uploads", "ps", "ms", "n", "ports", "ts", "is", "ds", "settings", "sets", "t", "es", "pers", "js", "ins", "sv", "ls", "sb", "v", "stats", "spec", "a", "hs", "vs", "ss", "sq", "parts", "ans", "fs", "S", "sts", "changes", "sports", "aws"], "avctx": ["avcontext", "Avcontext", "campkg", "avpkg", "avcv", "Avctx", "camctx", " avcv", "camcv", " avcontext", "Avpkg", " avpkg", "camcontext", "Avcv"], "buf": ["db", "read", "bytes", "result", "uf", "buff", "b", "sofar", "wait", "src", "window", "end", "mem", "pb", "ctx", "br", "pack", "bc", "box", "pad", "cam", "Buffer", "ob", "buffer", "msg", "raw", "seq", "cmd", "bp", "n", "len", "cb", "wb", "queue", "bound", "data", "err", "str", "limit", "ref", "pos", "bar", "pkg", "Buff", "rb", "max", "iter", "checked", "orig", "mb", "port", "block", "done", "bs", "off", "tmp", "cv", "batch", "img", "xff", "fb", "doc", "np", "aka", "lit", "ptr", "count", "length", "vec"], "buf_size": ["buf_length", " buf_loc", "buf_loc", "buf5size", "buf2start", " buf_start", "buf2sent", "buf2ize", "buf2loc", "bufishize", "buf2length", "bufishsize", "bufishsent", "buf_ize", "buf5end", "buf2end", "buf2size", " buf_sent", " buf_length", "buf5ize", "buf_sent", "buf_start", " buf_ize", "bufishloc"], "p": ["par", "sp", "b", "wp", "cp", "ping", "pb", "c", "pc", "h", "ctx", "i", "pro", "pt", "ps", "pa", "d", "bp", "n", "vp", "t", "pers", "pe", "proc", "pkg", "ap", "lp", "v", "m", "per", "jp", "np", "f", "pp", "P", "j", "tp"], "buf_end": ["buf__start", "db_len", "queue_END", "bufxend", "uf_stop", "buf_ends", " buf_ended", "buf_send", "buf_start", "db_send", "queue_start", "buf__ended", "bufxstop", " buf_ends", "uf_start", "buf2end", "buf_END", "buf__ends", "buf_ended", "queue_end", "buf__end", "bufxends", "db_end", "buftstop", "uf_end", "db_End", "buf_stop", "queue_ends", "buf_len", "bufxstart", " buf_start", "buf2send", "buftend", "buf_End", "uf_ends", "buf2End", "buf2len", "buftends", "buftstart"], "pps_id": ["slice_count", "par_count", "sliceuuclass", "par_type", "paruucount", "sliceovcount", "sliceovid", "par_class", "sliceovtype", "par_id", "slice_class", "paruutype", "slice_id", "sliceuutype", "sliceuuid", "sliceuucount", "paruuclass", "sliceovclass", "paruuid"], "slice_type": [" slice_types", " slice_kind", "slice_name", " slice_name", "slice_types", "slice_kind"], "field_poc": ["field_opOC", "field_pos", "field_opoc", "field_hos", "field_apoc", "field_apct", "field_apos", "field_pOC", "field_pct", "field_opos", "field_hoc", "field_opct", "field_hct", "field_apOC", "field_hOC"], "ret": ["gt", "read", "success", "result", "pret", "encrypted", "mem", "it", "Return", "ber", "back", "cont", "ter", "nt", "orted", "rect", "backed", "mt", "rets", "val", "aux", "tr", "usr", "red", "alt", "err", "ref", "rem", "out", "iter", "try", "complete", "rt", "fun", "found", "reset", "re", "tmp", "lit", "RET", "count", "Ret", "conv", "ft", " RET", "res", "def", "elt", "flag"], "sps": ["sfs", "smp", "Sfs", "sPS", " sfs", "Sps", "SPS", "ssps", " smp", "ssPS", "Smp", "ssfs", " sPS", "ssmp"], "src_length": [" src_ength", "src_location", "src_len", " src_distance", " src_code", " src_end", "rc_stream", "src_code", "rc_length", "srcJlength", "srcjstream", "sort_length", "srcJarray", "src_count", "src6len", "src1distance", "src1len", "src_stream", "src_end", "rc_maximum", "src_number", "sys_time", "srcxend", "srcxcode", "srcJtime", "src_array", "srcxlen", "src6ength", "srcjlength", "src_Length", " src_number", "sort_location", "sys_array", "srcjmaximum", "src6length", "src1length", "src_distance", "src_ength", "src_time", "src6Length", "sys_length", " src_count", " src_len", "src_maximum", " src_Length", "src1count", "srcxlength", "sort_time"], "consumed": ["Consumed", "cosumption", " consume", "consume", " unconsumption", "Consumption", "consumers", "reserved", " unconsume", "resumed", "consumption", " unconsumed", " consalted", " unconsalted", "Consumers", "consalted", "Consume", " consumption", "coserved", "resumption", "conserved", "cosumers", "cosume", "resume", "cosumed", "Consalted", "Conserved", " consumers"]}}
{"project": "FFmpeg", "commit_id": "c94326c1fc2fb5719c6f28fe1b95c0c74417998b", "target": 1, "func": "static av_always_inline void FUNC(intra_pred)(HEVCContext *s, int x0, int y0,\n\n                                              int log2_size, int c_idx)\n\n{\n\n#define PU(x) \\\n\n    ((x) >> s->ps.sps->log2_min_pu_size)\n\n#define MVF(x, y) \\\n\n    (s->ref->tab_mvf[(x) + (y) * min_pu_width])\n\n#define MVF_PU(x, y) \\\n\n    MVF(PU(x0 + ((x) << hshift)), PU(y0 + ((y) << vshift)))\n\n#define IS_INTRA(x, y) \\\n\n    (MVF_PU(x, y).pred_flag == PF_INTRA)\n\n#define MIN_TB_ADDR_ZS(x, y) \\\n\n    s->ps.pps->min_tb_addr_zs[(y) * (s->ps.sps->tb_mask+2) + (x)]\n\n#define EXTEND(ptr, val, len)         \\\n\ndo {                                  \\\n\n    pixel4 pix = PIXEL_SPLAT_X4(val); \\\n\n    for (i = 0; i < (len); i += 4)    \\\n\n        AV_WN4P(ptr + i, pix);        \\\n\n} while (0)\n\n\n\n#define EXTEND_RIGHT_CIP(ptr, start, length)                                   \\\n\n        for (i = start; i < (start) + (length); i += 4)                        \\\n\n            if (!IS_INTRA(i, -1))                                              \\\n\n                AV_WN4P(&ptr[i], a);                                           \\\n\n            else                                                               \\\n\n                a = PIXEL_SPLAT_X4(ptr[i+3])\n\n#define EXTEND_LEFT_CIP(ptr, start, length) \\\n\n        for (i = start; i > (start) - (length); i--) \\\n\n            if (!IS_INTRA(i - 1, -1)) \\\n\n                ptr[i - 1] = ptr[i]\n\n#define EXTEND_UP_CIP(ptr, start, length)                                      \\\n\n        for (i = (start); i > (start) - (length); i -= 4)                      \\\n\n            if (!IS_INTRA(-1, i - 3))                                          \\\n\n                AV_WN4P(&ptr[i - 3], a);                                       \\\n\n            else                                                               \\\n\n                a = PIXEL_SPLAT_X4(ptr[i - 3])\n\n#define EXTEND_DOWN_CIP(ptr, start, length)                                    \\\n\n        for (i = start; i < (start) + (length); i += 4)                        \\\n\n            if (!IS_INTRA(-1, i))                                              \\\n\n                AV_WN4P(&ptr[i], a);                                           \\\n\n            else                                                               \\\n\n                a = PIXEL_SPLAT_X4(ptr[i + 3])\n\n\n\n    HEVCLocalContext *lc = s->HEVClc;\n\n    int i;\n\n    int hshift = s->ps.sps->hshift[c_idx];\n\n    int vshift = s->ps.sps->vshift[c_idx];\n\n    int size = (1 << log2_size);\n\n    int size_in_luma_h = size << hshift;\n\n    int size_in_tbs_h  = size_in_luma_h >> s->ps.sps->log2_min_tb_size;\n\n    int size_in_luma_v = size << vshift;\n\n    int size_in_tbs_v  = size_in_luma_v >> s->ps.sps->log2_min_tb_size;\n\n    int x = x0 >> hshift;\n\n    int y = y0 >> vshift;\n\n    int x_tb = (x0 >> s->ps.sps->log2_min_tb_size) & s->ps.sps->tb_mask;\n\n    int y_tb = (y0 >> s->ps.sps->log2_min_tb_size) & s->ps.sps->tb_mask;\n\n\n\n    int cur_tb_addr = MIN_TB_ADDR_ZS(x_tb, y_tb);\n\n\n\n    ptrdiff_t stride = s->frame->linesize[c_idx] / sizeof(pixel);\n\n    pixel *src = (pixel*)s->frame->data[c_idx] + x + y * stride;\n\n\n\n    int min_pu_width = s->ps.sps->min_pu_width;\n\n\n\n    enum IntraPredMode mode = c_idx ? lc->tu.intra_pred_mode_c :\n\n                              lc->tu.intra_pred_mode;\n\n    pixel4 a;\n\n    pixel  left_array[2 * MAX_TB_SIZE + 1];\n\n    pixel  filtered_left_array[2 * MAX_TB_SIZE + 1];\n\n    pixel  top_array[2 * MAX_TB_SIZE + 1];\n\n    pixel  filtered_top_array[2 * MAX_TB_SIZE + 1];\n\n\n\n    pixel  *left          = left_array + 1;\n\n    pixel  *top           = top_array  + 1;\n\n    pixel  *filtered_left = filtered_left_array + 1;\n\n    pixel  *filtered_top  = filtered_top_array  + 1;\n\n    int cand_bottom_left = lc->na.cand_bottom_left && cur_tb_addr > MIN_TB_ADDR_ZS( x_tb - 1, (y_tb + size_in_tbs_v) & s->ps.sps->tb_mask);\n\n    int cand_left        = lc->na.cand_left;\n\n    int cand_up_left     = lc->na.cand_up_left;\n\n    int cand_up          = lc->na.cand_up;\n\n    int cand_up_right    = lc->na.cand_up_right    && cur_tb_addr > MIN_TB_ADDR_ZS((x_tb + size_in_tbs_h) & s->ps.sps->tb_mask, y_tb - 1);\n\n\n\n    int bottom_left_size = (FFMIN(y0 + 2 * size_in_luma_v, s->ps.sps->height) -\n\n                           (y0 + size_in_luma_v)) >> vshift;\n\n    int top_right_size   = (FFMIN(x0 + 2 * size_in_luma_h, s->ps.sps->width) -\n\n                           (x0 + size_in_luma_h)) >> hshift;\n\n\n\n    if (s->ps.pps->constrained_intra_pred_flag == 1) {\n\n        int size_in_luma_pu_v = PU(size_in_luma_v);\n\n        int size_in_luma_pu_h = PU(size_in_luma_h);\n\n        int on_pu_edge_x    = !av_mod_uintp2(x0, s->ps.sps->log2_min_pu_size);\n\n        int on_pu_edge_y    = !av_mod_uintp2(y0, s->ps.sps->log2_min_pu_size);\n\n        if (!size_in_luma_pu_h)\n\n            size_in_luma_pu_h++;\n\n        if (cand_bottom_left == 1 && on_pu_edge_x) {\n\n            int x_left_pu   = PU(x0 - 1);\n\n            int y_bottom_pu = PU(y0 + size_in_luma_v);\n\n            int max = FFMIN(size_in_luma_pu_v, s->ps.sps->min_pu_height - y_bottom_pu);\n\n            cand_bottom_left = 0;\n\n            for (i = 0; i < max; i += 2)\n\n                cand_bottom_left |= (MVF(x_left_pu, y_bottom_pu + i).pred_flag == PF_INTRA);\n\n        }\n\n        if (cand_left == 1 && on_pu_edge_x) {\n\n            int x_left_pu   = PU(x0 - 1);\n\n            int y_left_pu   = PU(y0);\n\n            int max = FFMIN(size_in_luma_pu_v, s->ps.sps->min_pu_height - y_left_pu);\n\n            cand_left = 0;\n\n            for (i = 0; i < max; i += 2)\n\n                cand_left |= (MVF(x_left_pu, y_left_pu + i).pred_flag == PF_INTRA);\n\n        }\n\n        if (cand_up_left == 1) {\n\n            int x_left_pu   = PU(x0 - 1);\n\n            int y_top_pu    = PU(y0 - 1);\n\n            cand_up_left = MVF(x_left_pu, y_top_pu).pred_flag == PF_INTRA;\n\n        }\n\n        if (cand_up == 1 && on_pu_edge_y) {\n\n            int x_top_pu    = PU(x0);\n\n            int y_top_pu    = PU(y0 - 1);\n\n            int max = FFMIN(size_in_luma_pu_h, s->ps.sps->min_pu_width - x_top_pu);\n\n            cand_up = 0;\n\n            for (i = 0; i < max; i += 2)\n\n                cand_up |= (MVF(x_top_pu + i, y_top_pu).pred_flag == PF_INTRA);\n\n        }\n\n        if (cand_up_right == 1 && on_pu_edge_y) {\n\n            int y_top_pu    = PU(y0 - 1);\n\n            int x_right_pu  = PU(x0 + size_in_luma_h);\n\n            int max = FFMIN(size_in_luma_pu_h, s->ps.sps->min_pu_width - x_right_pu);\n\n            cand_up_right = 0;\n\n            for (i = 0; i < max; i += 2)\n\n                cand_up_right |= (MVF(x_right_pu + i, y_top_pu).pred_flag == PF_INTRA);\n\n        }\n\n        memset(left, 128, 2 * MAX_TB_SIZE*sizeof(pixel));\n\n        memset(top , 128, 2 * MAX_TB_SIZE*sizeof(pixel));\n\n        top[-1] = 128;\n\n    }\n\n    if (cand_up_left) {\n\n        left[-1] = POS(-1, -1);\n\n        top[-1]  = left[-1];\n\n    }\n\n    if (cand_up)\n\n        memcpy(top, src - stride, size * sizeof(pixel));\n\n    if (cand_up_right) {\n\n        memcpy(top + size, src - stride + size, size * sizeof(pixel));\n\n        EXTEND(top + size + top_right_size, POS(size + top_right_size - 1, -1),\n\n               size - top_right_size);\n\n    }\n\n    if (cand_left)\n\n        for (i = 0; i < size; i++)\n\n            left[i] = POS(-1, i);\n\n    if (cand_bottom_left) {\n\n        for (i = size; i < size + bottom_left_size; i++)\n\n            left[i] = POS(-1, i);\n\n        EXTEND(left + size + bottom_left_size, POS(-1, size + bottom_left_size - 1),\n\n               size - bottom_left_size);\n\n    }\n\n\n\n    if (s->ps.pps->constrained_intra_pred_flag == 1) {\n\n        if (cand_bottom_left || cand_left || cand_up_left || cand_up || cand_up_right) {\n\n            int size_max_x = x0 + ((2 * size) << hshift) < s->ps.sps->width ?\n\n                                    2 * size : (s->ps.sps->width - x0) >> hshift;\n\n            int size_max_y = y0 + ((2 * size) << vshift) < s->ps.sps->height ?\n\n                                    2 * size : (s->ps.sps->height - y0) >> vshift;\n\n            int j = size + (cand_bottom_left? bottom_left_size: 0) -1;\n\n            if (!cand_up_right) {\n\n                size_max_x = x0 + ((size) << hshift) < s->ps.sps->width ?\n\n                                                    size : (s->ps.sps->width - x0) >> hshift;\n\n            }\n\n            if (!cand_bottom_left) {\n\n                size_max_y = y0 + (( size) << vshift) < s->ps.sps->height ?\n\n                                                     size : (s->ps.sps->height - y0) >> vshift;\n\n            }\n\n            if (cand_bottom_left || cand_left || cand_up_left) {\n\n                while (j > -1 && !IS_INTRA(-1, j))\n\n                    j--;\n\n                if (!IS_INTRA(-1, j)) {\n\n                    j = 0;\n\n                    while (j < size_max_x && !IS_INTRA(j, -1))\n\n                        j++;\n\n                    EXTEND_LEFT_CIP(top, j, j + 1);\n\n                    left[-1] = top[-1];\n\n                }\n\n            } else {\n\n                j = 0;\n\n                while (j < size_max_x && !IS_INTRA(j, -1))\n\n                    j++;\n\n                if (j > 0)\n\n                    if (x0 > 0) {\n\n                        EXTEND_LEFT_CIP(top, j, j + 1);\n\n                    } else {\n\n                        EXTEND_LEFT_CIP(top, j, j);\n\n                        top[-1] = top[0];\n\n                    }\n\n                left[-1] = top[-1];\n\n            }\n\n            left[-1] = top[-1];\n\n            if (cand_bottom_left || cand_left) {\n\n                a = PIXEL_SPLAT_X4(left[-1]);\n\n                EXTEND_DOWN_CIP(left, 0, size_max_y);\n\n            }\n\n            if (!cand_left)\n\n                EXTEND(left, left[-1], size);\n\n            if (!cand_bottom_left)\n\n                EXTEND(left + size, left[size - 1], size);\n\n            if (x0 != 0 && y0 != 0) {\n\n                a = PIXEL_SPLAT_X4(left[size_max_y - 1]);\n\n                EXTEND_UP_CIP(left, size_max_y - 1, size_max_y);\n\n                if (!IS_INTRA(-1, - 1))\n\n                    left[-1] = left[0];\n\n            } else if (x0 == 0) {\n\n                EXTEND(left, 0, size_max_y);\n\n            } else {\n\n                a = PIXEL_SPLAT_X4(left[size_max_y - 1]);\n\n                EXTEND_UP_CIP(left, size_max_y - 1, size_max_y);\n\n            }\n\n            top[-1] = left[-1];\n\n            if (y0 != 0) {\n\n                a = PIXEL_SPLAT_X4(left[-1]);\n\n                EXTEND_RIGHT_CIP(top, 0, size_max_x);\n\n            }\n\n        }\n\n    }\n\n    // Infer the unavailable samples\n\n    if (!cand_bottom_left) {\n\n        if (cand_left) {\n\n            EXTEND(left + size, left[size - 1], size);\n\n        } else if (cand_up_left) {\n\n            EXTEND(left, left[-1], 2 * size);\n\n            cand_left = 1;\n\n        } else if (cand_up) {\n\n            left[-1] = top[0];\n\n            EXTEND(left, left[-1], 2 * size);\n\n            cand_up_left = 1;\n\n            cand_left    = 1;\n\n        } else if (cand_up_right) {\n\n            EXTEND(top, top[size], size);\n\n            left[-1] = top[size];\n\n            EXTEND(left, left[-1], 2 * size);\n\n            cand_up      = 1;\n\n            cand_up_left = 1;\n\n            cand_left    = 1;\n\n        } else { // No samples available\n\n            left[-1] = (1 << (BIT_DEPTH - 1));\n\n            EXTEND(top,  left[-1], 2 * size);\n\n            EXTEND(left, left[-1], 2 * size);\n\n        }\n\n    }\n\n\n\n    if (!cand_left)\n\n        EXTEND(left, left[size], size);\n\n    if (!cand_up_left) {\n\n        left[-1] = left[0];\n\n    }\n\n    if (!cand_up)\n\n        EXTEND(top, left[-1], size);\n\n    if (!cand_up_right)\n\n        EXTEND(top + size, top[size - 1], size);\n\n\n\n    top[-1] = left[-1];\n\n\n\n    // Filtering process\n\n    if (!s->ps.sps->intra_smoothing_disabled_flag && (c_idx == 0  || s->ps.sps->chroma_format_idc == 3)) {\n\n        if (mode != INTRA_DC && size != 4){\n\n            int intra_hor_ver_dist_thresh[] = { 7, 1, 0 };\n\n            int min_dist_vert_hor = FFMIN(FFABS((int)(mode - 26U)),\n\n                                          FFABS((int)(mode - 10U)));\n\n            if (min_dist_vert_hor > intra_hor_ver_dist_thresh[log2_size - 3]) {\n\n                int threshold = 1 << (BIT_DEPTH - 5);\n\n                if (s->ps.sps->sps_strong_intra_smoothing_enable_flag && c_idx == 0 &&\n\n                    log2_size == 5 &&\n\n                    FFABS(top[-1]  + top[63]  - 2 * top[31])  < threshold &&\n\n                    FFABS(left[-1] + left[63] - 2 * left[31]) < threshold) {\n\n                    // We can't just overwrite values in top because it could be\n\n                    // a pointer into src\n\n                    filtered_top[-1] = top[-1];\n\n                    filtered_top[63] = top[63];\n\n                    for (i = 0; i < 63; i++)\n\n                        filtered_top[i] = ((64 - (i + 1)) * top[-1] +\n\n                                           (i + 1)  * top[63] + 32) >> 6;\n\n                    for (i = 0; i < 63; i++)\n\n                        left[i] = ((64 - (i + 1)) * left[-1] +\n\n                                   (i + 1)  * left[63] + 32) >> 6;\n\n                    top = filtered_top;\n\n                } else {\n\n                    filtered_left[2 * size - 1] = left[2 * size - 1];\n\n                    filtered_top[2 * size - 1]  = top[2 * size - 1];\n\n                    for (i = 2 * size - 2; i >= 0; i--)\n\n                        filtered_left[i] = (left[i + 1] + 2 * left[i] +\n\n                                            left[i - 1] + 2) >> 2;\n\n                    filtered_top[-1]  =\n\n                    filtered_left[-1] = (left[0] + 2 * left[-1] + top[0] + 2) >> 2;\n\n                    for (i = 2 * size - 2; i >= 0; i--)\n\n                        filtered_top[i] = (top[i + 1] + 2 * top[i] +\n\n                                           top[i - 1] + 2) >> 2;\n\n                    left = filtered_left;\n\n                    top  = filtered_top;\n\n                }\n\n            }\n\n        }\n\n    }\n\n\n\n    switch (mode) {\n\n    case INTRA_PLANAR:\n\n        s->hpc.pred_planar[log2_size - 2]((uint8_t *)src, (uint8_t *)top,\n\n                                          (uint8_t *)left, stride);\n\n        break;\n\n    case INTRA_DC:\n\n        s->hpc.pred_dc((uint8_t *)src, (uint8_t *)top,\n\n                       (uint8_t *)left, stride, log2_size, c_idx);\n\n        break;\n\n    default:\n\n        s->hpc.pred_angular[log2_size - 2]((uint8_t *)src, (uint8_t *)top,\n\n                                           (uint8_t *)left, stride, c_idx,\n\n                                           mode);\n\n        break;\n\n    }\n\n}\n", "idx": 7622, "substitutes": {"s": ["rs", "gs", "b", "ns", "c", "ctx", "h", "cs", "os", "ps", "p", "ms", "g", "n", "is", "ts", "ds", "t", "w", "js", "ins", "v", "ss", "fs", "e", "S"], "x0": ["rx0", " x2", "ex2", "x1", "ex1", " x1", "rx2", "x2", "ex0", "rx1"], "y0": ["b1", "gyElement", "yElement", "bElement", "b0", "gy0", "gy1", " yElement", "y1", " y1"], "log2_size": ["log3_size", "log3_SIZE", "log3_len", "log2_len", "log2_SIZE"], "c_idx": ["c_nx", "c_ridxs", "c_ridg", "c_ridy", "c_Idx", "c_idxs", "c_idg", "c_Idg", "c_Idy", "c_ridx", "c_ng", "c_Idxs", "c_nxs", "c_idy", "c_ny"], "i": ["init", "ic", "ini", "ij", "q", "ei", "ci", "it", "u", "cli", "oi", "gi", "mi", "qi", "ip", "li", "g", "si", "p", "zi", "is", "xi", "ind", "index", "t", "hi", "bi", "pi", "multi", "me", "ui", "id", "ki", "ji", "phi", "ti", "ims", "ix", "ai", "m", "status", "I", "iu", "in", "di", "ni", "ii"], "a": ["as", "b", "c", "ma", "alpha", "aaa", "xa", "at", "ta", "aa", "A", "ava", "aux", "na", "t", "va", "an", "ap", "au", "ea", "sa", "ac", "la", "ca", "alias", "am", "area", "ba"]}}
{"project": "FFmpeg", "commit_id": "6f3d2fb18bb6225c27e22a95846c42f2093dc3b7", "target": 0, "func": "static void end_last_frame(AVFilterContext *ctx)\n\n{\n\n    TileContext *tile    = ctx->priv;\n\n    AVFilterLink *outlink = ctx->outputs[0];\n\n    AVFilterBufferRef *out_buf = outlink->out_buf;\n\n\n\n    outlink->out_buf = NULL;\n\n    ff_start_frame(outlink, out_buf);\n\n    while (tile->current < tile->nb_frames)\n\n        draw_blank_frame(ctx, out_buf);\n\n    ff_draw_slice(outlink, 0, out_buf->video->h, 1);\n\n    ff_end_frame(outlink);\n\n    tile->current = 0;\n\n}\n", "idx": 7649, "substitutes": {"ctx": ["ck", "cf", "ij", "loc", "gc", "setup", "ct", "ctl", "gm", "cp", "c", "kt", "cmp", "bc", "anc", "fx", "wx", "sc", "fc", "cm", "cmd", " cx", "nc", "piece", "context", "cb", "ind", "lc", "hw", "kl", "xc", "js", "cc", "pkg", "xs", "kw", "tz", "req", "cfg", "resp", "jac", "gru", "fn", "tx", "cv", "desc", "jp", "np", "mc", "obj", "qt", "kb", "Context", "conn", "tc", "act"], "tile": ["TI", "thread", "draw", "tiny", "tree", "feat", "node", "window", "term", "kt", "color", "offset", "store", "toggle", "buffer", "template", "te", "til", "table", "util", "chip", "ts", "piece", "tty", "Tile", "tif", "texture", "key", "sel", "col", "scale", "th", "slice", "trace", "entity", "unit", " Tile", "sil", "module", "ti", "tip", "num", "tu", "feature", "port", "pixel", "cell", "frame", "shot", "tier", "grid", "tf", "cache", "mask", "vt", "count", "sim", "info", "tc", "tool", "ace", "tle", "detail", "il", "title", "coord", "ten"], "outlink": ["outgroup", "otlay", "outerlinked", " outpack", "offlink", "outlet", "olay", "Outpack", "outergate", "outgate", " outln", "Outline", "outputlink", "outerlink", "outcheck", "oulink", " outgroup", "Outgate", " outlay", "Outlink", "otgroup", "otlink", "connpack", "oloop", "gatelink", "outputcheck", "gateln", "olink", "otloop", "oulet", "oucheck", "outlinked", " outlinked", "offLink", "offlinked", "outloop", " outLink", " outloop", "connLink", "otln", "outerline", " outgate", "gategroup", "connlink", "outln", "outlay", "outline", "outputlet", " outline", " outcheck", "outLink", "Outlinked", "outpack", "OutLink", " outlet"], "out_buf": ["out___uf", "out2uf", "in_mem", "out64Buff", "out_comb", "out_buffer", "outbufbuf", "out_db", "out__buff", " out_msg", "outMemtab", "out__buffer", "outbufbuffer", "out_mem", "out_msg", "in_buf", "out64buf", "out_cb", "out64msg", " out_tab", "outMemuf", "outMembuf", "out__buf", "in_buffer", "out___buf", "out_buff", "out64uf", "in_cb", "out_uf", "outbufbuff", "outMemcomb", " out_buff", "out2buf", " out_db", "out_tab", "out__cb", " out_uf", "in_buff", " out_comb", "outbufmem", "out2buff", " out_Buff", "out___db", "out_Buff"]}}
{"project": "FFmpeg", "commit_id": "4b1f5e5090abed6c618c8ba380cd7d28d140f867", "target": 0, "func": "void av_register_output_format(AVOutputFormat *format)\n\n{\n\n    AVOutputFormat **p = &first_oformat;\n\n\n\n    while (*p != NULL)\n\n        p = &(*p)->next;\n\n\n\n    *p = format;\n\n    format->next = NULL;\n\n}\n", "idx": 7651, "substitutes": {"format": ["output", "init", "package", "form", "feat", "function", "layout", "prefix", "type", "flat", "ats", "null", "get", "join", "set", "mat", "file", "AT", "template", "fc", "raw", "at", "mt", "missing", "vp", "op", "MAT", "data", "fp", "unit", "to", "list", "pre", "style", "v", "transform", "reset", "port", "config", "new", "Format", "fn", "version", "parse", "print", "cat", "f", "html", "text", "name"], "p": ["post", "pid", "peer", "par", "q", "sp", "b", "it", "wp", "cp", "ping", "pb", "c", "pc", "h", "rep", "pad", "pro", "i", "pod", "er", "ps", "pa", "g", "bp", "d", "pat", "vp", "op", "pair", "o", "pl", "fp", "t", "pers", "ep", "pkg", "proc", "ap", "pr", "k", "lp", "port", "m", "part", "per", "parse", "y", "jp", "np", "f", "pp", "P", "point", "j", "a", "tp", "l"]}}
{"project": "qemu", "commit_id": "d5de7839d78b08c7bd14b03dac0413699b90da67", "target": 1, "func": "static void decode_32Bit_opc(CPUTriCoreState *env, DisasContext *ctx)\n\n{\n\n    int op1;\n\n    int32_t r1, r2, r3;\n\n    int32_t address, const16;\n\n    int8_t b, const4;\n\n    int32_t bpos;\n\n    TCGv temp, temp2, temp3;\n\n\n\n    op1 = MASK_OP_MAJOR(ctx->opcode);\n\n\n\n    /* handle JNZ.T opcode only being 7 bit long */\n\n    if (unlikely((op1 & 0x7f) == OPCM_32_BRN_JTT)) {\n\n        op1 = OPCM_32_BRN_JTT;\n\n    }\n\n\n\n    switch (op1) {\n\n/* ABS-format */\n\n    case OPCM_32_ABS_LDW:\n\n        decode_abs_ldw(env, ctx);\n\n\n    case OPCM_32_ABS_LDB:\n\n        decode_abs_ldb(env, ctx);\n\n\n    case OPCM_32_ABS_LDMST_SWAP:\n\n        decode_abs_ldst_swap(env, ctx);\n\n\n    case OPCM_32_ABS_LDST_CONTEXT:\n\n        decode_abs_ldst_context(env, ctx);\n\n\n    case OPCM_32_ABS_STORE:\n\n        decode_abs_store(env, ctx);\n\n\n    case OPCM_32_ABS_STOREB_H:\n\n        decode_abs_storeb_h(env, ctx);\n\n\n    case OPC1_32_ABS_STOREQ:\n\n        address = MASK_OP_ABS_OFF18(ctx->opcode);\n\n        r1 = MASK_OP_ABS_S1D(ctx->opcode);\n\n        temp = tcg_const_i32(EA_ABS_FORMAT(address));\n\n        temp2 = tcg_temp_new();\n\n\n\n        tcg_gen_shri_tl(temp2, cpu_gpr_d[r1], 16);\n\n        tcg_gen_qemu_st_tl(temp2, temp, ctx->mem_idx, MO_LEUW);\n\n\n\n        tcg_temp_free(temp2);\n\n        tcg_temp_free(temp);\n\n\n    case OPC1_32_ABS_LD_Q:\n\n        address = MASK_OP_ABS_OFF18(ctx->opcode);\n\n        r1 = MASK_OP_ABS_S1D(ctx->opcode);\n\n        temp = tcg_const_i32(EA_ABS_FORMAT(address));\n\n\n\n        tcg_gen_qemu_ld_tl(cpu_gpr_d[r1], temp, ctx->mem_idx, MO_LEUW);\n\n        tcg_gen_shli_tl(cpu_gpr_d[r1], cpu_gpr_d[r1], 16);\n\n\n\n        tcg_temp_free(temp);\n\n\n    case OPC1_32_ABS_LEA:\n\n        address = MASK_OP_ABS_OFF18(ctx->opcode);\n\n        r1 = MASK_OP_ABS_S1D(ctx->opcode);\n\n        tcg_gen_movi_tl(cpu_gpr_a[r1], EA_ABS_FORMAT(address));\n\n\n/* ABSB-format */\n\n    case OPC1_32_ABSB_ST_T:\n\n        address = MASK_OP_ABS_OFF18(ctx->opcode);\n\n        b = MASK_OP_ABSB_B(ctx->opcode);\n\n        bpos = MASK_OP_ABSB_BPOS(ctx->opcode);\n\n\n\n        temp = tcg_const_i32(EA_ABS_FORMAT(address));\n\n        temp2 = tcg_temp_new();\n\n\n\n        tcg_gen_qemu_ld_tl(temp2, temp, ctx->mem_idx, MO_UB);\n\n        tcg_gen_andi_tl(temp2, temp2, ~(0x1u << bpos));\n\n        tcg_gen_ori_tl(temp2, temp2, (b << bpos));\n\n        tcg_gen_qemu_st_tl(temp2, temp, ctx->mem_idx, MO_UB);\n\n\n\n        tcg_temp_free(temp);\n\n        tcg_temp_free(temp2);\n\n\n/* B-format */\n\n    case OPC1_32_B_CALL:\n\n    case OPC1_32_B_CALLA:\n\n    case OPC1_32_B_J:\n\n    case OPC1_32_B_JA:\n\n    case OPC1_32_B_JL:\n\n    case OPC1_32_B_JLA:\n\n        address = MASK_OP_B_DISP24(ctx->opcode);\n\n        gen_compute_branch(ctx, op1, 0, 0, 0, address);\n\n\n/* Bit-format */\n\n    case OPCM_32_BIT_ANDACC:\n\n        decode_bit_andacc(env, ctx);\n\n\n    case OPCM_32_BIT_LOGICAL_T1:\n\n        decode_bit_logical_t(env, ctx);\n\n\n    case OPCM_32_BIT_INSERT:\n\n        decode_bit_insert(env, ctx);\n\n\n    case OPCM_32_BIT_LOGICAL_T2:\n\n        decode_bit_logical_t2(env, ctx);\n\n\n    case OPCM_32_BIT_ORAND:\n\n        decode_bit_orand(env, ctx);\n\n\n    case OPCM_32_BIT_SH_LOGIC1:\n\n        decode_bit_sh_logic1(env, ctx);\n\n\n    case OPCM_32_BIT_SH_LOGIC2:\n\n        decode_bit_sh_logic2(env, ctx);\n\n\n    /* BO Format */\n\n    case OPCM_32_BO_ADDRMODE_POST_PRE_BASE:\n\n        decode_bo_addrmode_post_pre_base(env, ctx);\n\n\n    case OPCM_32_BO_ADDRMODE_BITREVERSE_CIRCULAR:\n\n        decode_bo_addrmode_bitreverse_circular(env, ctx);\n\n\n    case OPCM_32_BO_ADDRMODE_LD_POST_PRE_BASE:\n\n        decode_bo_addrmode_ld_post_pre_base(env, ctx);\n\n\n    case OPCM_32_BO_ADDRMODE_LD_BITREVERSE_CIRCULAR:\n\n        decode_bo_addrmode_ld_bitreverse_circular(env, ctx);\n\n\n    case OPCM_32_BO_ADDRMODE_STCTX_POST_PRE_BASE:\n\n        decode_bo_addrmode_stctx_post_pre_base(env, ctx);\n\n\n    case OPCM_32_BO_ADDRMODE_LDMST_BITREVERSE_CIRCULAR:\n\n        decode_bo_addrmode_ldmst_bitreverse_circular(env, ctx);\n\n\n/* BOL-format */\n\n    case OPC1_32_BOL_LD_A_LONGOFF:\n\n    case OPC1_32_BOL_LD_W_LONGOFF:\n\n    case OPC1_32_BOL_LEA_LONGOFF:\n\n    case OPC1_32_BOL_ST_W_LONGOFF:\n\n    case OPC1_32_BOL_ST_A_LONGOFF:\n\n        decode_bol_opc(env, ctx, op1);\n\n\n/* BRC Format */\n\n    case OPCM_32_BRC_EQ_NEQ:\n\n    case OPCM_32_BRC_GE:\n\n    case OPCM_32_BRC_JLT:\n\n    case OPCM_32_BRC_JNE:\n\n        const4 = MASK_OP_BRC_CONST4_SEXT(ctx->opcode);\n\n        address = MASK_OP_BRC_DISP15_SEXT(ctx->opcode);\n\n        r1 = MASK_OP_BRC_S1(ctx->opcode);\n\n        gen_compute_branch(ctx, op1, r1, 0, const4, address);\n\n\n/* BRN Format */\n\n    case OPCM_32_BRN_JTT:\n\n        address = MASK_OP_BRN_DISP15_SEXT(ctx->opcode);\n\n        r1 = MASK_OP_BRN_S1(ctx->opcode);\n\n        gen_compute_branch(ctx, op1, r1, 0, 0, address);\n\n\n/* BRR Format */\n\n    case OPCM_32_BRR_EQ_NEQ:\n\n    case OPCM_32_BRR_ADDR_EQ_NEQ:\n\n    case OPCM_32_BRR_GE:\n\n    case OPCM_32_BRR_JLT:\n\n    case OPCM_32_BRR_JNE:\n\n    case OPCM_32_BRR_JNZ:\n\n    case OPCM_32_BRR_LOOP:\n\n        address = MASK_OP_BRR_DISP15_SEXT(ctx->opcode);\n\n        r2 = MASK_OP_BRR_S2(ctx->opcode);\n\n        r1 = MASK_OP_BRR_S1(ctx->opcode);\n\n        gen_compute_branch(ctx, op1, r1, r2, 0, address);\n\n\n/* RC Format */\n\n    case OPCM_32_RC_LOGICAL_SHIFT:\n\n        decode_rc_logical_shift(env, ctx);\n\n\n    case OPCM_32_RC_ACCUMULATOR:\n\n        decode_rc_accumulator(env, ctx);\n\n\n    case OPCM_32_RC_SERVICEROUTINE:\n\n        decode_rc_serviceroutine(env, ctx);\n\n\n    case OPCM_32_RC_MUL:\n\n        decode_rc_mul(env, ctx);\n\n\n/* RCPW Format */\n\n    case OPCM_32_RCPW_MASK_INSERT:\n\n        decode_rcpw_insert(env, ctx);\n\n\n/* RCRR Format */\n\n    case OPC1_32_RCRR_INSERT:\n\n        r1 = MASK_OP_RCRR_S1(ctx->opcode);\n\n        r2 = MASK_OP_RCRR_S3(ctx->opcode);\n\n        r3 = MASK_OP_RCRR_D(ctx->opcode);\n\n        const16 = MASK_OP_RCRR_CONST4(ctx->opcode);\n\n        temp = tcg_const_i32(const16);\n\n        temp2 = tcg_temp_new(); /* width*/\n\n        temp3 = tcg_temp_new(); /* pos */\n\n\n\n        tcg_gen_andi_tl(temp2, cpu_gpr_d[r3+1], 0x1f);\n\n        tcg_gen_andi_tl(temp3, cpu_gpr_d[r3], 0x1f);\n\n\n\n        gen_insert(cpu_gpr_d[r2], cpu_gpr_d[r1], temp, temp2, temp3);\n\n\n\n        tcg_temp_free(temp);\n\n        tcg_temp_free(temp2);\n\n        tcg_temp_free(temp3);\n\n\n/* RCRW Format */\n\n    case OPCM_32_RCRW_MASK_INSERT:\n\n        decode_rcrw_insert(env, ctx);\n\n\n/* RCR Format */\n\n    case OPCM_32_RCR_COND_SELECT:\n\n        decode_rcr_cond_select(env, ctx);\n\n\n    case OPCM_32_RCR_MADD:\n\n        decode_rcr_madd(env, ctx);\n\n\n    case OPCM_32_RCR_MSUB:\n\n        decode_rcr_msub(env, ctx);\n\n\n/* RLC Format */\n\n    case OPC1_32_RLC_ADDI:\n\n    case OPC1_32_RLC_ADDIH:\n\n    case OPC1_32_RLC_ADDIH_A:\n\n    case OPC1_32_RLC_MFCR:\n\n    case OPC1_32_RLC_MOV:\n\n    case OPC1_32_RLC_MOV_64:\n\n    case OPC1_32_RLC_MOV_U:\n\n    case OPC1_32_RLC_MOV_H:\n\n    case OPC1_32_RLC_MOVH_A:\n\n    case OPC1_32_RLC_MTCR:\n\n        decode_rlc_opc(env, ctx, op1);\n\n\n\n\n\n\n    }\n\n}", "idx": 7654, "substitutes": {"env": ["init", "network", "ev", "et", "esc", "event", "window", "ov", "conf", "kh", "den", "er", "erd", "enter", "cmd", "inv", "ec", "vp", "ew", "viron", "eng", "context", "environment", "eh", "dev", "hw", "cb", "server", "query", "pkg", "sv", "code", "en", "v", "nv", "vs", "estate", "serv", "tx", "cv", "entry", "vt", "obj", "qt", "vm", "e", "conn", "nw", "ten"], "ctx": ["ck", "gc", "event", "conf", "kt", "scope", "sc", "ann", "addr", "cb", "wk", "js", "crit", "xs", "that", "txt", "req", "tmp", "batch", "jp", "mc", "xp", "work", "params", "loc", "HK", "kh", "cam", "mom", "mk", "context", "tz", "config", " context", "serv", "exec", "np", "check", "tk", "ct", "bc", "msg", " cx", "cm", "std", "hw", "pkg", "kw", "cfg", "cv", "kb", "act", "init", "sp", "cas", "cp", "wcs", "cmp", "wx", "cmd", "bp", "func", "cc", "xc", "proc", "scl", "jac", "resp", "tx", "gz", "handler", "obj", "qt", "conn", "def", "nw", "tc"], "op1": ["opId", " pop2", "oc11", "OPId", "oc101", "opn", "op2", " op0", "op01", "op11", " op2", "op101", " op01", "hop0", "OpOnly", "hop2", "OP0", "popn", "copId", "cop11", "cop01", "cop101", " pop0", "pop1", "OP01", "OPn", " pop1", "op0", "oc1", "cop0", "cop2", " opn", "hop1", "hop01", "cop1", "Op2", "hop11", "OP2", "pop01", "pop2", "Op0", " opOnly", "OP1", "opOnly", " opId", "oc01", " popOnly", "hop101", "Op1"], "r1": [" r0", "rone", " r7", "rank1", "R3", "rcone", "rank7", " rMap", "rOne", "rond", "Rone", "R1", "rankond", "rMap", "ROne", "r0", " rone", "rcMap", "Rond", "rc3", " rond", " rOne", "rc1", "RMap", "R0", "r7", "R7", "R2", "rc0", "rank2", "rcOne"], "r2": [" r0", "rtwo", "t02", "r02", "m02", " r02", "mtwo", " rtwo", "t2", "t0", "r0", "m0", "ttwo", "m2"], "r3": ["Rard", "R1", "m1", "R03", "m03", "r03", "m3", "R3", " r03", "mard", "rard", " rard"], "address": ["assembly", "prefix", "type", "asm", "operation", "argument", "offset", "store", "vector", "execute", "buffer", "base", "addr", "order", "table", "location", "network", "context", "option", "index", "pointer", "value", "ach", "position", "byte", "trace", "attribute", "number", "word", "resource", "distance", "angle", "memory", "Address", "command", "ash", "block", "ai", "port", "comment", "action", "phrase", "ptr", "alias", "message", "shape", "point", "directory", "length", "interface", "bm", "ase", "ace", "a", "variable", "reference", "name", "condition"], "const16": ["inst15", "cont12", "const15", "inst16", " const12", " const8", "inst8", "const12", " const15", "inst12", "cont16", "cont8", "const8", "cont15"], "b": ["db", "ab", "eb", "ib", "br", "bc", "binary", "ob", "buffer", "base", "p", "bp", "cb", "bi", "bb", "sb", "bf", "bin", "v", "be", "mb", "block", "B", "nb", "bs", "bl", "bm", "a", "ba"], "const4": ["const44", "const64", " const8", "cont64", "cont4", "Const8", "Const44", "Const4", " const64", " const44", "cont8", "const8", "cont44", "Const64"], "bpos": ["bbposition", "cbindex", "abposition", "bindex", "bbindex", "cbpos", "abindex", "bbpos", "cboffset", "boffset", "cbposition", "bboffset", "aboffset", "bposition", "abpos"], "temp": ["fake", " Temp", "Temp", "mem", "prefix", "term", "stem", "tem", "tar", "pt", "mi", "buffer", "ta", "template", "ip", "map", "base", "p", "timer", "tm", "typ", "mint", "tim", "context", "tr", "index", "perature", "t", "emp", "height", "input", "w", " temperature", "unt", "pre", "master", "txt", "memory", "cap", "port", "status", "tab", "tmp", "ptr", "local", "mm", "cache", "current", "mod", "test", "time", "EMP", "tc", "mp"], "temp2": ["temp5", "pt1", "tem5", "template2", " temp1", "template7", "pt2", "tmp4", " temp5", "temp02", "tem2", "temp4", "tem3", "tmp7", "emp1", "template1", "temTwo", "tem22", "ptr3", "temor", " temp4", "tem1", "ptr02", "emp2", "tmp02", "emp5", "temp7", "temp22", "tmp3", "ptr2", "template22", "ptr22", "empor", "tempTwo", "tmp22", "tempor", "tmp1", "tem02", "temp1", "tem7", "tem4", "tmp2", "templateTwo", "tmp5", "ptTwo", "tmpor"], "temp3": ["t03", "temp03", "tmp6", "t6", "tmp03", "m3", "tmp2", "t2", "tmp3", "temp6", "m2", "m03", "m6", "t3"]}}
{"project": "FFmpeg", "commit_id": "a150bad4062a29fc11b32117bc1ade38115cd95b", "target": 0, "func": "AVFilterBufferRef *avfilter_get_video_buffer_ref_from_frame(const AVFrame *frame,\n\n                                                            int perms)\n\n{\n\n    AVFilterBufferRef *picref =\n\n        avfilter_get_video_buffer_ref_from_arrays(frame->data, frame->linesize, perms,\n\n                                                  frame->width, frame->height,\n\n                                                  frame->format);\n\n    if (!picref)\n\n        return NULL;\n\n    avfilter_copy_frame_props(picref, frame);\n\n    return picref;\n\n}\n", "idx": 7659, "substitutes": {"frame": ["user", "draw", "cast", "rame", "event", "feat", "call", "instance", "window", "channel", "Frame", " input", "page", "state", "file", "buffer", "scene", "force", "profile", "base", "zone", "flow", "frames", "zo", "ie", "picture", "piece", "row", "process", "line", "movie", "ce", "data", "range", "from", "trace", " timeframe", "ref", "word", "list", "module", "code", " fr", " image", "video", "component", "feature", "df", "cell", "block", "shot", "part", "close", "load", "pixel", "version", "entry", "request", "doc", "remote", "show", "pose", "f", "sample", " framed", "face", "point", "fr", "one", "ace", " Frame", "image", "sequence"], "perms": [" perMS", " permissions", "permfs", "perMS", "Perms", "PERents", " perfs", "Permissions", "perm", "PerMS", "PERfs", "permms", "PERms", " perm", "PERmissions", "perments", "PERm", "perfs", "PERMS", "permissions", "perents", " perents", "permMS", "Perm"], "picref": ["icref", " picturerel", "picrel", "pref", "picob", "picelf", "picreference", " picelf", "icreference", " picreference", "imgdef", "micref", " picob", "pictureelf", " picRef", "imgref", "PicRef", "imgob", "pdef", "Picdef", " picdef", "micRef", " pictureelf", "Picreference", "pictureRef", " pictureref", "micreference", "icRef", "picturerel", "icdef", "picdef", "preference", "pob", "pictureref", " pictureRef", "imgreference", "picRef", "micdef", "Picref", " picrel"]}}
{"project": "qemu", "commit_id": "b7b5233ad7fdd9985bb6d05b7919f3a20723ff2c", "target": 1, "func": "void *g_realloc(void *ptr, size_t size)\n\n{\n\n    size_t old_size, copy;\n\n    void *new_ptr;\n\n\n\n    if (!ptr)\n\n        return g_malloc(size);\n\n    old_size = *(size_t *)((char *)ptr - 16);\n\n    copy = old_size < size ? old_size : size;\n\n    new_ptr = g_malloc(size);\n\n    memcpy(new_ptr, ptr, copy);\n\n    g_free(ptr);\n\n    return new_ptr;\n\n}\n", "idx": 7662, "substitutes": {"ptr": ["sp", " pointer", "src", "mem", "po", "ping", "ped", "dep", "pc", "ctx", "br", "rep", "pad", "offset", "scope", "pt", " addr", "rel", "buffer", "pointers", "p", "addr", "rect", "inst", "d", "len", "ind", "pointer", "tr", "inters", "t", "index", "r", "dh", "prime", "dr", "err", "ref", "pos", "pipe", "pre", "expr", "inter", "pr", "Ptr", "code", "iter", "handle", "alloc", "address", "obj", "dest", "length", "ctr", "fr", "arr", "tp", "loc"], "size": ["sp", "ci", "empty", "SIZE", "fee", "any", "type", "Size", "scope", "p", "si", "sy", "equal", "g", "len", "zero", "index", "data", " Size", "height", "scale", "number", "id", "space", "span", "style", "code", "dimension", "num", "s", "max", "sh", "small", "new", "now", "sn", "capacity", "address", "count", "shape", "sum", "ize", "time", "length", "z", "name"], "old_size": ["old__SIZE", " old_type", "old67size", "old_type", "oldaxysize", "older_Size", "old67Size", "older_hash", "old_scale", "oldaxytype", "old_Size", "oldaxycount", "old_sum", "old67hash", "old_SIZE", "old_length", " old_sum", "OLD_SIZE", "older_scale", "old_hash", "OLD_length", "old__size", "OLD_size", "old67scale", "older_size", " old_count", "old_count", "old__length"], "copy": ["share", "error", "clone", "sp", "gc", "ice", "cp", "quote", "save", "move", "store", "skip", "force", "ip", "map", "same", "co", "link", "score", "ge", "cop", "Copy", "sync", "ce", "scale", "delete", "repeat", "go", "slice", "limit", "push", "ignore", "memory", "clip", "opy", "load", "replace", "count", "core", "check", "write", "create", "le", "transfer"], "new_ptr": [" new_fp", "new_addr", "new_obj", "new__pr", "newlyfp", " new_pr", " new_ctx", "new_pt", "new__ptr", "new_fp", " new_desc", " new_obj", "new___ptr", "new_Ptr", "new___pt", " new_pt", "newlyptr", " new_pointer", "new_ctx", "new___addr", "new___Ptr", "new_pointer", "newlyobj", "new__obj", "new_pr", "new_desc", "new__fp", " new_Ptr", "newlypr", " new_addr"]}}
{"project": "FFmpeg", "commit_id": "369cb092ecbbaff20bb0a2a1d60536c3bc04a8f0", "target": 1, "func": "static OutputStream *new_audio_stream(OptionsContext *o, AVFormatContext *oc)\n\n{\n\n    AVStream *st;\n\n    OutputStream *ost;\n\n    AVCodecContext *audio_enc;\n\n\n\n    ost = new_output_stream(o, oc, AVMEDIA_TYPE_AUDIO);\n\n    st  = ost->st;\n\n\n\n    audio_enc = st->codec;\n\n    audio_enc->codec_type = AVMEDIA_TYPE_AUDIO;\n\n\n\n    if (!ost->stream_copy) {\n\n        char *sample_fmt = NULL;\n\n\n\n        MATCH_PER_STREAM_OPT(audio_channels, i, audio_enc->channels, oc, st);\n\n\n\n        MATCH_PER_STREAM_OPT(sample_fmts, str, sample_fmt, oc, st);\n\n        if (sample_fmt &&\n\n            (audio_enc->sample_fmt = av_get_sample_fmt(sample_fmt)) == AV_SAMPLE_FMT_NONE) {\n\n            av_log(NULL, AV_LOG_FATAL, \"Invalid sample format '%s'\\n\", sample_fmt);\n\n            exit_program(1);\n\n        }\n\n\n\n        MATCH_PER_STREAM_OPT(audio_sample_rate, i, audio_enc->sample_rate, oc, st);\n\n    }\n\n\n\n    return ost;\n\n}\n", "idx": 7666, "substitutes": {"o": ["so", "oa", "po", "c", "u", "i", "ou", "oi", "ob", "ok", "os", "p", "d", "co", "n", "oo", "op", "on", "og", "or", "bo", "t", "options", "out", "s", "v", "vo", "ot", "om", "y", "f", "io", "e", "O", "enc", "mo", "onet", "od"], "oc": ["ic", "ico", "loc", "et", "oco", "ct", "ive", "voc", "c", "anc", "aic", "ob", "ous", "ok", "ocal", "os", "oci", "co", "OC", "ocation", "unc", "ec", "toc", "nc", "ocr", "og", "mic", "osc", "oad", "cc", "roc", "arc", "soc", "ot", "vo", "oid", "uc", "ac", "vc", "usc", "ict", "isc", "mc", "erc", "irc", "enc", "ace", "ocon", "tc", "oss"], "st": ["put", "so", "sp", "et", "ty", "ct", "sw", "src", "step", "est", "stage", "cl", "i", "pt", "nd", "sc", "nt", "ob", "sys", "store", "os", "inst", "mt", "stat", " nost", "ocr", "ts", "std", "usr", "irst", "sty", "t", "spect", "se", "stop", "str", "ut", "th", "stan", "stack", "ast", "pg", "proc", "rest", "start", "ot", "be", "sec", "sl", "rt", "stream", "art", "ss", "sn", "stable", "ist", "storage", "ST", "otype", "rd", "ft", "ste", "sts", "ld", "sta", "net", "fr", "ust", "St", "tt"], "ost": ["post", "so", "et", "ort", "ct", "sw", "ust", "src", "est", "utt", "nt", "ob", "os", "boost", " ut", "\u00f3", "co", "mt", "inst", "oo", " nost", "oad", "ocr", "op", "or", " sto", "bo", "irst", "ott", "ast", "OST", "roc", "rest", "org", "host", "ot", "rost", "oid", "stream", "art", "wo", "tx", "ist", "yt", "ST", "rog", "otype", "us", " bos", "oe", "sta", " est", "obs", " soc", "St", "tt", "oss", "od"], "audio_enc": ["audio_ENC", "audio2rc", "audio__en", "audio_ent", "volume_enc", "audio_Enc", "audio___ens", " audio_ec", "media_ens", "audio2ec", " audio_en", "audio__Enc", " audio_rc", "music_en", "volume_ent", "media_ac", "audio2Enc", "audio2enc", "audio_ens", "audio___enc", "audio_en", "audio__enc", " audio_Enc", "volume_en", "audio_ac", "audio___ec", "media_inc", "audio___inc", "music_ec", "media_ec", "music_enc", "media_en", "audio2en", "audio_inc", "music_ENC", "audio_ec", "media_enc", "volume_Enc", "audio_rc", "audio__ec"], "sample_fmt": ["sampleablefpl", "sample_fremt", "sample_vmm", "sample_tlt", "sample_cmm", "sample__fMT", "sample_ftx", "sample_lnd", "sample_ltx", "sample_fpl", "sample_mtx", "sample_fMT", "sample__fmt", "sample_mmt", "sample_mMT", "sampleablefrelt", "sample__flt", "sample_forlt", "sample_clt", "sample_tmm", "sample__vlt", "sample_formn", "sample_fnd", "sample_fmm", "sample_vdr", "sampleableftx", "sampleablefmt", "sampleableflt", "sample_Fnd", "sample_frepl", "sample_vtx", "sample_formp", "sampleablefretx", "sample_lmt", "sample_flt", "sample_fmp", "sample_fretx", "sample_tmp", "sample__vMT", "sample_fdr", "sample__vtx", "sample_fformat", "sampleablefrepl", "sample__ftx", "sampleablefremt", "sample_frelt", "sample_mlt", "sample_cformat", "sample_fmn", "sample_tdr", "sample_FMT", "sample_vMT", "sample_vformat", "sample_ttx", "sample_cmt", "sample_tmn", "sample_Fmm", "sample_Flt", "sample_tmt", "sample_Fpl", "sample_Fmt", "sample_lmm", "sample__vmt", "sample_vmt", "sample_formt", "sample_vlt", "sample_Ftx"]}}
{"project": "FFmpeg", "commit_id": "221402c1c88b9d12130c6f5834029b535ee0e0c5", "target": 1, "func": "static int pcx_decode_frame(AVCodecContext *avctx, void *data, int *got_frame,\n                            AVPacket *avpkt)\n{\n    const uint8_t *buf = avpkt->data;\n    int buf_size       = avpkt->size;\n    AVFrame *const p   = data;\n    int compressed, xmin, ymin, xmax, ymax;\n    unsigned int w, h, bits_per_pixel, bytes_per_line, nplanes, stride, y, x,\n                 bytes_per_scanline;\n    uint8_t *ptr;\n    const uint8_t *buf_end = buf + buf_size;\n    const uint8_t *bufstart = buf;\n    uint8_t *scanline;\n    int ret = -1;\n    if (buf[0] != 0x0a || buf[1] > 5) {\n        av_log(avctx, AV_LOG_ERROR, \"this is not PCX encoded data\\n\");\n    compressed = buf[2];\n    xmin       = AV_RL16(buf + 4);\n    ymin       = AV_RL16(buf + 6);\n    xmax       = AV_RL16(buf + 8);\n    ymax       = AV_RL16(buf + 10);\n    if (xmax < xmin || ymax < ymin) {\n        av_log(avctx, AV_LOG_ERROR, \"invalid image dimensions\\n\");\n    w = xmax - xmin + 1;\n    h = ymax - ymin + 1;\n    bits_per_pixel     = buf[3];\n    bytes_per_line     = AV_RL16(buf + 66);\n    nplanes            = buf[65];\n    bytes_per_scanline = nplanes * bytes_per_line;\n    if (bytes_per_scanline < (w * bits_per_pixel * nplanes + 7) / 8 ||\n        (!compressed && bytes_per_scanline > buf_size / h)) {\n        av_log(avctx, AV_LOG_ERROR, \"PCX data is corrupted\\n\");\n    switch ((nplanes << 8) + bits_per_pixel) {\n    case 0x0308:\n        avctx->pix_fmt = AV_PIX_FMT_RGB24;\n        break;\n    case 0x0108:\n    case 0x0104:\n    case 0x0102:\n    case 0x0101:\n    case 0x0401:\n    case 0x0301:\n    case 0x0201:\n        avctx->pix_fmt = AV_PIX_FMT_PAL8;\n        break;\n    default:\n        av_log(avctx, AV_LOG_ERROR, \"invalid PCX file\\n\");\n    buf += 128;\n    if ((ret = ff_set_dimensions(avctx, w, h)) < 0)\n        return ret;\n    if ((ret = ff_get_buffer(avctx, p, 0)) < 0) {\n        av_log(avctx, AV_LOG_ERROR, \"get_buffer() failed\\n\");\n        return ret;\n    p->pict_type = AV_PICTURE_TYPE_I;\n    ptr    = p->data[0];\n    stride = p->linesize[0];\n    scanline = av_malloc(bytes_per_scanline + AV_INPUT_BUFFER_PADDING_SIZE);\n    if (!scanline)\n        return AVERROR(ENOMEM);\n    if (nplanes == 3 && bits_per_pixel == 8) {\n        for (y = 0; y < h; y++) {\n            buf = pcx_rle_decode(buf, buf_end,\n                                 scanline, bytes_per_scanline, compressed);\n            for (x = 0; x < w; x++) {\n                ptr[3 * x]     = scanline[x];\n                ptr[3 * x + 1] = scanline[x + bytes_per_line];\n                ptr[3 * x + 2] = scanline[x + (bytes_per_line << 1)];\n            ptr += stride;\n    } else if (nplanes == 1 && bits_per_pixel == 8) {\n        const uint8_t *palstart = bufstart + buf_size - 769;\n        if (buf_size < 769) {\n            av_log(avctx, AV_LOG_ERROR, \"File is too short\\n\");\n            ret = avctx->err_recognition & AV_EF_EXPLODE ?\n                  AVERROR_INVALIDDATA : buf_size;\n            goto end;\n        for (y = 0; y < h; y++, ptr += stride) {\n            buf = pcx_rle_decode(buf, buf_end,\n                                 scanline, bytes_per_scanline, compressed);\n            memcpy(ptr, scanline, w);\n        if (buf != palstart) {\n            av_log(avctx, AV_LOG_WARNING, \"image data possibly corrupted\\n\");\n            buf = palstart;\n        if (*buf++ != 12) {\n            av_log(avctx, AV_LOG_ERROR, \"expected palette after image data\\n\");\n            ret = avctx->err_recognition & AV_EF_EXPLODE ?\n                  AVERROR_INVALIDDATA : buf_size;\n            goto end;\n    } else if (nplanes == 1) {   /* all packed formats, max. 16 colors */\n        GetBitContext s;\n        for (y = 0; y < h; y++) {\n            init_get_bits(&s, scanline, bytes_per_scanline << 3);\n            buf = pcx_rle_decode(buf, buf_end,\n                                 scanline, bytes_per_scanline, compressed);\n            for (x = 0; x < w; x++)\n                ptr[x] = get_bits(&s, bits_per_pixel);\n            ptr += stride;\n    } else {    /* planar, 4, 8 or 16 colors */\n        int i;\n        for (y = 0; y < h; y++) {\n            buf = pcx_rle_decode(buf, buf_end,\n                                 scanline, bytes_per_scanline, compressed);\n            for (x = 0; x < w; x++) {\n                int m = 0x80 >> (x & 7), v = 0;\n                for (i = nplanes - 1; i >= 0; i--) {\n                    v <<= 1;\n                    v  += !!(scanline[i * bytes_per_line + (x >> 3)] & m);\n                ptr[x] = v;\n            ptr += stride;\n    if (nplanes == 1 && bits_per_pixel == 8) {\n        pcx_palette(&buf, (uint32_t *)p->data[1], 256);\n    } else if (bits_per_pixel < 8) {\n        const uint8_t *palette = bufstart + 16;\n        pcx_palette(&palette, (uint32_t *)p->data[1], 16);\n    *got_frame = 1;\n    ret = buf - bufstart;\nend:\n    av_free(scanline);\n    return ret;", "idx": 7670, "substitutes": {"avctx": ["navcontext", " avconn", "AVctx", "avcmd", "averpkg", "avpkg", "AVconn", "aircpp", "afctx", "AVcontext", "svctx", "afcmp", "aircu", "navgc", "avecmp", " avcmp", "avreq", "AVreq", "avtx", "afcpp", "afgc", "svreq", " avreq", " avcmd", "navjac", "avconn", " avcontext", "aftx", "avcpp", "avercu", " avgc", "avecontext", "avcontext", "avercpp", "afcmd", "avjac", "navtx", "avcas", "navctx", "avectx", "navcas", " avtx", "avcmp", "avercas", "svconn", "airpkg", "svcontext", "avgc", "avcu", "avertx", "afcontext", "avecmd", "afjac", "averctx", "airctx", "averjac", "afpkg", "afcas", "afcu"], "data": ["output", "read", "bytes", "xy", "padding", "next", "dat", "window", "channel", "pad", "feed", "rel", "page", "file", "buffer", "raw", "map", "d", "ata", "t", "r", "value", "Data", "input", "str", "record", "ref", "video", "bits", "frame", "block", "reader", "action", "response", "batch", "f", "DATA", "message", "obj", "size", "rec", "in", "length", "res", "text", "a", "name", "image", "bin"], "got_frame": ["received_msg", "got__state", "got_state", "got_msg", "got_image", "received_image", "got__image", "got__msg", "received_frame", "received_state", "got__frame"], "avpkt": ["avPds", "avpbnt", "avspacket", "avpett", "wavpacket", "avcpacket", " avPct", "avlpwd", "afpkt", " avPkt", "avlpacket", "wavPkt", "wavPacket", " avpnt", "wavpct", "avPct", "wavpkt", "avPkt", "avspct", "afpct", "avcpett", "avcpwd", "avlpkt", "avpacket", "wavpett", " avpct", "avPnt", "avpbkt", "afcpct", "avcpct", "avspkt", "wavPett", "avPwd", "avpbds", " avpds", "avcpkt", "afcpacket", "avpnt", "avpds", "avpct", "afpacket", "afcpkt", "avPacket", "wavPct", "afpwd", " avPds", "avcpnt", "avpbct", "avPett", "avlpct", " avPnt", "avpwd", "avspett", "avcpds", "afcpwd"], "buf": ["bag", "bytes", "uf", "dat", "late", "addr", "cb", "queue", "bu", "pg", "iter", "num", "txt", "req", "tmp", "fb", "batch", "aka", "cur", "coord", "bin", "buff", "mem", "cam", "pad", "bh", "str", "rb", "port", "pool", "desc", "conv", "ctr", "xff", "vec", "db", "ctx", "Buffer", "msg", "map", "prop", "seq", "len", "var", "tr", "r", "pkg", "Buff", "nm", "fac", "orig", "alloc", "bs", "cv", "bl", "que", "deg", "ff", "pb", "br", "pack", "cmp", "box", "buffer", "raw", "cmd", "vp", "used", "func", "err", "burst", "ref", "list", "proc", "cap", "emb", "img", "doc", "front", "cache", "obj"], "p": ["q", " P", "pb", "c", "u", "pc", "rep", "pro", "prop", "d", "ps", "n", "o", "fp", "t", "r", "pos", "ap", "v", "m", "f", "P", "pp", "comp", "j"], "compressed": ["ompress", "Compress", "compresses", "comppacked", "buffressed", "Compacted", "contressed", "omppacked", "compacted", "contress", "Compresses", " uncompresses", "ompacted", "buffression", " uncomppacked", "contresses", " uncompression", "compended", "ompressed", " uncompress", " uncompended", "Compended", "contended", "buffacted", " uncompacted", "compression", " uncompressed", "Compressed", "Compression", "compress", "buffpacked", "ompression"], "xmin": ["ixonly", " xbegin", " xsort", "xfrom", "lmin", "ymins", "oxsmall", "ixmin", "lmins", "xmins", "xMin", "xsort", "oxmins", "yonly", "yMin", "xisort", "ysort", "oxonly", "xiMin", "ximin", "oxmax", "oxmin", "ysmall", "lbegin", "ixfrom", "xbegin", "ximax", " xMin", "xsmall", "yfrom", "xonly", "ixbegin", "lmax", "ixmax", "ixmins", "ixsmall", "oxfrom", " xmins"], "ymin": ["skyonly", "ymins", "eyMin", "yonly", "yMin", "myminute", " ymins", " ystar", " ysmall", " yMin", "erymin", " yonly", "aymins", "eystart", "ysmall", " yminute", "ystar", "symax", "eymin", "symin", "skymins", "eryMin", "sysmall", "nyonly", "eyminute", "ystart", "nymin", "skymin", "skystart", "nystart", "nymins", "mymax", "eymax", "eryminute", "erystar", "aymax", " ystart", "yminute", "eystar", "mymin", "aymin", "mystart", "symins", "aysmall"], "xmax": ["ixlast", "xMax", "ixmin", " xma", "xax", " xMax", "oxax", "rxmax", " xax", "xend", "Xmax", " xend", "ixma", "oxMAX", "oxmax", "oxmin", "ixax", "xlast", "xma", "xMAX", "ixMAX", "XMax", " xlast", "Xmin", "Xend", "exmax", "oxend", " xMAX", "Xax", "exmin", "rxax", "exax", "oxma", "exlast", "rxMax", "ixmax", "rxend"], "ymax": ["ymmax", "ymmain", "ymatch", "ynax", "ypac", "ypatch", "iyax", "nyody", "yrax", "yratch", "nyatch", "ynac", "ymmand", "ypax", "ypody", "ypail", "ypad", "ymand", "iemax", "ymagic", "ynail", "uyake", "ymmail", "ymody", "yrac", "uyax", "iemapper", "ymake", "ypain", "ymmake", "iemaj", "ypake", "ynad", "iyapper", "ypagic", "yrad", "nyagic", "ymmaj", "yragic", "iyand", "ymaj", "nyax", "uyail", "yrail", "ymail", "ymac", "ymad", "ymain", "ymmapper", "yrody", "iyaj", "iemand", "ymapper", "uyain"], "w": ["aw", "sw", "wp", "window", "wal", "wid", "wa", "wx", "we", "d", "g", "n", "W", "ew", "wr", "wn", "wb", "hw", "iw", "rw", "wt", "win", "ww", "r", "tw", "height", "kw", "v", "m", "wh", "xp", "ex", "size", "z", "wl", "wd", "work", "l", "nw", "fw"], "h": ["ph", "q", "b", "c", "u", "kh", "oh", "ht", "bh", "n", "rows", "hz", "o", "hw", "hi", "height", "r", "k", "max", "v", "m", "ch", "hs", "ho", "he", "ih", "wh", "f", "hm", "size", "hd", "l", "ha", "length", "high", "html", "H", "z", "hh", "hr"], "bits_per_pixel": ["bits_PER_Pixel", "bits_per_Pixel", "bits_PER_pixel", "bits_for_pixel", "bits_per__image", "bits_PER_chip", "bits_per_color", "bits_per_line", "bits_per_channel", "bits_per2Pixel", "bits_for_line", "bits_PER_channel", "bits_per__channel", "bits_per___chip", "bits_per2channel", "bits_per___channel", "bits_per___pixel", "bits_per_chip", "bits_per_image", "bits_per__pixel", "bits_PER_image", "bits_for_color", "bits_per2pixel"], "bytes_per_line": ["bytes_Per_pixel", "bytes_perxline", "bytes_per_block", "bytes_Per_block", "bytes_per_Line", "bytes_Per_line", "bytes_in_page", "bytes_perxLine", "bytes_per_page", "bytes_per_pixel", "bytes_perxpage", "bytes_in_Line", "bytes_perxpixel", "bytes_Per_page", "bytes_Per_Line", "bytes_in_line"], "nplanes": ["nummodules", "anpages", "dplanes", "nanes", "nbmodules", "danes", "mframes", "nplane", "dplane", "numanes", "ncfiles", "anplanes", "anlines", "nmodules", "numframes", "nbpages", "ncpages", "gplanes", "nspages", " nframes", "gpages", "nsbands", "numlines", "cpages", "numplane", "nsplane", "nlines", "anframes", "nrplanes", "mblocks", "mplane", "ncmodules", "nframes", "nbfiles", "gplane", "nblocks", "ncplanes", "nsblocks", "nsplanes", "gframes", "nrplane", "nfiles", "nbands", "nrframes", "dframes", "gbands", " nplane", "cplanes", "cbands", "cplane", "numfiles", "nbplanes", "mplanes", "nsframes", "numplanes", "numpages", "glines", "npages", "nrblocks", " nanes"], "stride": ["slides", "strride", "glride", "slride", "gline", "collride", "collide", "colline", "collides", "glide", "slide", "strine", "sline", "glides", "strides"], "y": ["xy", "b", "dy", "cy", "c", "ies", "yi", "Y", "my", "gy", "sy", "n", "t", "key", "height", "yy", "iy", "m", "ch", "yt", "ey", "j", "z", "ym"], "x": ["xy", "X", "ox", "wx", "rx", "px", "n", "t", "height", "xc", "dx", "xs", "max", "ix", "m", "f", "xp", "ex", "size", "z", "l"], "bytes_per_scanline": ["bytes_per_binner", "bytes_per_Scanlines", "bytes_per_binline", "bytes_per_scanLine", "bytes_per_Scanlink", "bytes_per_scanlink", "bytes_per_checkline", "bytes_per_canline", "bytes_per_scanner", "bytes_per_Scanline", "bytes_per_scanlines", "bytes_per_checklines", "bytes_per_Scanner", "bytes_per_canLine", "bytes_per_canblock", "bytes_per_binblock", "bytes_per_checkLine", "bytes_per_ScanLine", "bytes_per_scanblock", "bytes_per_Scanblock", "bytes_per_checklink"], "ptr": ["buff", "src", "mem", "br", "pad", "pointers", "map", "progress", "addr", "cmd", "seek", "pointer", "tr", "temp", "err", "dr", "rc", "ref", "Ptr", "cap", "req", "alloc", "desc", "np", "cur", "ctr", "fr", "arr"], "buf_end": ["buff_start", "buf_ends", "buff_end", "buff_ends", "buf_start"], "bufstart": ["capend", "capstart", "bufferStart", "bufferstart", "camend", "capstop", "bufferend", "bufend", "bufferstop", "camstop", "capStart", "camStart", "bufstop", "camstart", "bufStart"], "scanline": ["Scanline", "rowlen", "scanLine", " scanlines", "rowline", "ScanLine", "scanlines", " scanLine", "Scanlen", "Scanlines", "scanlen", "rowlines", " scanlen", "rowLine"]}}
{"project": "qemu", "commit_id": "196a778428989217b82de042725dc8eb29c8f8d8", "target": 1, "func": "static void ioport_write(void *opaque, uint32_t addr, uint32_t val)\n\n{\n\n    PCIQXLDevice *d = opaque;\n\n    uint32_t io_port = addr - d->io_base;\n\n\n\n    switch (io_port) {\n\n    case QXL_IO_RESET:\n\n    case QXL_IO_SET_MODE:\n\n    case QXL_IO_MEMSLOT_ADD:\n\n    case QXL_IO_MEMSLOT_DEL:\n\n    case QXL_IO_CREATE_PRIMARY:\n\n        break;\n\n    default:\n\n        if (d->mode == QXL_MODE_NATIVE || d->mode == QXL_MODE_COMPAT)\n\n            break;\n\n        dprint(d, 1, \"%s: unexpected port 0x%x in vga mode\\n\", __FUNCTION__, io_port);\n\n        return;\n\n    }\n\n\n\n    switch (io_port) {\n\n    case QXL_IO_UPDATE_AREA:\n\n    {\n\n        QXLRect update = d->ram->update_area;\n\n        qemu_mutex_unlock_iothread();\n\n        d->ssd.worker->update_area(d->ssd.worker, d->ram->update_surface,\n\n                                   &update, NULL, 0, 0);\n\n        qemu_mutex_lock_iothread();\n\n        break;\n\n    }\n\n    case QXL_IO_NOTIFY_CMD:\n\n        d->ssd.worker->wakeup(d->ssd.worker);\n\n        break;\n\n    case QXL_IO_NOTIFY_CURSOR:\n\n        d->ssd.worker->wakeup(d->ssd.worker);\n\n        break;\n\n    case QXL_IO_UPDATE_IRQ:\n\n        qxl_set_irq(d);\n\n        break;\n\n    case QXL_IO_NOTIFY_OOM:\n\n        if (!SPICE_RING_IS_EMPTY(&d->ram->release_ring)) {\n\n            break;\n\n        }\n\n        pthread_yield();\n\n        if (!SPICE_RING_IS_EMPTY(&d->ram->release_ring)) {\n\n            break;\n\n        }\n\n        d->oom_running = 1;\n\n        d->ssd.worker->oom(d->ssd.worker);\n\n        d->oom_running = 0;\n\n        break;\n\n    case QXL_IO_SET_MODE:\n\n        dprint(d, 1, \"QXL_SET_MODE %d\\n\", val);\n\n        qxl_set_mode(d, val, 0);\n\n        break;\n\n    case QXL_IO_LOG:\n\n        if (d->guestdebug) {\n\n            fprintf(stderr, \"qxl/guest: %s\", d->ram->log_buf);\n\n        }\n\n        break;\n\n    case QXL_IO_RESET:\n\n        dprint(d, 1, \"QXL_IO_RESET\\n\");\n\n        qxl_hard_reset(d, 0);\n\n        break;\n\n    case QXL_IO_MEMSLOT_ADD:\n\n        PANIC_ON(val >= NUM_MEMSLOTS);\n\n        PANIC_ON(d->guest_slots[val].active);\n\n        d->guest_slots[val].slot = d->ram->mem_slot;\n\n        qxl_add_memslot(d, val, 0);\n\n        break;\n\n    case QXL_IO_MEMSLOT_DEL:\n\n        qxl_del_memslot(d, val);\n\n        break;\n\n    case QXL_IO_CREATE_PRIMARY:\n\n        PANIC_ON(val != 0);\n\n        dprint(d, 1, \"QXL_IO_CREATE_PRIMARY\\n\");\n\n        d->guest_primary.surface = d->ram->create_surface;\n\n        qxl_create_guest_primary(d, 0);\n\n        break;\n\n    case QXL_IO_DESTROY_PRIMARY:\n\n        PANIC_ON(val != 0);\n\n        dprint(d, 1, \"QXL_IO_DESTROY_PRIMARY\\n\");\n\n        qxl_destroy_primary(d);\n\n        break;\n\n    case QXL_IO_DESTROY_SURFACE_WAIT:\n\n        d->ssd.worker->destroy_surface_wait(d->ssd.worker, val);\n\n        break;\n\n    case QXL_IO_DESTROY_ALL_SURFACES:\n\n        d->ssd.worker->destroy_surfaces(d->ssd.worker);\n\n        break;\n\n    default:\n\n        fprintf(stderr, \"%s: ioport=0x%x, abort()\\n\", __FUNCTION__, io_port);\n\n        abort();\n\n    }\n\n}\n", "idx": 7696, "substitutes": {"opaque": ["ipaques", "paque", "iopaques", " opade", "oppade", "ipaque", "opque", " opacity", "opaques", "oppaque", "patile", "pque", "paques", "ipatile", " opatile", "iopque", "ipque", "pade", "oppatile", "opade", "opacity", "iopatile", "pacity", "opatile", "iopaque", "oppacity"], "addr": ["db", "prefix", "src", "oa", "wid", "offset", "pad", "i", "at", "ip", "cmd", "add", "oad", "name", "hw", "ref", "pos", "inter", "pkg", "start", "host", "ad", "ix", "Address", "ack", "alloc", "now", "ptr", "alias", "address", "ord", "obj", "eth", "hash", "adr", "coord", "work", "trans", "res", "conn", "env", "loc"], "val": ["db", "update", "xy", "mem", "it", "conf", "ctx", "buf", "Val", "rx", "buffer", "seq", "base", "p", "vol", "pol", "var", "data", " value", "vals", "key", "ival", "sel", "value", "unit", "v", "m", "al", "serv", "ret", "tx", "eval", "local", "Value", "vt", "VAL", "res", "x", "cho", "name"], "d": ["db", "dj", "all", "dc", "result", "q", "ctl", "dat", "end", "conf", "c", "md", "h", "nd", "self", "du", "p", "g", "dl", "dt", "ded", "dict", "bd", "sd", "name", "ds", "ind", "dev", "ed", "o", "t", "r", "D", "dh", "dr", "w", "dump", "id", "debug", "dm", "dx", "send", "rest", "ad", "dim", "dd", "dq", "m", "dn", "done", "der", "cd", "f", "ord", "pd", "diff", "de", "mod", "rd", "did", "l", "e", "ld", "j", "z", "td", "di", "dom", "fd", "da"]}}
{"project": "FFmpeg", "commit_id": "4cec43a9eeb58eb9e581a2d9d25f78e5bfbb0960", "target": 0, "func": "static int h264_slice_header_parse(H264Context *h, H264SliceContext *sl)\n\n{\n\n    const SPS *sps;\n\n    const PPS *pps;\n\n    unsigned int first_mb_in_slice;\n\n    unsigned int pps_id;\n\n    int ret;\n\n    unsigned int slice_type, tmp, i;\n\n    int last_pic_structure, last_pic_droppable;\n\n    int needs_reinit = 0;\n\n    int field_pic_flag, bottom_field_flag;\n\n    int frame_num, droppable, picture_structure;\n\n    int mb_aff_frame = 0;\n\n\n\n    first_mb_in_slice = get_ue_golomb(&sl->gb);\n\n\n\n    if (first_mb_in_slice == 0) { // FIXME better field boundary detection\n\n        if (h->current_slice && h->cur_pic_ptr && FIELD_PICTURE(h)) {\n\n            ff_h264_field_end(h, sl, 1);\n\n        }\n\n\n\n        h->current_slice = 0;\n\n        if (!h->first_field) {\n\n            if (h->cur_pic_ptr && !h->droppable) {\n\n                ff_thread_report_progress(&h->cur_pic_ptr->tf, INT_MAX,\n\n                                          h->picture_structure == PICT_BOTTOM_FIELD);\n\n            }\n\n            h->cur_pic_ptr = NULL;\n\n        }\n\n    }\n\n\n\n    slice_type = get_ue_golomb_31(&sl->gb);\n\n    if (slice_type > 9) {\n\n        av_log(h->avctx, AV_LOG_ERROR,\n\n               \"slice type %d too large at %d\\n\",\n\n               slice_type, first_mb_in_slice);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    if (slice_type > 4) {\n\n        slice_type -= 5;\n\n        sl->slice_type_fixed = 1;\n\n    } else\n\n        sl->slice_type_fixed = 0;\n\n\n\n    slice_type         = ff_h264_golomb_to_pict_type[slice_type];\n\n    sl->slice_type     = slice_type;\n\n    sl->slice_type_nos = slice_type & 3;\n\n\n\n    if (h->nal_unit_type  == NAL_IDR_SLICE &&\n\n        sl->slice_type_nos != AV_PICTURE_TYPE_I) {\n\n        av_log(h->avctx, AV_LOG_ERROR, \"A non-intra slice in an IDR NAL unit.\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    pps_id = get_ue_golomb(&sl->gb);\n\n    if (pps_id >= MAX_PPS_COUNT) {\n\n        av_log(h->avctx, AV_LOG_ERROR, \"pps_id %u out of range\\n\", pps_id);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    if (!h->ps.pps_list[pps_id]) {\n\n        av_log(h->avctx, AV_LOG_ERROR,\n\n               \"non-existing PPS %u referenced\\n\",\n\n               pps_id);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    if (!h->setup_finished) {\n\n        h->ps.pps = (const PPS*)h->ps.pps_list[pps_id]->data;\n\n    } else if (h->ps.pps != (const PPS*)h->ps.pps_list[pps_id]->data) {\n\n        av_log(h->avctx, AV_LOG_ERROR, \"PPS changed between slices\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    if (!h->ps.sps_list[h->ps.pps->sps_id]) {\n\n        av_log(h->avctx, AV_LOG_ERROR,\n\n               \"non-existing SPS %u referenced\\n\",\n\n               h->ps.pps->sps_id);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    if (h->ps.sps != (const SPS*)h->ps.sps_list[h->ps.pps->sps_id]->data) {\n\n        h->ps.sps = (SPS*)h->ps.sps_list[h->ps.pps->sps_id]->data;\n\n\n\n        if (h->bit_depth_luma    != h->ps.sps->bit_depth_luma ||\n\n            h->chroma_format_idc != h->ps.sps->chroma_format_idc)\n\n            needs_reinit         = 1;\n\n    }\n\n\n\n    pps = h->ps.pps;\n\n    sps = h->ps.sps;\n\n\n\n    if (!h->setup_finished) {\n\n        h->avctx->profile = ff_h264_get_profile(sps);\n\n        h->avctx->level   = sps->level_idc;\n\n        h->avctx->refs    = sps->ref_frame_count;\n\n\n\n        if (h->mb_width  != sps->mb_width ||\n\n            h->mb_height != sps->mb_height * (2 - sps->frame_mbs_only_flag))\n\n            needs_reinit = 1;\n\n\n\n        h->mb_width  = sps->mb_width;\n\n        h->mb_height = sps->mb_height * (2 - sps->frame_mbs_only_flag);\n\n        h->mb_num    = h->mb_width * h->mb_height;\n\n        h->mb_stride = h->mb_width + 1;\n\n\n\n        h->b_stride = h->mb_width * 4;\n\n\n\n        h->chroma_y_shift = sps->chroma_format_idc <= 1; // 400 uses yuv420p\n\n\n\n        h->width  = 16 * h->mb_width;\n\n        h->height = 16 * h->mb_height;\n\n\n\n        ret = init_dimensions(h);\n\n        if (ret < 0)\n\n            return ret;\n\n\n\n        if (sps->video_signal_type_present_flag) {\n\n            h->avctx->color_range = sps->full_range ? AVCOL_RANGE_JPEG\n\n                : AVCOL_RANGE_MPEG;\n\n            if (sps->colour_description_present_flag) {\n\n                if (h->avctx->colorspace != sps->colorspace)\n\n                    needs_reinit = 1;\n\n                h->avctx->color_primaries = sps->color_primaries;\n\n                h->avctx->color_trc       = sps->color_trc;\n\n                h->avctx->colorspace      = sps->colorspace;\n\n            }\n\n        }\n\n    }\n\n\n\n    if (h->context_initialized && needs_reinit) {\n\n        h->context_initialized = 0;\n\n        if (sl != h->slice_ctx) {\n\n            av_log(h->avctx, AV_LOG_ERROR,\n\n                   \"changing width %d -> %d / height %d -> %d on \"\n\n                   \"slice %d\\n\",\n\n                   h->width, h->avctx->coded_width,\n\n                   h->height, h->avctx->coded_height,\n\n                   h->current_slice + 1);\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n\n\n        ff_h264_flush_change(h);\n\n\n\n        if ((ret = get_pixel_format(h)) < 0)\n\n            return ret;\n\n        h->avctx->pix_fmt = ret;\n\n\n\n        av_log(h->avctx, AV_LOG_INFO, \"Reinit context to %dx%d, \"\n\n               \"pix_fmt: %d\\n\", h->width, h->height, h->avctx->pix_fmt);\n\n\n\n        if ((ret = h264_slice_header_init(h)) < 0) {\n\n            av_log(h->avctx, AV_LOG_ERROR,\n\n                   \"h264_slice_header_init() failed\\n\");\n\n            return ret;\n\n        }\n\n    }\n\n    if (!h->context_initialized) {\n\n        if (sl != h->slice_ctx) {\n\n            av_log(h->avctx, AV_LOG_ERROR,\n\n                   \"Cannot (re-)initialize context during parallel decoding.\\n\");\n\n            return AVERROR_PATCHWELCOME;\n\n        }\n\n\n\n        if ((ret = get_pixel_format(h)) < 0)\n\n            return ret;\n\n        h->avctx->pix_fmt = ret;\n\n\n\n        if ((ret = h264_slice_header_init(h)) < 0) {\n\n            av_log(h->avctx, AV_LOG_ERROR,\n\n                   \"h264_slice_header_init() failed\\n\");\n\n            return ret;\n\n        }\n\n    }\n\n\n\n    frame_num = get_bits(&sl->gb, sps->log2_max_frame_num);\n\n    if (!h->setup_finished)\n\n        h->poc.frame_num = frame_num;\n\n\n\n    sl->mb_mbaff       = 0;\n\n\n\n    last_pic_structure = h->picture_structure;\n\n    last_pic_droppable = h->droppable;\n\n\n\n    droppable = h->nal_ref_idc == 0;\n\n    if (sps->frame_mbs_only_flag) {\n\n        picture_structure = PICT_FRAME;\n\n    } else {\n\n        field_pic_flag = get_bits1(&sl->gb);\n\n        if (field_pic_flag) {\n\n            bottom_field_flag = get_bits1(&sl->gb);\n\n            picture_structure = PICT_TOP_FIELD + bottom_field_flag;\n\n        } else {\n\n            picture_structure = PICT_FRAME;\n\n            mb_aff_frame      = sps->mb_aff;\n\n        }\n\n    }\n\n    if (!h->setup_finished) {\n\n        h->droppable         = droppable;\n\n        h->picture_structure = picture_structure;\n\n        h->mb_aff_frame      = mb_aff_frame;\n\n    }\n\n    sl->mb_field_decoding_flag = h->picture_structure != PICT_FRAME;\n\n\n\n    if (h->current_slice != 0) {\n\n        if (last_pic_structure != picture_structure ||\n\n            last_pic_droppable != droppable) {\n\n            av_log(h->avctx, AV_LOG_ERROR,\n\n                   \"Changing field mode (%d -> %d) between slices is not allowed\\n\",\n\n                   last_pic_structure, h->picture_structure);\n\n            return AVERROR_INVALIDDATA;\n\n        } else if (!h->cur_pic_ptr) {\n\n            av_log(h->avctx, AV_LOG_ERROR,\n\n                   \"unset cur_pic_ptr on slice %d\\n\",\n\n                   h->current_slice + 1);\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n    } else {\n\n        /* Shorten frame num gaps so we don't have to allocate reference\n\n         * frames just to throw them away */\n\n        if (h->poc.frame_num != h->poc.prev_frame_num) {\n\n            int unwrap_prev_frame_num = h->poc.prev_frame_num;\n\n            int max_frame_num         = 1 << sps->log2_max_frame_num;\n\n\n\n            if (unwrap_prev_frame_num > h->poc.frame_num)\n\n                unwrap_prev_frame_num -= max_frame_num;\n\n\n\n            if ((h->poc.frame_num - unwrap_prev_frame_num) > sps->ref_frame_count) {\n\n                unwrap_prev_frame_num = (h->poc.frame_num - sps->ref_frame_count) - 1;\n\n                if (unwrap_prev_frame_num < 0)\n\n                    unwrap_prev_frame_num += max_frame_num;\n\n\n\n                h->poc.prev_frame_num = unwrap_prev_frame_num;\n\n            }\n\n        }\n\n\n\n        /* See if we have a decoded first field looking for a pair...\n\n         * Here, we're using that to see if we should mark previously\n\n         * decode frames as \"finished\".\n\n         * We have to do that before the \"dummy\" in-between frame allocation,\n\n         * since that can modify s->current_picture_ptr. */\n\n        if (h->first_field) {\n\n            assert(h->cur_pic_ptr);\n\n            assert(h->cur_pic_ptr->f->buf[0]);\n\n            assert(h->cur_pic_ptr->reference != DELAYED_PIC_REF);\n\n\n\n            /* figure out if we have a complementary field pair */\n\n            if (!FIELD_PICTURE(h) || h->picture_structure == last_pic_structure) {\n\n                /* Previous field is unmatched. Don't display it, but let it\n\n                 * remain for reference if marked as such. */\n\n                if (!last_pic_droppable && last_pic_structure != PICT_FRAME) {\n\n                    ff_thread_report_progress(&h->cur_pic_ptr->tf, INT_MAX,\n\n                                              last_pic_structure == PICT_TOP_FIELD);\n\n                }\n\n            } else {\n\n                if (h->cur_pic_ptr->frame_num != h->poc.frame_num) {\n\n                    /* This and previous field were reference, but had\n\n                     * different frame_nums. Consider this field first in\n\n                     * pair. Throw away previous field except for reference\n\n                     * purposes. */\n\n                    if (!last_pic_droppable && last_pic_structure != PICT_FRAME) {\n\n                        ff_thread_report_progress(&h->cur_pic_ptr->tf, INT_MAX,\n\n                                                  last_pic_structure == PICT_TOP_FIELD);\n\n                    }\n\n                } else {\n\n                    /* Second field in complementary pair */\n\n                    if (!((last_pic_structure   == PICT_TOP_FIELD &&\n\n                           h->picture_structure == PICT_BOTTOM_FIELD) ||\n\n                          (last_pic_structure   == PICT_BOTTOM_FIELD &&\n\n                           h->picture_structure == PICT_TOP_FIELD))) {\n\n                        av_log(h->avctx, AV_LOG_ERROR,\n\n                               \"Invalid field mode combination %d/%d\\n\",\n\n                               last_pic_structure, h->picture_structure);\n\n                        h->picture_structure = last_pic_structure;\n\n                        h->droppable         = last_pic_droppable;\n\n                        return AVERROR_INVALIDDATA;\n\n                    } else if (last_pic_droppable != h->droppable) {\n\n                        avpriv_request_sample(h->avctx,\n\n                                              \"Found reference and non-reference fields in the same frame, which\");\n\n                        h->picture_structure = last_pic_structure;\n\n                        h->droppable         = last_pic_droppable;\n\n                        return AVERROR_PATCHWELCOME;\n\n                    }\n\n                }\n\n            }\n\n        }\n\n\n\n        while (h->poc.frame_num != h->poc.prev_frame_num &&\n\n               h->poc.frame_num != (h->poc.prev_frame_num + 1) % (1 << sps->log2_max_frame_num)) {\n\n            H264Picture *prev = h->short_ref_count ? h->short_ref[0] : NULL;\n\n            av_log(h->avctx, AV_LOG_DEBUG, \"Frame num gap %d %d\\n\",\n\n                   h->poc.frame_num, h->poc.prev_frame_num);\n\n            ret = initialize_cur_frame(h);\n\n            if (ret < 0) {\n\n                h->first_field = 0;\n\n                return ret;\n\n            }\n\n\n\n            h->poc.prev_frame_num++;\n\n            h->poc.prev_frame_num        %= 1 << sps->log2_max_frame_num;\n\n            h->cur_pic_ptr->frame_num = h->poc.prev_frame_num;\n\n            ff_thread_report_progress(&h->cur_pic_ptr->tf, INT_MAX, 0);\n\n            ff_thread_report_progress(&h->cur_pic_ptr->tf, INT_MAX, 1);\n\n            ret = ff_generate_sliding_window_mmcos(h, 1);\n\n            if (ret < 0 && (h->avctx->err_recognition & AV_EF_EXPLODE))\n\n                return ret;\n\n            ret = ff_h264_execute_ref_pic_marking(h, h->mmco, h->mmco_index);\n\n            if (ret < 0 && (h->avctx->err_recognition & AV_EF_EXPLODE))\n\n                return ret;\n\n            /* Error concealment: If a ref is missing, copy the previous ref\n\n             * in its place.\n\n             * FIXME: Avoiding a memcpy would be nice, but ref handling makes\n\n             * many assumptions about there being no actual duplicates.\n\n             * FIXME: This does not copy padding for out-of-frame motion\n\n             * vectors.  Given we are concealing a lost frame, this probably\n\n             * is not noticeable by comparison, but it should be fixed. */\n\n            if (h->short_ref_count) {\n\n                if (prev &&\n\n                    h->short_ref[0]->f->width == prev->f->width &&\n\n                    h->short_ref[0]->f->height == prev->f->height &&\n\n                    h->short_ref[0]->f->format == prev->f->format) {\n\n                    av_image_copy(h->short_ref[0]->f->data,\n\n                                  h->short_ref[0]->f->linesize,\n\n                                  (const uint8_t **)prev->f->data,\n\n                                  prev->f->linesize,\n\n                                  prev->f->format,\n\n                                  h->mb_width  * 16,\n\n                                  h->mb_height * 16);\n\n                    h->short_ref[0]->poc = prev->poc + 2;\n\n                }\n\n                h->short_ref[0]->frame_num = h->poc.prev_frame_num;\n\n            }\n\n        }\n\n\n\n        /* See if we have a decoded first field looking for a pair...\n\n         * We're using that to see whether to continue decoding in that\n\n         * frame, or to allocate a new one. */\n\n        if (h->first_field) {\n\n            assert(h->cur_pic_ptr);\n\n            assert(h->cur_pic_ptr->f->buf[0]);\n\n            assert(h->cur_pic_ptr->reference != DELAYED_PIC_REF);\n\n\n\n            /* figure out if we have a complementary field pair */\n\n            if (!FIELD_PICTURE(h) || h->picture_structure == last_pic_structure) {\n\n                /* Previous field is unmatched. Don't display it, but let it\n\n                 * remain for reference if marked as such. */\n\n                h->cur_pic_ptr = NULL;\n\n                h->first_field = FIELD_PICTURE(h);\n\n            } else {\n\n                if (h->cur_pic_ptr->frame_num != h->poc.frame_num) {\n\n                    /* This and the previous field had different frame_nums.\n\n                     * Consider this field first in pair. Throw away previous\n\n                     * one except for reference purposes. */\n\n                    h->first_field = 1;\n\n                    h->cur_pic_ptr = NULL;\n\n                } else {\n\n                    /* Second field in complementary pair */\n\n                    h->first_field = 0;\n\n                }\n\n            }\n\n        } else {\n\n            /* Frame or first field in a potentially complementary pair */\n\n            h->first_field = FIELD_PICTURE(h);\n\n        }\n\n\n\n        if (!FIELD_PICTURE(h) || h->first_field) {\n\n            if (h264_frame_start(h) < 0) {\n\n                h->first_field = 0;\n\n                return AVERROR_INVALIDDATA;\n\n            }\n\n        } else {\n\n            release_unused_pictures(h, 0);\n\n        }\n\n    }\n\n\n\n    assert(h->mb_num == h->mb_width * h->mb_height);\n\n    if (first_mb_in_slice << FIELD_OR_MBAFF_PICTURE(h) >= h->mb_num ||\n\n        first_mb_in_slice >= h->mb_num) {\n\n        av_log(h->avctx, AV_LOG_ERROR, \"first_mb_in_slice overflow\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    sl->resync_mb_x = sl->mb_x =  first_mb_in_slice % h->mb_width;\n\n    sl->resync_mb_y = sl->mb_y = (first_mb_in_slice / h->mb_width) <<\n\n                                 FIELD_OR_MBAFF_PICTURE(h);\n\n    if (h->picture_structure == PICT_BOTTOM_FIELD)\n\n        sl->resync_mb_y = sl->mb_y = sl->mb_y + 1;\n\n    assert(sl->mb_y < h->mb_height);\n\n\n\n    if (h->picture_structure == PICT_FRAME) {\n\n        h->curr_pic_num = h->poc.frame_num;\n\n        h->max_pic_num  = 1 << sps->log2_max_frame_num;\n\n    } else {\n\n        h->curr_pic_num = 2 * h->poc.frame_num + 1;\n\n        h->max_pic_num  = 1 << (sps->log2_max_frame_num + 1);\n\n    }\n\n\n\n    if (h->nal_unit_type == NAL_IDR_SLICE)\n\n        get_ue_golomb(&sl->gb); /* idr_pic_id */\n\n\n\n    if (sps->poc_type == 0) {\n\n        int poc_lsb = get_bits(&sl->gb, sps->log2_max_poc_lsb);\n\n\n\n        if (!h->setup_finished)\n\n            h->poc.poc_lsb = poc_lsb;\n\n\n\n        if (pps->pic_order_present == 1 && h->picture_structure == PICT_FRAME) {\n\n            int delta_poc_bottom = get_se_golomb(&sl->gb);\n\n            if (!h->setup_finished)\n\n                h->poc.delta_poc_bottom = delta_poc_bottom;\n\n        }\n\n    }\n\n\n\n    if (sps->poc_type == 1 && !sps->delta_pic_order_always_zero_flag) {\n\n        int delta_poc = get_se_golomb(&sl->gb);\n\n\n\n        if (!h->setup_finished)\n\n            h->poc.delta_poc[0] = delta_poc;\n\n\n\n        if (pps->pic_order_present == 1 && h->picture_structure == PICT_FRAME) {\n\n            delta_poc = get_se_golomb(&sl->gb);\n\n\n\n            if (!h->setup_finished)\n\n                h->poc.delta_poc[1] = delta_poc;\n\n        }\n\n    }\n\n\n\n    if (!h->setup_finished)\n\n        ff_h264_init_poc(h->cur_pic_ptr->field_poc, &h->cur_pic_ptr->poc,\n\n                         sps, &h->poc, h->picture_structure, h->nal_ref_idc);\n\n\n\n    if (pps->redundant_pic_cnt_present)\n\n        sl->redundant_pic_count = get_ue_golomb(&sl->gb);\n\n\n\n    if (sl->slice_type_nos == AV_PICTURE_TYPE_B)\n\n        sl->direct_spatial_mv_pred = get_bits1(&sl->gb);\n\n\n\n    ret = ff_h264_parse_ref_count(&sl->list_count, sl->ref_count,\n\n                                  &sl->gb, pps, sl->slice_type_nos,\n\n                                  h->picture_structure);\n\n    if (ret < 0)\n\n        return ret;\n\n\n\n    if (sl->slice_type_nos != AV_PICTURE_TYPE_I) {\n\n       ret = ff_h264_decode_ref_pic_list_reordering(h, sl);\n\n       if (ret < 0) {\n\n           sl->ref_count[1] = sl->ref_count[0] = 0;\n\n           return ret;\n\n       }\n\n    }\n\n\n\n    sl->pwt.use_weight = 0;\n\n    for (i = 0; i < 2; i++) {\n\n        sl->pwt.luma_weight_flag[i]   = 0;\n\n        sl->pwt.chroma_weight_flag[i] = 0;\n\n    }\n\n    if ((pps->weighted_pred && sl->slice_type_nos == AV_PICTURE_TYPE_P) ||\n\n        (pps->weighted_bipred_idc == 1 &&\n\n         sl->slice_type_nos == AV_PICTURE_TYPE_B))\n\n        ff_h264_pred_weight_table(&sl->gb, sps, sl->ref_count,\n\n                                  sl->slice_type_nos, &sl->pwt);\n\n\n\n    // If frame-mt is enabled, only update mmco tables for the first slice\n\n    // in a field. Subsequent slices can temporarily clobber h->mmco_index\n\n    // or h->mmco, which will cause ref list mix-ups and decoding errors\n\n    // further down the line. This may break decoding if the first slice is\n\n    // corrupt, thus we only do this if frame-mt is enabled.\n\n    if (h->nal_ref_idc) {\n\n        ret = ff_h264_decode_ref_pic_marking(h, &sl->gb,\n\n                                             !(h->avctx->active_thread_type & FF_THREAD_FRAME) ||\n\n                                             h->current_slice == 0);\n\n        if (ret < 0 && (h->avctx->err_recognition & AV_EF_EXPLODE))\n\n            return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    if (sl->slice_type_nos != AV_PICTURE_TYPE_I && pps->cabac) {\n\n        tmp = get_ue_golomb_31(&sl->gb);\n\n        if (tmp > 2) {\n\n            av_log(h->avctx, AV_LOG_ERROR, \"cabac_init_idc %u overflow\\n\", tmp);\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n        sl->cabac_init_idc = tmp;\n\n    }\n\n\n\n    sl->last_qscale_diff = 0;\n\n    tmp = pps->init_qp + get_se_golomb(&sl->gb);\n\n    if (tmp > 51 + 6 * (sps->bit_depth_luma - 8)) {\n\n        av_log(h->avctx, AV_LOG_ERROR, \"QP %u out of range\\n\", tmp);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    sl->qscale       = tmp;\n\n    sl->chroma_qp[0] = get_chroma_qp(h, 0, sl->qscale);\n\n    sl->chroma_qp[1] = get_chroma_qp(h, 1, sl->qscale);\n\n    // FIXME qscale / qp ... stuff\n\n    if (sl->slice_type == AV_PICTURE_TYPE_SP)\n\n        get_bits1(&sl->gb); /* sp_for_switch_flag */\n\n    if (sl->slice_type == AV_PICTURE_TYPE_SP ||\n\n        sl->slice_type == AV_PICTURE_TYPE_SI)\n\n        get_se_golomb(&sl->gb); /* slice_qs_delta */\n\n\n\n    sl->deblocking_filter     = 1;\n\n    sl->slice_alpha_c0_offset = 0;\n\n    sl->slice_beta_offset     = 0;\n\n    if (pps->deblocking_filter_parameters_present) {\n\n        tmp = get_ue_golomb_31(&sl->gb);\n\n        if (tmp > 2) {\n\n            av_log(h->avctx, AV_LOG_ERROR,\n\n                   \"deblocking_filter_idc %u out of range\\n\", tmp);\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n        sl->deblocking_filter = tmp;\n\n        if (sl->deblocking_filter < 2)\n\n            sl->deblocking_filter ^= 1;  // 1<->0\n\n\n\n        if (sl->deblocking_filter) {\n\n            sl->slice_alpha_c0_offset = get_se_golomb(&sl->gb) * 2;\n\n            sl->slice_beta_offset     = get_se_golomb(&sl->gb) * 2;\n\n            if (sl->slice_alpha_c0_offset >  12 ||\n\n                sl->slice_alpha_c0_offset < -12 ||\n\n                sl->slice_beta_offset >  12     ||\n\n                sl->slice_beta_offset < -12) {\n\n                av_log(h->avctx, AV_LOG_ERROR,\n\n                       \"deblocking filter parameters %d %d out of range\\n\",\n\n                       sl->slice_alpha_c0_offset, sl->slice_beta_offset);\n\n                return AVERROR_INVALIDDATA;\n\n            }\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 7716, "substitutes": {"h": ["ph", "header", "gh", "q", "event", "b", "c", "http", "kh", "ctx", "here", "comm", "self", "oh", "uh", "ht", "bh", "p", "g", "zh", "d", "hz", "eh", "hw", "hi", "history", "dh", "w", "th", "el", "each", "HH", "hal", "rh", "k", "always", "s", "info", "ah", "v", "host", "handle", "sh", "m", "ch", "hs", "he", "ih", "cache", "wh", "cur", "hm", "hd", "e", "hash", "hl", "html", "ha", "H", "j", "hh", "x", "ssh", "l", "hp"], "sl": ["ph", "so", "sp", "Sl", "sle", "ssl", "sw", "ln", "ell", "SL", "sol", "c", "ctx", "gl", "cl", "sc", "spl", "tl", "skip", "li", "profile", "zh", "dl", "ml", "settings", "sd", "fl", "pl", "lc", "kl", "se", "stack", "split", "lo", "sel", "isl", "vl", "slice", "el", "syn", "coll", "sv", "ls", "pkg", "sb", "style", "phi", "lp", "s", "scl", "handle", "sh", "gro", "rl", "shr", "la", "sn", "serv", "ptr", "lit", "desc", "bl", "spot", "cur", "sql", "jl", "hl", "nl", "acl", "l", "loc", "sing"], "sps": ["ppr", "spl", " spps", "ppl", "Sps", "spps", "Spps", " spl", "Spr", "spr", "Spl", " spr", "ppps"], "pps": ["dds", "mph", "eps", "amps", "PS", "balls", "ppa", "ppers", "cpp", "px", "ps", "psc", "fps", "Ps", "ppo", "ips", "clips", "PP", "bps", "vs", "ups", "hands", "parts", "pp", "pres", "photos", "pes", "ops", "mp"], "first_mb_in_slice": ["first_mb_in_frame", "first_mb_inxice", "first_mb_inxslice", "first_mb_in_ice", "first_mb_in__slice", "first_mb_inxframe", "first_mb_in__ice", "first_mb_in__sample", "first_mb_in_sample", "first_mb_in_sequence"], "pps_id": ["ops_id", "opsacindex", "ops_index", "pps_index", "ppsacbase", "pps_name", "opsacid", "ppsacindex", "pps_base", "ops_base", "ppsacname", "ops_name", "opsacbase", "opsacname", "ppsegbase", "ppsegindex", "ppsacid", "ppsegid", "ppsegname"], "ret": ["result", "pret", "mem", "Return", "rel", "nt", "prop", "rets", "val", "std", "alt", "limit", "ref", "rt", "status", "resp", "RET", "jp", "Ret", "fi", "ll", "res", "def", "elt", "flag"], "slice_type": ["slice_TYPE", "sliceLEType", "slice_info", "slice__type", "shift_info", "ice_code", "nodeetyype", "staritycolor", "slice_ype", "slice_index", "slice__types", "slice_link", "node_type", "style_test", "sliceetytype", "slice_Type", "shift_type", "nodeetytest", "slice_pe", "sliceitytype", "staritytype", "sliceetytry", "style_TYPE", "star_type", "shiftetname", "sliceLEunit", "service_try", "slice\u05bccode", "shift_unit", "sliceLEcolor", "sliceetname", " slice_value", "starityunit", "slice_ty", "sliceetytest", "sliceOdate", "slice_value", "slice_address", "sliceetydate", "sliceLEtest", "sliceetyype", "slice_unit", "slice2link", " slice_no", "sliceityaddress", "sliceettype", "styleetytype", "service_name", "shiftetunit", "sliceityunit", "slice__index", "sliceOtype", "sliceThevalue", "style_Type", "slice_try", "slice___pe", "sliceetyTYPE", "slice\u05bctype", "sliceOname", "nodeetytype", "slice_no", "slice__name", "sliceOtry", "slice2type", "sliceetyname", "slice_lock", "sliceLEtype", "service_date", "node_ty", "serviceetytype", "star_color", "serviceetytry", "nodeetyty", "slice___type", "node_test", " slice_name", "star_address", "slice___Type", "sliceitycolor", " slice_index", "slice___ype", "sliceLEaddress", "sliceTheType", "slice2Type", "node_ype", " slice_info", " slice_Type", " slice_ype", "slice\u05bclock", "slice_color", "serviceetydate", " slice_link", "slice_code", "style_type", "star_unit", "sliceThetype", "sliceetinfo", "ice_lock", " slice_pe", "ice_type", " slice_types", "service_type", "sliceetyty", "slice2info", "starityaddress", "slice_name", "sliceetyType", "serviceetyname", "slice_types", "styleetyType", "slice_date", " slice_unit", "styleetyTYPE", "styleetytest", "shiftetinfo", "slice_test", "shiftettype", "sliceLETYPE", "shift_name", "sliceetunit"], "tmp": ["sp", "src", "cmp", "nt", "extra", "ip", "etc", "ind", "tv", "perm", "t", "temp", "pos", "png", "v", "ot", "mb", "img", "mm", "ptr", "np", "vt", "test", "td", "snap", "ii", "tt", "mp"], "i": ["init", "ci", "b", "it", "im", "c", "mi", "ip", "li", "p", "si", "n", "ind", "index", "t", "pi", "id", "ti", "ir", "m", "I", "iat", "f", "j", "di", "ni", "ii"], "last_pic_structure": ["last_pic_constitute", "last_pic_constructure", "last_pic_strict", "last_pic2constrict", "last_pic_instrict", "last_pic_distitute", "last_pic_institute", "last_pic2constitute", "last_pic_struction", "last_pic_distructure", "last_pic_distruction", "last_pic_instructure", "last_pic2structure", "last_pic_instruction", "last_pic2stitute", "last_pic_construction", "last_pic2construction", "last_pic2struction", "last_pic_stitute", "last_pic2constructure", "last_pic_constrict", "last_pic_district", "last_pic2strict"], "last_pic_droppable": ["last_pic_droppedable", "last_pic_droppedability", "last_pic_croppabe", "last_pic_droposble", "last_pic_dropletble", "last_pic_droposabe", "last_pic_dropletabe", "last_pic_dropletable", "last_pic_cropletable", "last_pic_croppability", "last_pic_cropletabe", "last_pic_droposability", "last_pic_droppble", "last_pic_croppable", "last_pic_droposable", "last_pic_cropletble", "last_pic_droppability", "last_pic_droppedabe", "last_pic_dropletability", "last_pic_croppble", "last_pic_cropletability", "last_pic_droppedble", "last_pic_droppabe"], "field_pic_flag": ["field_picityflag", "field_picture_flags", "field_picricflags", "field_picricnum", "field_picricerror", "field_picityflags", "field_picture_num", "field_picityerror", "field_picitynum", "field_picture_flag", "field_pic_error", "field_pic_flags", "field_picture_error", "field_picricflag", "field_pic_num"], "bottom_field_flag": ["bottom_field_tag", "bottom_fields_flags", "bottom_field_no", "bottom_fields_flag", "bottom_fields_no", "bottom_fields_tag", "bottom_field_flags"], "frame_num": ["framemodid", " frame_ref", "frame_ref", "framemodnum", " frame_id", "framemodref", "framemodnumber", " frame_number", "frame_number", "frame_id"], "droppable": ["droposible", "droploadble", "droposabe", "drooppatable", "dropletble", "Dropletatable", "droppible", "croppworthy", "Dropletabe", "Droppatable", "cropletable", "croppable", "droposatable", "Dropletible", "cropletible", "drooppable", "dropletible", "dropletworthy", "Dropletable", "dropletabe", "cropletworthy", "Droppable", "croppble", "droppatable", "droppworthy", "Droppible", "drooppabe", "droploadworthy", "Droppabe", "droploadible", "dropletatable", "droposworthy", "cropletble", "droppble", "droposable", "droploadable", "dropletable", "droppabe", "croppible", "drooppible", "droposble"], "picture_structure": ["picture_constructure", "picture_destructure", "picture_destitute", "picture_estruction", "picture_strructure", "picture_strruction", "picture_restructure", "picture_strype", "picture_sturation", "picture_stitute", "picture_struction", "picture_resturation", "picture_constype", "picture_restruction", "picture_consturation", "picture_estitute", "picture_stitution", "picture_construction", "picture_struration", "picture_destruction", "picture_constitute", "picture_destitution", "picture_constitution", "picture_stype", "picture_estitution", "picture_restype", "picture_estructure"]}}
{"project": "FFmpeg", "commit_id": "be4dfbf7b71e44a53ca8da882a081e35ea134c83", "target": 0, "func": "int ffurl_shutdown(URLContext *h, int flags)\n\n{\n\n    if (!h->prot->url_shutdown)\n\n        return AVERROR(EINVAL);\n\n    return h->prot->url_shutdown(h, flags);\n\n}\n", "idx": 7729, "substitutes": {"h": ["ph", "q", "c", "kh", "here", "uh", "oh", "ht", "bh", "help", "p", "has", "hz", "eh", "hw", "history", "dh", "th", "hal", " inh", "rh", "ah", "handle", "host", "sh", "ash", "m", "ch", "hs", "he", "ih", "f", "hm", "hd", "pp", "hash", "hl", "z", "H", "j", "hh", "hr", "hp"], "flags": ["members", "styles", "alf", "weights", "ants", "fee", " Flags", "wcs", "ats", "ags", "locks", "kind", "files", "acts", "ensions", "frames", "pages", "settings", "uts", "fps", "vals", "types", "atts", "ids", "options", "properties", "tags", "bits", "Flags", "FLAG", "lag", "parts", "heads", "posts", "FO", "doms", "features", "faces", "ops", "flag"]}}
{"project": "qemu", "commit_id": "049a9f7b946fe1d3ff97127f8905881dbb78cb00", "target": 1, "func": "static void i82378_init(DeviceState *dev, I82378State *s)\n\n{\n\n    ISABus *isabus = DO_UPCAST(ISABus, qbus, qdev_get_child_bus(dev, \"isa.0\"));\n\n    ISADevice *pit;\n\n    qemu_irq *out0_irq;\n\n\n\n    /* This device has:\n\n       2 82C59 (irq)\n\n       1 82C54 (pit)\n\n       2 82C37 (dma)\n\n       NMI\n\n       Utility Bus Support Registers\n\n\n\n       All devices accept byte access only, except timer\n\n     */\n\n\n\n    qdev_init_gpio_out(dev, s->out, 2);\n\n    qdev_init_gpio_in(dev, i82378_request_pic_irq, 16);\n\n\n\n    /* Workaround the fact that i8259 is not qdev'ified... */\n\n    out0_irq = qemu_allocate_irqs(i82378_request_out0_irq, s, 1);\n\n\n\n    /* 2 82C59 (irq) */\n\n    s->i8259 = i8259_init(isabus, *out0_irq);\n\n    isa_bus_irqs(isabus, s->i8259);\n\n\n\n    /* 1 82C54 (pit) */\n\n    pit = pit_init(isabus, 0x40, 0, NULL);\n\n\n\n    /* speaker */\n\n    pcspk_init(isabus, pit);\n\n\n\n    /* 2 82C37 (dma) */\n\n    DMA_init(1, &s->out[1]);\n\n    isa_create_simple(isabus, \"i82374\");\n\n\n\n    /* timer */\n\n    isa_create_simple(isabus, \"mc146818rtc\");\n\n}\n", "idx": 7732, "substitutes": {"dev": ["ev", "des", "sw", "app", "att", "mem", "av", "cam", "pad", "pro", "DEV", "dem", "ve", "nt", "os", "d", "p", "g", "cmd", "util", "sd", "data", "hw", "t", "o", "w", "go", "adv", "proc", "debug", "device", "v", "ad", "Device", "Dev", "spec", "serv", "scan", "priv", "test", "de", "tech", "boot", "dis", "ver", "bus", "conn", "def"], "s": ["rs", "gs", "ses", "ssl", "b", "sw", "ns", "eps", "its", "c", "ats", "aws", "i", "sys", "cs", "comm", "os", "ps", "p", "g", "d", "n", "is", "ts", "ds", "sd", "ports", "settings", "o", "t", "r", "js", "sv", "ls", "events", "sb", "services", "out", "v", "ims", "stats", "spec", "a", "vs", "ss", "bs", "states", "south", "sq", "fs", "e", "S", "sts", "in", "changes", "params", "sand", "sing"], "isabus": ["isab", "itsaws", "risalis", "risasar", " isasar", " isalis", "risorus", "misatus", "risaws", "isews", " isews", "risews", "risatis", "isalis", "isaws", "risabol", "issatis", " isabytes", "risabus", "issabol", "itsabytes", "issalis", "isabis", " isab", "itsabus", "risabis", " isaws", "misews", "isatis", "risabi", "issabus", "isabytes", "risatus", "isatus", " isorus", "isorus", " isabi", " isatus", "issab", "issabytes", "risab", "issabi", "isabi", "misabis", "misabus", " isabis", " isatis", "issasar", "itsasar", "issorus", " isabol", "issaws", "isasar", "isabol"], "pit": ["rot", "cas", "it", "po", "ped", "pc", "itch", "phy", "pt", "mat", "kat", "prot", "pri", "nat", "pat", "p", "pa", " Pit", "vp", "pir", "trap", "pl", "pi", "pet", "pr", "pert", "lp", "tip", "pocket", "pai", "hat", "pei", "pot", "rit", "kit", "pac", "jit", "jp", "fi", "pin", "press"], "out0_irq": ["out0_irequ", "out0__irqs", "out0_irequest", "out0_ireQ", "out0__irquest", "out0_mirqi", "out0_mirqs", "out0_irqs", "out0__iraqs", "out0__iraq", "out0_prz", "out0_mirQ", "out0__irqi", "out0_prqs", "out0_irue", "out0_irqi", "out0_ireqi", "out0__iraquest", "out0_mirqu", "out0_mirquest", "out0_iraquest", "out0_iraqi", "out0_mirq", "out0_irqu", "out0__irq", "out0__iraqi", "out0_pirz", "out0_drz", "out0_drue", "out0_ireqs", "out0_pirQ", "out0_iraq", "out0_drqs", "out0_iraqs", "out0_pirqs", "out0_ireq", "out0_irquest", "out0_pirue", "out0_drq", "out0_pirq", "out0_irQ", "out0_prue", "out0_prq", "out0_pirqu", "out0_irz"]}}
{"project": "qemu", "commit_id": "0ae18ceeaaa2c1749e742c4b112f6c3bf0896408", "target": 0, "func": "static void realview_init(ram_addr_t ram_size, int vga_ram_size,\n\n                     const char *boot_device, DisplayState *ds,\n\n                     const char *kernel_filename, const char *kernel_cmdline,\n\n                     const char *initrd_filename, const char *cpu_model)\n\n{\n\n    CPUState *env;\n\n    qemu_irq *pic;\n\n    void *scsi_hba;\n\n    PCIBus *pci_bus;\n\n    NICInfo *nd;\n\n    int n;\n\n    int done_smc = 0;\n\n    qemu_irq cpu_irq[4];\n\n    int ncpu;\n\n    int index;\n\n\n\n    if (!cpu_model)\n\n        cpu_model = \"arm926\";\n\n    /* FIXME: obey smp_cpus.  */\n\n    if (strcmp(cpu_model, \"arm11mpcore\") == 0) {\n\n        ncpu = 4;\n\n    } else {\n\n        ncpu = 1;\n\n    }\n\n\n\n    for (n = 0; n < ncpu; n++) {\n\n        env = cpu_init(cpu_model);\n\n        if (!env) {\n\n            fprintf(stderr, \"Unable to find CPU definition\\n\");\n\n            exit(1);\n\n        }\n\n        pic = arm_pic_init_cpu(env);\n\n        cpu_irq[n] = pic[ARM_PIC_CPU_IRQ];\n\n        if (n > 0) {\n\n            /* Set entry point for secondary CPUs.  This assumes we're using\n\n               the init code from arm_boot.c.  Real hardware resets all CPUs\n\n               the same.  */\n\n            env->regs[15] = 0x80000000;\n\n        }\n\n    }\n\n\n\n    /* ??? RAM should repeat to fill physical memory space.  */\n\n    /* SDRAM at address zero.  */\n\n    cpu_register_physical_memory(0, ram_size, IO_MEM_RAM);\n\n\n\n    arm_sysctl_init(0x10000000, 0xc1400400);\n\n\n\n    if (ncpu == 1) {\n\n        /* ??? The documentation says GIC1 is nFIQ and either GIC2 or GIC3\n\n           is nIRQ (there are inconsistencies).  However Linux 2.6.17 expects\n\n           GIC1 to be nIRQ and ignores all the others, so do that for now.  */\n\n        pic = realview_gic_init(0x10040000, cpu_irq[0]);\n\n    } else {\n\n        pic = mpcore_irq_init(cpu_irq);\n\n    }\n\n\n\n    pl050_init(0x10006000, pic[20], 0);\n\n    pl050_init(0x10007000, pic[21], 1);\n\n\n\n    pl011_init(0x10009000, pic[12], serial_hds[0], PL011_ARM);\n\n    pl011_init(0x1000a000, pic[13], serial_hds[1], PL011_ARM);\n\n    pl011_init(0x1000b000, pic[14], serial_hds[2], PL011_ARM);\n\n    pl011_init(0x1000c000, pic[15], serial_hds[3], PL011_ARM);\n\n\n\n    /* DMA controller is optional, apparently.  */\n\n    pl080_init(0x10030000, pic[24], 2);\n\n\n\n    sp804_init(0x10011000, pic[4]);\n\n    sp804_init(0x10012000, pic[5]);\n\n\n\n    pl110_init(ds, 0x10020000, pic[23], 1);\n\n\n\n    index = drive_get_index(IF_SD, 0, 0);\n\n    if (index == -1) {\n\n        fprintf(stderr, \"qemu: missing SecureDigital card\\n\");\n\n        exit(1);\n\n    }\n\n    pl181_init(0x10005000, drives_table[index].bdrv, pic[17], pic[18]);\n\n\n\n    pl031_init(0x10017000, pic[10]);\n\n\n\n    pci_bus = pci_vpb_init(pic, 48, 1);\n\n    if (usb_enabled) {\n\n        usb_ohci_init_pci(pci_bus, 3, -1);\n\n    }\n\n    if (drive_get_max_bus(IF_SCSI) > 0) {\n\n        fprintf(stderr, \"qemu: too many SCSI bus\\n\");\n\n        exit(1);\n\n    }\n\n    scsi_hba = lsi_scsi_init(pci_bus, -1);\n\n    for (n = 0; n < LSI_MAX_DEVS; n++) {\n\n        index = drive_get_index(IF_SCSI, 0, n);\n\n        if (index == -1)\n\n            continue;\n\n        lsi_scsi_attach(scsi_hba, drives_table[index].bdrv, n);\n\n    }\n\n    for(n = 0; n < nb_nics; n++) {\n\n        nd = &nd_table[n];\n\n        if (!nd->model)\n\n            nd->model = done_smc ? \"rtl8139\" : \"smc91c111\";\n\n        if (strcmp(nd->model, \"smc91c111\") == 0) {\n\n            smc91c111_init(nd, 0x4e000000, pic[28]);\n\n        } else {\n\n            pci_nic_init(pci_bus, nd, -1);\n\n        }\n\n    }\n\n\n\n    /* Memory map for RealView Emulation Baseboard:  */\n\n    /* 0x10000000 System registers.  */\n\n    /*  0x10001000 System controller.  */\n\n    /*  0x10002000 Two-Wire Serial Bus.  */\n\n    /* 0x10003000 Reserved.  */\n\n    /*  0x10004000 AACI.  */\n\n    /*  0x10005000 MCI.  */\n\n    /* 0x10006000 KMI0.  */\n\n    /* 0x10007000 KMI1.  */\n\n    /*  0x10008000 Character LCD.  */\n\n    /* 0x10009000 UART0.  */\n\n    /* 0x1000a000 UART1.  */\n\n    /* 0x1000b000 UART2.  */\n\n    /* 0x1000c000 UART3.  */\n\n    /*  0x1000d000 SSPI.  */\n\n    /*  0x1000e000 SCI.  */\n\n    /* 0x1000f000 Reserved.  */\n\n    /*  0x10010000 Watchdog.  */\n\n    /* 0x10011000 Timer 0+1.  */\n\n    /* 0x10012000 Timer 2+3.  */\n\n    /*  0x10013000 GPIO 0.  */\n\n    /*  0x10014000 GPIO 1.  */\n\n    /*  0x10015000 GPIO 2.  */\n\n    /* 0x10016000 Reserved.  */\n\n    /* 0x10017000 RTC.  */\n\n    /*  0x10018000 DMC.  */\n\n    /*  0x10019000 PCI controller config.  */\n\n    /*  0x10020000 CLCD.  */\n\n    /* 0x10030000 DMA Controller.  */\n\n    /* 0x10040000 GIC1.  */\n\n    /* 0x10050000 GIC2.  */\n\n    /* 0x10060000 GIC3.  */\n\n    /* 0x10070000 GIC4.  */\n\n    /*  0x10080000 SMC.  */\n\n    /*  0x40000000 NOR flash.  */\n\n    /*  0x44000000 DoC flash.  */\n\n    /*  0x48000000 SRAM.  */\n\n    /*  0x4c000000 Configuration flash.  */\n\n    /* 0x4e000000 Ethernet.  */\n\n    /*  0x4f000000 USB.  */\n\n    /*  0x50000000 PISMO.  */\n\n    /*  0x54000000 PISMO.  */\n\n    /*  0x58000000 PISMO.  */\n\n    /*  0x5c000000 PISMO.  */\n\n    /* 0x60000000 PCI.  */\n\n    /* 0x61000000 PCI Self Config.  */\n\n    /* 0x62000000 PCI Config.  */\n\n    /* 0x63000000 PCI IO.  */\n\n    /* 0x64000000 PCI mem 0.  */\n\n    /* 0x68000000 PCI mem 1.  */\n\n    /* 0x6c000000 PCI mem 2.  */\n\n\n\n    realview_binfo.ram_size = ram_size;\n\n    realview_binfo.kernel_filename = kernel_filename;\n\n    realview_binfo.kernel_cmdline = kernel_cmdline;\n\n    realview_binfo.initrd_filename = initrd_filename;\n\n    realview_binfo.nb_cpus = ncpu;\n\n    arm_load_kernel(first_cpu, &realview_binfo);\n\n\n\n    /* ??? Hack to map an additional page of ram for the secondary CPU\n\n       startup code.  I guess this works on real hardware because the\n\n       BootROM happens to be in ROM/flash or in memory that isn't clobbered\n\n       until after Linux boots the secondary CPUs.  */\n\n    cpu_register_physical_memory(0x80000000, 0x1000, IO_MEM_RAM + ram_size);\n\n}\n", "idx": 7749, "substitutes": {"ram_size": ["mem_addr", "ram_name", "ram6addr", "mem_group", "ram_SIZE", "mem_size", "ram_group", "ram6group", "ram6name", " ram_SIZE", "ram_addr", "mem_name", " ram_name", "ram6size"], "vga_ram_size": ["vga_rom_name", "vga_rom_size", "vga_rom_SIZE", "vga_ram_name", "vga_ram_SIZE"], "boot_device": ["bootdevdev", "bootdevserial", "cpu_device", "cpu_dev", "boot_group", "boot_dev", "bootdevgroup", "bootdevdevice", "boot_serial", "cpu_group", "cpu_serial"], "ds": ["ck", "db", "rs", "des", "dat", "eps", "sys", "cs", "du", "dt", "ps", "d", "si", "sd", "eds", "pers", "dh", "vd", "dd", "Ds", "vs", "bs", "pd", "ys", "de", "ks", "di", "da"], "kernel_filename": ["proc__file", "proc_fn", "proc_filename", "proc__module", "kernel_file", "kernel___file", "kernel___filename", "kernel_fn", "kernel__fn", "kernel__filename", "kernel_module", "kernel__file", "kernel__module", "proc_file", "proc_module", "proc__filename", "proc__fn", "kernel___fn", "kernel___module"], "kernel_cmdline": ["kernel_catset", "kernel_cmdmode", "kernel_commandline", "kernel_commandset", "kernel_submode", "kernel_cmdset", "kernel_subline", "kernel_catline", "kernel_commandmode", "kernel_subset", "kernel_catmode"], "initrd_filename": ["initrm_filename", "initrm_file", "initrdmopfolder", "initrmmopfilename", "initrd_file", "initrdmopfilename", "initrd_name", "initrdmopname", "initrm_name", "initrdmopfile", "initrd_folder", "initrmmopname", "initrmmopfolder", "initrm_folder", "initrmmopfile"], "cpu_model": ["cpu_brand", "cpu2type", "cpu2Model", "pu_link", "pu_mode", "pu_model", "CPU_type", "cpu_Model", "CPU_brand", "CPU_model", "pu_Model", "cpu_link", " cpu_mode", "CPU_Model", "CPU_models", "cpu_value", "CPU_mode", " cpu_option", "cpu2mode", "cpu_type", "cpu_models", "pu_lock", "cpu2model", "cpu_lock", "cpu_option", " cpu_value", "cpu_mode"], "env": ["policy", "db", "ev", "chart", "sp", "esc", "et", "ei", "window", "po", "end", "ped", "pb", "ctx", "pen", "eric", "cam", "eni", "anc", "conn", "em", "buf", "sc", "eas", "er", "eg", "ps", "si", "ec", "dev", "ew", "context", "eng", "environment", "vp", "server", "pe", "proc", "py", "esp", "en", "org", "v", "ah", "cap", "nv", "ef", "eu", "vs", "tmp", "cv", "ptr", "jp", "ee", "manager", "vt", "obj", "qt", "e", "net", "enc", "shell"], "pic": ["rip", "ic", "par", "sp", "jpg", "magic", "wp", "Pic", "ping", "pb", "ics", "pc", "pen", "eric", "pan", "cam", "anc", "ctx", "Pict", "fig", "sc", "pict", "fc", "pins", "p", "pat", "pa", "pick", "ps", "pol", "picture", "virt", "lib", "xi", "pl", "phys", "pi", "str", "syn", "pipe", "proc", "py", "pr", "png", "style", "nic", "lp", "icc", "txt", "cap", "shot", "fn", "ac", "sac", "img", "parse", "doc", "ig", "jp", "pac", "pse", "pn", "Picture", "iac", "pp", "pres", "pin", "res", "spr", "arr", "tick", "capt", "script"], "scsi_hba": ["scsi_hbc", "scsi_bda", "scsi_pbc", "scsi_pda", "scsi_bbc", "scsi_bbd", "scsi_lba", "scsi_lbd", "scsi_lbc", "scsi_pbd", "scsi_hbd", "scsi_pba", "scsi_lda", "scsi_hda", "scsi_bba"], "pci_bus": ["pci_box", "pci__bus", "pio_box", "pci__Bus", "pio_Bus", "pci__box", "pio_us", "pci_us", "pci__us", "pio_bus", "pci_Bus"], "nd": ["ck", "ini", "ns", "ped", "md", " ni", "nt", "nn", "ND", "ind", "na", "wn", "ng", "vd", "nv", "inf", "dd", "st", "und", "dn", " din", "fn", "sn", "nb", "ld", "ne", "ni", "fd", "inn"], "n": ["all", "names", "mn", "ln", "node", "ns", "c", "note", "nr", "i", "con", "nt", "nor", "nn", "rn", "p", "g", "d", "gn", "nc", "len", "no", "network", "un", "na", "o", "t", "r", "N", "w", "nu", "el", "number", "an", "k", "ng", "yn", "en", "num", "v", "cn", "nm", "s", "m", "fn", "dn", "nb", "sn", "nan", "y", "count", "np", "l", "e", "j", "z", "ll", "x", "ne", "ni", "conn", "nl", "name", "nw"], "cpu_irq": ["cpu_lrq", "cpu__irqs", "cpu_irqs", "cpu__irq", "cpu_ireQ", "cpu_pirq", "cpu_iraqs", "cpu__irues", "cpu_irequ", "cpu_ireque", "cpu__irqu", "cpu_pirch", "cpu_ireqs", "cpu_mirqs", "cpu_mirQ", "cpu_ibrqs", "cpu__ireqs", "cpu_irqu", "cpu_iraues", "cpu_pirqs", "cpu_iraqu", "cpu_mirch", "cpu_arq", "cpu_lrqq", "cpu__ireues", "cpu_irque", "cpu_pirqq", "cpu_arqs", "cpu_irch", "cpu_ibrQ", "cpu_irqq", "cpu__irequ", "cpu_ibrqq", "cpu_ibrqu", "cpu_mirq", "cpu_iraq", "cpu_pirque", "cpu__ireque", "cpu_ibrues", "cpu__ireq", "cpu_irech", "cpu_ibrq", "cpu__irque", "cpu_ireq", "cpu_irues", "cpu_ireues", "cpu_irQ", "cpu_arque", "cpu_ibrch", "cpu_lrqs", "cpu_lrch"], "ncpu": ["mcgpu", "ncgpu", "nvcp", "cnpy", "cPU", "gncp", "nccore", "nvcpu", "nccp", "mcuda", "nicuda", "cgpu", "ccpu", "NCgpu", "mcpc", "nicPU", "cuda", "niccpu", "ncrow", "npPU", "cnrow", "gnpu", "nicpu", "nccpu", "npcpu", "cnuda", "NCuda", "cncp", "nvrow", "gncpu", "cnPU", "gnrow", "ccore", "mcur", "ncPU", "NCcpu", "cnpu", "cncore", "NCpc", "cngpu", "NCPU", "NCcore", "npuda", "cnur", "cpu", "NCpu", "ncpc", "mcpu", "cur", "cncpu", "mcpy", "cnpc", "ncuda", "NCpy", "ncur", "ncpy", "nvpu", "nppu"], "index": ["thread", "error", "type", "i", "cycle", "nn", "si", "order", "link", "location", "len", "ind", "total", "number", "id", "pos", "ion", "num", "Index", "axis", "count", "loop", "f", "size", "di", "x", "ii", "name"]}}
{"project": "qemu", "commit_id": "55e1819c509b3d9c10a54678b9c585bbda13889e", "target": 0, "func": "QString *qstring_from_substr(const char *str, int start, int end)\n\n{\n\n    QString *qstring;\n\n\n\n    qstring = g_malloc(sizeof(*qstring));\n\n\n\n    qstring->length = end - start + 1;\n\n    qstring->capacity = qstring->length;\n\n\n\n    qstring->string = g_malloc(qstring->capacity + 1);\n\n    memcpy(qstring->string, str + start, qstring->length);\n\n    qstring->string[qstring->length] = 0;\n\n\n\n    QOBJECT_INIT(qstring, &qstring_type);\n\n\n\n    return qstring;\n\n}\n", "idx": 7754, "substitutes": {"str": ["Str", "sp", "next", "c", "gr", "br", "i", "buf", "p", "g", "add", "len", "name", "ind", "tr", "r", "from", "w", "dr", "pos", "rest", "begin", "s", "ix", "st", "cur", "obj", "e", "ctr", "fr", "enc", "arr", "res", "star", "j", "gap", "End", "STR", "ring"], "start": ["init", "next", "it", "step", "shift", "get", "offset", "pad", "Start", "wind", "p", "addr", "n", "use", "started", "ind", "index", "pointer", "first", "range", "stop", "from", "r", "old", "id", "pos", "inter", "pre", "rest", "begin", "iter", "req", "st", "part", "art", "entry", "starting", "ish", "starter", "before", "size", "in", "length", "origin"], "end": ["ension", "ff", "END", "offset", "pad", "set", "nd", "last", "mid", "ent", "d", "add", "ended", "eng", "ind", "and", "bound", "stop", "append", "hend", "pend", "to", "id", "rest", "send", "ending", "max", "ue", "en", "begin", "ad", "num", "due", "st", "size", "e", "length", "End"], "qstring": ["qqobject", "qcomment", "qservice", "qarray", "eqsequence", "aqservice", "sqsequence", "qString", " qsystem", "querstring", "sqring", "requarray", "aqresource", " qnumber", "qudriver", "qqcomment", "qustring", "requsequence", "sqsection", "qusection", "qualobject", "sqarray", "qsystem", "requstring", "requdata", " qstrings", "qudata", "eqservice", "qsection", "requfile", "qualstr", "qstr", "qserver", "sqfile", "qustr", "eqstrings", "dqstr", "qusequence", "qqsequence", "questdata", " qcomment", "sqsite", "qqstr", "qbuffer", "qqbuffer", "sqresource", "eqnumber", "qualString", "aqstring", "quresource", "quservice", " qsequence", "eqserver", "sqobject", "sqstr", "questcomment", "quserver", "qsequence", "qufile", "qqstrings", " qbuffer", "aqdriver", "sqString", "sqstrings", "requnumber", "qualcomment", "querfile", "qring", "qqstring", "qunumber", "eqsite", "dqString", "sqstring", "eqfile", "requsection", "qqnumber", "dqobject", "requresource", "dqstring", "eqresource", "quernumber", "requfilename", "qucomment", "sqdata", "qdata", "dqring", "qresource", "questfilename", "qualring", "quobject", "qdriver", "qusite", "qnumber", "eqdriver", "sqnumber", " qring", "qualnumber", "dqnumber", "qustrings", "queststr", "sqfilename", "querserver", "qqdata", "questarray", "sqcomment", "questsystem", "qsite", "qualstring", " qobject", "eqstring", " qstr", "qobject", "eqcomment", "questring", "qfilename", "questnumber", "qfile", "qubuffer", "requcomment", "qstrings", "dqcomment", "queststring", "sqsystem"]}}
{"project": "qemu", "commit_id": "12d69ac03b45156356b240424623719f15d8143e", "target": 0, "func": "static void test_source_wait_event_notifier(void)\n\n{\n\n    EventNotifierTestData data = { .n = 0, .active = 1 };\n\n    event_notifier_init(&data.e, false);\n\n    aio_set_event_notifier(ctx, &data.e, event_ready_cb);\n\n    g_assert(g_main_context_iteration(NULL, false));\n\n    g_assert_cmpint(data.n, ==, 0);\n\n    g_assert_cmpint(data.active, ==, 1);\n\n\n\n    event_notifier_set(&data.e);\n\n    g_assert(g_main_context_iteration(NULL, false));\n\n    g_assert_cmpint(data.n, ==, 1);\n\n    g_assert_cmpint(data.active, ==, 0);\n\n\n\n    while (g_main_context_iteration(NULL, false));\n\n    g_assert_cmpint(data.n, ==, 1);\n\n    g_assert_cmpint(data.active, ==, 0);\n\n\n\n    aio_set_event_notifier(ctx, &data.e, NULL);\n\n    while (g_main_context_iteration(NULL, false));\n\n    g_assert_cmpint(data.n, ==, 1);\n\n\n\n    event_notifier_cleanup(&data.e);\n\n}\n", "idx": 7761, "substitutes": {}}
{"project": "qemu", "commit_id": "f9749f28b78be36471d3d0f5d4b6eed030f8942e", "target": 0, "func": "static int coroutine_fn is_allocated_base(BlockDriverState *top,\n\n                                          BlockDriverState *base,\n\n                                          int64_t sector_num,\n\n                                          int nb_sectors, int *pnum)\n\n{\n\n    BlockDriverState *intermediate;\n\n    int ret, n;\n\n\n\n    ret = bdrv_co_is_allocated(top, sector_num, nb_sectors, &n);\n\n    if (ret) {\n\n        *pnum = n;\n\n        return ret;\n\n    }\n\n\n\n    /*\n\n     * Is the unallocated chunk [sector_num, n] also\n\n     * unallocated between base and top?\n\n     */\n\n    intermediate = top->backing_hd;\n\n\n\n    while (intermediate != base) {\n\n        int pnum_inter;\n\n\n\n        ret = bdrv_co_is_allocated(intermediate, sector_num, nb_sectors,\n\n                                   &pnum_inter);\n\n        if (ret < 0) {\n\n            return ret;\n\n        } else if (ret) {\n\n            *pnum = pnum_inter;\n\n            return 0;\n\n        }\n\n\n\n        /*\n\n         * [sector_num, nb_sectors] is unallocated on top but intermediate\n\n         * might have\n\n         *\n\n         * [sector_num+x, nr_sectors] allocated.\n\n         */\n\n        if (n > pnum_inter) {\n\n            n = pnum_inter;\n\n        }\n\n\n\n        intermediate = intermediate->backing_hd;\n\n    }\n\n\n\n    *pnum = n;\n\n    return 1;\n\n}\n", "idx": 7762, "substitutes": {"top": ["upper", "root", "node", "prefix", "highest", "target", "bot", "h", "sys", "bottom", "state", "primary", "localhost", "at", "template", "best", "p", "table", "first", "tops", "t", "bit", "th", "tools", "to", "soc", "master", "above", "las", "new", "part", "most", "tmp", "TOP", "super", "parent", "local", "test", "Top", "prototype", "global", "high", "tor", "origin", "x", "tp", "title", "onet", "python"], "base": ["init", "b", "binding", "root", "bot", "back", "real", "disabled", "bottom", "buffer", "secondary", "bt", "bound", "server", "Base", "bit", "initial", "shadow", "to", "balance", "start", "out", "bare", "iso", "reset", "block", "basic", "part", "tmp", "super", "local", "kit", "area", "boot", "check", "bas", "based"], "sector_num": [" sector_um", "sectorNamenum", "sectorLnum", "sector_NUM", "sectoritynu", "sector2mon", "sector_nu", "sector_begin", "seat_num", " sector_begin", "sector7prim", "sector2begin", "sectoritynum", "sector_um", "sectorityprim", "sectorNamebegin", "sector7nu", "sector2um", "seat_NUM", "sectorLmon", "seat_nu", "sector7NUM", " sector_mon", "sectorityNUM", "sectorLnom", "sector7num", " sector_nom", "sector_prim", "seat_prim", "sector_snap", "sectorLsnap", " sector_snap", "sector_nom", "sector2num", "sectorNamemon", "sectorNameum", "sector_mon"], "nb_sectors": ["nb_sugments", "nb_vegments", "nb_beriers", "nb_beors", "nb_seitors", "nb_vectors", "nb_veriers", "nb_syors", "nb_veitors", "nb_teors", "nb_seurers", "nb_megments", "nb_suirs", "nb_severs", "nb_teitors", "nb_esors", "nb_syitors", "nb_vevers", "nb_segments", "nb_veirs", "nb_bevers", "nb_seors", "nb_meors", "nb_suors", "nb_seirs", "nb_bectors", "nb_mectors", "nb_teurers", "nb_syurers", "nb_veurers", "nb_esvers", "nb_suctors", "nb_esriers", "nb_esctors", "nb_tectors", "nb_syctors", "nb_meirs", "nb_veors", "nb_seriers"], "pnum": ["pennum", "kinumn", "pnenum", "gnnum", "publicmun", "publicUM", "gnenum", "kinUM", "pnnum", "kinnum", "panenum", "wnnum", "pnumer", "gnom", "penumn", "penUM", "kinum", "wnUM", "publicum", "pngnum", "panUM", "penum", "panom", "nnenum", "publicnum", "wnumn", "pngUM", "pngmun", "pnumn", "pnUM", "kinenum", "pnom", "pnmun", "panmun", "panumer", "pannum", "nnnum", "pngum", "nnumer", "gnum", "wnum", "panum", "nnum", "kinom", "gnumer"], "intermediate": ["iterceptor", "imior", "preval", "intmedi", "tramediate", "innerceptor", "intval", "INTERmedi", "intmediate", "INTERior", "tramedi", "interval", "trval", "intceptor", "INTERmediate", "Intermediate", "INTERval", "nemediate", " interility", "immedi", "iterior", "Intermedi", "premediate", "nemedi", "imval", "interior", "neior", "internalmedi", "preior", "intermedi", "innerior", " interval", "itermedi", "premedi", "INTERceptor", "immediate", "innermediate", " interceptor", "Interior", "iterval", "neceptor", "innermedi", "traior", "internalmediate", " intermedi", "interceptor", "interility", "itermediate", "trmedi", "internalval", "trmediate", "traceptor", "internalior", "iterility", "trility", "Interval"], "ret": ["gc", "att", "det", "nat", "virt", "red", "alt", "t", "utils", "iter", "num", "txt", "reset", "cat", "jp", "j", "elt", "flag", "this", "gt", "success", "verified", "ter", "nt", "ben", "dt", "rect", " Ret", "zero", "inter", "nil", "out", "lit", "ert", "it", "git", "back", "ry", "backed", "mt", "len", "val", "tr", "rev", "rem", "rest", "try", "rt", "final", "re", "reg", "ft", "ount", "sat", "ll", "res", " RET", "deg", "result", "repl", "pret", "false", "rier", "cmd", "rets", "ary", "ref", "bool", "status", "resp", "print", "RET", "f", "Ret", "arg", "def"], "n": ["mn", "ln", "ns", "c", "h", "nr", "i", "nd", "nt", "nor", "ann", "nn", "nat", "p", "g", "d", "tn", "nc", "len", "un", "na", "o", "t", "nu", "N", "number", "r", "nm", "cn", "en", "num", "v", "nv", "m", "fn", "dn", "nb", "sn", "nan", "np", "pn", "j", "nl", "non", "ne", "x", "ni", "z", "l"], "pnum_inter": ["pnum_ref", "pnum___ref", "pnum_con", "pnum_iter", "pnhum_war", "pnenum_inter", "pnenum_int", "pnum_Inter", "pnenum_inst", "pnumer_inter", "pnum__iter", "pnum2pair", "pnenum_inner", "pnum___pair", "pnum____war", "pnum_war", "pnum_ver", "pnum2inter", "pnum_inst", "pnump___ref", "pnhum_iter", "pnump_inter", "pnump___pair", "pnum___inter", "pnum____iter", "pnum_inner", "pnum____inter", "pnump___inter", "pnumer_val", "pnum____adr", "pnum2ref", "pnhum_inter", "pnum_int", "pnump___iter", "pnum_adr", "pnumer_iter", "pnum___iter", "pnum__Inter", "pnump_iter", "pnum_pair", "pnum2iter", "pnhum_adr", "pnumer_ver", "pnumer_con", "pnum_val", "pnump_pair", "pnum__inter", "pnump_ref", "pnumer_Inter"]}}
{"project": "qemu", "commit_id": "c6bf0f7ffa90c720377eb6bddd27037041acbc5b", "target": 0, "func": "static DisplayType select_display(const char *p)\n\n{\n\n    Error *err = NULL;\n\n    const char *opts;\n\n    DisplayType display = DT_DEFAULT;\n\n\n\n    if (strstart(p, \"sdl\", &opts)) {\n\n#ifdef CONFIG_SDL\n\n        display = DT_SDL;\n\n        while (*opts) {\n\n            const char *nextopt;\n\n\n\n            if (strstart(opts, \",frame=\", &nextopt)) {\n\n                opts = nextopt;\n\n                if (strstart(opts, \"on\", &nextopt)) {\n\n                    no_frame = 0;\n\n                } else if (strstart(opts, \"off\", &nextopt)) {\n\n                    no_frame = 1;\n\n                } else {\n\n                    goto invalid_sdl_args;\n\n                }\n\n            } else if (strstart(opts, \",alt_grab=\", &nextopt)) {\n\n                opts = nextopt;\n\n                if (strstart(opts, \"on\", &nextopt)) {\n\n                    alt_grab = 1;\n\n                } else if (strstart(opts, \"off\", &nextopt)) {\n\n                    alt_grab = 0;\n\n                } else {\n\n                    goto invalid_sdl_args;\n\n                }\n\n            } else if (strstart(opts, \",ctrl_grab=\", &nextopt)) {\n\n                opts = nextopt;\n\n                if (strstart(opts, \"on\", &nextopt)) {\n\n                    ctrl_grab = 1;\n\n                } else if (strstart(opts, \"off\", &nextopt)) {\n\n                    ctrl_grab = 0;\n\n                } else {\n\n                    goto invalid_sdl_args;\n\n                }\n\n            } else if (strstart(opts, \",window_close=\", &nextopt)) {\n\n                opts = nextopt;\n\n                if (strstart(opts, \"on\", &nextopt)) {\n\n                    no_quit = 0;\n\n                } else if (strstart(opts, \"off\", &nextopt)) {\n\n                    no_quit = 1;\n\n                } else {\n\n                    goto invalid_sdl_args;\n\n                }\n\n            } else if (strstart(opts, \",gl=\", &nextopt)) {\n\n                opts = nextopt;\n\n                if (strstart(opts, \"on\", &nextopt)) {\n\n                    request_opengl = 1;\n\n                } else if (strstart(opts, \"off\", &nextopt)) {\n\n                    request_opengl = 0;\n\n                } else {\n\n                    goto invalid_sdl_args;\n\n                }\n\n            } else {\n\n            invalid_sdl_args:\n\n                fprintf(stderr, \"Invalid SDL option string: %s\\n\", p);\n\n                exit(1);\n\n            }\n\n            opts = nextopt;\n\n        }\n\n#else\n\n        fprintf(stderr, \"SDL support is disabled\\n\");\n\n        exit(1);\n\n#endif\n\n    } else if (strstart(p, \"vnc\", &opts)) {\n\n#ifdef CONFIG_VNC\n\n        if (*opts == '=') {\n\n            if (vnc_parse(opts + 1, &err) == NULL) {\n\n                error_report_err(err);\n\n                exit(1);\n\n            }\n\n        } else {\n\n            fprintf(stderr, \"VNC requires a display argument vnc=<display>\\n\");\n\n            exit(1);\n\n        }\n\n#else\n\n        fprintf(stderr, \"VNC support is disabled\\n\");\n\n        exit(1);\n\n#endif\n\n    } else if (strstart(p, \"curses\", &opts)) {\n\n#ifdef CONFIG_CURSES\n\n        display = DT_CURSES;\n\n#else\n\n        fprintf(stderr, \"Curses support is disabled\\n\");\n\n        exit(1);\n\n#endif\n\n    } else if (strstart(p, \"gtk\", &opts)) {\n\n#ifdef CONFIG_GTK\n\n        display = DT_GTK;\n\n        while (*opts) {\n\n            const char *nextopt;\n\n\n\n            if (strstart(opts, \",grab_on_hover=\", &nextopt)) {\n\n                opts = nextopt;\n\n                if (strstart(opts, \"on\", &nextopt)) {\n\n                    grab_on_hover = true;\n\n                } else if (strstart(opts, \"off\", &nextopt)) {\n\n                    grab_on_hover = false;\n\n                } else {\n\n                    goto invalid_gtk_args;\n\n                }\n\n            } else if (strstart(opts, \",gl=\", &nextopt)) {\n\n                opts = nextopt;\n\n                if (strstart(opts, \"on\", &nextopt)) {\n\n                    request_opengl = 1;\n\n                } else if (strstart(opts, \"off\", &nextopt)) {\n\n                    request_opengl = 0;\n\n                } else {\n\n                    goto invalid_gtk_args;\n\n                }\n\n            } else {\n\n            invalid_gtk_args:\n\n                fprintf(stderr, \"Invalid GTK option string: %s\\n\", p);\n\n                exit(1);\n\n            }\n\n            opts = nextopt;\n\n        }\n\n#else\n\n        fprintf(stderr, \"GTK support is disabled\\n\");\n\n        exit(1);\n\n#endif\n\n    } else if (strstart(p, \"none\", &opts)) {\n\n        display = DT_NONE;\n\n    } else {\n\n        fprintf(stderr, \"Unknown display type: %s\\n\", p);\n\n        exit(1);\n\n    }\n\n\n\n    return display;\n\n}\n", "idx": 7766, "substitutes": {"p": ["par", "q", "sp", "b", "wp", "cp", "pb", "c", "pc", "pro", "i", "ip", "ps", "g", "d", "bp", "pat", "n", "vp", "fp", "t", "r", "w", "ap", "pr", "s", "lp", "v", "m", "y", "jp", "np", "f", "P", "pp", "l"], "err": ["ev", "error", "Er", "conf", "kr", "cli", "buf", "aaa", "msg", "er", "die", "cmd", "cb", "usr", "r", "str", "proc", "rr", "rb", "cr", "txt", "cfg", "ch", "cur", "obj", "arr", "Error", "res"], "opts": ["opats", "copTS", "optgs", "opTS", " opters", "coputs", "att", "optt", "oppops", "optts", " copns", "coprs", "imts", "copns", "iopt", "iopres", "opstions", "opsks", "copter", "opstes", "argcs", "OPuts", "copjs", "initts", "ioptions", "opths", "optter", "OPcs", "optuts", "iopins", "opgt", "atcs", "experrs", "OPt", "experts", "optps", " opbs", "opns", "opws", "oppts", " oprets", "opsods", "initops", "opsns", "opscs", "opins", "cpgt", "obTS", "optrs", "OPTS", " oputs", "iopps", "Oprets", "opste", "opster", "iopts", "opms", "opports", "initths", "opsds", "OPps", "operats", " opgt", "experjs", "oprets", "opergs", " optods", "copbs", " opops", "obcs", "initTS", "oppTS", " copts", " coptes", "opsports", "opsgt", "opsres", "cptes", " opTS", "topins", "experats", " opports", "opsrs", " opths", "opds", "oputs", " oprs", "optx", "opps", "experws", "opsats", "Opcs", "cpts", "opsters", "experTS", "opsbs", "imuts", "opsms", "optters", " opmits", "iopcs", "expergs", "Optes", "opcs", "coptx", "opmits", " copports", "operuts", "Opts", "cpps", "operjs", "experds", "copts", "OpTS", " opks", "optws", "experuts", "optTS", " opats", "ioputs", "options", " opps", "oprs", "optes", "copgs", "opsmits", "opgs", "topt", "iopgs", " opte", "opbs", "argrets", "topts", "operTS", "obt", "OPts", "copters", "Opters", "optins", "opters", "copms", "opres", "opjs", "ioptes", "optats", " opcs", " optes", "optte", "oppths", "copks", "Opps", "imws", "optmits", " opres", "opsuts", "opvals", "imds", " opms", " opods", "Opsts", "Opws", "opks", "opte", "opsjs", "opsts", "opstx", "optvals", " opsts", "Oputs", "topgs", "argsts", "iopgt", "opter", "Options", "atTS", " opns", " optns", "obts", "iopats", "atts", "opsvals", "opt", " optgt", "opods", "Opats", "opsTS", "opops", "opttes", " optts", "opsws", " opjs", "expervals", " optx", "coptes", "argts", "operts"], "nextopt": ["randoption", "maxopt", "Nextpt", "Nextprop", "trueopted", "nextkw", "nextmsg", " NEXToption", " nextopted", " nextvert", "trueopt", "appendmsg", "latestobj", "nextattr", "Nextopted", "invopted", "futuremsg", "firstopt", "newobj", "futureopt", "nexttimeout", "Nextvirt", "Nextevent", "futureop", " nextblock", "futurept", " nextjson", "newprop", "Nextstat", "anyopt", "firstaltern", "invvert", "appendopt", "futureoption", "Nextop", "anyopted", " nextkw", " NEXTopted", "tenattr", "nextoption", "ndoption", "tentimeout", "nextpost", "firstprop", "nextevent", "tenblock", "newopt", "tenopt", "futurevert", " nexttimeout", "nextvert", "Nextoption", "nextcrit", " nextop", "newop", "newoption", "futurecrit", "govpt", "newsopt", "invopt", "nextaltern", "futureopted", "Nextpost", " NEXTstat", "nextjson", " NEXTop", "govopt", "nextopted", "latestoption", "newskw", "futurepost", "appendopted", "newoptions", " nextpost", " nextprop", "randop", "newsattr", "newspt", " nextvirt", "nextprop", "newstimeout", "tenoptions", "anyop", " NEXTevent", "nextpt", "futurekw", "randopt", "newattr", " nextevent", "Nextopt", "Nextoptions", "ndblock", " nextattr", "nextblock", "maxjson", "nextobj", " NEXTjson", "anyoption", "Nextalt", "appendoption", "trueoption", " nextpt", "trueop", "maxopted", "myoption", "govoption", " nextalt", "ndopted", "newsoption", "myopted", "tenoption", " nextmsg", "nextop", "tenop", "randvirt", " nextstat", " nextcrit", "latestattr", "nextoptions", "latestopt", "nextalt", "tenaltern", "nextstat", "tenprop", "ndopt", " nextobj", "nextvirt", "maxop", "myopt", "tenopted", " NEXTopt", "invop", "futurealt", "mycrit", " nextaltern", " nextoption", "govop", "Nextvert", "firstoption"]}}
{"project": "FFmpeg", "commit_id": "465e1dadbef7596a3eb87089a66bb4ecdc26d3c4", "target": 0, "func": "static int get_packetheader(NUTContext *nut, ByteIOContext *bc, int prefix_length, int calculate_checksum)\n\n{\n\n    int64_t start, size, last_size;\n\n    start= url_ftell(bc) - prefix_length;\n\n\n\n    if(start != nut->packet_start + nut->written_packet_size){\n\n        av_log(nut->avf, AV_LOG_ERROR, \"get_packetheader called at weird position\\n\");\n\n        return -1;\n\n    }\n\n    \n\n    if(calculate_checksum)\n\n        init_checksum(bc, update_adler32, 0);\n\n\n\n    size= get_v(bc);\n\n    last_size= get_v(bc);\n\n    if(nut->written_packet_size != last_size){\n\n        av_log(nut->avf, AV_LOG_ERROR, \"packet size missmatch %d != %lld at %lld\\n\", nut->written_packet_size, last_size, start);\n\n        return -1;\n\n    }\n\n\n\n    nut->last_packet_start = nut->packet_start;\n\n    nut->packet_start = start;\n\n    nut->written_packet_size= size;\n\n\n\n    return size;\n\n}\n", "idx": 7777, "substitutes": {"nut": ["stab", "tree", "nit", "note", "rup", "utt", "cot", "nat", "dan", "piece", "orb", "utils", "anova", "cn", "that", "num", "anon", "critical", "dn", "art", "lost", "core", "rot", "wp", "ox", "mom", "roy", "nuts", "nt", "pie", "oren", "dig", "rn", "norm", "roo", "ocr", "ut", "nil", "ot", "config", "fn", "nova", "hn", "our", "exec", "desc", "np", "ape", "pieces", "addy", "Nut", "nc", "na", "nm", "org", "orn", "knife", "nv", "pot", "fail", "sat", "net", "snap", "aum", "news", "gob", "form", "mn", "nih", "node", "none", "nor", "cmd", "n", "etc", "wn", "olf", "nu", "ref", "tip", "img", "runner", "obj", "hog", "nw"], "bc": ["db", "cf", "ic", "dc", "gc", "bn", "bitcoin", "bec", "c", "bg", "pc", "cl", "cs", "comm", "sc", "fc", "BBC", "cm", "chron", "bp", "BC", "nc", "ec", "cb", "bo", "lc", "bt", "bi", "cc", "xc", "bb", "arc", "mac", "cn", "bf", "oc", "jac", "gru", "uc", "vc", "bs", "exec", "mc", "tc", "ba"], "prefix_length": ["prefixinglength", "prefix_Length", "prefixingsize", " prefix_len", "prefixinglen", "prefix_len", " prefix_size", "prefixingLength", "prefix_size", " prefix_Length"], "calculate_checksum": ["calculate_csume", "calculate_statssum", "calculate_cksums", "calculate_cksate", "calculate_csum", "calculate_ckssum", "calculate_cksize", "calculate_checkssum", "calculate_cssum", "calculate_statsum", "calculate_statsize", "calculate_checksize", "calculate_csums", "calculate_checksume", "calculate_statsate", "calculate_cksum", "calculate_checksums", "calculate_cksume", "calculate_checksate"], "start": ["init", "open", "read", "error", "next", "it", "end", "step", "shift", "get", "offset", "i", "set", "store", "state", "Start", "pad", "create", "skip", "base", "addr", "add", "seed", "seek", "len", "use", "pointer", "index", "first", "key", "prep", "stop", "from", "import", "need", "range", "id", "pos", "pre", "space", "rest", "top", "send", "begin", "try", "iter", "reset", "st", "art", "entry", "ist", "starting", "ish", "before", "check", "length", "origin", "trans", "source"], "size": ["content", "export", "bytes", "grow", "ice", "SIZE", "empty", "end", " end", "fee", "Size", "set", "year", "p", "zone", "equal", "body", "notice", "fit", "len", "n", "data", "sent", "se", "t", "height", "scale", "number", "space", "send", "max", "code", "num", "v", "small", "loss", "city", "sn", "south", "storage", "area", "capacity", "count", "shape", "sum", "ize", "l", "unknown", "length", "e", "format", "news", "ne", "since", "name", "resolution", "speed"], "last_size": ["first___length", "last___length", "latest_Size", "first_message", "last67Size", "Last_Size", "last___name", "latest_size", "latest_loc", "last___Size", "first_name", "last_SIZE", "last67speed", " last_Size", "last_Size", "last___loc", "last_message", "last67SIZE", "last_length", "last_name", "first___message", " last_SIZE", "latest_term", "Last_size", "last_speed", "first_size", "first___size", "first_length", "last___message", "last___size", "Last_speed", "first___name", "last67size", "Last_SIZE", "last_term", "last_loc", "last___term"]}}
{"project": "qemu", "commit_id": "75f19f8c3006970632303b49043b075dc4fe922e", "target": 0, "func": "static void megasas_unmap_frame(MegasasState *s, MegasasCmd *cmd)\n\n{\n\n    PCIDevice *p = PCI_DEVICE(s);\n\n\n\n    pci_dma_unmap(p, cmd->frame, cmd->pa_size, 0, 0);\n\n    cmd->frame = NULL;\n\n    cmd->pa = 0;\n\n    clear_bit(cmd->index, s->frame_map);\n\n}\n", "idx": 7779, "substitutes": {"s": ["rs", "service", "gs", "ses", "sp", "q", "ns", "c", "ctx", "h", "i", "sys", "qs", "state", "cs", "comm", "self", "os", "ps", "d", "n", "is", "ts", "ds", "o", "t", "es", "r", "js", "sv", "ls", "out", "stats", "args", "m", "spec", "st", "ss", "sq", "obj", "e", "S", "sts", "j", "a"], "cmd": ["content", "cod", "cast", "q", "buff", "ct", "call", "cp", "term", "c", "md", "cli", "job", "ctx", "cmp", "cont", "set", "kind", "nd", "comm", "nt", "msg", "mk", "raw", "seq", "ext", "bind", "op", "ind", "and", "range", "utils", "cc", "js", "pkg", "dx", "control", "send", "rest", "txt", "args", "req", "cfg", "dq", "command", "ch", "tab", "comment", "config", "quit", "report", "build", "batch", "cd", "exec", "desc", "kick", "now", "obj", "unknown", "comp", "ctr", "Cmd", "text", "auth", "conn", "def", "act"], "p": ["ph", "pid", "peer", "q", "sp", "b", "app", "cp", "c", "pc", "h", "up", "phy", "i", "pt", "d", "pa", "g", "bp", "n", "vp", "op", "pl", "t", "pers", "pi", "pm", "pre", "pkg", "proc", "ap", "lp", "v", "m", "part", "y", "jp", "np", "P", "pp", "j", "tp"]}}
{"project": "qemu", "commit_id": "02cb7f3a256517cbf3136caff2863fbafc57b540", "target": 0, "func": "int v9fs_co_open2(V9fsState *s, V9fsFidState *fidp, char *fullname, gid_t gid,\n\n                  int flags, int mode)\n\n{\n\n    int err;\n\n    FsCred cred;\n\n\n\n    cred_init(&cred);\n\n    cred.fc_mode = mode & 07777;\n\n    cred.fc_uid = fidp->uid;\n\n    cred.fc_gid = gid;\n\n    v9fs_co_run_in_worker(\n\n        {\n\n            fidp->fs.fd = s->ops->open2(&s->ctx, fullname, flags, &cred);\n\n            err = 0;\n\n            if (fidp->fs.fd == -1) {\n\n                err = -errno;\n\n            }\n\n        });\n\n    if (!err) {\n\n        total_open_fd++;\n\n        if (total_open_fd > open_fd_hw) {\n\n            v9fs_reclaim_fd(s);\n\n        }\n\n    }\n\n    return err;\n\n}\n", "idx": 7780, "substitutes": {"s": ["rs", "gs", "sp", "ses", "ssl", "b", "ns", "c", "its", "h", "sam", "sys", "qs", "state", "cs", "os", "p", "ps", "d", "n", "is", "ts", "ds", "ops", "t", "js", "sv", "ls", "sb", "xs", "v", "ims", "stats", "m", "hs", "a", "vs", "ss", "bs", "sq", "session", "f", "fs", "e", "S", "sts", "j", "aws", "source"], "fidp": ["fpidpc", "fpidps", "foidp", "vitphp", "fitp", "fado", "foido", "fitP", " fidphp", " fidpc", "fadpa", "fstartP", "fpidP", "fitpid", "foidpid", "fidpid", "fpidphp", "fido", "lfidp", " fpidpc", "fidcp", "fidscp", "fstartp", "fitcp", "vitp", "fpidpa", "fitpre", "fstartphp", "foidP", "fmtP", "fmtp", "vidcp", " fpidpa", " fpidps", "fitphp", "vitcp", " fpidP", "fadps", "fpidp", "fidphp", "foidps", "fidP", " fpidp", "vidphp", "lfoido", "fidsp", "fidspre", "vitpre", "lfidpid", "fmtpc", "lfoidP", "fito", "fidpa", " fidpa", "fmtphp", "foidpa", "fidps", " fidP", "fidsphp", "fstartpc", "lfidP", "vidp", "fadp", "fadpid", "fidpre", "fadP", "lfoidpid", " fidps", "lfoidp", " fpidphp", "lfido", "fidpc", "vidpre"], "fullname": ["largenamed", " fullName", "localname", "localName", "fullpath", "fullnam", "fullfilename", " fullfilename", "largename", " fullnam", "largeName", "fullnamed", " fullpath", "localnam", "longName", "longnam", "longname", "longfilename", "fullName", "largepath", "Fullname", " fullnamed", "localfilename", "Fullpath", "Fullnamed", "FullName"], "gid": ["Gid", "gId", "egdata", "pgdata", " gID", "Gno", "gdata", "GID", "vgID", "igId", "gno", "vgid", "gID", "vgdata", " gId", "pgid", "vgId", "GId", "igid", "igno", "egId", "egid", "egID", "pgID", " gno", "igID", "pgId"], "flags": [" modes", "fields", "styles", "times", "ags", "locks", "missions", "kind", "acts", "frames", "ms", "lines", "details", "settings", "fps", "vals", "types", "options", "params", "properties", "tags", "bits", "status", "levels", "Flags", "mask", "posts", "links", "comments", "features", "faces", "ops", "flag"], "mode": ["type", "md", "cmp", "kind", "Mode", "force", "mid", "te", "cmd", "ms", "mt", "tm", "perm", "scale", "pe", "position", "id", "module", "role", "code", "dim", "status", "command", "m", "dir", "MODE", "pose", "mask", "mod", "de", "size", "time", "format", "ase", "def", "ode", "flag"], "err": ["conf", "kr", "c", "h", "eric", "rel", "buf", "die", "order", "ec", "ind", "iter", "cr", "txt", "ch", "Error", "coord", "elt", "rs", "lr", "nr", "rn", "er", "ach", "str", "expr", "esp", "code", "out", "der", "cer", "oe", "l", "ev", "eor", "error", "msg", "timer", "score", "usr", "r", "dr", "rc", "rev", "rr", "attr", "try", "fi", "fr", "res", "ver", "result", "Er", "fee", "br", "cmp", "eas", "i", "raw", "erer", "n", "ner", "id", "fer", "pr", "inner", "resp", "off", "gz", "ptr", "count", "f", "e", "arr", "conn"], "cred": ["callkered", "dcld", "acld", "cld", " crib", " cde", "dcrib", "dcpred", "dcreed", " cded", "acreed", "conoded", "dcmem", " crc", "bcoded", "lcoded", "kmem", "uncded", "ckered", "camreed", "gld", "camred", "uncred", "krib", "lcrib", "uncrib", "acrc", "camde", "cpred", "cde", "cald", "lcred", "cmem", "bcreed", "carc", "cded", "acred", "conded", " ckered", " cpred", "creed", "crc", "grib", "lcreed", "kpred", "carib", "gred", "conred", " cmem", "conrib", "acrib", "dcred", "coded", " creed", "callreed", "greed", "callred", "crib", "callde", "camkered", " cld", "cared", "kred", "conreed", "bcrib", " coded", "bcred", "uncoded"], "total_open_fd": ["total_Open_fa", "total_open_FD", "total_Open_fd", "total_openMfs", "total_open_fs", "total_openMfd", "total_Open_FD", "total_open_fc", "total_open_df", "total_Open_fs", "total_open_db", "total_openMFD", "total_open_fa", "total_openMfa"]}}
{"project": "qemu", "commit_id": "bbe2f399b222f1f2fcf5cd2ea78e4f5c9a66c64e", "target": 0, "func": "static int receive_filter(VirtIONet *n, const uint8_t *buf, int size)\n\n{\n\n    static const uint8_t bcast[] = {0xff, 0xff, 0xff, 0xff, 0xff, 0xff};\n\n    static const uint8_t vlan[] = {0x81, 0x00};\n\n    uint8_t *ptr = (uint8_t *)buf;\n\n    int i;\n\n\n\n    if (n->promisc)\n\n        return 1;\n\n\n\n    if (!memcmp(&ptr[12], vlan, sizeof(vlan))) {\n\n        int vid = be16_to_cpup((uint16_t *)(ptr + 14)) & 0xfff;\n\n        if (!(n->vlans[vid >> 5] & (1U << (vid & 0x1f))))\n\n            return 0;\n\n    }\n\n\n\n    if ((ptr[0] & 1) && n->allmulti)\n\n        return 1;\n\n\n\n    if (!memcmp(ptr, bcast, sizeof(bcast)))\n\n        return 1;\n\n\n\n    if (!memcmp(ptr, n->mac, ETH_ALEN))\n\n        return 1;\n\n\n\n    for (i = 0; i < n->mac_table.in_use; i++) {\n\n        if (!memcmp(ptr, &n->mac_table.macs[i * ETH_ALEN], ETH_ALEN))\n\n            return 1;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 7782, "substitutes": {"n": ["mn", "bn", "ln", "node", "ns", "c", "note", "nr", "comm", "nt", "nor", "ann", "nn", "rn", "p", "g", "norm", "tn", "nc", "gn", "un", "na", "wn", "nu", "N", "an", "nm", "cn", "en", "num", "v", "ren", "out", "nv", "m", "fn", "dn", "nb", "sn", "nan", "nas", "np", "nex", "ll", "nl", "non", "ne", "names", "conn", "name", "nw"], "buf": ["read", "bytes", "cast", "uf", "buff", "b", "mem", "window", "pb", "ctx", "late", "bc", "Buffer", "buffer", "msg", "raw", "map", "p", "cmd", "cb", "tr", "queue", "r", "err", "w", "rc", "ref", "Buff", "out", "bf", "v", "block", "alloc", "tmp", "cv", "batch", "doc", "vec"], "size": ["sp", "empty", "SIZE", "mem", "c", "type", "offset", "Size", "set", "si", "seed", "len", "data", "scale", "id", "send", "start", "code", "en", "cap", "count", "address", "message", "ize", "e", "length", "name"], "bcast": ["obmap", "obcast", "bcasting", "fbcaster", "vcatch", "bgcast", "bmap", "vcaster", "wbcaster", "bbcast", "vbox", " bmap", "bcaster", "bcatch", "obare", " bcasts", "bbcaster", "bbcatch", "fbcast", "bbare", "bbbox", "bcasts", "bbox", "wbcmd", "bbcmd", "bbcasts", "bare", "bcmd", "vcast", "bgcaster", "obcasts", "bbcasting", "wbcasting", "fbcasting", " bare", "bbmap", "wbcast", "bgcatch", "bgbox", "fbcmd"], "vlan": ["tvul", "evlan", "invlan", "tvordan", " vlad", "vordan", "invld", " vlv", "tvlock", " vld", "plad", "evLAN", "vlad", "vault", "evault", "invlad", "tvlan", " vault", "tvld", " vlock", "vld", " vLAN", "vLAN", "vlv", "vlock", "tvlv", "invlv", "pul", " vul", "tvLAN", "tvault", " vordan", "tvlad", "plan", "vul", "evordan", "plock"], "ptr": ["vr", "rod", "sp", "buff", "grad", "uf", "mem", "ctx", "br", "shift", "rep", "pad", "offset", "cont", "pt", "xt", "nt", "rel", "buffer", "pointers", "p", "rect", "addr", "cmd", "bp", "ts", "ind", "pointer", "tr", "inters", "t", "fp", "r", "dh", "js", "dr", "push", "ref", "pos", "str", "proc", "expr", "attr", "pkg", "pr", "Ptr", "iter", "rt", "embed", "off", "tmp", "desc", "jp", "np", "cur", "obj", "rd", "pp", "ctr", "adr", "arr", "tp", "deg", "crop", "loc", "vec"], "i": ["init", "ic", "ini", " bi", "ei", "ci", " ii", "it", "im", "cli", " v", "gi", "mi", "qi", "ip", "li", "g", "si", "ami", "p", "zi", "xi", "ind", "index", "o", " ti", "t", "pi", "bi", "multi", "hi", "ri", "me", "id", "ui", "ki", "mu", "ji", "phi", "ti", " pi", "v", "ims", "ix", " j", "ai", "m", "I", "y", "\u0438", "us", "sim", "gu", "iu", "MI", "j", "x", "di", "ni", "ii"]}}
{"project": "FFmpeg", "commit_id": "4bb0b31f762c422ad15bee68da7bcf76940cc9fa", "target": 0, "func": "static int output_packet(InputStream *ist, int ist_index,\n\n                         OutputStream *ost_table, int nb_ostreams,\n\n                         const AVPacket *pkt)\n\n{\n\n    AVFormatContext *os;\n\n    OutputStream *ost;\n\n    int ret, i;\n\n    int got_output;\n\n    void *buffer_to_free = NULL;\n\n    static unsigned int samples_size= 0;\n\n    AVSubtitle subtitle, *subtitle_to_free;\n\n    int64_t pkt_pts = AV_NOPTS_VALUE;\n\n#if CONFIG_AVFILTER\n\n    int frame_available;\n\n#endif\n\n    float quality;\n\n\n\n    AVPacket avpkt;\n\n    int bps = av_get_bytes_per_sample(ist->st->codec->sample_fmt);\n\n\n\n    if(ist->next_pts == AV_NOPTS_VALUE)\n\n        ist->next_pts= ist->pts;\n\n\n\n    if (pkt == NULL) {\n\n        /* EOF handling */\n\n        av_init_packet(&avpkt);\n\n        avpkt.data = NULL;\n\n        avpkt.size = 0;\n\n        goto handle_eof;\n\n    } else {\n\n        avpkt = *pkt;\n\n    }\n\n\n\n    if(pkt->dts != AV_NOPTS_VALUE)\n\n        ist->next_pts = ist->pts = av_rescale_q(pkt->dts, ist->st->time_base, AV_TIME_BASE_Q);\n\n    if(pkt->pts != AV_NOPTS_VALUE)\n\n        pkt_pts = av_rescale_q(pkt->pts, ist->st->time_base, AV_TIME_BASE_Q);\n\n\n\n    //while we have more to decode or while the decoder did output something on EOF\n\n    while (avpkt.size > 0 || (!pkt && got_output)) {\n\n        uint8_t *data_buf, *decoded_data_buf;\n\n        int data_size, decoded_data_size;\n\n        AVFrame *decoded_frame, *filtered_frame;\n\n    handle_eof:\n\n        ist->pts= ist->next_pts;\n\n\n\n        if(avpkt.size && avpkt.size != pkt->size)\n\n            av_log(NULL, ist->showed_multi_packet_warning ? AV_LOG_VERBOSE : AV_LOG_WARNING,\n\n                   \"Multiple frames in a packet from stream %d\\n\", pkt->stream_index);\n\n            ist->showed_multi_packet_warning=1;\n\n\n\n        /* decode the packet if needed */\n\n        decoded_frame    = filtered_frame = NULL;\n\n        decoded_data_buf = NULL; /* fail safe */\n\n        decoded_data_size= 0;\n\n        data_buf  = avpkt.data;\n\n        data_size = avpkt.size;\n\n        subtitle_to_free = NULL;\n\n        if (ist->decoding_needed) {\n\n            switch(ist->st->codec->codec_type) {\n\n            case AVMEDIA_TYPE_AUDIO:{\n\n                if(pkt && samples_size < FFMAX(pkt->size * bps, AVCODEC_MAX_AUDIO_FRAME_SIZE)) {\n\n                    samples_size = FFMAX(pkt->size * bps, AVCODEC_MAX_AUDIO_FRAME_SIZE);\n\n                    av_free(samples);\n\n                    samples= av_malloc(samples_size);\n\n                }\n\n                decoded_data_size= samples_size;\n\n                    /* XXX: could avoid copy if PCM 16 bits with same\n\n                       endianness as CPU */\n\n                ret = avcodec_decode_audio3(ist->st->codec, samples, &decoded_data_size,\n\n                                            &avpkt);\n\n                if (ret < 0)\n\n                    return ret;\n\n                avpkt.data += ret;\n\n                avpkt.size -= ret;\n\n                data_size   = ret;\n\n                got_output  = decoded_data_size > 0;\n\n                /* Some bug in mpeg audio decoder gives */\n\n                /* decoded_data_size < 0, it seems they are overflows */\n\n                if (!got_output) {\n\n                    /* no audio frame */\n\n                    continue;\n\n                }\n\n                decoded_data_buf = (uint8_t *)samples;\n\n                ist->next_pts += ((int64_t)AV_TIME_BASE/bps * decoded_data_size) /\n\n                    (ist->st->codec->sample_rate * ist->st->codec->channels);\n\n                break;}\n\n            case AVMEDIA_TYPE_VIDEO:\n\n                    decoded_data_size = (ist->st->codec->width * ist->st->codec->height * 3) / 2;\n\n                    if (!(decoded_frame = avcodec_alloc_frame()))\n\n                        return AVERROR(ENOMEM);\n\n                    avpkt.pts = pkt_pts;\n\n                    avpkt.dts = ist->pts;\n\n                    pkt_pts = AV_NOPTS_VALUE;\n\n\n\n                    ret = avcodec_decode_video2(ist->st->codec,\n\n                                                decoded_frame, &got_output, &avpkt);\n\n                    quality = same_quant ? decoded_frame->quality : 0;\n\n                    if (ret < 0)\n\n                        goto fail;\n\n                    if (!got_output) {\n\n                        /* no picture yet */\n\n                        av_freep(&decoded_frame);\n\n                        goto discard_packet;\n\n                    }\n\n                    ist->next_pts = ist->pts = guess_correct_pts(&ist->pts_ctx, decoded_frame->pkt_pts,\n\n                                                                 decoded_frame->pkt_dts);\n\n                    if (ist->st->codec->time_base.num != 0) {\n\n                        int ticks= ist->st->parser ? ist->st->parser->repeat_pict+1 : ist->st->codec->ticks_per_frame;\n\n                        ist->next_pts += ((int64_t)AV_TIME_BASE *\n\n                                          ist->st->codec->time_base.num * ticks) /\n\n                            ist->st->codec->time_base.den;\n\n                    }\n\n                    avpkt.size = 0;\n\n                    buffer_to_free = NULL;\n\n                    pre_process_video_frame(ist, (AVPicture *)decoded_frame, &buffer_to_free);\n\n                    break;\n\n            case AVMEDIA_TYPE_SUBTITLE:\n\n                ret = avcodec_decode_subtitle2(ist->st->codec,\n\n                                               &subtitle, &got_output, &avpkt);\n\n                if (ret < 0)\n\n                    return ret;\n\n                if (!got_output) {\n\n                    goto discard_packet;\n\n                }\n\n                subtitle_to_free = &subtitle;\n\n                avpkt.size = 0;\n\n                break;\n\n            default:\n\n                return -1;\n\n            }\n\n        } else {\n\n            switch(ist->st->codec->codec_type) {\n\n            case AVMEDIA_TYPE_AUDIO:\n\n                ist->next_pts += ((int64_t)AV_TIME_BASE * ist->st->codec->frame_size) /\n\n                    ist->st->codec->sample_rate;\n\n                break;\n\n            case AVMEDIA_TYPE_VIDEO:\n\n                if (ist->st->codec->time_base.num != 0) {\n\n                    int ticks= ist->st->parser ? ist->st->parser->repeat_pict+1 : ist->st->codec->ticks_per_frame;\n\n                    ist->next_pts += ((int64_t)AV_TIME_BASE *\n\n                                      ist->st->codec->time_base.num * ticks) /\n\n                        ist->st->codec->time_base.den;\n\n                }\n\n                break;\n\n            }\n\n            avpkt.size = 0;\n\n        }\n\n\n\n        // preprocess audio (volume)\n\n        if (ist->st->codec->codec_type == AVMEDIA_TYPE_AUDIO) {\n\n            if (audio_volume != 256) {\n\n                switch (ist->st->codec->sample_fmt) {\n\n                case AV_SAMPLE_FMT_U8:\n\n                {\n\n                    uint8_t *volp = samples;\n\n                    for (i = 0; i < (decoded_data_size / sizeof(*volp)); i++) {\n\n                        int v = (((*volp - 128) * audio_volume + 128) >> 8) + 128;\n\n                        *volp++ = av_clip_uint8(v);\n\n                    }\n\n                    break;\n\n                }\n\n                case AV_SAMPLE_FMT_S16:\n\n                {\n\n                short *volp;\n\n                volp = samples;\n\n                for(i=0;i<(decoded_data_size / sizeof(short));i++) {\n\n                    int v = ((*volp) * audio_volume + 128) >> 8;\n\n                    *volp++ = av_clip_int16(v);\n\n                }\n\n                break;\n\n                }\n\n                case AV_SAMPLE_FMT_S32:\n\n                {\n\n                    int32_t *volp = samples;\n\n                    for (i = 0; i < (decoded_data_size / sizeof(*volp)); i++) {\n\n                        int64_t v = (((int64_t)*volp * audio_volume + 128) >> 8);\n\n                        *volp++ = av_clipl_int32(v);\n\n                    }\n\n                    break;\n\n                }\n\n                case AV_SAMPLE_FMT_FLT:\n\n                {\n\n                    float *volp = samples;\n\n                    float scale = audio_volume / 256.f;\n\n                    for (i = 0; i < (decoded_data_size / sizeof(*volp)); i++) {\n\n                        *volp++ *= scale;\n\n                    }\n\n                    break;\n\n                }\n\n                case AV_SAMPLE_FMT_DBL:\n\n                {\n\n                    double *volp = samples;\n\n                    double scale = audio_volume / 256.;\n\n                    for (i = 0; i < (decoded_data_size / sizeof(*volp)); i++) {\n\n                        *volp++ *= scale;\n\n                    }\n\n                    break;\n\n                }\n\n                default:\n\n                    av_log(NULL, AV_LOG_FATAL,\n\n                           \"Audio volume adjustment on sample format %s is not supported.\\n\",\n\n                           av_get_sample_fmt_name(ist->st->codec->sample_fmt));\n\n                    exit_program(1);\n\n                }\n\n            }\n\n        }\n\n\n\n        /* frame rate emulation */\n\n        if (input_files[ist->file_index].rate_emu) {\n\n            int64_t pts = av_rescale(ist->pts, 1000000, AV_TIME_BASE);\n\n            int64_t now = av_gettime() - ist->start;\n\n            if (pts > now)\n\n                usleep(pts - now);\n\n        }\n\n        /* if output time reached then transcode raw format,\n\n           encode packets and output them */\n\n        for (i = 0; i < nb_ostreams; i++) {\n\n            OutputFile *of = &output_files[ost_table[i].file_index];\n\n            int frame_size;\n\n\n\n            ost = &ost_table[i];\n\n            if (ost->source_index != ist_index)\n\n                continue;\n\n\n\n            if (of->start_time && ist->pts < of->start_time)\n\n                continue;\n\n\n\n            if (of->recording_time != INT64_MAX &&\n\n                av_compare_ts(ist->pts, AV_TIME_BASE_Q, of->recording_time + of->start_time,\n\n                              (AVRational){1, 1000000}) >= 0) {\n\n                ost->is_past_recording_time = 1;\n\n                continue;\n\n            }\n\n\n\n#if CONFIG_AVFILTER\n\n            if (ist->st->codec->codec_type == AVMEDIA_TYPE_VIDEO &&\n\n                ost->input_video_filter) {\n\n                AVRational sar;\n\n                if (ist->st->sample_aspect_ratio.num)\n\n                    sar = ist->st->sample_aspect_ratio;\n\n                else\n\n                    sar = ist->st->codec->sample_aspect_ratio;\n\n                av_vsrc_buffer_add_frame(ost->input_video_filter, decoded_frame, ist->pts, sar);\n\n                if (!(filtered_frame = avcodec_alloc_frame())) {\n\n                    ret = AVERROR(ENOMEM);\n\n                    goto fail;\n\n                }\n\n            }\n\n            frame_available = ist->st->codec->codec_type != AVMEDIA_TYPE_VIDEO ||\n\n                !ost->output_video_filter || avfilter_poll_frame(ost->output_video_filter->inputs[0]);\n\n            while (frame_available) {\n\n                AVRational ist_pts_tb;\n\n                if (ist->st->codec->codec_type == AVMEDIA_TYPE_VIDEO && ost->output_video_filter)\n\n                    get_filtered_video_frame(ost->output_video_filter, filtered_frame, &ost->picref, &ist_pts_tb);\n\n                if (ost->picref)\n\n                    ist->pts = av_rescale_q(ost->picref->pts, ist_pts_tb, AV_TIME_BASE_Q);\n\n#else\n\n                filtered_frame = decoded_frame;\n\n#endif\n\n                os = output_files[ost->file_index].ctx;\n\n\n\n                /* set the input output pts pairs */\n\n                //ost->sync_ipts = (double)(ist->pts + input_files[ist->file_index].ts_offset - start_time)/ AV_TIME_BASE;\n\n\n\n                if (ost->encoding_needed) {\n\n                    av_assert0(ist->decoding_needed);\n\n                    switch(ost->st->codec->codec_type) {\n\n                    case AVMEDIA_TYPE_AUDIO:\n\n                        do_audio_out(os, ost, ist, decoded_data_buf, decoded_data_size);\n\n                        break;\n\n                    case AVMEDIA_TYPE_VIDEO:\n\n#if CONFIG_AVFILTER\n\n                        if (ost->picref->video && !ost->frame_aspect_ratio)\n\n                            ost->st->codec->sample_aspect_ratio = ost->picref->video->pixel_aspect;\n\n#endif\n\n                        do_video_out(os, ost, ist, filtered_frame, &frame_size,\n\n                                     same_quant ? quality : ost->st->codec->global_quality);\n\n                        if (vstats_filename && frame_size)\n\n                            do_video_stats(os, ost, frame_size);\n\n                        break;\n\n                    case AVMEDIA_TYPE_SUBTITLE:\n\n                        do_subtitle_out(os, ost, ist, &subtitle,\n\n                                        pkt->pts);\n\n                        break;\n\n                    default:\n\n                        abort();\n\n                    }\n\n                } else {\n\n                    AVPacket opkt;\n\n                    int64_t ost_tb_start_time= av_rescale_q(of->start_time, AV_TIME_BASE_Q, ost->st->time_base);\n\n\n\n                    av_init_packet(&opkt);\n\n\n\n                    if ((!ost->frame_number && !(pkt->flags & AV_PKT_FLAG_KEY)) && !copy_initial_nonkeyframes)\n\n#if !CONFIG_AVFILTER\n\n                        continue;\n\n#else\n\n                        goto cont;\n\n#endif\n\n\n\n                    /* no reencoding needed : output the packet directly */\n\n                    /* force the input stream PTS */\n\n\n\n                    if(ost->st->codec->codec_type == AVMEDIA_TYPE_AUDIO)\n\n                        audio_size += data_size;\n\n                    else if (ost->st->codec->codec_type == AVMEDIA_TYPE_VIDEO) {\n\n                        video_size += data_size;\n\n                        ost->sync_opts++;\n\n                    }\n\n\n\n                    opkt.stream_index= ost->index;\n\n                    if(pkt->pts != AV_NOPTS_VALUE)\n\n                        opkt.pts= av_rescale_q(pkt->pts, ist->st->time_base, ost->st->time_base) - ost_tb_start_time;\n\n                    else\n\n                        opkt.pts= AV_NOPTS_VALUE;\n\n\n\n                    if (pkt->dts == AV_NOPTS_VALUE)\n\n                        opkt.dts = av_rescale_q(ist->pts, AV_TIME_BASE_Q, ost->st->time_base);\n\n                    else\n\n                        opkt.dts = av_rescale_q(pkt->dts, ist->st->time_base, ost->st->time_base);\n\n                    opkt.dts -= ost_tb_start_time;\n\n\n\n                    opkt.duration = av_rescale_q(pkt->duration, ist->st->time_base, ost->st->time_base);\n\n                    opkt.flags= pkt->flags;\n\n\n\n                    //FIXME remove the following 2 lines they shall be replaced by the bitstream filters\n\n                    if(   ost->st->codec->codec_id != CODEC_ID_H264\n\n                       && ost->st->codec->codec_id != CODEC_ID_MPEG1VIDEO\n\n                       && ost->st->codec->codec_id != CODEC_ID_MPEG2VIDEO\n\n                       ) {\n\n                        if(av_parser_change(ist->st->parser, ost->st->codec, &opkt.data, &opkt.size, data_buf, data_size, pkt->flags & AV_PKT_FLAG_KEY))\n\n                            opkt.destruct= av_destruct_packet;\n\n                    } else {\n\n                        opkt.data = data_buf;\n\n                        opkt.size = data_size;\n\n                    }\n\n\n\n                    write_frame(os, &opkt, ost->st->codec, ost->bitstream_filters);\n\n                    ost->st->codec->frame_number++;\n\n                    ost->frame_number++;\n\n                    av_free_packet(&opkt);\n\n                }\n\n#if CONFIG_AVFILTER\n\n                cont:\n\n                frame_available = (ist->st->codec->codec_type == AVMEDIA_TYPE_VIDEO) &&\n\n                                   ost->output_video_filter && avfilter_poll_frame(ost->output_video_filter->inputs[0]);\n\n                if (ost->picref)\n\n                    avfilter_unref_buffer(ost->picref);\n\n            }\n\n            av_freep(&filtered_frame);\n\n#endif\n\n            }\n\n\n\nfail:\n\n        av_free(buffer_to_free);\n\n        /* XXX: allocate the subtitles in the codec ? */\n\n        if (subtitle_to_free) {\n\n            avsubtitle_free(subtitle_to_free);\n\n            subtitle_to_free = NULL;\n\n        }\n\n        av_freep(&decoded_frame);\n\n        if (ret < 0)\n\n            return ret;\n\n    }\n\n discard_packet:\n\n\n\n    return 0;\n\n}\n", "idx": 7808, "substitutes": {"ist": ["isting", "ists", "htt", "elist", "ik", "ht", "inst", "ind", "ast", "ird", "iter", "artist", "istant", "art", "ict", "isted", "iat", "pas", "pect", "xp", "ust", "pport", "ift", "ic", "wp", "edit", "alist", "ire", "iana", "rank", "archive", "ista", "iste", "mit", "IST", "ia", "via", "irc", "ort", "ert", "ive", "it", "ilst", "ief", "pt", "dit", "is", "pir", "usr", "ister", "ont", "wi", "ident", "lect", "ld", "il", "act", "ij", "istor", "est", "its", "xt", "erd", "assert", "stat", "irst", "spect", "ush", "ept", "each", "list", "dist", "exist", "hist", "wikipedia", "istar", "sts", "isi", "hop", "ism"], "ist_index": ["ist_id", "ost_index", "ist_count", "ost_count", "ist_address", "istdbindex", "istdbid", "ost_address", "istdbaddress", "istdbcount", "ost_id"], "ost_table": [" ost_able", "ost_able", " ost_source", "ost_info", " ost_info", "ost_source"], "nb_ostreams": ["nb_ost_s", "nb_ost__", "nb_ostrownsize", "nb_iststreamsize", "nb_ostrownlist", "nb_oststreams", "nb_iststreamlist", "nb_istreamlist", "nb_ostrown_", "nb_ostreamlist", "nb_ostrowns", "nb_ostream_", "nb_istreamsize", "nb_ost_size", "nb_oststream_", "nb_oststreamsize", "nb_iststreams", "nb_iststream_", "nb_istreams", "nb_oststreamlist", "nb_istream_", "nb_ostreamsize", "nb_ost_list"], "pkt": [" pkg", "cpqt", "pkl", "cpmsg", "patkt", "Pkg", "pingacket", "podkl", "pkw", "apkt", "expkt", "cpdu", "pet", "pingkt", "prkt", "pwt", "pct", "patkat", "Pwk", "cpet", "pdu", " pkat", " pmsg", " packet", "compmsg", " pwt", "pcacket", "mkt", "vpkt", "mkw", "cpkt", "apacket", "cpnt", "ppwd", "pwd", "cpacket", "patkg", "compkt", "dpacket", "ppacket", "Pkat", "prck", " pkl", "mmsg", "pqt", "pingkat", "dpnt", "expqt", "dpkg", " pwk", " pwd", " pct", "prkat", "Pct", "Packet", "pingwd", "expdu", "podkt", "pwk", "ppkt", "pkg", "prwk", " pnt", " pkw", "Pck", "pkat", "vpet", "pcwt", "apwk", "dpwt", "Pkt", "pmsg", "podkw", "pckt", "cpkg", "pck", "pnt", "cpwk", "compacket", "vpacket", " pdu", "dpkt", "compkg", "packet", "compct", " pqt", " pck", "dpkat", "podmsg", "patacket", "expacket", "ppkat", "pcnt", " pet", "mkl", "vpnt", "apkat", "cpkat"], "os": ["ns", "ol", "ox", "sys", "cs", "oS", "ps", "Os", "ms", "op", "ds", "OS", "o", "es", "pos", "s", "oc", "ot", "oses", "bs", "ss", "us", "io", "res", "ops", "oss"], "ost": ["post", "ort", "est", "ous", "osp", "op", "irst", "ott", "ast", "OST", "ird", "rest", "oc", "host", "ot", "oid", "yt", "otype", "oe", "hop", "ust", "tt", "ops", "oss", "od"], "ret": ["result", "mem", "af", "rel", "nt", "rets", "len", "val", "alt", "vals", "ref", "dim", "rt", "status", "resp", "re", "new", "rin", "RET", "Ret", "fi", "ft", "ll", "res", "elt", "flag"], "i": ["ij", "ci", "b", "im", "c", "mi", "ip", "li", "p", "si", "n", "ind", "index", "bi", "pi", "id", "ti", "iter", "v", "m", "I", "iat", "f", "fi", "iu", "j", "ii"], "got_output": ["gotablenext", "gotweboutput", "got_next", "got___data", "gotableresponse", "got___buffer", "gotwebbuffer", "got_buffer", "got_out", "got___out", "gotableoutput", " got_data", "gotwebout", "got_response", "got_data", "gotableOutput", "got_Output", "gotwebdata", " got_buffer", "got___output", " got_out", " got_next", " got_Output", " got_response"], "buffer_to_free": ["buffer_To_available", "buffer_To_used", "buffer_To_free", "buffer_to_FREE", "buffer_To_FREE", "buffer_to_used", "buffer_to_available"], "subtitle": ["SubTitle", "subTitle", "Subformat", " subTitle", "Subtitle", "ubtitle", "subformat", "ubTitle", " subformat", "ubformat"], "subtitle_to_free": ["subtitle_to_Free", "subtitle_to_buffer", "subtitle_from_FREE", "subtitle_from_free", "subtitle_to_FREE", "subtitle_from_buffer", "subtitle_from_Free"], "frame_available": [" frame_free", "frame_used", "frame_free", " frame_changed", "frame_changed", " frame_used"], "quality": [" check", " pointer", " fps", "type", " test", " load", " equality", " cast", "val", "func", " af", "value", "ref", " cap", " compress", "cap", "alloc", " freeze", "f", "flags", "check", "condition"], "avpkt": [" avpth", "aveppkt", "avpcelt", "ajpkat", "avwpvc", "avcpacket", "avPkg", "avpecht", "avrespacket", "avewpkg", "avewpkt", "avpaacket", "avapkt", "avewpacket", "avnpdt", "averpaqt", "avmdt", "avrespkg", "auxpkg", " avcpet", " avcpkt", " avcpmsg", "avepvc", "avnpkt", "avewpdu", "auxpkt", "avepkt", "avpbkg", "avperkt", "avpcht", "avpth", "avcachekg", "avppacket", "avppelt", "avppkt", " avpelt", "auxpaqt", "averpkg", "avperkg", "avppkg", "avapet", "avrespkt", "aveppet", "avpakt", "avPqt", "ajpcht", "avpvc", " avcpct", " avpmsg", "avwpkg", "avpbvc", "avepelt", "avpqt", " avpdt", "avdpelt", "avcachecht", "avpervc", "avmmsg", "avepcmd", "avwpkt", "avppct", "ajpkt", "avcpkt", "avcpmsg", "avpckt", "auxpaacket", "avpercmd", "avwpelt", " avcpdt", "avewpelt", "avpet", "avcpth", "ajpidkg", "avppet", "averpakg", "averpacket", "avpcacket", "avepdu", "avpdu", "avcpelt", "avpkg", "avcpet", "avpcmd", "averpqt", "auxpakg", "ajpidcht", "avewpcmd", "avnpet", " avpet", "avwpacket", "avrespqt", "avpidkat", "avcachekat", "avapkg", "avwpqt", "averpkt", "aveppkg", "avpkat", "avmet", "avapacket", " avcpth", "avpmsg", "aveppacket", "avepacket", "avnpmsg", "ajpkg", "avdpth", "ajpidkt", "auxpacket", "avcachekt", "avwpcmd", "avpidcht", "avepet", "avpaqt", "averpaacket", "avpbcmd", "avpekg", "avpelt", "avwpdu", "avpdt", "avdpct", "avpidkt", "avpekat", " avcpelt", "avPkt", "avPet", "avewpvc", "avpacket", "avpcdu", "auxpakt", " avpct", "avpbkt", "avcpct", "ajpidkat", "avmkt", "avpidkg", "avppth", "avpct", "auxpqt", "avapqt", "avPacket", "avpekt", "avdpkt", "averpakt", "avcpdt", "avepkg", "avpakg", "avcpdu"], "data_buf": ["data_buffer", "data_cur", "data_buff", "data2buffer", "data2cur", "data___buf", "data2buf", "data___cur", " data_cur", "data___buff", " data_buffer", " data_buff", "data2buff", "data___buffer"], "decoded_data_buf": ["decoded_data_buff", "decoded_data_buffer", "decoded_datalytmp", "decoded_datalybuff", "decoded_window_buff", "decoded_data_tmp", "decoded_datalybuffer", "decoded_window_buf", "decoded_window_buffer", "decoded_window_tmp", "decoded_datalybuf"], "data_size": ["data2size", "data2length", "data_length", "data_SIZE", "data2len", " data_length", " data_len", "data_len", " data_SIZE", "data2SIZE"], "decoded_data_size": ["decoded_data_SIZE", "decoded_data_length", "decoded_frame_SIZE", "decoded_data_len", "decoded_frame_size", "decoded_frame_len", "decoded_frame_length"], "decoded_frame": ["decoded___data", "decoded_face", "decoded___frames", "decoded___face", "decode_frame", "decode_data", "decode_face", "decoded_frames", "decoded___frame", "decoded_data", "decode_frames"], "filtered_frame": ["filted_data", "filtered____frame", "filted_msg", "filted_frames", "filtered____msg", "filted_frame", "filtered_msg", "filtered_frames", "filtered____data", "filtered____frames", "filtered_data"], "st": ["service", "cast", "src", "step", "est", "stage", "ctx", "cl", "set", "store", "nd", "state", "sc", "stru", "co", "stat", "std", "se", "sty", "stack", "stop", "cc", "str", "rest", "start", "dist", "sec", "status", "stream", "storage", "desc", "ST", "obj", "ste", "sts", "sta", "interface", "ust", "St"], "codec": ["rendec", "codef", "rendef", "Codef", "indec", "inderer", "codEC", "indEC", "coderer", "renderer", "rendEC", "Codec", "Coderer", "indef", "CodEC"]}}
{"project": "qemu", "commit_id": "42a268c241183877192c376d03bd9b6d527407c7", "target": 0, "func": "static void gen_tlbsx_440(DisasContext *ctx)\n\n{\n\n#if defined(CONFIG_USER_ONLY)\n\n    gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC);\n\n#else\n\n    TCGv t0;\n\n    if (unlikely(ctx->pr)) {\n\n        gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC);\n\n        return;\n\n    }\n\n    t0 = tcg_temp_new();\n\n    gen_addr_reg_index(ctx, t0);\n\n    gen_helper_440_tlbsx(cpu_gpr[rD(ctx->opcode)], cpu_env, t0);\n\n    tcg_temp_free(t0);\n\n    if (Rc(ctx->opcode)) {\n\n        int l1 = gen_new_label();\n\n        tcg_gen_trunc_tl_i32(cpu_crf[0], cpu_so);\n\n        tcg_gen_brcondi_tl(TCG_COND_EQ, cpu_gpr[rD(ctx->opcode)], -1, l1);\n\n        tcg_gen_ori_i32(cpu_crf[0], cpu_crf[0], 0x02);\n\n        gen_set_label(l1);\n\n    }\n\n#endif\n\n}\n", "idx": 7814, "substitutes": {"ctx": ["ck", "act", "gt", "cf", "gc", "setup", "ct", "ctl", "prefix", "cp", "c", "wcs", "kt", "pc", "cmp", "bc", "anc", "cl", "wx", "sc", "nt", "comm", "ann", "p", "cm", "co", "cmd", "stat", "nc", "aux", "context", "cb", "ind", "hw", "history", "kl", "cc", "xc", "github", "push", "crit", "pkg", "xs", "kw", "scl", "txt", "req", "ork", "cfg", "resp", "jac", "ac", "tx", "gz", "ca", "desc", "jp", "np", "cur", "obj", "xp", "qt", "ctr", "x", "cu", "work", "conn", "today", "abc", "nw", "tc", "urg"], "t0": [" t00", " t1", "T1", "T000", "tr0", "ts0", "temp050", "t000", " t000", "temp0", "ts050", "dtZero", "wt0", "dt1", "to0", "tZero", "dt00", "tr1", "t1", "wt1", "t050", "t00", "to1", "T0", "tempZero", "T00", "tsZero", "tr000", "dt050", "dt0"]}}
{"project": "qemu", "commit_id": "c2b38b277a7882a592f4f2ec955084b2b756daaa", "target": 0, "func": "GSource *iohandler_get_g_source(void)\n\n{\n\n    iohandler_init();\n\n    return aio_get_g_source(iohandler_ctx);\n\n}\n", "idx": 7828, "substitutes": {}}
{"project": "FFmpeg", "commit_id": "a4c7a5ea27050a28625eabf1ba98cfef9ac6620d", "target": 0, "func": "int ff_mpeg1_find_frame_end(ParseContext *pc, const uint8_t *buf, int buf_size)\n\n{\n\n    int i;\n\n    uint32_t state= pc->state;\n\n\n\n    /* EOF considered as end of frame */\n\n    if (buf_size == 0)\n\n        return 0;\n\n\n\n/*\n\n 0  frame start         -> 1/4\n\n 1  first_SEQEXT        -> 0/2\n\n 2  first field start   -> 3/0\n\n 3  second_SEQEXT       -> 2/0\n\n 4  searching end\n\n*/\n\n\n\n    for(i=0; i<buf_size; i++){\n\n        assert(pc->frame_start_found>=0 && pc->frame_start_found<=4);\n\n        if(pc->frame_start_found&1){\n\n            if(state == EXT_START_CODE && (buf[i]&0xF0) != 0x80)\n\n                pc->frame_start_found--;\n\n            else if(state == EXT_START_CODE+2){\n\n                if((buf[i]&3) == 3) pc->frame_start_found= 0;\n\n                else                pc->frame_start_found= (pc->frame_start_found+1)&3;\n\n            }\n\n            state++;\n\n        }else{\n\n            i= ff_find_start_code(buf+i, buf+buf_size, &state) - buf - 1;\n\n            if(pc->frame_start_found==0 && state >= SLICE_MIN_START_CODE && state <= SLICE_MAX_START_CODE){\n\n                i++;\n\n                pc->frame_start_found=4;\n\n            }\n\n            if(state == SEQ_END_CODE){\n\n                pc->state=-1;\n\n                return i+1;\n\n            }\n\n            if(pc->frame_start_found==2 && state == SEQ_START_CODE)\n\n                pc->frame_start_found= 0;\n\n            if(pc->frame_start_found<4 && state == EXT_START_CODE)\n\n                pc->frame_start_found++;\n\n            if(pc->frame_start_found == 4 && (state&0xFFFFFF00) == 0x100){\n\n                if(state < SLICE_MIN_START_CODE || state > SLICE_MAX_START_CODE){\n\n                    pc->frame_start_found=0;\n\n                    pc->state=-1;\n\n                    return i-3;\n\n                }\n\n            }\n\n        }\n\n    }\n\n    pc->state= state;\n\n    return END_NOT_FOUND;\n\n}\n", "idx": 7834, "substitutes": {"pc": ["ck", "dc", "gc", "po", "c", "pan", "sc", "px", "ec", "pointer", "pi", "pg", "arc", "oc", "ack", "controller", "phrase", "disc", "pac", "mc", "xp", "iac", "enc", "cu", "wp", "cam", "pad", "pl", "roc", "soc", "lp", "ac", "ca", "conv", "pp", "PC", "patch", "tk", "acl", "peer", "ctx", "amps", "bc", "anc", "pt", "cs", "p", "pa", "chron", "nc", "rc", "pm", "pkg", "icc", "cell", "isc", "mp", "cod", "put", "cp", "ping", "pb", "cmp", "pod", "sys", "client", "fc", "bp", "etc", "unc", "vp", "sync", "lc", "func", "cc", "proc", "pr", "resp", "vc", "pic", "doc", "amp", "pd", "tp", "conn", "tc"], "buf": ["init", "db", "bag", "read", "bytes", "uf", "buff", "b", "um", "pb", "late", "br", "ctx", "cam", "bc", "h", "offset", "Buffer", "buffer", "msg", "raw", "map", "bh", "p", "seq", "wav", "cmd", "bp", "etc", "n", "len", "cb", "queue", "data", "history", "err", "bb", "ref", "bar", "pkg", "proc", "Buff", "pos", "begin", "rb", "bf", "iter", "v", "bin", "cap", "block", "bs", "fb", "img", "batch", "cv", "ptr", "tmp", "cache", "xff", "aka", "cur", "conv", "que", "length", "loc", "vec"], "buf_size": ["bufLenlen", "buffer_size", "uf_size", "ref_length", "bufLensize", "ref_range", "buffer_SIZE", "buf_count", "buffer_Size", "bufLenrange", "uf_number", "uf_Size", "buf_limit", "buf_number", "buf_range", "buf_Size", "buf_body", "buf_SIZE", "ref_len", "bufLenlength", " buf_body", "buf_length", "buf_len", "ref_size", "uf_count", " buf_limit"], "i": ["ei", " ii", "im", "c", "gi", "zi", "ind", "pointer", "pi", "iter", "I", "batch", "io", "in", "j", "iri", "x", "di", "ic", "q", "mi", "ms", "xi", "index", "ri", "bi", "go", "ki", "inter", "ti", "v", "ai", "m", "port", "us", "info", "json", "l", "ci", "it", "any", "u", "ip", "li", "p", "ami", "is", "o", "r", "limit", "to", " iter", "y", "ii", "init", "ini", "ij", " bi", "uri", "b", "cli", " x", "oi", "si", "n", "multi", "err", "me", "ui", "id", "ji", "list", "phi", "ir", "ims", "ix", "status", " mi", "print", "ish", "f", "sim", "ex", "iu"], "frame_start_found": ["frame_reset_found", "frame_end_field", "frame_start__find", "frame_offset_based", "frame_end_finder", "frame_start_fd", "frame_offset_found", "frame_start_based", "frame_start_Found", "frame_end_bound", "frame_start_to", "frame_start_field", "frame_startedfound", "frame_end_find", "frame_start___fl", "frame_start_find", "frame_end_founded", "frame_start_defined", "frame_end_top", "frame_startedFound", "frame_starterdone", "frame_startxstarted", "frame_start_founded", "frame_start_loaded", "frame_source_Found", "frame_end_Found", "frame_startxfailed", "frame_starterFound", "frame_source_started", "frame_end_count", "frame_start_finder", "frame_reset_allowed", "frame_start_started", "frame_starterfound", "frame_end_found", "frame_start__Found", "frame_startxtested", "frame_startxfield", "frame_startxfound", "frame_startfulfound", "frame_end_loaded", "frame_art_found", "frame_start_pos", "frame_start__finder", "frame_start_err", "frame_art_failed", "frame_offset_Found", "frame_start___find", "frame_start_tested", "frame_starterallowed", "frame_art_tested", "frame_reseterFound", "frame_starterfounded", "frame_start_top", "frame_reset_Found", "frame_end_rest", "frame_reseterdone", "frame_end_pos", "frame_start_failed", "frame_start_fl", "frame_start___Found", "frame_start___bound", "frame_start__found", "frame_reset_done", "frame_startfulfinder", "frame_source_found", "frame_start_done", "frame_startxFound", "frame_startfultop", "frame_startxfind", "frame_end_to", "frame_startedloaded", "frame_starterloaded", "frame_start_rest", "frame_start___tested", "frame_reseterfound", "frame_startxdefined", "frame_end_based", "frame_start_allowed", "frame_end_fl", "frame_end_tested", "frame_art_Found", "frame_startedfounded", "frame_source_defined", "frame_start_bound", "frame_start___found", "frame_end_err", "frame_end_fd", "frame_start___pos", "frame_startfulrest", "frame_start_count", "frame_reseterallowed"], "state": ["policy", "depth", "event", "function", "po", "note", "scope", "self", "see", "or", "ind", "pointer", "State", "key", "trace", "value", "tag", "level", "effect", "memory", "priority", "ch", "comment", "controller", "there", "parent", "can", "loop", "test", "message", "current", "size", "in", "ne", "output", "post", "next", "job", "store", "g", "zone", "index", "monitor", "position", "unit", "resource", "reason", "start", "out", "code", "timeout", "max", "be", "stats", "port", "config", "part", "action", "version", "local", "remote", "fire", "info", "oe", "length", "class", "color", "error", "terror", "power", "type", "offset", "cor", "msg", "progress", "p", "mt", "no", "to", "debug", "style", "s", "st", "al", "close", "topic", "hash", "powered", "name", "init", "STATE", "result", "ate", "what", "we", "te", "stat", "n", "program", "release", "used", "range", "err", "id", "list", "commit", "mode", "handle", "component", "where", "status", "block", "spec", "now", "states", "print", "rule", "area", "count", "cache", "point", "e", "sequence"]}}
{"project": "FFmpeg", "commit_id": "0f8d3d8a462c0152ac489dbb013f6df027edd6c4", "target": 0, "func": "static av_cold int encode_init(AVCodecContext *avctx)\n\n{\n\n    FFV1Context *s = avctx->priv_data;\n\n    const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(avctx->pix_fmt);\n\n    int i, j, k, m, ret;\n\n\n\n    if ((ret = ff_ffv1_common_init(avctx)) < 0)\n\n        return ret;\n\n\n\n    s->version = 0;\n\n\n\n    if ((avctx->flags & (AV_CODEC_FLAG_PASS1 | AV_CODEC_FLAG_PASS2)) ||\n\n        avctx->slices > 1)\n\n        s->version = FFMAX(s->version, 2);\n\n\n\n    // Unspecified level & slices, we choose version 1.2+ to ensure multithreaded decodability\n\n    if (avctx->slices == 0 && avctx->level < 0 && avctx->width * avctx->height > 720*576)\n\n        s->version = FFMAX(s->version, 2);\n\n\n\n    if (avctx->level <= 0 && s->version == 2) {\n\n        s->version = 3;\n\n    }\n\n    if (avctx->level >= 0 && avctx->level <= 4) {\n\n        if (avctx->level < s->version) {\n\n            av_log(avctx, AV_LOG_ERROR, \"Version %d needed for requested features but %d requested\\n\", s->version, avctx->level);\n\n            return AVERROR(EINVAL);\n\n        }\n\n        s->version = avctx->level;\n\n    }\n\n\n\n    if (s->ec < 0) {\n\n        s->ec = (s->version >= 3);\n\n    }\n\n\n\n    if ((s->version == 2 || s->version>3) && avctx->strict_std_compliance > FF_COMPLIANCE_EXPERIMENTAL) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Version 2 needed for requested features but version 2 is experimental and not enabled\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n#if FF_API_CODER_TYPE\n\nFF_DISABLE_DEPRECATION_WARNINGS\n\n    if (avctx->coder_type != -1)\n\n        s->ac = avctx->coder_type > 0 ? AC_RANGE_CUSTOM_TAB : AC_GOLOMB_RICE;\n\n    else\n\nFF_ENABLE_DEPRECATION_WARNINGS\n\n#endif\n\n    if (s->ac == 1) // Compatbility with common command line usage\n\n        s->ac = AC_RANGE_CUSTOM_TAB;\n\n    else if (s->ac == AC_RANGE_DEFAULT_TAB_FORCE)\n\n        s->ac = AC_RANGE_DEFAULT_TAB;\n\n\n\n    s->plane_count = 3;\n\n    switch(avctx->pix_fmt) {\n\n    case AV_PIX_FMT_YUV444P9:\n\n    case AV_PIX_FMT_YUV422P9:\n\n    case AV_PIX_FMT_YUV420P9:\n\n    case AV_PIX_FMT_YUVA444P9:\n\n    case AV_PIX_FMT_YUVA422P9:\n\n    case AV_PIX_FMT_YUVA420P9:\n\n        if (!avctx->bits_per_raw_sample)\n\n            s->bits_per_raw_sample = 9;\n\n    case AV_PIX_FMT_GRAY10:\n\n    case AV_PIX_FMT_YUV444P10:\n\n    case AV_PIX_FMT_YUV420P10:\n\n    case AV_PIX_FMT_YUV422P10:\n\n    case AV_PIX_FMT_YUVA444P10:\n\n    case AV_PIX_FMT_YUVA422P10:\n\n    case AV_PIX_FMT_YUVA420P10:\n\n        if (!avctx->bits_per_raw_sample && !s->bits_per_raw_sample)\n\n            s->bits_per_raw_sample = 10;\n\n    case AV_PIX_FMT_GRAY12:\n\n    case AV_PIX_FMT_YUV444P12:\n\n    case AV_PIX_FMT_YUV420P12:\n\n    case AV_PIX_FMT_YUV422P12:\n\n        s->packed_at_lsb = 1;\n\n        if (!avctx->bits_per_raw_sample && !s->bits_per_raw_sample)\n\n            s->bits_per_raw_sample = 12;\n\n    case AV_PIX_FMT_GRAY16:\n\n    case AV_PIX_FMT_YUV444P16:\n\n    case AV_PIX_FMT_YUV422P16:\n\n    case AV_PIX_FMT_YUV420P16:\n\n    case AV_PIX_FMT_YUVA444P16:\n\n    case AV_PIX_FMT_YUVA422P16:\n\n    case AV_PIX_FMT_YUVA420P16:\n\n        if (!avctx->bits_per_raw_sample && !s->bits_per_raw_sample) {\n\n            s->bits_per_raw_sample = 16;\n\n        } else if (!s->bits_per_raw_sample) {\n\n            s->bits_per_raw_sample = avctx->bits_per_raw_sample;\n\n        }\n\n        if (s->bits_per_raw_sample <= 8) {\n\n            av_log(avctx, AV_LOG_ERROR, \"bits_per_raw_sample invalid\\n\");\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n        s->version = FFMAX(s->version, 1);\n\n    case AV_PIX_FMT_GRAY8:\n\n    case AV_PIX_FMT_YA8:\n\n    case AV_PIX_FMT_YUV444P:\n\n    case AV_PIX_FMT_YUV440P:\n\n    case AV_PIX_FMT_YUV422P:\n\n    case AV_PIX_FMT_YUV420P:\n\n    case AV_PIX_FMT_YUV411P:\n\n    case AV_PIX_FMT_YUV410P:\n\n    case AV_PIX_FMT_YUVA444P:\n\n    case AV_PIX_FMT_YUVA422P:\n\n    case AV_PIX_FMT_YUVA420P:\n\n        s->chroma_planes = desc->nb_components < 3 ? 0 : 1;\n\n        s->colorspace = 0;\n\n        s->transparency = desc->nb_components == 4 || desc->nb_components == 2;\n\n        if (!avctx->bits_per_raw_sample && !s->bits_per_raw_sample)\n\n            s->bits_per_raw_sample = 8;\n\n        else if (!s->bits_per_raw_sample)\n\n            s->bits_per_raw_sample = 8;\n\n        break;\n\n    case AV_PIX_FMT_RGB32:\n\n        s->colorspace = 1;\n\n        s->transparency = 1;\n\n        s->chroma_planes = 1;\n\n        s->bits_per_raw_sample = 8;\n\n        break;\n\n    case AV_PIX_FMT_RGB48:\n\n        s->colorspace = 1;\n\n        s->chroma_planes = 1;\n\n        s->bits_per_raw_sample = 16;\n\n        s->use32bit = 1;\n\n        s->version = FFMAX(s->version, 1);\n\n        if (avctx->strict_std_compliance > FF_COMPLIANCE_EXPERIMENTAL) {\n\n            av_log(avctx, AV_LOG_ERROR, \"16bit RGB is experimental and under development, only use it for experiments\\n\");\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n        break;\n\n    case AV_PIX_FMT_0RGB32:\n\n        s->colorspace = 1;\n\n        s->chroma_planes = 1;\n\n        s->bits_per_raw_sample = 8;\n\n        break;\n\n    case AV_PIX_FMT_GBRP9:\n\n        if (!avctx->bits_per_raw_sample)\n\n            s->bits_per_raw_sample = 9;\n\n    case AV_PIX_FMT_GBRP10:\n\n        if (!avctx->bits_per_raw_sample && !s->bits_per_raw_sample)\n\n            s->bits_per_raw_sample = 10;\n\n    case AV_PIX_FMT_GBRP12:\n\n        if (!avctx->bits_per_raw_sample && !s->bits_per_raw_sample)\n\n            s->bits_per_raw_sample = 12;\n\n    case AV_PIX_FMT_GBRP14:\n\n        if (!avctx->bits_per_raw_sample && !s->bits_per_raw_sample)\n\n            s->bits_per_raw_sample = 14;\n\n    case AV_PIX_FMT_GBRP16:\n\n        if (!avctx->bits_per_raw_sample && !s->bits_per_raw_sample)\n\n            s->bits_per_raw_sample = 16;\n\n        else if (!s->bits_per_raw_sample)\n\n            s->bits_per_raw_sample = avctx->bits_per_raw_sample;\n\n        s->colorspace = 1;\n\n        s->chroma_planes = 1;\n\n        if (s->bits_per_raw_sample >= 16) {\n\n            s->use32bit = 1;\n\n            if (avctx->strict_std_compliance > FF_COMPLIANCE_EXPERIMENTAL) {\n\n                av_log(avctx, AV_LOG_ERROR, \"16bit RGB is experimental and under development, only use it for experiments\\n\");\n\n                return AVERROR_INVALIDDATA;\n\n            }\n\n        }\n\n        s->version = FFMAX(s->version, 1);\n\n        break;\n\n    default:\n\n        av_log(avctx, AV_LOG_ERROR, \"format not supported\\n\");\n\n        return AVERROR(ENOSYS);\n\n    }\n\n    av_assert0(s->bits_per_raw_sample >= 8);\n\n\n\n    if (s->bits_per_raw_sample > 8) {\n\n        if (s->ac == AC_GOLOMB_RICE) {\n\n            av_log(avctx, AV_LOG_INFO,\n\n                    \"bits_per_raw_sample > 8, forcing range coder\\n\");\n\n            s->ac = AC_RANGE_CUSTOM_TAB;\n\n        }\n\n    }\n\n    if (s->transparency) {\n\n        av_log(avctx, AV_LOG_WARNING, \"Storing alpha plane, this will require a recent FFV1 decoder to playback!\\n\");\n\n    }\n\n#if FF_API_PRIVATE_OPT\n\nFF_DISABLE_DEPRECATION_WARNINGS\n\n    if (avctx->context_model)\n\n        s->context_model = avctx->context_model;\n\n    if (avctx->context_model > 1U) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Invalid context model %d, valid values are 0 and 1\\n\", avctx->context_model);\n\n        return AVERROR(EINVAL);\n\n    }\n\nFF_ENABLE_DEPRECATION_WARNINGS\n\n#endif\n\n\n\n    if (s->ac == AC_RANGE_CUSTOM_TAB) {\n\n        for (i = 1; i < 256; i++)\n\n            s->state_transition[i] = ver2_state[i];\n\n    } else {\n\n        RangeCoder c;\n\n        ff_build_rac_states(&c, 0.05 * (1LL << 32), 256 - 8);\n\n        for (i = 1; i < 256; i++)\n\n            s->state_transition[i] = c.one_state[i];\n\n    }\n\n\n\n    for (i = 0; i < 256; i++) {\n\n        s->quant_table_count = 2;\n\n        if (s->bits_per_raw_sample <= 8) {\n\n            s->quant_tables[0][0][i]=           quant11[i];\n\n            s->quant_tables[0][1][i]=        11*quant11[i];\n\n            s->quant_tables[0][2][i]=     11*11*quant11[i];\n\n            s->quant_tables[1][0][i]=           quant11[i];\n\n            s->quant_tables[1][1][i]=        11*quant11[i];\n\n            s->quant_tables[1][2][i]=     11*11*quant5 [i];\n\n            s->quant_tables[1][3][i]=   5*11*11*quant5 [i];\n\n            s->quant_tables[1][4][i]= 5*5*11*11*quant5 [i];\n\n        } else {\n\n            s->quant_tables[0][0][i]=           quant9_10bit[i];\n\n            s->quant_tables[0][1][i]=        11*quant9_10bit[i];\n\n            s->quant_tables[0][2][i]=     11*11*quant9_10bit[i];\n\n            s->quant_tables[1][0][i]=           quant9_10bit[i];\n\n            s->quant_tables[1][1][i]=        11*quant9_10bit[i];\n\n            s->quant_tables[1][2][i]=     11*11*quant5_10bit[i];\n\n            s->quant_tables[1][3][i]=   5*11*11*quant5_10bit[i];\n\n            s->quant_tables[1][4][i]= 5*5*11*11*quant5_10bit[i];\n\n        }\n\n    }\n\n    s->context_count[0] = (11 * 11 * 11        + 1) / 2;\n\n    s->context_count[1] = (11 * 11 * 5 * 5 * 5 + 1) / 2;\n\n    memcpy(s->quant_table, s->quant_tables[s->context_model],\n\n           sizeof(s->quant_table));\n\n\n\n    for (i = 0; i < s->plane_count; i++) {\n\n        PlaneContext *const p = &s->plane[i];\n\n\n\n        memcpy(p->quant_table, s->quant_table, sizeof(p->quant_table));\n\n        p->quant_table_index = s->context_model;\n\n        p->context_count     = s->context_count[p->quant_table_index];\n\n    }\n\n\n\n    if ((ret = ff_ffv1_allocate_initial_states(s)) < 0)\n\n        return ret;\n\n\n\n#if FF_API_CODED_FRAME\n\nFF_DISABLE_DEPRECATION_WARNINGS\n\n    avctx->coded_frame->pict_type = AV_PICTURE_TYPE_I;\n\nFF_ENABLE_DEPRECATION_WARNINGS\n\n#endif\n\n\n\n    if (!s->transparency)\n\n        s->plane_count = 2;\n\n    if (!s->chroma_planes && s->version > 3)\n\n        s->plane_count--;\n\n\n\n    avcodec_get_chroma_sub_sample(avctx->pix_fmt, &s->chroma_h_shift, &s->chroma_v_shift);\n\n    s->picture_number = 0;\n\n\n\n    if (avctx->flags & (AV_CODEC_FLAG_PASS1 | AV_CODEC_FLAG_PASS2)) {\n\n        for (i = 0; i < s->quant_table_count; i++) {\n\n            s->rc_stat2[i] = av_mallocz(s->context_count[i] *\n\n                                        sizeof(*s->rc_stat2[i]));\n\n            if (!s->rc_stat2[i])\n\n                return AVERROR(ENOMEM);\n\n        }\n\n    }\n\n    if (avctx->stats_in) {\n\n        char *p = avctx->stats_in;\n\n        uint8_t (*best_state)[256] = av_malloc_array(256, 256);\n\n        int gob_count = 0;\n\n        char *next;\n\n        if (!best_state)\n\n            return AVERROR(ENOMEM);\n\n\n\n        av_assert0(s->version >= 2);\n\n\n\n        for (;;) {\n\n            for (j = 0; j < 256; j++)\n\n                for (i = 0; i < 2; i++) {\n\n                    s->rc_stat[j][i] = strtol(p, &next, 0);\n\n                    if (next == p) {\n\n                        av_log(avctx, AV_LOG_ERROR,\n\n                               \"2Pass file invalid at %d %d [%s]\\n\", j, i, p);\n\n                        av_freep(&best_state);\n\n                        return AVERROR_INVALIDDATA;\n\n                    }\n\n                    p = next;\n\n                }\n\n            for (i = 0; i < s->quant_table_count; i++)\n\n                for (j = 0; j < s->context_count[i]; j++) {\n\n                    for (k = 0; k < 32; k++)\n\n                        for (m = 0; m < 2; m++) {\n\n                            s->rc_stat2[i][j][k][m] = strtol(p, &next, 0);\n\n                            if (next == p) {\n\n                                av_log(avctx, AV_LOG_ERROR,\n\n                                       \"2Pass file invalid at %d %d %d %d [%s]\\n\",\n\n                                       i, j, k, m, p);\n\n                                av_freep(&best_state);\n\n                                return AVERROR_INVALIDDATA;\n\n                            }\n\n                            p = next;\n\n                        }\n\n                }\n\n            gob_count = strtol(p, &next, 0);\n\n            if (next == p || gob_count <= 0) {\n\n                av_log(avctx, AV_LOG_ERROR, \"2Pass file invalid\\n\");\n\n                av_freep(&best_state);\n\n                return AVERROR_INVALIDDATA;\n\n            }\n\n            p = next;\n\n            while (*p == '\\n' || *p == ' ')\n\n                p++;\n\n            if (p[0] == 0)\n\n                break;\n\n        }\n\n        if (s->ac == AC_RANGE_CUSTOM_TAB)\n\n            sort_stt(s, s->state_transition);\n\n\n\n        find_best_state(best_state, s->state_transition);\n\n\n\n        for (i = 0; i < s->quant_table_count; i++) {\n\n            for (k = 0; k < 32; k++) {\n\n                double a=0, b=0;\n\n                int jp = 0;\n\n                for (j = 0; j < s->context_count[i]; j++) {\n\n                    double p = 128;\n\n                    if (s->rc_stat2[i][j][k][0] + s->rc_stat2[i][j][k][1] > 200 && j || a+b > 200) {\n\n                        if (a+b)\n\n                            p = 256.0 * b / (a + b);\n\n                        s->initial_states[i][jp][k] =\n\n                            best_state[av_clip(round(p), 1, 255)][av_clip_uint8((a + b) / gob_count)];\n\n                        for(jp++; jp<j; jp++)\n\n                            s->initial_states[i][jp][k] = s->initial_states[i][jp-1][k];\n\n                        a=b=0;\n\n                    }\n\n                    a += s->rc_stat2[i][j][k][0];\n\n                    b += s->rc_stat2[i][j][k][1];\n\n                    if (a+b) {\n\n                        p = 256.0 * b / (a + b);\n\n                    }\n\n                    s->initial_states[i][j][k] =\n\n                        best_state[av_clip(round(p), 1, 255)][av_clip_uint8((a + b) / gob_count)];\n\n                }\n\n            }\n\n        }\n\n        av_freep(&best_state);\n\n    }\n\n\n\n    if (s->version > 1) {\n\n        int plane_count = 1 + 2*s->chroma_planes + s->transparency;\n\n        s->num_v_slices = (avctx->width > 352 || avctx->height > 288 || !avctx->slices) ? 2 : 1;\n\n\n\n        if (avctx->height < 5)\n\n            s->num_v_slices = 1;\n\n\n\n        for (; s->num_v_slices < 32; s->num_v_slices++) {\n\n            for (s->num_h_slices = s->num_v_slices; s->num_h_slices < 2*s->num_v_slices; s->num_h_slices++) {\n\n                int maxw = (avctx->width  + s->num_h_slices - 1) / s->num_h_slices;\n\n                int maxh = (avctx->height + s->num_v_slices - 1) / s->num_v_slices;\n\n                if (s->num_h_slices > avctx->width || s->num_v_slices > avctx->height)\n\n                    continue;\n\n                if (maxw * maxh * (int64_t)(s->bits_per_raw_sample+1) * plane_count > 8<<24)\n\n                    continue;\n\n                if (avctx->slices == s->num_h_slices * s->num_v_slices && avctx->slices <= MAX_SLICES || !avctx->slices)\n\n                    goto slices_ok;\n\n            }\n\n        }\n\n        av_log(avctx, AV_LOG_ERROR,\n\n               \"Unsupported number %d of slices requested, please specify a \"\n\n               \"supported number with -slices (ex:4,6,9,12,16, ...)\\n\",\n\n               avctx->slices);\n\n        return AVERROR(ENOSYS);\n\nslices_ok:\n\n        if ((ret = write_extradata(s)) < 0)\n\n            return ret;\n\n    }\n\n\n\n    if ((ret = ff_ffv1_init_slice_contexts(s)) < 0)\n\n        return ret;\n\n    s->slice_count = s->max_slice_count;\n\n    if ((ret = ff_ffv1_init_slices_state(s)) < 0)\n\n        return ret;\n\n\n\n#define STATS_OUT_SIZE 1024 * 1024 * 6\n\n    if (avctx->flags & AV_CODEC_FLAG_PASS1) {\n\n        avctx->stats_out = av_mallocz(STATS_OUT_SIZE);\n\n        if (!avctx->stats_out)\n\n            return AVERROR(ENOMEM);\n\n        for (i = 0; i < s->quant_table_count; i++)\n\n            for (j = 0; j < s->max_slice_count; j++) {\n\n                FFV1Context *sf = s->slice_context[j];\n\n                av_assert0(!sf->rc_stat2[i]);\n\n                sf->rc_stat2[i] = av_mallocz(s->context_count[i] *\n\n                                             sizeof(*sf->rc_stat2[i]));\n\n                if (!sf->rc_stat2[i])\n\n                    return AVERROR(ENOMEM);\n\n            }\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 7852, "substitutes": {"avctx": ["avegc", "avernp", "ajkl", "wavkt", " avcmp", "awtx", "awctx", "ajreq", "avcp", "vrctx", "navjac", "ajctx", "averconf", "avtc", "abreq", "avcontext", "aveconn", "avstat", "avjac", "ajnp", "avectl", "wavcfg", "navconf", "ajpy", "avecp", "avcfg", "avcu", "avkt", "averstat", "afjac", "averctx", "avnp", "averobj", "ajcu", "averpkg", "ajctl", "afctx", "avestat", "ajkw", " avjp", "avejac", "navgc", "navcp", " avpy", "ivercontext", "aveconf", "wavjac", "ajcontext", "avconn", "iverpy", "avecontext", "navtx", "afkt", "navctx", "avectx", "verctx", "avetc", "wavctx", "averreq", "averkl", "afconfig", "avgc", "ajstat", "avctl", "avertx", "avconf", "wavcontext", "averkw", "avehandle", "navcontext", " avconn", "avca", "navnp", "avpkg", "avesys", "varkl", "varconn", "aveca", "vertx", "avtx", "aveconfig", "avhandle", "awcmp", "avercfg", "verctl", "avergc", " avkt", "avercp", "averconn", "abcontext", "avecu", " avkl", " avcontext", "aftx", "avercu", "avercontext", "ajgc", "aveobj", "avepy", " avtx", "ajobj", " avpkg", "iverctx", "wavpy", " avjac", "avertc", "averjp", " avctl", "ajpkg", "vrcontext", "afpy", "ajconn", "avercmp", "averjac", "avsys", "vrcmp", "avereq", "abctx", "afcmp", "avreq", "ajtx", "afsys", "avjp", "awcontext", "avetx", " avreq", "navtc", "ajkt", "avecfg", "navca", "avobj", "avekl", "averhandle", "ajconfig", "iverjac", "varctx", "varkw", "avkl", "ajjac", " avhandle", "avconfig", "abtx", "ajcp", "verconn", "avcmp", "ajcfg", "averkt", "vrjp", "avekt", "averca", "avepkg", "afcontext", "navsys", "avkw", "avpy"], "s": ["as", "bes", "rs", "gs", "ses", "des", "b", "sw", "results", "less", "tes", "ns", "its", "eps", "ats", "h", "sys", "set", "qs", "cs", "sc", "os", "ps", "ms", "tests", "g", "details", "is", "ts", "ports", "ds", "als", "sets", "t", "es", "utils", "js", "ins", "sv", "ls", "sm", "sb", "gets", "params", "services", "grades", "v", "ims", "stats", "tags", "spec", "vs", "hs", "ss", "bs", "y", "sq", "fs", "S", "sts", "changes", "sports", "aws", "mods", "ows"], "desc": ["Desc", "dc", "esc", "des", "mem", "cmp", "buf", "sc", "description", "msg", "ext", "cmd", " des", "ec", "ds", "col", "asc", "txt", "dist", "meta", "sub", "dir", "doc", "rec", "enc", "def"], "i": ["ic", "ij", "ci", "b", " ii", "it", "h", "ik", "mi", "li", "si", "n", "o", "pi", "bi", "r", "v", " mi", "I", "y", "x", "ii"], "j": ["dj", "ja", "ij", "q", "b", "jj", "J", "aj", "g", "n", "uj", "index", "jc", "js", "pos", "ji", "v", "jump", "jl", "size", "kj", "z", "ii", "l"], "k": ["ck", "q", "km", "kr", "kh", "kk", "kid", "ka", "kind", "K", "ik", "ek", "mk", "ak", "ke", "kl", "key", "ki", "kn", "v", "sk", "ko", "kg", "ks", "kj", "z", "tk"], "m": ["q", "km", "mn", "mem", "gm", "h", "em", "M", "mi", "msg", "ms", "mt", "n", "tm", "o", "sm", "nm", "v", "mb", "mm", "mc", "vm", "bm", "mo", "l", "rm"], "ret": ["gt", "success", "result", "gc", "mem", "att", "cont", "det", "ter", "nt", "ry", "mi", "mt", "details", "rets", "len", "val", "tr", "alt", "lo", "t", "err", "el", "ref", "rem", "out", "try", "reset", "rt", "status", "fun", "re", "reg", "print", "RET", "Ret", "fi", "ft", "ll", "res", " RET", "rm", "cert"], "coder_type": ["coder_types", "coder__types", "coder_name", "coding_name", "coding_tag", "coding_types", "coder__type", "coder__tag", "coding_type", "coder_tag", "coder_id", "coder__name", "coding_id"], "FF_ENABLE_DEPRECATION_WARNINGS": ["FF_ENABLE_DEPRECATION_ERRORS", "FF_ENABLE_DEPRECATION_ERRORs", "FF_ENABLE_DEPRECATION_WARs", "FF_ENABLE_DEPRECATION_OFFE", "FF_ENABLE_DEPRECATION_WARNINGE", "FF_ENABLE_DEPRECATION_ERRORE", "FF_ENABLE_DEPRECATION_ERRORIES", "FF_ENABLE_DEPRECATION_OFFs", "FF_ENABLE_DEPRECATION_WARS", "FF_ENABLE_DEPRECATION_WARNINGs", "FF_ENABLE_DEPRECATION_WARE", "FF_ENABLE_DEPRECATION_OFFIES", "FF_ENABLE_DEPRECATION_WARNINGIES", "FF_ENABLE_DEPRECATION_WARIES", "FF_ENABLE_DEPRECATION_OFFS"]}}
{"project": "FFmpeg", "commit_id": "d85aa76115214183e7e3b7d65e950da61474959a", "target": 0, "func": "static int hls_slice_data_wpp(HEVCContext *s, const HEVCNAL *nal)\n\n{\n\n    const uint8_t *data = nal->data;\n\n    int length          = nal->size;\n\n    HEVCLocalContext *lc = s->HEVClc;\n\n    int *ret = av_malloc_array(s->sh.num_entry_point_offsets + 1, sizeof(int));\n\n    int *arg = av_malloc_array(s->sh.num_entry_point_offsets + 1, sizeof(int));\n\n    int64_t offset;\n\n    int startheader, cmpt = 0;\n\n    int i, j, res = 0;\n\n\n\n    if (!ret || !arg) {\n\n        av_free(ret);\n\n        av_free(arg);\n\n        return AVERROR(ENOMEM);\n\n    }\n\n\n\n\n\n    if (!s->sList[1]) {\n\n        ff_alloc_entries(s->avctx, s->sh.num_entry_point_offsets + 1);\n\n\n\n\n\n        for (i = 1; i < s->threads_number; i++) {\n\n            s->sList[i] = av_malloc(sizeof(HEVCContext));\n\n            memcpy(s->sList[i], s, sizeof(HEVCContext));\n\n            s->HEVClcList[i] = av_mallocz(sizeof(HEVCLocalContext));\n\n            s->sList[i]->HEVClc = s->HEVClcList[i];\n\n        }\n\n    }\n\n\n\n    offset = (lc->gb.index >> 3);\n\n\n\n    for (j = 0, cmpt = 0, startheader = offset + s->sh.entry_point_offset[0]; j < nal->skipped_bytes; j++) {\n\n        if (nal->skipped_bytes_pos[j] >= offset && nal->skipped_bytes_pos[j] < startheader) {\n\n            startheader--;\n\n            cmpt++;\n\n        }\n\n    }\n\n\n\n    for (i = 1; i < s->sh.num_entry_point_offsets; i++) {\n\n        offset += (s->sh.entry_point_offset[i - 1] - cmpt);\n\n        for (j = 0, cmpt = 0, startheader = offset\n\n             + s->sh.entry_point_offset[i]; j < nal->skipped_bytes; j++) {\n\n            if (nal->skipped_bytes_pos[j] >= offset && nal->skipped_bytes_pos[j] < startheader) {\n\n                startheader--;\n\n                cmpt++;\n\n            }\n\n        }\n\n        s->sh.size[i - 1] = s->sh.entry_point_offset[i] - cmpt;\n\n        s->sh.offset[i - 1] = offset;\n\n\n\n    }\n\n    if (s->sh.num_entry_point_offsets != 0) {\n\n        offset += s->sh.entry_point_offset[s->sh.num_entry_point_offsets - 1] - cmpt;\n\n        if (length < offset) {\n\n            av_log(s->avctx, AV_LOG_ERROR, \"entry_point_offset table is corrupted\\n\");\n\n            res = AVERROR_INVALIDDATA;\n\n            goto error;\n\n        }\n\n        s->sh.size[s->sh.num_entry_point_offsets - 1] = length - offset;\n\n        s->sh.offset[s->sh.num_entry_point_offsets - 1] = offset;\n\n\n\n    }\n\n    s->data = data;\n\n\n\n    for (i = 1; i < s->threads_number; i++) {\n\n        s->sList[i]->HEVClc->first_qp_group = 1;\n\n        s->sList[i]->HEVClc->qp_y = s->sList[0]->HEVClc->qp_y;\n\n        memcpy(s->sList[i], s, sizeof(HEVCContext));\n\n        s->sList[i]->HEVClc = s->HEVClcList[i];\n\n    }\n\n\n\n    avpriv_atomic_int_set(&s->wpp_err, 0);\n\n    ff_reset_entries(s->avctx);\n\n\n\n    for (i = 0; i <= s->sh.num_entry_point_offsets; i++) {\n\n        arg[i] = i;\n\n        ret[i] = 0;\n\n    }\n\n\n\n    if (s->ps.pps->entropy_coding_sync_enabled_flag)\n\n        s->avctx->execute2(s->avctx, hls_decode_entry_wpp, arg, ret, s->sh.num_entry_point_offsets + 1);\n\n\n\n    for (i = 0; i <= s->sh.num_entry_point_offsets; i++)\n\n        res += ret[i];\n\nerror:\n\n    av_free(ret);\n\n    av_free(arg);\n\n    return res;\n\n}\n", "idx": 7854, "substitutes": {"s": ["sw", "less", "tes", "c", "h", "self", "ps", "ports", "ts", "js", "w", "gets", "sb", "xs", "services", "ss", "south", "changes", "sports", "as", "rs", "so", "csv", "ses", "https", "os", "g", "ms", "tests", "es", "v", "stats", "bits", "m", "vs", "a", "aws", "l", "ops", "gs", "bis", "ssl", "sg", "times", "src", "ns", "ats", "cs", "comm", "p", "is", "o", "r", "sv", "hs", "bs", "sq", "parts", "fs", "sql", "S", "b", "its", "acs", "qs", "sys", "details", "n", "ds", "ins", "ids", "ls", "scl", "ims", "sh", "views", "status", "spec", "f", "sts"], "nal": ["annAL", " nally", "anAL", "anally", "Nald", "anals", " naler", "annali", "naler", "nale", "analer", "annal", "norald", "noral", " nAL", " nale", "gnally", "Nalid", "nald", " nals", "nanaler", "anal", "anale", "gnalid", "norAL", "nally", " nalid", "gnAL", "nals", "norals", "nali", "Nals", " nali", "analid", "Naler", "NAL", "gnale", "nanal", "Nal", "nanAL", " nald", "nalid", "gnal", "gnali", "nanalid", "nAL", "annalid"], "data": ["content", "bytes", "empty", "dat", "mem", "window", "type", "values", "buf", "buffer", "extra", "map", "d", "p", "base", "table", "rew", "len", "ata", "t", "input", "Data", "value", "ref", "mu", "bits", "m", "block", "array", "batch", "area", "cache", "f", "DATA", "sample", "size", "length", "res", "def"], "lc": ["ic", "dc", "lv", "ln", "lr", "c", "ctx", "pc", "cli", "cl", "bc", "cs", "lf", "tl", "sc", "fc", "dl", "ec", "lu", "kl", "LC", "lb", "cc", "xc", "rc", "ly", "ls", "lp", "rl", "las", "vc", "mc", "lic", "ll", "wl", "acl", "l", "tc"], "ret": ["gt", "success", "result", "repl", "mem", "back", "nt", "buffer", "mt", "rets", "val", "aux", "tr", "red", "alt", "t", "r", "ref", "rev", "rem", "nil", "out", "req", "reset", "rt", "fun", "final", "re", "resp", "reg", "tmp", "RET", "Ret", "ft", "ll", "res", "arr", "rex", "def", "elt"], "arg": ["par", "event", "call", "ar", "mem", "target", "argument", "ma", "ob", "aj", "arm", "g", "cmd", "vol", "len", "var", "arp", "val", "op", "aux", "ary", "ax", "ref", "tag", "pg", "attr", "arc", "mac", "au", "Arg", "num", "args", "ray", "ack", "cell", "ac", "reg", "local", "doc", "ig", "ag", "param", "arr", "res", "ring"], "offset": ["error", "et", "padding", "next", "prefix", "mem", "end", "af", "shift", "set", "pad", "buffer", "ta", "base", "addr", "p", "table", "mt", "location", "seek", " overhead", "zero", "option", "row", "index", "pointer", "o", "range", "ut", "bound", "trace", "position", "rc", "ref", "start", "timeout", "ow", "slot", "reset", "offs", "scroll", "off", "ptr", "area", "alias", "address", "f", "size", "point", "info", "Offset", "length", "oot", "coord", "onto", "origin", "flag"], "startheader": ["starthead", "firstheader", "beginheading", "startingheaders", " startoffset", "beginoffset", "beginheader", "endHeader", "starttimer", "stopheaders", "opentimer", "startheading", " startpadding", "startingtimer", "endpadding", "arttable", "arthead", "Startheader", "endhead", "startingheader", "startframe", "maxheader", "startingpadding", "firstHeader", "startpadding", "endheaders", "maxhead", "maxtable", "stoppadding", "stopheader", " startheading", "endheader", "StartHeader", "starttable", "Startheaders", " starthead", "firstheaders", "startoffset", " startframe", "endheading", "firstpadding", "openheaders", "artheader", " startHeader", "maxframe", "beginhead", "endoffset", "Startpadding", "startheaders", "artframe", " starttimer", "openpadding", "stopHeader", "openheader", " startheaders", "startHeader", " starttable"], "i": ["chain", " ii", "im", "c", "gi", "zi", "ind", "hi", "pi", "I", "batch", "io", "in", "MI", "by", "x", "\u0438", "di", "ic", "instance", "mi", "g", "xi", "index", "ri", "bi", "ki", "start", "ti", "v", "ai", "m", "remote", "ia", "info", "a", "l", "ci", "it", "ip", "li", "p", "ami", "is", "dr", "to", "y", "ii", "name", "init", "ij", "ini", "uri", "oi", "qi", "si", "ie", "n", "iq", "multi", "me", "id", "ui", "ji", "phi", "ims", "ix", "status", "ish", "f", "sim", "ex", "iu", "point", "e"], "j": ["dj", "ja", "ev", "ij", "q", "b", "bj", "jo", "it", "jj", "im", "job", "note", "J", "br", "h", "pt", "aj", "p", "d", "g", "n", "ind", "uj", "index", "o", "bi", "jc", "js", "str", "pos", "ji", "pr", "k", "oj", "v", "m", "adj", "bs", "y", "jump", "jp", "jit", "f", "je", "obj", "jl", "kj", "z", "fr", "json", "x", "l"], "cmpt": ["commbd", " cmpc", "cmpr", " cmpos", "rompty", "commply", "kmps", "gcpty", "fmdr", "gcpc", "kmpt", "kmpos", " cmptr", "mcpt", "cmpc", "commpc", " cmpty", "cmdr", "mrpl", "commpt", "fmpt", "cmps", "commps", "gcps", "rompr", "sempt", "mrdr", "mcdr", "kmpty", " cmpr", "commpr", " cmbd", "commptr", " cmps", "cmpos", "cmpl", "kmply", "commpos", "kmpr", "mrct", "cmply", "gcpt", "mcct", "fmct", "mrpt", "mcpl", "commpty", "cmct", "rompt", "sempr", "semptr", "sembd", "cmbd", "cmpty", " cmply", "cmptr", "rompos", "fmpl"]}}
{"project": "qemu", "commit_id": "c1076c3e13a86140cc2ba29866512df8460cc7c2", "target": 0, "func": "static void pxa2xx_lcdc_dma0_redraw_rot0(PXA2xxLCDState *s,\n\n                hwaddr addr, int *miny, int *maxy)\n\n{\n\n    DisplaySurface *surface = qemu_console_surface(s->con);\n\n    int src_width, dest_width;\n\n    drawfn fn = NULL;\n\n    if (s->dest_width)\n\n        fn = s->line_fn[s->transp][s->bpp];\n\n    if (!fn)\n\n        return;\n\n\n\n    src_width = (s->xres + 3) & ~3;     /* Pad to a 4 pixels multiple */\n\n    if (s->bpp == pxa_lcdc_19pbpp || s->bpp == pxa_lcdc_18pbpp)\n\n        src_width *= 3;\n\n    else if (s->bpp > pxa_lcdc_16bpp)\n\n        src_width *= 4;\n\n    else if (s->bpp > pxa_lcdc_8bpp)\n\n        src_width *= 2;\n\n\n\n    dest_width = s->xres * s->dest_width;\n\n    *miny = 0;\n\n    framebuffer_update_display(surface, s->sysmem,\n\n                               addr, s->xres, s->yres,\n\n                               src_width, dest_width, s->dest_width,\n\n                               s->invalidated,\n\n                               fn, s->dma_ch[0].palette, miny, maxy);\n\n}\n", "idx": 7866, "substitutes": {"s": ["des", "sw", "less", "conf", "c", "h", "ps", "ports", "ts", "settings", "t", "se", "js", "events", "sb", "xs", "grades", "ss", "changes", "series", "sports", "comments", "params", "as", "rs", "so", "ses", "results", "g", "ms", "es", "v", "stats", "bits", "m", "vs", "conv", "sis", "a", "aws", "l", "ops", "gs", "ns", "ats", "ies", "ags", "cs", "comm", "p", "aunts", "is", "sv", "hs", "bs", "sq", "parts", "fs", "S", "b", "eps", "its", "qs", "sys", "als", "details", "n", "ds", "ins", "ls", "ims", "sym", "args", "sl", "views", "status", "spec", "states", "obj", "ex", "sts", "mods"], "addr": ["rs", "ar", "src", "ctx", " add", "offset", "pad", " address", "at", "rn", "ip", "add", "mt", " ka", "arp", "or", "usr", "hw", " work", " af", " err", "r", "err", "dr", "rc", "id", "inter", "ad", " plat", "handle", "Address", " loc", "ix", "ptr", "alias", "address", "ord", " act", "amp", " pad", "ag", "adr", " mac", "coord", "nl", "a", "act"], "miny": ["mnyt", "minsyy", "Minny", "mintyy", "minyy", "mnY", "smallx", "Minicy", "Minyt", "Miny", "mncy", " minsy", "smallcy", "minsy", "minicy", "smally", " minny", " minY", "minsny", "minx", "Minsy", "mnx", "mintny", "Minyy", "minty", "minyt", "mny", " minyt", "mnny", " minx", "smallY", "minsicy", "minY", "mnsy", "mincy", "minny", " mincy", "minticy"], "maxy": ["lury", "hiley", "maj", "haxy", "moy", "mery", "hny", "miley", "hoy", "manaxy", "lery", "laxy", "maniley", "mury", "gmery", "manoy", "mny", " miley", " moy", " mny", "manny", " mury", "laj", "gmury", "gmaj", " mery", " maj", "gmaxy"], "surface": ["plane", "draw", "result", "console", "uf", "form", "um", "sheet", "window", " surfaces", "h", "view", "pad", "con", "sc", "buffer", "map", "profile", "display", "screen", "vp", "tty", " surf", "wrapper", "proc", "glass", "sb", "fac", "v", "sur", "cell", "bridge", "tain", "np", "tile", "f", "face", "interface", "fd", "source"], "src_width": ["src64length", "src_strength", "src2height", "src2radius", "src_size", "config_length", "src64radius", "src_platform", "src_driver", "dest_radius", "configlenplatform", " src_loss", "src_radius", "src7width", "srclenwidth", "dest_strength", "dest_length", "dest_height", "src_weight", "src_length", "configlenlength", " src_weight", "dest_driver", "dest_size", "src2strength", "src7length", "srclenplatform", "config_platform", " src_length", "src7size", "src64strength", "configlenwidth", "src2length", "configlensize", "src_loss", "config_size", "src2Width", "src2width", "src7driver", "src_height", " src_Width", " src_height", "src64width", "src_Width", "config_width", "srclensize", "srclenlength", "src2weight"], "dest_width": [" dest_weight", " dest_height", "orig_max", "dest___max", " dest_Width", "dest_radius", "dest___width", "orig_size", " dest_radius", "dest_length", "dest_height", "src_weight", "dest___height", "src_length", "dest_max", "dest_size", "src_depth", "dest_depth", "dest_Width", "dest_weight", "orig_width", "src_height", "dest___size", "orig_height", "src_Width"]}}
{"project": "qemu", "commit_id": "37ad223c515da2fe9f1c679768cb5ccaa42e57e1", "target": 0, "func": "build_dmar_q35(GArray *table_data, GArray *linker)\n\n{\n\n    int dmar_start = table_data->len;\n\n\n\n    AcpiTableDmar *dmar;\n\n    AcpiDmarHardwareUnit *drhd;\n\n\n\n    dmar = acpi_data_push(table_data, sizeof(*dmar));\n\n    dmar->host_address_width = VTD_HOST_ADDRESS_WIDTH - 1;\n\n    dmar->flags = 0;    /* No intr_remap for now */\n\n\n\n    /* DMAR Remapping Hardware Unit Definition structure */\n\n    drhd = acpi_data_push(table_data, sizeof(*drhd));\n\n    drhd->type = cpu_to_le16(ACPI_DMAR_TYPE_HARDWARE_UNIT);\n\n    drhd->length = cpu_to_le16(sizeof(*drhd));   /* No device scope now */\n\n    drhd->flags = ACPI_DMAR_INCLUDE_PCI_ALL;\n\n    drhd->pci_segment = cpu_to_le16(0);\n\n    drhd->address = cpu_to_le64(Q35_HOST_BRIDGE_IOMMU_ADDR);\n\n\n\n    build_header(linker, table_data, (void *)(table_data->data + dmar_start),\n\n                 \"DMAR\", table_data->len - dmar_start, 1, NULL);\n\n}\n", "idx": 7869, "substitutes": {"dmar": ["ddmad", " damber", "drvar", "dcor", "Dmar", " dgar", "domar", "drtar", "drover", "pdmar", "damar", "dmad", "ddtar", "daover", "doma", "Dma", "dogar", "dotar", " dtar", "dacor", "pdtar", "daamber", "dma", "Dtar", "ddmar", " dcor", "domad", "drmad", "drmar", "ddvar", "pdmad", "dramber", " dma", "dgar", "pdma", "damber", "dtar", "dover", " dover", " dmad", "Dgar", "dvar", " dvar", "drcor", "Dmad"], "drhd": ["drdd", "srdh", " drhim", "ardhd", "ardpd", "adrht", "drstd", "adrder", "Drht", "ardhs", " drpd", "adrhs", "drmpd", "ptrhim", "drmht", "adrhd", "arhs", "drmhd", "vrds", "arddh", "drmdh", "derkb", "drder", "drkb", "Drhs", "hrht", "adrpd", "mrdd", "prhd", "srhd", "grhl", "mrkb", "drHD", "prht", "drhim", "vrhd", "ptrds", " drds", "hrpd", "adrHD", "drmder", "drld", " drHD", "rsdh", " drkb", "grdh", "mrhd", "Drhd", "arpd", " drld", "drpd", "mrha", " drdh", "drmhs", "rsht", "prhl", "dersd", "mrsd", "drhl", "mrhim", "hrhs", "grhd", "drmHD", "srpd", " drha", "prdh", "rshs", "derha", "drdh", "rshd", "mrstd", "vrld", "vrHD", "ptrhd", "hrhd", "drsd", "drht", "ptrHD", "drha", "drds", " drstd", "adrdh", "Drdh", "grht", " drdd", "derhd", "arhd", "hrdh", "ptrstd", "ptrdd", " drhl", " drhs", "ptrld", " drht", "drhs", " drsd", "ardh", "srder"]}}
{"project": "qemu", "commit_id": "db1da1f2b5f3a2383030438553988f0734a97dbe", "target": 0, "func": "static GtkWidget *gd_create_menu_machine(GtkDisplayState *s, GtkAccelGroup *accel_group)\n\n{\n\n    GtkWidget *machine_menu;\n\n    GtkWidget *separator;\n\n\n\n    machine_menu = gtk_menu_new();\n\n    gtk_menu_set_accel_group(GTK_MENU(machine_menu), accel_group);\n\n\n\n    s->pause_item = gtk_check_menu_item_new_with_mnemonic(_(\"_Pause\"));\n\n    gtk_menu_shell_append(GTK_MENU_SHELL(machine_menu), s->pause_item);\n\n\n\n    separator = gtk_separator_menu_item_new();\n\n    gtk_menu_shell_append(GTK_MENU_SHELL(machine_menu), separator);\n\n\n\n    s->reset_item = gtk_menu_item_new_with_mnemonic(_(\"_Reset\"));\n\n    gtk_menu_shell_append(GTK_MENU_SHELL(machine_menu), s->reset_item);\n\n\n\n    s->powerdown_item = gtk_menu_item_new_with_mnemonic(_(\"Power _Down\"));\n\n    gtk_menu_shell_append(GTK_MENU_SHELL(machine_menu), s->powerdown_item);\n\n\n\n    separator = gtk_separator_menu_item_new();\n\n    gtk_menu_shell_append(GTK_MENU_SHELL(machine_menu), separator);\n\n\n\n    s->quit_item = gtk_menu_item_new_with_mnemonic(_(\"_Quit\"));\n\n    gtk_menu_item_set_accel_path(GTK_MENU_ITEM(s->quit_item),\n\n                                 \"<QEMU>/Machine/Quit\");\n\n    gtk_accel_map_add_entry(\"<QEMU>/Machine/Quit\",\n\n                            GDK_KEY_q, GDK_CONTROL_MASK);\n\n    gtk_menu_shell_append(GTK_MENU_SHELL(machine_menu), s->quit_item);\n\n\n\n    return machine_menu;\n\n}\n", "idx": 7873, "substitutes": {"s": ["as", "rs", "styles", "gs", "ses", "ns", "conf", "c", "its", "ries", "ats", "ies", "ers", "qs", "cs", "comm", "os", "ps", "p", "d", "g", "n", "details", "ports", "ts", "tests", "ds", "als", "sets", "t", "se", "pers", "plays", "r", "dates", "js", "ins", "sv", "ls", "sm", "sb", "services", "comments", "events", "gets", "ims", "stats", "sl", "views", "m", "hs", "vs", "ss", "bs", "states", "sq", "parts", "fs", "e", "S", "sts", "changes", "series", "sis", "aws", "ops"], "accel_group": ["accelablegroup", "acceler_function", "accel_user", "acceler_groups", "accel_context", "accel_function", "accelablecontext", "acceler_data", "accelablefunction", "accelggroup", "accelablegroups", "accel_data", "acceler_group", "acceler_user", "accelguser", "accelgdata", "accel_groups", "acceler_context", "accelggroups"], "machine_menu": ["machine_current", "machine_database", "mobile_directory", "created_menu", "human_menu", " machine_document", "machine___panel", "createdThemenu", "machineingdatabase", "machine_directory", "target_directory", "machineJmain", "machine_queue", "machineixdisplay", "machine8origin", "machineThemenu", "human_context", " machine_global", "createdTheblock", "machine_document", "machineJorigin", "human_current", "machineixglobal", "humaningmenu", "server8origin", "server_site", "server8menu", "machine64menu", "machine_main", "machine_table", "machine___menu", "machineingui", "targetJmenu", "machineJsite", "session_document", "machineetcurrent", "machineetdirectory", "machine8directory", "machine_category", "machineedloader", "machine_group", "machine8menu", "server8site", " machine_category", "sessioningmenu", "session_ui", "session_menu", "machine_global", "created_ui", "machine12main", "machine8current", "human_loader", "server_origin", "humaningloader", "machineixmenu", "machineedcurrent", "machineJdirectory", "machine8label", " machine_module", "machineedmenu", "mobile_current", "machine_display", "machine12menu", "machineTheui", "server8directory", "machineingmenu", "machine___group", "humaningcurrent", "sessioningdatabase", "humaningcontext", "machineetmenu", "machineJmenu", "machine_item", "machineThegroup", "mobileetmenu", "machine8site", "machine64mi", " machine_queue", "machine_label", "machineTheblock", "sessioningui", "machine_loader", "machine___ui", "machine_site", "target_table", "machineJtable", "target_menu", " machine_display", "machine8context", "machine_ui", "machineeddisplay", "createdThegroup", "mobileetdirectory", "machine12table", "machine_module", "server_directory", "mobile_label", "machine12directory", "mobileetlabel", "targetJdirectory", "machine_panel", "created_block", "machineedglobal", "machineingcurrent", "machine_context", "machine_mi", "targetJmain", " machine_panel", "created_group", "server_menu", "sessioningdocument", "session_database", "machine_origin", "targetJtable", " machine_mi", "createdTheui", "mobile_menu", "machine___block", "mobileetcurrent", "machine64category", "machine8loader", "machineingloader", "machine_block", "machineingdocument", "machineedcontext", "machineingcontext", "target_main", "machineetlabel", "machine___module", " machine_item"], "separator": ["variinator", " separer", "separATOR", " separoder", "participer", "separer", " separinator", " separcer", "separinator", "celeroder", " separner", "celerator", "alternator", "alterner", "participATOR", "gerinator", "separoder", "varioder", "participator", "celerinator", "alternATOR", "severant", "separcer", "gerator", "separner", "parator", " separager", "perater", "percer", "terminer", "generATOR", "variator", "genercer", "gerant", "generator", "perator", "separant", "separager", " separater", "parner", "severinator", "parinator", "paroder", "terminager", "severator", "perATOR", "termininator", "terminATOR", "geroder", " separATOR", "severoder", "terminator", "separater", "participinator", "celerner", "alternager", "variant", "generater"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "static void mv88w8618_flashcfg_write(void *opaque, target_phys_addr_t offset,\n\n                                     uint64_t value, unsigned size)\n\n{\n\n    mv88w8618_flashcfg_state *s = opaque;\n\n\n\n    switch (offset) {\n\n    case MP_FLASHCFG_CFGR0:\n\n        s->cfgr0 = value;\n\n        break;\n\n    }\n\n}\n", "idx": 7874, "substitutes": {"opaque": ["oplac", "iopa", "opla", " opulus", "obane", " opane", "opac", "iopac", "oplulus", "obacity", " opacity", "oplane", "oac", "oificate", "iopificate", "opificate", "opa", "oaque", "opacity", "oplacity", "oplificate", "iopaque", "opane", "oplaque", "opulus", "oa", "obulus", "obaque"], "offset": ["padding", "prefix", "window", "type", "shift", "set", "buffer", "ta", "addr", "cmd", "location", "seek", "len", "op", "pointer", "index", "o", "key", "trace", "position", "id", "attribute", "pos", "top", "style", "start", "usage", "slot", "priority", "tz", "oid", "command", "alloc", "off", "owner", "alias", "area", "address", "mask", "count", "point", "Offset", "length", "flag"], "value": ["package", "expression", "weight", "type", "values", "field", "set", " Value", "state", "buf", "vector", "buffer", "val", "ay", "index", "data", "key", "total", "input", "scale", "position", "byte", "unit", "attribute", "number", "ue", "v", "memory", "Value", "address", "message", "operator", "length", "text", "VALUE", "json", "name"], "size": ["bytes", "sp", "SIZE", "mem", "weight", "type", "h", "shift", "Size", "cmd", "n", "len", "data", "num", "cap", "command", "count", "address", "message", "sum", "ize", "e", "length", "z", "name"], "s": ["rs", "gs", "q", "sp", "b", "ns", "c", "h", "i", "qs", "p", "g", "ps", "n", "ts", "ds", "o", "t", "es", "r", "w", "an", "ls", "sb", "v", "stats", "sl", "m", "hs", "ss", "bs", "sq", "socket", "fs", "e", "S", "sts", "j", "a"]}}
{"project": "qemu", "commit_id": "60fe637bf0e4d7989e21e50f52526444765c63b4", "target": 1, "func": "static int qemu_rdma_get_fd(void *opaque)\n\n{\n\n    QEMUFileRDMA *rfile = opaque;\n\n    RDMAContext *rdma = rfile->rdma;\n\n\n\n    return rdma->comp_channel->fd;\n\n}\n", "idx": 7881, "substitutes": {"opaque": ["OPacity", "obaques", "obque", "omposit", "oposter", "opsoster", "opque", "ocacity", "opaques", "opsacity", "opsaques", "oposit", "poposit", "opacity", "OPaque", "opsaque", "OPaques", "ompaque", "popaque", "ompque", "popaques", "ocaque", "ocaques", "popque", "obosit", "OPoster", "ocoster", "ompaques", "obaque"], "rfile": [" rFile", "srFILE", "rlog", "srfile", "rFILE", "rarFile", "rFile", "srobject", " rFILE", "Rlog", "rfiles", "srFile", "Rfiles", "rdfiles", " rfiles", "rarFILE", " rlog", "rarobject", "rdfile", "rarfile", "rdlog", " robject", "Rfile", "robject"], "rdma": ["hrmas", "rnge", "rtm", "rrna", "drma", "hrm", "rdmas", "rnla", "rnna", "hrma", "rtmas", "ldMA", "rtma", "rdMA", "rrma", "rdmu", "hrwa", "ldna", "drwa", "drla", "rrla", "rrmu", "rdna", "rnca", "rnMA", "drmu", "rrge", "rdla", "drge", "ldma", "rnma", "rtwa", "rdwa", "rdm", "drmas", "rdca", "rnmu", "rrca", "rdge", "ldca", "drm", "rrMA"]}}
{"project": "qemu", "commit_id": "323ad19bcc601d3ec9cb6f0f5b4d67b602fc519e", "target": 1, "func": "static void dump_ppc_insns (CPUPPCState *env)\n\n{\n\n    opc_handler_t **table, *handler;\n\n    const char *p, *q;\n\n    uint8_t opc1, opc2, opc3;\n\n\n\n    printf(\"Instructions set:\\n\");\n\n    /* opc1 is 6 bits long */\n\n    for (opc1 = 0x00; opc1 < PPC_CPU_OPCODES_LEN; opc1++) {\n\n        table = env->opcodes;\n\n        handler = table[opc1];\n\n        if (is_indirect_opcode(handler)) {\n\n            /* opc2 is 5 bits long */\n\n            for (opc2 = 0; opc2 < PPC_CPU_INDIRECT_OPCODES_LEN; opc2++) {\n\n                table = env->opcodes;\n\n                handler = env->opcodes[opc1];\n\n                table = ind_table(handler);\n\n                handler = table[opc2];\n\n                if (is_indirect_opcode(handler)) {\n\n                    table = ind_table(handler);\n\n                    /* opc3 is 5 bits long */\n\n                    for (opc3 = 0; opc3 < PPC_CPU_INDIRECT_OPCODES_LEN;\n\n                            opc3++) {\n\n                        handler = table[opc3];\n\n                        if (handler->handler != &gen_invalid) {\n\n                            /* Special hack to properly dump SPE insns */\n\n                            p = strchr(handler->oname, '_');\n\n                            if (p == NULL) {\n\n                                printf(\"INSN: %02x %02x %02x (%02d %04d) : \"\n\n                                       \"%s\\n\",\n\n                                       opc1, opc2, opc3, opc1,\n\n                                       (opc3 << 5) | opc2,\n\n                                       handler->oname);\n\n                            } else {\n\n                                q = \"speundef\";\n\n                                if ((p - handler->oname) != strlen(q) ||\n\n                                    memcmp(handler->oname, q, strlen(q)) != 0) {\n\n                                    /* First instruction */\n\n                                    printf(\"INSN: %02x %02x %02x (%02d %04d) : \"\n\n                                           \"%.*s\\n\",\n\n                                           opc1, opc2 << 1, opc3, opc1,\n\n                                           (opc3 << 6) | (opc2 << 1),\n\n                                           (int)(p - handler->oname),\n\n                                           handler->oname);\n\n                                }\n\n                                if (strcmp(p + 1, q) != 0) {\n\n                                    /* Second instruction */\n\n                                    printf(\"INSN: %02x %02x %02x (%02d %04d) : \"\n\n                                           \"%s\\n\",\n\n                                           opc1, (opc2 << 1) | 1, opc3, opc1,\n\n                                           (opc3 << 6) | (opc2 << 1) | 1,\n\n                                           p + 1);\n\n                                }\n\n                            }\n\n                        }\n\n                    }\n\n                } else {\n\n                    if (handler->handler != &gen_invalid) {\n\n                        printf(\"INSN: %02x %02x -- (%02d %04d) : %s\\n\",\n\n                               opc1, opc2, opc1, opc2, handler->oname);\n\n                    }\n\n                }\n\n            }\n\n        } else {\n\n            if (handler->handler != &gen_invalid) {\n\n                printf(\"INSN: %02x -- -- (%02d ----) : %s\\n\",\n\n                       opc1, opc1, handler->oname);\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 7882, "substitutes": {"env": ["policy", "db", "ev", "esc", "setup", "window", "end", "conf", "ctx", "h", "here", "def", "scope", "conn", "store", "er", "addr", "inv", "dev", "ew", "vp", "viron", "context", "environment", "eh", "server", "err", "w", "pkg", "sv", "attr", "en", "gate", "v", "ah", "org", "req", "config", "worker", "vs", "ptr", "desc", "manager", "obj", "operator", "vm", "e", "engine", "global", "ten"], "table": ["policy", "tree", "chain", "state", "file", "order", "t", "attribute", "module", "level", "tmp", "entry", "batch", "filter", "TABLE", "journal", "package", "service", "csv", "root", "page", "store", "base", "Table", "context", "index", "stack", "master", "summary", "angle", "port", "pool", "address", "collection", "td", "db", "header", "peer", "type", "able", "offset", "map", "dict", "label", "tr", "total", "history", "bar", "try", "container", "array", "shape", "window", "binary", "set", "buffer", "domain", "body", "row", "data", "list", "entity", "handle", "tab", "stable", "tf", "cache", "count", "point", "qualified", "database", "variable", "interface"], "handler": ["policy", "event", "function", "way", "when", "http", "h", "file", "ler", "dev", "or", "pointer", "key", "attribute", "wrapper", "application", "layer", "handled", "priority", "worker", "reader", "controller", "lambda", "entry", "owner", "message", "test", "filter", "player", "folder", "method", "root", "job", "store", "er", "lib", "context", "index", " handlers", "server", "command", "stream", "Handler", "address", "info", "html", "json", "header", "hand", "error", "target", "type", "ctx", "field", "connection", "loader", "trap", "and", "history", "callback", "finder", "style", "usage", "host", "processor", "writer", "session", "definition", "result", "magic", "node", "window", "metadata", "then", "client", "buffer", "help", "actor", "profile", "behavior", "location", "parser", "data", "older", "hander", "handle", "man", "driver", "tx", "storage", "rule", "alias", "manager", "holder", "interface", "database", "high"], "p": ["c", "h", "pro", "ps", "pat", "d", "impl", "php", "fp", "t", "pe", "pos", "pg", "jp", "P", "j", "x", "ph", "par", "wp", "pad", "er", "g", "op", "pre", "ap", "lp", "v", "m", "part", "per", "parse", "np", "dp", "pp", "l", "peer", "u", "pc", "ctx", "pt", "ip", "pa", "o", "r", "pkg", "k", "sp", "b", "cp", "ping", "pb", "cmp", "rep", "i", "cmd", "bp", "vp", "func", "pr", "new", "f", "tp", "def"], "q": ["quick", "qual", "b", "quant", "it", "quote", "ping", "c", "u", "h", "i", "qs", "qi", "ip", "g", "d", "n", "iq", "queue", "o", "fp", "Q", "r", "w", "query", "question", "pkg", "qv", "ue", "k", "qa", "eq", " Q", "v", "req", "qq", "qu", "dq", "ch", "aq", "y", "sq", "f", "quest", "que", "qt", "P", "e", "pp", "j", "z", "l", "mp"], "opc1": ["opco9", "opac3", "opco01", "hoppc3", "opc81", "opcode2", "opcol81", "opl01", "opl3", "opc25", "oppc10", "optc001", "oprc101", " oplc4", "oppcol1", " oplc0", "opptc9", "opcode17", "opcu1", "opac4", "opfc1", "OPac1", "opC2", "alpcOne", "opcpOne", "oprc001", "opcu17", "optc1", "opc8", "opsc101", "opc101", "opcp0", "opsco001", "hoppc01", " opc17", "hopc1", "opco0", " opC17", "alc001", " oplc1", "optc2", "alc1", " opl2", "oprc1", "oppcOne", "opac41", " opc001", " opac0", "optcOne", "opc71", "opl2", "opac0", "alpc1", "hopc01", " opC1", "oppc4", "opac1", "opci1", "opcol17", "oppc0", "OPac001", " opac25", "opcOne", " opac9", "oppc71", "opc0", " opl1", " opc0", "oppc25", "opc17", "opcp9", "oppcol71", "opcache81", " opac2", " oplc2", "hoppc14", "opl14", "opc10", "opc41", " opac1", "OPac101", "opco14", "oprc2", "opsco101", "OPc001", "opc9", " opl8", "opco41", "opcol71", "opcache17", "opac8", "opce41", "hopc3", "opfc3", "oprcOne", "opl1", " opC2", "opci2", "opc4", " opl3", "opcu71", "hoppc1", "opco2", "opco001", "opac001", "opac2", "opcode1", " opc41", "opptc0", "opfc2", "oppc17", "opce0", "opC1", "opsc001", "oppc2", "opce2", " opac001", "oppc101", "opc14", "opcol1", "opl8", "opcp1", "OPc2", "oppc9", "opci101", "alc10", "opsc1", "opfc8", "OPc101", "opco3", "alcOne", " opc9", "oppc001", "opcache1", "oppc3", " opac41", "opptcOne", "opac9", "opco25", "opciOne", "opcache71", " opc4", "opptc1", "oppc14", "opci10", "oppcol81", "opsco1", "oplc2", " opc25", "oplc0", "hopc14", "oplc4", "oppc01", "opc01", "optc0", "opC17", "OPc1", "opco1", "alpc001", "opcu81", " opc8", "opci001", "opci17", "opac25", "optc9", "opco101", "opce1", "oplc1", "opac101", "oppc1", "opacOne", "oppc81", "opc001", "alpc10", "oprc10", "OPac2", "oppcol17"], "opc2": ["oprc43", "opc02", "opgc72", "opac3", "opl3", "hotcTwo", "opsec4", "opcp02", "opc022", "operatorc72", "extc3", "extci4", "opc82", "optcTwo", " opct2", "opct1", "operatorcow2", "hoppctwo", "opac4", " opctTwo", "opconf62", "opcTwo", "OPctwo", "copc5", "opC2", "opfc1", "ipc43", "ope2", "opcatTwo", "optc1", "opvc2", "opca2", "opf4", "opceTwo", "OPc002", "opconf5", "oppc02", "opk4", "opcow4", "opz14", "opce4", "OPca02", "opgc5", "oppc72", "optc2", "hotc72", "oprc1", "opcatwo", "opf2", "opl2", "opc0002", "hoppc02", "opvc02", "opcat1", "opct2", "opjc2", "optz14", "opcpTwo", "oppc4", "hotcatTwo", "opac1", "ipc1", "extci05", "hopctwo", "opct02", "opk2", "opc05", "optz82", "hopc2", "hotcat1", "copc2", "opgc62", "opcow022", "hoppc6", "opz82", "oppc6", "hopc6", "operatorcow72", "opcitwo", "extc2", "opca002", "opgc2", "opco14", "optc4", "opctTwo", "oprc2", "oppctwo", "opci05", "extci2", "opc002", "opfctwo", "opc6", "opfc02", "optpc4", "OPca2", "opac02", "ope1", "opz0002", "operatorc4", "extc4", "ipac02", "opct4", "opjc14", "opcptwo", "opc62", "opl022", "opeTwo", " opcTwo", "copc72", "opci2", "opk3", "opc4", "opco82", "hotc1", "opct3", "opcp4", "extci3", "opci3", "operatorcow022", "hotc2", "oppcTwo", "oppc5", "hopc02", "opconf2", "opco2", "operatorc022", "opcat72", "opac2", "opc43", "opfc2", "opfTwo", "opjc0002", "opco0002", "optc14", "OPca002", "opC1", "oppc2", "opce2", "opcow2", "opc14", "opci4", "ope4", "OPc2", "opci002", "opc5", "hoppc2", "oprc02", "opC72", "opfc43", "opk02", "opvc002", "opsec72", "opl72", "opjc82", "hotcat2", "optc0002", "optpc1", "copc62", "ipac43", "ipc02", "optpcTwo", "ipac1", "opconf72", "opct72", "ipac2", " opc4", "opcat2", "coppc62", "ipc2", "OPc02", "operatorcow4", "coppc5", "opcow72", "opc72", " opct4", "opCTwo", "opl4", "opca02", "operatorc2", "opctwo", "opsec2", "opcp2", "opsec022", "opz2", "coppc72", "opce1", "opfc6", "hotcat72", "opac05", "coppc2", "optc82", "optpc2", "oppc1", " opc02", "opcp6", "oppc62", "OPcatwo", " opct3", " opct02", "opac43", "opl05", "optz2", "extc05", "optz0002", "opci02", "opvctwo"], "opc3": ["opac3", "opunc13", " opc03", " opc23", "apc343", "uppcthree", "optco2", "operec3", "ioppc3", " opac83", "opcThree", "operec1", "upciii", "opce003", "opc23", "opceThree", "opoc15", "opsc43", "opec03", "opaciii", "opk03", "opcs3", "opce43", "oprc13", "hopc53", "optco3", "hopjc128", "optc128", "apc03", "opoc343", "apc3", "opcc3", "Opc33", "OppcThree", "opcaThree", "upcthree", "optc93", "opcat03", "optc2", "oppc15", "opca23", "opci33", "opca1", "opc21", "oparcthree", "opjc93", "optci3", "oprc128", " opac03", "opco128", "opfc03", "opk1", "ioppc23", "iopc15", " opacThree", "opfc003", "oplcThree", "opci15", "opac1", "opjc3", "oppcthree", "opsc003", "opunc3", "upc03", "opacThree", "oplc003", "oplc3", "OpcThree", "optc03", "Opc3", "oppc83", "opc53", "opccthree", "Oppc3", "operecThree", "opcat3", "optc3", "oppc03", "opc93", "opkThree", "apcat15", "opac23", "oparc23", "oppc003", "opjc15", "opsc03", "opc13", "oppc23", "opci003", "opcc03", "opcatiii", " opac1", "hopjc3", "oprc2", "opec1", "oprc03", "Oppc003", "oppc93", "opunc128", "Oppc33", "optci93", " opc83", "hopc3", "opciii", "opcat15", "opfc3", "opco03", "opc83", "opacthree", "opcc83", "opcatthree", "hopjc53", " opac3", "opc003", "opcc15", "opspc43", "opc128", "iopc23", "optco03", "opac128", "opct3", "opk3", "operc1", " opac23", " opcThree", "opci3", "opoc03", "optci15", "iopc3", "opecThree", "opco2", "opcc1", "oparc15", "opjc21", "opercThree", "opcs23", "opc43", "opspc03", "opac2", "opunc53", "opciThree", "opcc23", "Opc003", "operec03", "opca3", "opct343", "optco128", "opac83", "hopc128", "opc33", "oparc3", "operc3", "opce03", "opcthree", "hopjc13", "opcs1", "opfc43", "opco3", "apcat3", "iopcthree", "oppc3", "apc15", "opc15", "ioppc15", "optc15", "apcat343", "opspc003", "opjc128", "oppc21", "oprc53", "hopc13", "uppciii", "oppcThree", "opc03", "oppc33", "oplc33", "opsc3", "opjc53", "opjc13", "operc03", "optci21", "opoc3", "opce3", "opct15", "opce1", "opec3", "uppc3", "ioppcthree", "oppciii", "oppc1", "opct03", "opcat343", "opac03", "opspc3", "oppc43", "opcsThree", "oprc3", "opc343", "opci21", "upc3", "apcat03", "uppc03", "opci93", "optc21"]}}
{"project": "FFmpeg", "commit_id": "bf2cba453244a74331238a472fe0e309f116f4d9", "target": 1, "func": "yuv2rgb_2_c_template(SwsContext *c, const int16_t *buf[2],\n\n                     const int16_t *ubuf[2], const int16_t *vbuf[2],\n\n                     const int16_t *abuf[2], uint8_t *dest, int dstW,\n\n                     int yalpha, int uvalpha, int y,\n\n                     enum PixelFormat target, int hasAlpha)\n\n{\n\n    const int16_t *buf0  = buf[0],  *buf1  = buf[1],\n\n                  *ubuf0 = ubuf[0], *ubuf1 = ubuf[1],\n\n                  *vbuf0 = vbuf[0], *vbuf1 = vbuf[1],\n\n                  *abuf0 = abuf[0], *abuf1 = abuf[1];\n\n    int  yalpha1 = 4095 - yalpha;\n\n    int uvalpha1 = 4095 - uvalpha;\n\n    int i;\n\n\n\n    for (i = 0; i < (dstW >> 1); i++) {\n\n        int Y1 = (buf0[i * 2]     * yalpha1  + buf1[i * 2]     * yalpha)  >> 19;\n\n        int Y2 = (buf0[i * 2 + 1] * yalpha1  + buf1[i * 2 + 1] * yalpha)  >> 19;\n\n        int U  = (ubuf0[i]        * uvalpha1 + ubuf1[i]        * uvalpha) >> 19;\n\n        int V  = (vbuf0[i]        * uvalpha1 + vbuf1[i]        * uvalpha) >> 19;\n\n        int A1, A2;\n\n        const void *r =  c->table_rV[V],\n\n                   *g = (c->table_gU[U] + c->table_gV[V]),\n\n                   *b =  c->table_bU[U];\n\n\n\n        if (hasAlpha) {\n\n            A1 = (abuf0[i * 2    ] * yalpha1 + abuf1[i * 2    ] * yalpha) >> 19;\n\n            A2 = (abuf0[i * 2 + 1] * yalpha1 + abuf1[i * 2 + 1] * yalpha) >> 19;\n\n        }\n\n\n\n        yuv2rgb_write(dest, i, Y1, Y2, U, V, hasAlpha ? A1 : 0, hasAlpha ? A2 : 0,\n\n                      r, g, b, y, target, hasAlpha);\n\n    }\n\n}\n", "idx": 7885, "substitutes": {"buf0": ["uf000", "uf047", "buff1", "buff047", "buff0", "buf000", "uf2", "uf1", "buf047", "buf2", "buff000", "aka0", "brace1", "aka2", "aka000", "brace0", "uf0", "buffer2", "buff2", "buffer1", "brace047", "buffer0", "aka1"], "buf1": ["buff3", "uf4", "buff1", "buffer01", "uf3", "buff0", "uf01", "buf4", "queue1", "buf01", "uf2", "uf1", "buff4", "buf2", " buf01", "queue0", "queue4", "buf3", "uf0", "buffer2", "buffer1", " buf2", "buffer0", "queue3"], "ubuf0": ["ubuf10", "abufi", "ubufi", "ubdj1", "ubbo10", "ubuff1", "ubdj8", "ubbufi", "ubuff0", "ubdj0", "abuf4", "ubbuf1", "ubbuf10", "ubuff8", "ubbuff1", "ubbo1", "ubbuff10", "ubbo0", "ubbuf8", "ubbuf0", "ubdji", "ubbo4", "abbuf10", "abbuf4", "abuf10", "ubuf8", "ubbuff0", "ubbuff4", "abbufi", "abbuf0", "abuf8", "ubuffi", "abbuf1", "abbuf8", "ubuf4", "ubbuf4"], "ubuf1": ["ubuff1", "abuf30", "ubuff0", "ubundle01", "abbuf01", "ubbuf2", "ubbuf1", "ubbuff1", "ubbuf30", "ubundle1", "abuf2", "ubbuf0", "ubbuf01", "ubbuff0", "abuf01", "ubundle0", "ubuff30", "abbuf0", "ubuf2", "ubuf01", "ubuf30", "abbuf1", "ubuff2", "ubbuff2", "abbuf2", "ubundle30", "ubuff01", "abbuf30"], "vbuf0": ["verbuf0", "vseq047", "vcv0", "veruf7", "avbuf1", "avuf0", "vcv7", "vuf3", "vuf0", "vbuff7", "vuf047", "veruf0", "vseq1", "verbuf1", "vseq0", "vbuff3", "vbuf7", "vbuff047", "vcv3", "avbuf047", "avbuf0", "avuf047", "vuf7", "veruf1", "vbuf3", "verbuf7", "vuf1", "avuf1", "verbuf3", "veruf3", "vcv1", "vbuff0", "vbuf047", "vbuff1"], "vbuf1": [" vpkg3", "vbuf2", "vpkg1", "vcmd2", "Vuf2", "vbuffer3", "Vuf11", "vpkg0", " vbuf100", "vpkg3", "vbuff2", "vcmd1", " vpkg1", "vuf3", "Vuf1", "vbuffer0", "vbuff11", "Vbuf2", "vcmd3", "vbuf100", "vpkg100", "vbuff3", "Vbuf11", "vuf11", " vbuf3", "vbuffer1", "vbuf11", "vuf2", "Vbuf1", "Vbuf3", "Vuf3", " vpkg100", "vcmd11", "vbuf3", "vbuffer100", "vuf1", "vbuff100", " vpkg0", "vbuff0", "vbuff1"], "abuf0": ["labbuf0", "absuf2", "labuf2", "abbuff3", "abff1", "abimg10", "absbuf1", "abbuff0", "abff10", "labbuf1", "absuf25", "abuf3", "abuff3", "abbuf3", "abimg0", "absbuf2", "abff2", "absuf0", "labbuf10", "abutf2", "absuf1", "labuf0", "abutf1", "abuf2", "abimg2", "abff0", "absbuf3", "abuff0", "abbuf10", "abuf10", "absbuf0", "absbuf25", "abbuf25", "abutf0", "labuf1", "abbuff2", "abbuf0", "abuff2", "labuf10", "abbuf1", "labbuf2", "abimg1", "abbuff1", "abutf25", "absuf3", "abuff25", "abbuf2", "abuf25", "abuff1"], "abuf1": ["abuffer0", "absuf2", "absuf01", "abuff01", "abuffy1", "abbuf01", "absbuf1", "abbufOne", "abimg0", "absbuf2", "abuffy100", "absuf0", "abuffy0", "absuf1", "absufOne", "abuf2", "absuff0", "abimg2", "abuffer1", "abimg01", "abbuf100", "abuffOne", "abuff0", "abufferOne", "abuffy2", "abuffer2", "abuf100", "absbuf0", "abuf01", "abbuf0", "abuff2", "absuf100", "abuff100", "abbuf1", "absuff100", "absuff2", "abimg1", "absuff1", "abufOne", "absbuf01", "abbuf2", "absbufOne", "abuff1"], "i": ["asi", "ei", " ii", "im", "c", "ori", "ik", "gi", "zi", "ind", " ti", "t", "pi", "key", "hi", "iter", "Ti", " j", "I", "batch", "io", "in", "j", "iri", "di", "\u0438", "x", "this", "ic", "mi", "xi", "index", "ri", "bi", "go", "ki", "span", "start", "ti", "ai", "m", "item", "ia", "info", "a", "l", "ci", "it", "ip", "li", "p", "ami", "is", "o", "try", "y", "ii", "name", "init", "ini", "ij", "uri", "cli", "oi", "qi", "si", "n", "multi", "me", "ui", "id", "ji", "phi", "ims", "ix", "status", "sim", "iu", "e", "point"], "A1": [" A3", "R3", "R1", "AA1", "ROne", "BOne", "B2", "AM3", "B3", "AM11", "AOne", "AA11", "R2", " A12", "AA3", "AA12", "A11", "A12", "AM1", "B1", "AM12", "A3", " A11", " AOne"], "A2": ["ABTwo", "A4", "AA5", "aTwo", "A6", "AM02", "AA02", "AA2", "AA6", " A5", "A02", "a2", " ATwo", "AM2", "AM6", "AB5", " A4", " A02", "ATwo", "AB4", "AB2", "A5", "a4", "a5", " A6", "AM5"], "r": ["rs", "vr", "q", "ar", "sr", "c", "h", "er", "p", "d", "n", "o", "err", "w", "dr", "rc", "rb", "cr", "v", "m", "re", "rg", "R", "f", "e", "ro"], "g": ["gt", "gb", "q", "gp", "c", "u", "bg", "gr", "h", "fg", "p", "d", "n", "w", "go", "k", "v", "m", "reg", "rg", "y", "f", "j", "gg", "G", "l"], "b": ["c", "u", "bg", "h", "bc", "p", "d", "n", "o", "t", "bi", "w", "bb", "rb", "v", "be", "m", "B", "fb", "y", "f", "e", "j", "a", "l", "ba"]}}
{"project": "FFmpeg", "commit_id": "b88be742fac7a77a8095e8155ba8790db4b77568", "target": 1, "func": "static int minimum_frame_bits(VC2EncContext *s)\n\n{\n\n    int slice_x, slice_y, bits = 0;\n\n    s->size_scaler = 64;\n\n    for (slice_y = 0; slice_y < s->num_y; slice_y++) {\n\n        for (slice_x = 0; slice_x < s->num_x; slice_x++) {\n\n            bits += count_hq_slice(s, NULL, slice_x, slice_y, s->q_ceil);\n\n        }\n\n    }\n\n    return bits;\n\n}\n", "idx": 7892, "substitutes": {"s": ["rs", "gs", "ses", "sw", "sg", "less", "ns", "conf", "c", "eps", "ats", "sys", "qs", "cs", "comm", "os", "p", "g", "ms", "ps", "n", "is", "ts", "ds", "ains", "sets", "t", "es", "r", "js", "ins", "space", "sv", "ls", "sb", "v", "ims", "stats", "m", "spec", "a", "vs", "hs", "ss", "bs", "sq", "parts", "fs", "e", "S", "sts", "x", "aws", "l", "ops"], "slice_x": ["slice09y", "slice____xf", "ice_x", "slice__y", "slice__x", "slice____x", "sliceablex", "sliceleti", "slice__lat", " slice_i", "slice_inx", "slice__i", "sliceletx", "slice____ex", "sliceletex", "slice_xx", " slice_lat", "slot_ex", "slice_xf", "ice_ey", "slot_inx", "slot____inx", "slice____inx", "sliceletxf", "ice_xs", "slice_ey", "slice09x", "slot_xi", "slot_x", "sliceableex", " slice_ex", "slice_lat", "slice_xi", "slice____i", "slot____ex", "slice____xi", " slice_xf", "sliceablexx", "slot_xx", "slot____xi", "slice_xs", "slice_i", "slice_race", "slice09lat", "ice_ex", "slot____x", "slice09i", "slot_race", "slice_ex", "sliceablerace"], "slice_y": ["slice___xy", "ice_x", "slice_yo", "slicepty", "sliceNameyo", "slice_yy", "single_y", "slice_ly", "species_ly", "slice___ly", "sliceablex", "slice___y", "slice_asy", "slice_ny", " slice_ny", "sliceableyy", "slice___yo", "single_ya", "slice_ya", "slice_xy", "sliceptyy", "species_y", "ice_y", "species_xy", "sliceNameya", "sliceingly", " slice_yy", "slice_vy", "ice_ya", "sliceixx", "sliceingyo", "single_asy", "sliceableny", "sliceixya", "sliceNameasy", "sliceixvy", "species_yo", "sliceabley", "sliceixy", "single_yo", "sliceptx", "sliceingxy", "ice_vy", "sliceNamey", "sliceingy", "sliceptny"]}}
{"project": "qemu", "commit_id": "0b8b8753e4d94901627b3e86431230f2319215c4", "target": 1, "func": "static void fd_coroutine_enter(void *opaque)\n\n{\n\n    FDYieldUntilData *data = opaque;\n\n    qemu_set_fd_handler(data->fd, NULL, NULL, NULL);\n\n    qemu_coroutine_enter(data->co, NULL);\n\n}\n", "idx": 7893, "substitutes": {"opaque": ["OPacity", "OPacement", "orula", "oaques", "compacity", "oraques", "oppaques", "opaques", "replaques", "oppula", "oppaque", "oacement", "oaque", "compaques", "opacement", "compula", "opacity", "OPaque", "OPaques", "replacement", "compaque", "replaque", "oracity", "oacity", "opula", "oppacity", "replacity", "oraque"], "data": ["aw", " some", " whoever", " missing", "next", "empty", "dat", "step", " possibly", " who", "join", "roy", "rel", "store", "ATA", "ta", "defined", "extra", " unused", "valid", "d", "table", "missing", "no", " DATA", "name", "ata", "zero", " junk", "row", "o", "Data", "str", "value", "id", " garbage", "ad", "who", "command", "block", "reader", "done", "entry", "batch", "area", "DATA", "message", " dummy", "size", "info", "hash", "by", "di", "def", "da"]}}
{"project": "qemu", "commit_id": "e976c6a1e40ad74d616a186d3b48b0ad8f5eb970", "target": 1, "func": "static void qcow_aio_write_cb(void *opaque, int ret)\n\n{\n\n    QCowAIOCB *acb = opaque;\n\n    BlockDriverState *bs = acb->common.bs;\n\n    BDRVQcowState *s = bs->opaque;\n\n    int index_in_cluster;\n\n    uint64_t cluster_offset;\n\n    const uint8_t *src_buf;\n\n    int n_end;\n\n\n\n    acb->hd_aiocb = NULL;\n\n\n\n    if (ret < 0) {\n\n    fail:\n\n        acb->common.cb(acb->common.opaque, ret);\n\n        qemu_aio_release(acb);\n\n        return;\n\n    }\n\n\n\n    acb->nb_sectors -= acb->n;\n\n    acb->sector_num += acb->n;\n\n    acb->buf += acb->n * 512;\n\n\n\n    if (acb->nb_sectors == 0) {\n\n        /* request completed */\n\n        acb->common.cb(acb->common.opaque, 0);\n\n        qemu_aio_release(acb);\n\n        return;\n\n    }\n\n\n\n    index_in_cluster = acb->sector_num & (s->cluster_sectors - 1);\n\n    n_end = index_in_cluster + acb->nb_sectors;\n\n    if (s->crypt_method &&\n\n        n_end > QCOW_MAX_CRYPT_CLUSTERS * s->cluster_sectors)\n\n        n_end = QCOW_MAX_CRYPT_CLUSTERS * s->cluster_sectors;\n\n\n\n    cluster_offset = alloc_cluster_offset(bs, acb->sector_num << 9,\n\n                                          index_in_cluster,\n\n                                          n_end, &acb->n);\n\n    if (!cluster_offset || (cluster_offset & 511) != 0) {\n\n        ret = -EIO;\n\n        goto fail;\n\n    }\n\n    if (s->crypt_method) {\n\n        if (!acb->cluster_data) {\n\n            acb->cluster_data = qemu_mallocz(QCOW_MAX_CRYPT_CLUSTERS *\n\n                                             s->cluster_size);\n\n            if (!acb->cluster_data) {\n\n                ret = -ENOMEM;\n\n                goto fail;\n\n            }\n\n        }\n\n        encrypt_sectors(s, acb->sector_num, acb->cluster_data, acb->buf,\n\n                        acb->n, 1, &s->aes_encrypt_key);\n\n        src_buf = acb->cluster_data;\n\n    } else {\n\n        src_buf = acb->buf;\n\n    }\n\n    acb->hd_aiocb = bdrv_aio_write(s->hd,\n\n                                   (cluster_offset >> 9) + index_in_cluster,\n\n                                   src_buf, acb->n,\n\n                                   qcow_aio_write_cb, acb);\n\n    if (acb->hd_aiocb == NULL)\n\n        goto fail;\n\n}\n", "idx": 7916, "substitutes": {"opaque": ["ipaques", "obaques", "compatile", "obque", "compacity", " Opaque", "ipaque", "ipker", "operaque", " Oportal", "opque", "obacity", "opker", "bitaque", "opaques", "oportal", "obatile", "OPatile", "bitque", "obula", " Opque", "ipacity", "compaques", " opatile", "ipatile", "ipque", "OPortal", "opacity", "OPaque", " opker", "OPker", "OPaques", " opaques", "popaque", "popacity", "operortal", "OPula", "popaques", "compaque", "opatile", "bitatile", "opula", "OPque", "popatile", "bitacity", "operque", "popula", "obaque"], "ret": ["gt", "result", "rot", "pret", "att", "reply", "ter", "nt", "ry", "ext", "dt", "cmd", "mt", "rets", "len", "val", "tr", "red", "t", "alt", "err", "after", "ref", "inter", "rev", "rem", "out", "try", "txt", "sec", "rt", "reset", "status", "resp", "re", "der", "lit", "tf", "RET", "desc", "pas", "print", "vt", "Ret", "nz", "ft", "arg", "tech", "eth", "hash", "ll", "res", "vet", "deg", "def", "rm", "elt", "flag"], "acb": ["acsb", "aqb", "actrb", "macbe", "aclbb", "ccfb", "acbm", "acr", " acp", "accfb", "iacbr", "aicb", "macsb", "Acbr", "macrb", "aconbm", "rcnb", "pacgb", "sacb", "aclx", "acob", "aicl", "ancpb", "acmb", "aqgb", "actzb", "pacbe", " aczb", "rcb", "Acbd", "racrb", "pacbr", "aconbd", "iacfb", "macgb", "acwb", "facb", "aclr", "icbr", "sacsb", "ancbar", "accb", "icb", "aconob", " acwb", "aconab", "ancba", " acdb", "acbd", "ocb", " lacba", "pacrb", "ancob", "racb", "ecrb", "accg", "achwb", "icbd", "ainbm", "acdb", "pacb", "ccob", "aicgb", "aclb", "aconsb", "pacfb", "accl", "acbar", "sacba", "aclrb", "ainrb", " acbd", "pacmb", "ancnb", " acsb", "actnb", "aconfb", "ocnb", "iacx", "acab", "aclbr", "aconrb", "accbm", "achrb", "sacrb", " acgb", "accn", " acbb", "sacbb", "iacsb", "ccpb", "sacnb", "acrb", "facr", "acy", "absb", " acrb", "iacr", "acf", "Acbe", "iacbar", "ancbd", " lacrb", "ecsb", "acbl", "acl", "accnb", "accx", "acbi", "acba", "accbb", "icrb", "facsb", "macb", "aicmb", " acl", "icgb", "aconf", " lacf", "accsb", "ainbb", "ccnb", "aclnb", "accbar", "iacy", "aclbd", "ocsb", "aconnb", "acong", "aclbi", " acbe", "racba", "icnb", "sacn", "actb", "macba", "aconl", " acob", "facab", "aconb", "Acnb", "acx", "racf", "aclbar", "racwb", "facg", "aicbi", "aconbe", "acp", "accbr", "ancb", "ccbe", "aql", "iacnb", "abb", "acly", "aclbl", "actsb", "acgb", "macbd", "aconba", "ecb", "sacdb", "rcpb", "sacgb", " lacb", " acba", "actwb", "aclp", "Acfb", "accba", "aicbr", "Acbl", "aconbb", "ocbb", "accob", "facgb", "acpb", "acbb", " acmb", "aclgb", "aclmb", "achzb", "accbd", "pacba", "macbb", "acfb", "facba", "pacbi", "accrb", "accy", "Acb", "rcob", "macbl", "acn", "pacbb", "ecdb", "Acbb", "accr", "acg", "aczb", "sacbr", "ccb", "acnb", "acln", "accgb", "pacbar", "ainb", "actbr", "abbr", "pacbd", "acbe", "iacb", "achb", "Acsb", "icbar", "acbr", "abba", "accp", "accmb", "accab", "aconr", "pacwb", "pacsb"], "bs": ["bes", "rs", "bytes", "gs", "bis", "b", "bn", "ns", "ubs", "its", "bos", "bg", "bc", "sys", "qs", "cs", "os", "bh", "is", "ts", "bles", "ds", "BS", "cb", "bi", "aus", "js", "bb", "ls", "blocks", "sb", "bps", "ubis", "outs", "bits", "vs", "zb", "ss", "bl", "fs", "us", "ks", "bm", "obs", "bas", "ops", "lbs"], "s": ["bes", "rs", "gs", "bis", "ses", "b", "less", "tes", "ns", "irs", "c", "its", "orders", "h", "ies", "ats", "abilities", "sys", "qs", "cs", "os", "uploads", "ps", "g", "p", "details", "ms", "als", "is", "ts", "ds", "sets", "t", "js", "w", "sv", "ls", "params", "sb", "xs", "v", "ims", "stats", "tags", "args", "sl", "bits", "spec", "hs", "a", "ss", "sn", "parts", "fs", "ys", "S", "sts", "changes", "series", "sports", "aws"], "index_in_cluster": ["index_in_clust", "index_in_pluster", "index_in_chust", "index_in_plusters", "index_in_Closer", "index_in_flust", "index_in_chuster", "index_in_closer", "index_in_Cluster", "index_in_glusters", "index_in_scoser", "index_in_glust", "index_in_chusters", "index_in_plause", "index_in_flause", "index_in_scusters", "index_in_gluster", "index_in_clause", "index_in_gloser", "index_in_Clusters", "index_in_Clause", "index_in_plust", "index_in_scust", "index_in_scuster", "index_in_fluster", "index_in_Clust", "index_in_clusters", "index_in_flusters", "index_in_ploser"], "cluster_offset": ["clocation____metadata", "cluster_loc", "clusterableid", "cluster____offset", "cluster_onet", "clusterableoffset", "clusteringonet", "clust_loc", "cluster_off", "clocation____onet", "cluster_metadata", "clust_offset", "clocation____style", "cluster____style", "clocation_offset", "clocation____offset", "cluster_info", "clocation_onet", "clusterableoff", "clocation_metadata", "cluster_id", "clust_length", "cluster____metadata", "cluster_style", "cluster____onet", "clust_off", "clust_data", "cluster_data", "clusteringoffset", "clocation_style", "clusteringstyle", "cluster_length", "clusterabledata", "clust_id", "clusteringmetadata", "clust_location", "clust_info", "cluster_location"], "src_buf": ["src_data", "src_buff", "source_buff", "source_buf", "source_data", "src_mem", "source_mem"], "n_end": ["n__END", "sn_END", "n2end", "n_stop", "n_End", "n__nd", "n__max", "n2END", "N_tail", "n__end", "n_nd", "sn__end", "sn_ended", "ln_eng", "n_ended", "N_END", "n_tail", "ln_end", "sn_end", "ln_ended", "N_End", "n__ended", "n_max", "n_eng", " n_nd", "sn_max", "sn__ended", "n_END", "N_end", " n_END", "sn__max", "sn__END", "N_stop", "n2nd"]}}
{"project": "FFmpeg", "commit_id": "08d2cee49c323715b66df0e4ff45ec0e07aaea7b", "target": 0, "func": "static int opt_input_file(const char *opt, const char *filename)\n\n{\n\n    AVFormatContext *ic;\n\n    AVInputFormat *file_iformat = NULL;\n\n    int err, i, ret, rfps, rfps_base;\n\n    int64_t timestamp;\n\n    uint8_t buf[128];\n\n    AVDictionary **opts;\n\n    int orig_nb_streams;                     // number of streams before avformat_find_stream_info\n\n\n\n    if (last_asked_format) {\n\n        if (!(file_iformat = av_find_input_format(last_asked_format))) {\n\n            fprintf(stderr, \"Unknown input format: '%s'\\n\", last_asked_format);\n\n            ffmpeg_exit(1);\n\n        }\n\n        last_asked_format = NULL;\n\n    }\n\n\n\n    if (!strcmp(filename, \"-\"))\n\n        filename = \"pipe:\";\n\n\n\n    using_stdin |= !strncmp(filename, \"pipe:\", 5) ||\n\n                    !strcmp(filename, \"/dev/stdin\");\n\n\n\n    /* get default parameters from command line */\n\n    ic = avformat_alloc_context();\n\n    if (!ic) {\n\n        print_error(filename, AVERROR(ENOMEM));\n\n        ffmpeg_exit(1);\n\n    }\n\n    if (audio_sample_rate) {\n\n        snprintf(buf, sizeof(buf), \"%d\", audio_sample_rate);\n\n        av_dict_set(&format_opts, \"sample_rate\", buf, 0);\n\n    }\n\n    if (audio_channels) {\n\n        snprintf(buf, sizeof(buf), \"%d\", audio_channels);\n\n        av_dict_set(&format_opts, \"channels\", buf, 0);\n\n    }\n\n    if (frame_rate.num) {\n\n        snprintf(buf, sizeof(buf), \"%d/%d\", frame_rate.num, frame_rate.den);\n\n        av_dict_set(&format_opts, \"framerate\", buf, 0);\n\n    }\n\n    if (frame_width && frame_height) {\n\n        snprintf(buf, sizeof(buf), \"%dx%d\", frame_width, frame_height);\n\n        av_dict_set(&format_opts, \"video_size\", buf, 0);\n\n    }\n\n    if (frame_pix_fmt != PIX_FMT_NONE)\n\n        av_dict_set(&format_opts, \"pixel_format\", av_get_pix_fmt_name(frame_pix_fmt), 0);\n\n\n\n    ic->video_codec_id   =\n\n        find_codec_or_die(video_codec_name   , AVMEDIA_TYPE_VIDEO   , 0);\n\n    ic->audio_codec_id   =\n\n        find_codec_or_die(audio_codec_name   , AVMEDIA_TYPE_AUDIO   , 0);\n\n    ic->subtitle_codec_id=\n\n        find_codec_or_die(subtitle_codec_name, AVMEDIA_TYPE_SUBTITLE, 0);\n\n    ic->flags |= AVFMT_FLAG_NONBLOCK;\n\n\n\n    /* open the input file with generic libav function */\n\n    err = avformat_open_input(&ic, filename, file_iformat, &format_opts);\n\n    if (err < 0) {\n\n        print_error(filename, err);\n\n        ffmpeg_exit(1);\n\n    }\n\n    assert_avoptions(format_opts);\n\n\n\n    if(opt_programid) {\n\n        int i, j;\n\n        int found=0;\n\n        for(i=0; i<ic->nb_streams; i++){\n\n            ic->streams[i]->discard= AVDISCARD_ALL;\n\n        }\n\n        for(i=0; i<ic->nb_programs; i++){\n\n            AVProgram *p= ic->programs[i];\n\n            if(p->id != opt_programid){\n\n                p->discard = AVDISCARD_ALL;\n\n            }else{\n\n                found=1;\n\n                for(j=0; j<p->nb_stream_indexes; j++){\n\n                    ic->streams[p->stream_index[j]]->discard= AVDISCARD_DEFAULT;\n\n                }\n\n            }\n\n        }\n\n        if(!found){\n\n            fprintf(stderr, \"Specified program id not found\\n\");\n\n            ffmpeg_exit(1);\n\n        }\n\n        opt_programid=0;\n\n    }\n\n\n\n    if (loop_input) {\n\n        av_log(NULL, AV_LOG_WARNING, \"-loop_input is deprecated, use -loop 1\\n\");\n\n        ic->loop_input = loop_input;\n\n    }\n\n\n\n    /* Set AVCodecContext options for avformat_find_stream_info */\n\n    opts = setup_find_stream_info_opts(ic, codec_opts);\n\n    orig_nb_streams = ic->nb_streams;\n\n\n\n    /* If not enough info to get the stream parameters, we decode the\n\n       first frames to get it. (used in mpeg case for example) */\n\n    ret = avformat_find_stream_info(ic, opts);\n\n    if (ret < 0 && verbose >= 0) {\n\n        fprintf(stderr, \"%s: could not find codec parameters\\n\", filename);\n\n        av_close_input_file(ic);\n\n        ffmpeg_exit(1);\n\n    }\n\n\n\n    timestamp = start_time;\n\n    /* add the stream start time */\n\n    if (ic->start_time != AV_NOPTS_VALUE)\n\n        timestamp += ic->start_time;\n\n\n\n    /* if seeking requested, we execute it */\n\n    if (start_time != 0) {\n\n        ret = av_seek_frame(ic, -1, timestamp, AVSEEK_FLAG_BACKWARD);\n\n        if (ret < 0) {\n\n            fprintf(stderr, \"%s: could not seek to position %0.3f\\n\",\n\n                    filename, (double)timestamp / AV_TIME_BASE);\n\n        }\n\n        /* reset seek info */\n\n        start_time = 0;\n\n    }\n\n\n\n    /* update the current parameters so that they match the one of the input stream */\n\n    for(i=0;i<ic->nb_streams;i++) {\n\n        AVStream *st = ic->streams[i];\n\n        AVCodecContext *dec = st->codec;\n\n        InputStream *ist;\n\n\n\n        dec->thread_count = thread_count;\n\n\n\n        input_streams = grow_array(input_streams, sizeof(*input_streams), &nb_input_streams, nb_input_streams + 1);\n\n        ist = &input_streams[nb_input_streams - 1];\n\n        ist->st = st;\n\n        ist->file_index = nb_input_files;\n\n        ist->discard = 1;\n\n        ist->opts = filter_codec_opts(codec_opts, ist->st->codec->codec_id, 0);\n\n\n\n        if (i < nb_ts_scale)\n\n            ist->ts_scale = ts_scale[i];\n\n\n\n        switch (dec->codec_type) {\n\n        case AVMEDIA_TYPE_AUDIO:\n\n            ist->dec = avcodec_find_decoder_by_name(audio_codec_name);\n\n            if(!ist->dec)\n\n                ist->dec = avcodec_find_decoder(dec->codec_id);\n\n            if(audio_disable)\n\n                st->discard= AVDISCARD_ALL;\n\n            break;\n\n        case AVMEDIA_TYPE_VIDEO:\n\n            ist->dec= avcodec_find_decoder_by_name(video_codec_name);\n\n            if(!ist->dec)\n\n                ist->dec = avcodec_find_decoder(dec->codec_id);\n\n            rfps      = ic->streams[i]->r_frame_rate.num;\n\n            rfps_base = ic->streams[i]->r_frame_rate.den;\n\n            if (dec->lowres) {\n\n                dec->flags |= CODEC_FLAG_EMU_EDGE;\n\n            }\n\n            if(me_threshold)\n\n                dec->debug |= FF_DEBUG_MV;\n\n\n\n            if (dec->time_base.den != rfps*dec->ticks_per_frame || dec->time_base.num != rfps_base) {\n\n\n\n                if (verbose >= 0)\n\n                    fprintf(stderr,\"\\nSeems stream %d codec frame rate differs from container frame rate: %2.2f (%d/%d) -> %2.2f (%d/%d)\\n\",\n\n                            i, (float)dec->time_base.den / dec->time_base.num, dec->time_base.den, dec->time_base.num,\n\n\n\n                    (float)rfps / rfps_base, rfps, rfps_base);\n\n            }\n\n\n\n            if(video_disable)\n\n                st->discard= AVDISCARD_ALL;\n\n            else if(video_discard)\n\n                st->discard= video_discard;\n\n            break;\n\n        case AVMEDIA_TYPE_DATA:\n\n            break;\n\n        case AVMEDIA_TYPE_SUBTITLE:\n\n            ist->dec = avcodec_find_decoder_by_name(subtitle_codec_name);\n\n            if(!ist->dec)\n\n                ist->dec = avcodec_find_decoder(dec->codec_id);\n\n            if(subtitle_disable)\n\n                st->discard = AVDISCARD_ALL;\n\n            break;\n\n        case AVMEDIA_TYPE_ATTACHMENT:\n\n        case AVMEDIA_TYPE_UNKNOWN:\n\n            break;\n\n        default:\n\n            abort();\n\n        }\n\n    }\n\n\n\n    /* dump the file content */\n\n    if (verbose >= 0)\n\n        av_dump_format(ic, nb_input_files, filename, 0);\n\n\n\n    input_files = grow_array(input_files, sizeof(*input_files), &nb_input_files, nb_input_files + 1);\n\n    input_files[nb_input_files - 1].ctx        = ic;\n\n    input_files[nb_input_files - 1].ist_index  = nb_input_streams - ic->nb_streams;\n\n    input_files[nb_input_files - 1].ts_offset  = input_ts_offset - (copy_ts ? 0 : timestamp);\n\n\n\n    top_field_first = -1;\n\n    frame_rate    = (AVRational){0, 0};\n\n    frame_pix_fmt = PIX_FMT_NONE;\n\n    frame_height = 0;\n\n    frame_width  = 0;\n\n    audio_sample_rate = 0;\n\n    audio_channels    = 0;\n\n    audio_sample_fmt  = AV_SAMPLE_FMT_NONE;\n\n    av_freep(&ts_scale);\n\n    nb_ts_scale = 0;\n\n\n\n    for (i = 0; i < orig_nb_streams; i++)\n\n        av_dict_free(&opts[i]);\n\n    av_freep(&opts);\n\n    av_freep(&video_codec_name);\n\n    av_freep(&audio_codec_name);\n\n    av_freep(&subtitle_codec_name);\n\n    uninit_opts();\n\n    init_opts();\n\n    return 0;\n\n}\n", "idx": 7925, "substitutes": {"opt": ["init", "ff", "it", "ctx", "prop", "seek", "op", "option", "cb", "temp", "w", "ref", "options", "attr", "kw", "timeout", "txt", "req", "config", "off", "tmp", "info", "nom", "oop", "env", "Opt", "bin"], "filename": ["output", "fd", "names", "jpg", "root", "prefix", "src", "null", "none", "file", "files", "buffer", "rn", "til", "wav", "ename", "ame", "n", "typ", "unc", "joined", "FN", "program", "url", "tif", "upload", "fp", "kl", "fps", "mpeg", "username", "w", "ames", "fil", "png", "nm", "brace", "ren", "nil", "txt", "video", "FIL", "final", "config", "fn", "Filename", "dir", "rather", "f", "aka", "dest", "length", "kj", "format", "source", "text", "other", "title", "bas", "name", "json", "path"], "ic": ["ico", "dc", "ci", "ct", "ican", "it", "ics", "tic", "c", "voc", "pc", "eric", "bc", "anc", "aic", "ik", "fc", "ip", "ric", "ec", "wic", "mic", "pi", "cc", "rc", " nic", "icing", "icc", "nic", " ac", "oc", "ici", "ac", "vc", "pic", "onic", "mc", "ia", "iac", "lic", "cu", "IC", "tc"], "file_iformat": ["file_ivati", "file_iformait", "file_ikkat", "file_instiat", "file_icolata", "file_ikkiat", "file_iformata", "file_icolati", "file_icolait", "file_iformats", "file_iformiat", "file_instats", "file_instat", "file_ikkats", "file_mediiat", "file_ivait", "file_ikkata", "file_mediata", "file_instata", "file_ikkati", "file_ivat", "file_ikkait", "file_iformati", "file_ivata", "file_mediat", "file_icolat", "file_mediats"], "err": ["ev", "race", "error", "conf", "fee", "er", "order", "stat", "len", "cb", "usr", "r", "str", "fer", "proc", "rr", "attr", "code", "iter", "cr", "req", "resp", "test", "e", "Error", "coord"], "i": ["ij", "b", "it", "im", "c", "ib", "ik", "mi", "ip", "si", "g", "n", "t", "pi", "r", "ir", "m", "I", "iat", "f", "fi", "io", "iu", "ii", "l"], "ret": ["result", "gc", "mem", "back", "rel", "nt", "progress", "cmd", "len", "val", "na", "alt", "reset", "fun", "status", "re", "RET", "jp", "Ret", "conv", "res", "fd", "rm", "elt", "flag"], "rfps": ["ffps", "fbps", "rrates", "rbps", "rframes", "frates", "mrates", "mframes", "mfps", " rrates", " rbps", "fframes", "mbps", " rframes"], "rfps_base": ["rfps_offset", "rhz_base", "rfps_scale", "rhz_scale", "rfps_info", "rhz_info", "rhz_offset"], "timestamp": ["frametime", "timeestamp", "framtime", "framestamp", "timeeline", "frameline", "imeline", "timtime", "imetime", "imtime", "imestamp", "timeline", "timetime", "timeetime"], "buf": ["bag", "bytes", "uf", "empty", "bed", "cb", "queue", "kl", "txt", "req", "foo", "fb", "pause", "batch", "tmp", "aka", "cur", "loop", "filter", "boxes", "read", "buff", "mem", "uffy", "str", "code", "rb", "stream", "pool", "desc", "conv", "text", "vec", "db", "ctx", "bc", "Buffer", "msg", "seq", "progress", "prop", "var", "tr", "usr", "bar", "pkg", "Buff", "kw", "mb", "bs", "cv", "result", "ff", "window", "pb", "br", "box", "buffer", "raw", "wav", "cmd", "bp", "data", "bt", "func", "proc", "mu", "cap", "block", "tx", "img", "doc", "cache", "count", "obj", "arr"], "opts": ["opcs", "veopt", "optopt", "vetions", "opopt", "vets", " opopt", "options", "opttions", "optcs", "optts", "vecs", " opcs", " options"], "orig_nb_streams": ["orig_nb2pathd", "orig_nb_recers", "orig_nb_reamers", "orig_nb2streams", "orig_nb_reams", "orig_nb_streamers", "orig_nb2streamls", "orig_nb_recs", "orig_nb2pathls", "orig_nb_reamls", "orig_nb2streamers", "orig_nb_pathers", "orig_nb_paths", "orig_nb2paths", "orig_nb_recd", "orig_nb_pathls", "orig_nb2streamd", "orig_nb_reamd", "orig_nb2pathers", "orig_nb_streamd", "orig_nb_recls", "orig_nb_streamls", "orig_nb_pathd"]}}
{"project": "qemu", "commit_id": "3393bc105d58e1f4a27d9a8e7062da9cef260cc3", "target": 0, "func": "static int usb_hub_handle_control(USBDevice *dev, USBPacket *p,\n\n               int request, int value, int index, int length, uint8_t *data)\n\n{\n\n    USBHubState *s = (USBHubState *)dev;\n\n    int ret;\n\n\n\n    ret = usb_desc_handle_control(dev, p, request, value, index, length, data);\n\n    if (ret >= 0) {\n\n        return ret;\n\n    }\n\n\n\n    switch(request) {\n\n    case EndpointOutRequest | USB_REQ_CLEAR_FEATURE:\n\n        if (value == 0 && index != 0x81) { /* clear ep halt */\n\n            goto fail;\n\n        }\n\n        ret = 0;\n\n        break;\n\n    case DeviceRequest | USB_REQ_GET_INTERFACE:\n\n        data[0] = 0;\n\n        ret = 1;\n\n        break;\n\n    case DeviceOutRequest | USB_REQ_SET_INTERFACE:\n\n        ret = 0;\n\n        break;\n\n        /* usb specific requests */\n\n    case GetHubStatus:\n\n        data[0] = 0;\n\n        data[1] = 0;\n\n        data[2] = 0;\n\n        data[3] = 0;\n\n        ret = 4;\n\n        break;\n\n    case GetPortStatus:\n\n        {\n\n            unsigned int n = index - 1;\n\n            USBHubPort *port;\n\n            if (n >= NUM_PORTS) {\n\n                goto fail;\n\n            }\n\n            port = &s->ports[n];\n\n            data[0] = port->wPortStatus;\n\n            data[1] = port->wPortStatus >> 8;\n\n            data[2] = port->wPortChange;\n\n            data[3] = port->wPortChange >> 8;\n\n            ret = 4;\n\n        }\n\n        break;\n\n    case SetHubFeature:\n\n    case ClearHubFeature:\n\n        if (value == 0 || value == 1) {\n\n        } else {\n\n            goto fail;\n\n        }\n\n        ret = 0;\n\n        break;\n\n    case SetPortFeature:\n\n        {\n\n            unsigned int n = index - 1;\n\n            USBHubPort *port;\n\n            USBDevice *dev;\n\n            if (n >= NUM_PORTS) {\n\n                goto fail;\n\n            }\n\n            port = &s->ports[n];\n\n            dev = port->port.dev;\n\n            switch(value) {\n\n            case PORT_SUSPEND:\n\n                port->wPortStatus |= PORT_STAT_SUSPEND;\n\n                break;\n\n            case PORT_RESET:\n\n                if (dev) {\n\n                    usb_send_msg(dev, USB_MSG_RESET);\n\n                    port->wPortChange |= PORT_STAT_C_RESET;\n\n                    /* set enable bit */\n\n                    port->wPortStatus |= PORT_STAT_ENABLE;\n\n                }\n\n                break;\n\n            case PORT_POWER:\n\n                break;\n\n            default:\n\n                goto fail;\n\n            }\n\n            ret = 0;\n\n        }\n\n        break;\n\n    case ClearPortFeature:\n\n        {\n\n            unsigned int n = index - 1;\n\n            USBHubPort *port;\n\n\n\n            if (n >= NUM_PORTS) {\n\n                goto fail;\n\n            }\n\n            port = &s->ports[n];\n\n            switch(value) {\n\n            case PORT_ENABLE:\n\n                port->wPortStatus &= ~PORT_STAT_ENABLE;\n\n                break;\n\n            case PORT_C_ENABLE:\n\n                port->wPortChange &= ~PORT_STAT_C_ENABLE;\n\n                break;\n\n            case PORT_SUSPEND:\n\n                port->wPortStatus &= ~PORT_STAT_SUSPEND;\n\n                break;\n\n            case PORT_C_SUSPEND:\n\n                port->wPortChange &= ~PORT_STAT_C_SUSPEND;\n\n                break;\n\n            case PORT_C_CONNECTION:\n\n                port->wPortChange &= ~PORT_STAT_C_CONNECTION;\n\n                break;\n\n            case PORT_C_OVERCURRENT:\n\n                port->wPortChange &= ~PORT_STAT_C_OVERCURRENT;\n\n                break;\n\n            case PORT_C_RESET:\n\n                port->wPortChange &= ~PORT_STAT_C_RESET;\n\n                break;\n\n            default:\n\n                goto fail;\n\n            }\n\n            ret = 0;\n\n        }\n\n        break;\n\n    case GetHubDescriptor:\n\n        {\n\n            unsigned int n, limit, var_hub_size = 0;\n\n            memcpy(data, qemu_hub_hub_descriptor,\n\n                   sizeof(qemu_hub_hub_descriptor));\n\n            data[2] = NUM_PORTS;\n\n\n\n            /* fill DeviceRemovable bits */\n\n            limit = ((NUM_PORTS + 1 + 7) / 8) + 7;\n\n            for (n = 7; n < limit; n++) {\n\n                data[n] = 0x00;\n\n                var_hub_size++;\n\n            }\n\n\n\n            /* fill PortPwrCtrlMask bits */\n\n            limit = limit + ((NUM_PORTS + 7) / 8);\n\n            for (;n < limit; n++) {\n\n                data[n] = 0xff;\n\n                var_hub_size++;\n\n            }\n\n\n\n            ret = sizeof(qemu_hub_hub_descriptor) + var_hub_size;\n\n            data[0] = ret;\n\n            break;\n\n        }\n\n    default:\n\n    fail:\n\n        ret = USB_RET_STALL;\n\n        break;\n\n    }\n\n    return ret;\n\n}\n", "idx": 7936, "substitutes": {"dev": ["des", "att", "usb", "disabled", "DEV", "pro", "buf", "det", "den", " device", "d", "w", "device", "watch", "Device", "dn", "home", "pub", "test", "hid", "de", "stick", "loc", "mem", "devices", "cam", "pad", " Dev", "nt", "ve", "server", "go", "out", "normal", "v", "priv", "private", "db", "ev", "end", "any", "dep", "md", "ctx", "dem", "pt", "sd", "var", "on", "tr", "hw", "adv", "debug", "van", "dd", "serial", "tech", "development", "ver", "app", "window", "av", "sys", "buffer", "raw", "proc", "mode", "ad", "off", "stable", "doc", "obj", "gu", "wd", "Dev", "conn", "def", "develop"], "p": ["par", "q", "sp", "b", "wp", "cp", "ping", "pb", "c", "pc", "h", "pro", "pt", "d", "pa", "g", "pat", "vp", "t", "r", "pe", "w", "pkg", "ap", "v", "m", "part", "jp", "np", "f", "P", "pp", "tp", "press"], "request": ["package", "method", "service", "event", "call", "task", "access", "type", "direction", "operation", "argument", "set", "primary", "vector", "cmd", " Request", "seek", "position", "query", "push", "each", "reason", "attribute", "forward", "begin", "mode", "have", "change", "req", "common", "feature", "command", "select", "requ", "object", "report", "version", "item", "address", "message", "quest", "Request", "QUEST", "point", "param", "interface", "variable", "create", "reference", "condition"], "value": ["content", "ceive", "result", "function", "expression", "event", "false", "end", "type", "direction", "values", "set", "state", "description", "ve", "vector", "buffer", "valid", "raw", "see", "flow", "wise", "document", "val", "ay", "total", "key", "server", "input", "number", "position", "initial", "unit", "scale", "attribute", "password", "ue", "timeout", "max", "change", "v", "feature", "status", "new", "command", "action", "version", "response", "Value", "hello", "rule", "address", "message", "allow", "VAL", "test", "size", "variable", "format", "VALUE", "name", "condition"], "index": ["condition", "error", "instance", "end", "note", "operation", "offset", "i", "find", "set", "vector", "path", "si", "order", "connection", "location", "seek", "len", "document", "val", "ind", "row", "zero", "key", "context", "input", "number", "position", "connect", "id", "pos", "attribute", "reason", "ion", "device", "start", "timeout", "code", "num", "slot", "command", "Index", "action", "response", "scan", "axis", "address", "message", "count", "point", "interface", "x", "object"], "length": ["padding", "end", "type", "join", "offset", "buffer", "duration", "partial", "len", "lib", "full", "t", "total", "available", "Length", "ENGTH", "en", "ength", "load", "ptr", "enth", "capacity", "count", "idth", "address", "shape", "size", "ize", "time", " len", "l", "sequence"], "data": ["bytes", "des", "dat", "att", "step", "rel", "buf", "last", "valid", "mid", "d", "add", "lu", "t", "w", "trace", "device", "api", "batch", "filter", "size", "di", "params", "da", "bin", "output", "next", "results", "mem", "join", "apps", "ta", "dt", "rew", "zero", "button", "Data", "str", "reason", "out", "m", "done", "info", "td", "text", "a", "json", "ops", "aw", "it", "ns", "at", "actions", "prop", "no", "len", "ata", "r", "to", "attr", "dd", "final", "response", "DATA", "all", "sp", "window", "then", "set", " Data", "buffer", "raw", "table", "details", " DATA", "ds", "list", "mu", "args", "block", "fa", "off", "tx", "cache", "obj", "format", "def"], "s": ["rs", "gs", "ses", "b", "ns", "c", "h", "sam", "sys", "set", "state", "cs", "self", "os", "d", "ps", "g", "ts", "settings", "ds", "is", "sd", "ports", "t", "pers", "js", "w", "syn", "sv", "sb", "services", "v", "m", "spec", "ss", "bs", "serv", "sq", "fs", "S", "sts", "j", "a"], "ret": ["gc", "att", "note", "det", "rel", "last", "ts", "url", "alt", "t", "txt", "reset", "cat", "j", "detail", "elt", "gt", "mem", "ter", "nt", "sort", "dt", " Ret", "out", "summary", "v", "report", "db", "it", "end", "back", "ry", "prop", "mt", "len", "val", "tr", "r", "rev", "rem", "rest", "try", "rt", "mb", "final", "re", "ft", "ll", "res", " RET", "deg", "result", "get", "ext", "cmd", "details", "rets", "tn", "full", "err", "ref", "fun", "status", "resp", "print", "RET", "Ret", "obj", "arg", "format", "def"], "port": ["policy", "pid", "way", "po", "eport", "pan", "pro", "state", "file", "Port", "ports", "queue", "key", "t", "pi", "trace", "PORT", "device", "bridge", "test", "player", "pport", "service", "page", "ve", "seat", "ported", "server", "go", "pipe", "proxy", "timeout", "v", "be", " sport", "project", "mit", "per", "report", "version", "serv", "pool", "pp", "peer", "export", "ort", "it", "gp", "end", "channel", "type", "pc", "phy", "pt", "plugin", "prop", "connection", "var", "tr", "import", "pkg", "host", "boat", "select", "net", "mate", "form", "cp", "ping", "pod", "client", "profile", "table", "vp", "row", "pr", "tip", "handle", "component", "feature", "status", "driver", "ptr", "member", "manager", "point", "public", "termin", "pin", "interface", "def"], "n": ["all", "names", "mn", "ln", "ns", "any", "c", "note", "nr", "i", "ation", "nor", "nt", "nn", "d", "g", "gn", "nc", "tn", "on", "un", "na", "o", "ner", "t", "r", "N", "number", "an", "ion", "ng", "nm", "en", "num", "v", "cn", "ren", "m", "new", "fn", "dn", "nb", "sn", "nan", "np", "f", "size", "ex", "j", "z", "x", "ne", "l"]}}
{"project": "FFmpeg", "commit_id": "7684a36113fa12c88ba80b5498f05849a6b58632", "target": 0, "func": "static int mxf_write_packet(AVFormatContext *s, AVPacket *pkt)\n\n{\n\n    MXFContext *mxf = s->priv_data;\n\n    AVIOContext *pb = s->pb;\n\n    AVStream *st = s->streams[pkt->stream_index];\n\n    MXFStreamContext *sc = st->priv_data;\n\n    MXFIndexEntry ie = {0};\n\n\n\n    if (!mxf->edit_unit_byte_count && !(mxf->edit_units_count % EDIT_UNITS_PER_BODY)) {\n\n        mxf->index_entries = av_realloc(mxf->index_entries,\n\n            (mxf->edit_units_count + EDIT_UNITS_PER_BODY)*sizeof(*mxf->index_entries));\n\n        if (!mxf->index_entries) {\n\n            av_log(s, AV_LOG_ERROR, \"could not allocate index entries\\n\");\n\n            return -1;\n\n        }\n\n    }\n\n\n\n    if (st->codec->codec_id == AV_CODEC_ID_MPEG2VIDEO) {\n\n        if (!mxf_parse_mpeg2_frame(s, st, pkt, &ie)) {\n\n            av_log(s, AV_LOG_ERROR, \"could not get mpeg2 profile and level\\n\");\n\n            return -1;\n\n        }\n\n    }\n\n\n\n    if (!mxf->header_written) {\n\n        if (mxf->edit_unit_byte_count) {\n\n            mxf_write_partition(s, 1, 2, header_open_partition_key, 1);\n\n            mxf_write_klv_fill(s);\n\n            mxf_write_index_table_segment(s);\n\n        } else {\n\n            mxf_write_partition(s, 0, 0, header_open_partition_key, 1);\n\n        }\n\n        mxf->header_written = 1;\n\n    }\n\n\n\n    if (st->index == 0) {\n\n        if (!mxf->edit_unit_byte_count &&\n\n            (!mxf->edit_units_count || mxf->edit_units_count > EDIT_UNITS_PER_BODY) &&\n\n            !(ie.flags & 0x33)) { // I frame, Gop start\n\n            mxf_write_klv_fill(s);\n\n            mxf_write_partition(s, 1, 2, body_partition_key, 0);\n\n\n\n            mxf_write_klv_fill(s);\n\n            mxf_write_index_table_segment(s);\n\n        }\n\n\n\n        mxf_write_klv_fill(s);\n\n        mxf_write_system_item(s);\n\n\n\n        if (!mxf->edit_unit_byte_count) {\n\n            mxf->index_entries[mxf->edit_units_count].offset = mxf->body_offset;\n\n            mxf->index_entries[mxf->edit_units_count].flags = ie.flags;\n\n            mxf->index_entries[mxf->edit_units_count].temporal_ref = ie.temporal_ref;\n\n            mxf->body_offset += KAG_SIZE; // size of system element\n\n        }\n\n        mxf->edit_units_count++;\n\n    } else if (!mxf->edit_unit_byte_count && st->index == 1) {\n\n        mxf->index_entries[mxf->edit_units_count-1].slice_offset =\n\n            mxf->body_offset - mxf->index_entries[mxf->edit_units_count-1].offset;\n\n    }\n\n\n\n    mxf_write_klv_fill(s);\n\n    avio_write(pb, sc->track_essence_element_key, 16); // write key\n\n    if (s->oformat == &ff_mxf_d10_muxer) {\n\n        if (st->codec->codec_type == AVMEDIA_TYPE_VIDEO)\n\n            mxf_write_d10_video_packet(s, st, pkt);\n\n        else\n\n            mxf_write_d10_audio_packet(s, st, pkt);\n\n    } else {\n\n        klv_encode_ber4_length(pb, pkt->size); // write length\n\n        avio_write(pb, pkt->data, pkt->size);\n\n        mxf->body_offset += 16+4+pkt->size + klv_fill_size(16+4+pkt->size);\n\n    }\n\n\n\n    avio_flush(pb);\n\n\n\n    return 0;\n\n}\n", "idx": 7967, "substitutes": {"s": ["as", "rs", "gs", "ses", "sp", "b", "sg", "ns", "conf", "c", "its", "ctx", "ats", "h", "acs", "i", "sys", "qs", "cs", "comm", "os", "p", "g", "ms", "ps", "n", "is", "ts", "ds", "t", "es", "js", "w", "ins", "ast", "ls", "sb", "xs", "scl", "v", "ims", "stats", "status", "m", "spec", "hs", "a", "ss", "bs", "south", "vs", "local", "sq", "ans", "fs", "sql", "us", "S", "sts", "changes", "z", "sports", "aws", "l"], "pkt": ["ppet", "wpKT", "dct", " pct", "wpkt", "Pct", "Pet", "cct", "Packet", "wpacket", "dKT", "pKT", "cet", "cacket", "pet", "packet", "ppkt", "dkt", "ckt", "pct", "ppacket", "dacket", "wpct", "ppct", " pet", " pKT", " packet", "Pkt"], "mxf": ["vxc", "Mxc", "rmfw", "mxff", "mxe", "modulecf", "Mxd", "mfo", "imcf", " mxd", "hcf", "imxf", " meph", "gmcf", " mfi", "vfe", " mlf", "mcf", " mfif", "Mfe", "adexff", "adexc", "modulefi", "amlf", " mfo", "adexf", "Mcf", "cmlf", " mfx", " mfe", " mxe", "vmoxy", "mfif", "imprintf", "vmxf", "cmxf", "mfx", "meanxff", "rmxf", "mfi", "amoxy", "Mfw", "imxff", "mffe", "imxc", "gxf", "meph", "gmfo", " mxff", "meanffe", "gmfe", "amxf", " mcf", " mxc", "hfe", "moxy", "cmcf", "hfo", "vcf", "vmcf", "gmfi", "rmxc", " mfw", "gmxf", " moxy", "rmcf", "meanxf", "gxe", "tmeph", "imlf", "vmfe", "adefif", "amcf", "tmxf", "hxf", "meanfx", "mlf", "meanprintf", "rmxe", "vxf", "mprintf", "imfx", "cmffe", "rmeph", "mfe", "mxd", " mffe", "modulexf", "cmfx", "Mxff", "Mxe", "mfw", "gxd", "cmxff", "tmxc", "tmxff", "modulefe", "Mxf", "imfif", "gcf", "tmcf", "amfe", "meancf", " mprintf", "amxc", "amxff", "mxc"], "pb": ["db", "pid", "dc", "sp", "uf", "b", "bj", "gp", "cp", "pc", "ctx", "buf", "ob", "p", "ps", "pa", "bp", "typ", "vp", "cb", "pl", "wb", "fp", "phys", "ub", "pg", "pkg", "proc", "sb", "pr", "lp", "rb", "bs", "cv", "jp", "np", "pp", "PB", "tk", "tp", "tc", "mp"], "st": ["so", "sp", "sw", "src", "it", "est", "c", "ctx", "kt", "stage", "ra", "pt", "nd", "nt", "store", "te", "stru", "p", "mt", "stat", "ts", "std", "tr", "sty", "t", "se", "str", "th", "ast", "sv", "sm", "sb", "start", "v", "rt", "sl", "stream", "ss", "sn", "tx", "ist", "bs", "ST", "obj", "ft", "ste", "td", "sts", "sta", "z", "ost", "St", "l"], "sc": ["dc", "sp", "esc", "sw", "pc", "ctx", "cl", "bc", "anc", "cs", "co", "ec", "cc", "rc", "sv", "soc", "scl", "cr", "uc", "ac", "SC", "ss", "sci", "cv", "ca", "sq", "mc", "tc"], "edit_units_count": ["edit_units\u05bcchild", "edit_unit_multi", "edit_units_carry", "edit_units\u05bccarry", "edit_units_multi", "edit_units_length", "edit_unitsingcount", "edit_unitsingcurrent", "edit_unit_count", "edit_unit_carry", "edit_units_nb", "edit_unitsitycount", "edit_units_current", "edit_units_child", "edit_unit_nb", "edit_unitsingcounter", "edit_unit_length", "edit_unitsityhandle", "edit_unit_current", "edit_unitsitymulti", "edit_unit_counter", "edit_units_handle", "edit_units\u05bccount", "edit_unit_child", "edit_unit_handle", "edit_units_counter"]}}
{"project": "qemu", "commit_id": "3ad493fc5ea38c005670adc5933058a28ccabdd4", "target": 0, "func": "int cpu_arm_handle_mmu_fault (CPUState *env, target_ulong address,\n\n                              int access_type, int mmu_idx, int is_softmmu)\n\n{\n\n    uint32_t phys_addr;\n\n    target_ulong page_size;\n\n    int prot;\n\n    int ret, is_user;\n\n\n\n    is_user = mmu_idx == MMU_USER_IDX;\n\n    ret = get_phys_addr(env, address, access_type, is_user, &phys_addr, &prot,\n\n                        &page_size);\n\n    if (ret == 0) {\n\n        /* Map a single [sub]page.  */\n\n        phys_addr &= ~(uint32_t)0x3ff;\n\n        address &= ~(uint32_t)0x3ff;\n\n        tlb_set_page (env, address, phys_addr, prot | PAGE_EXEC, mmu_idx,\n\n                      page_size);\n\n        return 0;\n\n    }\n\n\n\n    if (access_type == 2) {\n\n        env->cp15.c5_insn = ret;\n\n        env->cp15.c6_insn = address;\n\n        env->exception_index = EXCP_PREFETCH_ABORT;\n\n    } else {\n\n        env->cp15.c5_data = ret;\n\n        if (access_type == 1 && arm_feature(env, ARM_FEATURE_V6))\n\n            env->cp15.c5_data |= (1 << 11);\n\n        env->cp15.c6_data = address;\n\n        env->exception_index = EXCP_DATA_ABORT;\n\n    }\n\n    return 1;\n\n}\n", "idx": 7972, "substitutes": {"env": ["uv", "outer", "esc", "ei", "event", "conf", "see", "ec", "enter", "dev", "cb", "environment", "queue", "gear", "query", "sb", "en", "ah", "txt", "worker", "dn", "estate", "message", "operator", "esm", "forge", "ve", "er", "editor", "context", "eh", "server", "rb", "code", "v", "command", "vs", "desc", "oe", "shell", "db", "ev", "et", "console", "kernel", "end", "ctx", "em", "era", "msg", "viron", "hw", "dh", " environment", "sv", "nv", "answer", "response", "cv", "vm", "engine", "init", "chart", "window", "ov", "here", "buffer", "erd", "te", "actor", "esi", "cmd", "inv", "vp", "ew", "eng", "ner", "err", "Environment", "commit", "ef", "ptr", "equ", "doc", "ee", "manager", "vt", "obj", "e", "conn"], "address": ["service", "event", "instance", "region", "target", "type", "reply", "argument", "description", "execute", "buffer", "ip", "table", "addr", "order", "domain", "add", "location", "enter", "network", "context", "index", "account", "pointer", "history", "data", "number", "position", "record", "resource", "attribute", "id", "route", "mac", "password", "device", "ad", "memory", "host", "Address", "command", "ash", "array", "port", "block", "object", "comment", "action", "phrase", "ptr", "request", "alias", "dress", "message", "email", "search", "eth", "point", "length", "holder", "interface", "ace", "adr", "a", "reference", "name", "path"], "access_type": ["auth_operator", "authityype", " access_Type", "accessureType", "access___type", "index___type", " access_spec", "accessitytype", "index___Type", "accessaccesspolicy", "access___Type", "access_policy", "authitytype", "accessaccesstype", " access_id", "access___policy", "access___typ", "accessityoperator", "accessurelevel", "index___policy", "access_typ", "accessityType", " access_level", "access_kind", "auth_Type", "index_type", "accessityype", "accessaccesstyp", "authityType", "index_policy", "accessuretype", "access_spec", " access_kind", "index_typ", "access___spec", "access_operator", "index_Type", "access_id", "access_level", "authityoperator", "accessaccessType", "access_ype", "access___id", "access_Type", "auth_type", "accessurekind", "index___typ", "auth_ype"], "mmu_idx": ["mmu_idn", "mmu_idexc", "mmu_idX", "mmu_Idxc", "mmu__idx", "mmu_Idxf", "mmu_ridn", "mmu_idey", "mmu_idexf", "mmu_idxc", "mmu__idxf", "mmu_Idx", "mmu_IdX", "mmu__idn", "mmu_idxf", "mmu_ridX", "mmu_idy", "mmu__idxc", "mmu_idex", "mmu_ridx", "mmu_Idy", "mmu_ridxc", "mmu_iden", "mmu_Idn"], "is_softmmu": ["is_softmaux", "is_hardmmcu", "is_softmmux", "is_softumux", "is_softmemu", "is_softmmcu", "is_softumcu", "is_softumus", "is_softmacu", "is_softmemcu", "is_hardmemcu", "is_softmemus", "is_softmmus", "is_hardmemus", "is_hardmemux", "is_hardmmus", "is_hardmemu", "is_softmemux", "is_softmau", "is_hardmmux", "is_softumu", "is_hardmmu", "is_softmaus"], "phys_addr": ["phys_add", "physical_ref", "phys_ptr", "phy_addr", "phys_ref", "phys__ref", "phys_src", "physical_ptr", " phys_add", "physical_addr", "physongref", " phys_map", " phys__ref", "phys_map", "phys__conn", "phys_attr", " phys__addr", "phys_address", "phy_info", " phys_ref", " phys__map", "physongaddr", " phys_conn", "phys__map", "phys_conn", " phys_src", "phy_attr", "phys_info", "phy_address", " phys__conn", "physical_address", "physongmap", "phys__addr", "physongconn"], "page_size": ["page2height", "pageLspeed", "page_count", "page_length", "pagemodcount", "page2size", "pool_state", "page_index", "window_length", "pageingSIZE", "page_speed", "page_height", "pool_speed", "pageLstate", "pool_size", "pageingsize", "pool_SIZE", " page_height", "window_SIZE", "pageingindex", "pagemodsize", "pageLSIZE", "pageLsize", "page2count", " page_count", "window_size", "page_SIZE", "page_state", "window_index", "pageinglength", "pagemodheight"], "prot": ["policy", "method", "mult", "rot", "prefix", "gap", "type", "pc", "phy", "pro", "virtual", "kind", "ht", "seq", "prop", "pat", "ext", "chron", "stat", "cmd", "typ", "platform", "tif", "phys", "crypt", "ocol", "col", "pos", "pkg", "password", "Prot", " PROT", "port", "status", "version", "pattern", "ptr", "tf", "jp", "eth", "tech", "size", "net", "format", "tp"], "ret": ["gt", "result", "ert", "encrypted", "mem", "att", "Return", "reply", "back", "cont", "ter", "det", "nt", "vector", "cor", "addr", "cmd", "mt", "rets", "len", "val", "aux", "tr", "t", "alt", "err", "bit", "ref", "inter", "rev", "rem", "pert", "out", "try", "txt", "reset", "rt", "fun", "resp", "re", "reg", "ptr", "lit", "print", "RET", "response", "jp", "Ret", "eth", "ft", "arg", "res", "ne", "deg", "def", "rm", "elt"], "is_user": ["is__user", "isThedevice", "is_device", "is___User", "is_username", " is_username", "is__User", "is___user", " is_User", " is_usr", "isTheUser", "isTheuser", "is___usr", "is_User", " is_device", "is__username", "is_usr"]}}
{"project": "FFmpeg", "commit_id": "082cf97106e2e94a969877d4f8c05c1e526acf54", "target": 0, "func": "static inline int get_chroma_qp(H264Context *h, int t, int qscale){\n\n    return h->pps.chroma_qp_table[t][qscale];\n\n}\n", "idx": 7977, "substitutes": {"h": ["ph", "q", "b", "mem", "c", "ctx", "i", "comm", "oh", "ht", "bh", "p", "g", "d", "n", "context", "o", "hw", "dh", "w", "cc", "k", "v", "ah", "host", "sh", "m", "ch", "hs", "ac", "he", "ih", "f", "obj", "hm", "pp", "in", "j", "H", "l", "hp"], "t": ["ty", "q", "ct", "task", "it", "type", "c", "i", "T", "pt", "ta", "at", "te", "dt", "p", "d", "n", "typ", "ts", "tr", "wt", "str", "k", "ti", "s", "tip", "rt", "m", "f", "vt", "qt", "time", "td", "j", "a", "tp", "title", "l", "tt", "tc"], "qscale": [" Qwarn", "chcale", "chscale", "qualscale", " Qshape", "dqstatus", "qstatus", "qualwarn", " qScale", "psc", "chstatus", "pscale", "qsc", "qcale", "qualScale", " qshape", "qshape", "dqscale", " QScale", " qwarn", "chsc", "dqsc", "dqcale", "qualshape", " Qscale", "pcale", "qwarn", "pstatus", "qScale"]}}
{"project": "FFmpeg", "commit_id": "fd92dafaff8844b5fedf94679b93d953939a7f7b", "target": 0, "func": "static int binkb_decode_plane(BinkContext *c, AVFrame *frame, BitstreamContext *bc,\n\n                              int plane_idx, int is_key, int is_chroma)\n\n{\n\n    int blk, ret;\n\n    int i, j, bx, by;\n\n    uint8_t *dst, *ref, *ref_start, *ref_end;\n\n    int v, col[2];\n\n    const uint8_t *scan;\n\n    int xoff, yoff;\n\n    LOCAL_ALIGNED_16(int16_t, block, [64]);\n\n    LOCAL_ALIGNED_16(int32_t, dctblock, [64]);\n\n    int coordmap[64];\n\n    int ybias = is_key ? -15 : 0;\n\n    int qp;\n\n\n\n    const int stride = frame->linesize[plane_idx];\n\n    int bw = is_chroma ? (c->avctx->width  + 15) >> 4 : (c->avctx->width  + 7) >> 3;\n\n    int bh = is_chroma ? (c->avctx->height + 15) >> 4 : (c->avctx->height + 7) >> 3;\n\n\n\n    binkb_init_bundles(c);\n\n    ref_start = frame->data[plane_idx];\n\n    ref_end   = frame->data[plane_idx] + (bh * frame->linesize[plane_idx] + bw) * 8;\n\n\n\n    for (i = 0; i < 64; i++)\n\n        coordmap[i] = (i & 7) + (i >> 3) * stride;\n\n\n\n    for (by = 0; by < bh; by++) {\n\n        for (i = 0; i < BINKB_NB_SRC; i++) {\n\n            if ((ret = binkb_read_bundle(c, bc, i)) < 0)\n\n                return ret;\n\n        }\n\n\n\n        dst  = frame->data[plane_idx]  + 8*by*stride;\n\n        for (bx = 0; bx < bw; bx++, dst += 8) {\n\n            blk = binkb_get_value(c, BINKB_SRC_BLOCK_TYPES);\n\n            switch (blk) {\n\n            case 0:\n\n                break;\n\n            case 1:\n\n                scan = bink_patterns[bitstream_read(bc, 4)];\n\n                i = 0;\n\n                do {\n\n                    int mode = bitstream_read_bit(bc);\n\n                    int run  = bitstream_read(bc, binkb_runbits[i]) + 1;\n\n\n\n                    i += run;\n\n                    if (i > 64) {\n\n                        av_log(c->avctx, AV_LOG_ERROR, \"Run went out of bounds\\n\");\n\n                        return AVERROR_INVALIDDATA;\n\n                    }\n\n                    if (mode) {\n\n                        v = binkb_get_value(c, BINKB_SRC_COLORS);\n\n                        for (j = 0; j < run; j++)\n\n                            dst[coordmap[*scan++]] = v;\n\n                    } else {\n\n                        for (j = 0; j < run; j++)\n\n                            dst[coordmap[*scan++]] = binkb_get_value(c, BINKB_SRC_COLORS);\n\n                    }\n\n                } while (i < 63);\n\n                if (i == 63)\n\n                    dst[coordmap[*scan++]] = binkb_get_value(c, BINKB_SRC_COLORS);\n\n                break;\n\n            case 2:\n\n                memset(dctblock, 0, sizeof(*dctblock) * 64);\n\n                dctblock[0] = binkb_get_value(c, BINKB_SRC_INTRA_DC);\n\n                qp = binkb_get_value(c, BINKB_SRC_INTRA_Q);\n\n                read_dct_coeffs(bc, dctblock, bink_scan, binkb_intra_quant, qp);\n\n                c->binkdsp.idct_put(dst, stride, dctblock);\n\n                break;\n\n            case 3:\n\n                xoff = binkb_get_value(c, BINKB_SRC_X_OFF);\n\n                yoff = binkb_get_value(c, BINKB_SRC_Y_OFF) + ybias;\n\n                ref = dst + xoff + yoff * stride;\n\n                if (ref < ref_start || ref + 8*stride > ref_end) {\n\n                    av_log(c->avctx, AV_LOG_WARNING, \"Reference block is out of bounds\\n\");\n\n                } else if (ref + 8*stride < dst || ref >= dst + 8*stride) {\n\n                    c->hdsp.put_pixels_tab[1][0](dst, ref, stride, 8);\n\n                } else {\n\n                    put_pixels8x8_overlapped(dst, ref, stride);\n\n                }\n\n                c->bdsp.clear_block(block);\n\n                v = binkb_get_value(c, BINKB_SRC_INTER_COEFS);\n\n                read_residue(bc, block, v);\n\n                c->binkdsp.add_pixels8(dst, block, stride);\n\n                break;\n\n            case 4:\n\n                xoff = binkb_get_value(c, BINKB_SRC_X_OFF);\n\n                yoff = binkb_get_value(c, BINKB_SRC_Y_OFF) + ybias;\n\n                ref = dst + xoff + yoff * stride;\n\n                if (ref < ref_start || ref + 8 * stride > ref_end) {\n\n                    av_log(c->avctx, AV_LOG_WARNING, \"Reference block is out of bounds\\n\");\n\n                } else if (ref + 8*stride < dst || ref >= dst + 8*stride) {\n\n                    c->hdsp.put_pixels_tab[1][0](dst, ref, stride, 8);\n\n                } else {\n\n                    put_pixels8x8_overlapped(dst, ref, stride);\n\n                }\n\n                memset(dctblock, 0, sizeof(*dctblock) * 64);\n\n                dctblock[0] = binkb_get_value(c, BINKB_SRC_INTER_DC);\n\n                qp = binkb_get_value(c, BINKB_SRC_INTER_Q);\n\n                read_dct_coeffs(bc, dctblock, bink_scan, binkb_inter_quant, qp);\n\n                c->binkdsp.idct_add(dst, stride, dctblock);\n\n                break;\n\n            case 5:\n\n                v = binkb_get_value(c, BINKB_SRC_COLORS);\n\n                c->bdsp.fill_block_tab[1](dst, v, stride, 8);\n\n                break;\n\n            case 6:\n\n                for (i = 0; i < 2; i++)\n\n                    col[i] = binkb_get_value(c, BINKB_SRC_COLORS);\n\n                for (i = 0; i < 8; i++) {\n\n                    v = binkb_get_value(c, BINKB_SRC_PATTERN);\n\n                    for (j = 0; j < 8; j++, v >>= 1)\n\n                        dst[i*stride + j] = col[v & 1];\n\n                }\n\n                break;\n\n            case 7:\n\n                xoff = binkb_get_value(c, BINKB_SRC_X_OFF);\n\n                yoff = binkb_get_value(c, BINKB_SRC_Y_OFF) + ybias;\n\n                ref = dst + xoff + yoff * stride;\n\n                if (ref < ref_start || ref + 8 * stride > ref_end) {\n\n                    av_log(c->avctx, AV_LOG_WARNING, \"Reference block is out of bounds\\n\");\n\n                } else if (ref + 8*stride < dst || ref >= dst + 8*stride) {\n\n                    c->hdsp.put_pixels_tab[1][0](dst, ref, stride, 8);\n\n                } else {\n\n                    put_pixels8x8_overlapped(dst, ref, stride);\n\n                }\n\n                break;\n\n            case 8:\n\n                for (i = 0; i < 8; i++)\n\n                    memcpy(dst + i*stride, c->bundle[BINKB_SRC_COLORS].cur_ptr + i*8, 8);\n\n                c->bundle[BINKB_SRC_COLORS].cur_ptr += 64;\n\n                break;\n\n            default:\n\n                av_log(c->avctx, AV_LOG_ERROR, \"Unknown block type %d\\n\", blk);\n\n                return AVERROR_INVALIDDATA;\n\n            }\n\n        }\n\n    }\n\n    if (bitstream_tell(bc) & 0x1F) // next plane data starts at 32-bit boundary\n\n        bitstream_skip(bc, 32 - (bitstream_tell(bc) & 0x1F));\n\n\n\n    return 0;\n\n}\n", "idx": 7980, "substitutes": {"c": ["content", "cf", "dc", "chain", "gc", "ci", "b", "ct", "call", "cp", "conf", "ctx", "h", "cam", "cont", "cl", "con", "cs", "sc", "cor", "fc", "p", "cm", "d", "co", "g", "n", "ec", "nc", "context", "cb", "lc", "ce", "t", "r", "cc", "w", "xc", "rc", "cn", "cr", "m", "config", "ac", "vc", "cv", "ca", "cd", "cache", "f", "mc", "abc", "e", "C", "comp", "com", "cu", "l", "tc"], "frame": ["ence", "user", "cf", "rame", "event", "function", "error", "b", "call", "chain", "window", "channel", "Frame", "fram", "framework", "iframe", "box", "page", "state", "file", "buffer", "scene", "fc", "force", "profile", "p", "flow", "zone", "rig", "frames", "picture", "context", "process", "data", "t", "movie", "range", "ce", "me", "module", "role", "code", "component", "video", "feature", "command", "block", "m", "request", "object", "close", "version", "remote", "show", "f", "core", "face", "e", "point", "fr", "image", "condition", "sequence"], "bc": ["ck", "cf", "ic", "dc", "gc", "b", "bg", "pc", "ctx", "sc", "cs", "fc", "bp", "BC", "nc", "bd", "ec", "cb", "bo", "bt", "lc", "bi", "cc", "xc", "bb", "arc", "sb", "bf", "uc", "vc", "bs", "ca", "mc", "bm", "tc", "ba"], "plane_idx": ["plane_indh", "plane_ndice", "plane_uidy", "plane_Idze", "plane_midx", "plane_idice", "plane_Idy", "plane__idp", "plane__inz", "plane_indp", "plane_idz", "plane_idexc", "plane_idX", "plane_idy", "plane_tryw", "plane_identze", "plane_ndx", "plane_idw", "plane_idex", "plane_indf", "plane_infoz", "plane_tryix", "plane_indxc", "plane_idp", "plane_uidix", "plane_idf", "plane_identice", "plane_indx", "plane_infoix", "plane_Idice", "plane__inp", "plane__inX", "plane_itz", "plane_idix", "plane__idx", "plane__idX", "plane_tryh", "plane_midz", "plane_identx", "plane_midix", "plane_idh", "plane_tryy", "plane_uidw", "plane_IDp", "plane_ndz", "plane_Idxc", "plane_tryp", "plane_itf", "plane_infof", "plane_midf", "plane_uidx", "plane_itix", "plane_Idz", "plane_itx", "plane_inX", "plane_tryf", "plane_ith", "plane_inz", "plane_inp", "plane_IDX", "plane_ndze", "plane_idze", "plane_tryx", "plane_itp", "plane_IDz", "plane_indy", "plane__inx", "plane_inx", "plane_Idx", "plane__idz", "plane_IDx", "plane_identz", "plane_idxc", "plane_infox", "plane_idey"], "is_key": ["is_row", " is_row", " is_char", "is_root", "is_char", "is__key", " is_keys", " is_root", "is__Key", "is_Key", "is_keys", " is_Key", "is__root", "is__keys"], "is_chroma": ["is_chinu", "is_archara", "is_genA", "is_romu", "is_romara", "is_chanu", "is_china", "is_chinan", "is_archA", "is_archa", "is_gena", "is_geno", "is_chinai", "is_chromo", "is_genia", "is_chromai", "is_romia", "is_romai", "is_chana", "is_romo", "is_romA", "is_chromA", "is_archo", "is_chromu", "is_chanan", "is_chanai", "is_chromara", "is_roman", "is_roma", "is_chromia", "is_chroman"], "blk": ["brtk", "BLk", "selk", "selck", "bleck", "bmk", "blak", "blek", "blck", " blj", "bmtk", "brak", "selak", "bltk", "bmak", "Blark", "blesk", "Blj", "blsk", "selj", "broark", "BLtk", "brck", "Blsk", "bmck", "brosk", "BLak", "brk", "blj", "blark", "bleark", "brock", "Blck", "Blk", "BLck", "brok", " blak", " blck", "Blak"], "ret": ["gt", "result", "mem", "it", "ber", "cont", "rel", "det", "nt", "ry", "dt", "mt", " Ret", "rets", "val", "over", "tr", "alt", "r", "err", "rev", "rem", "rest", "out", "summary", "txt", "try", "not", "rt", "reset", "resp", "re", "report", "print", "RET", "cat", "Ret", "nz", "net", "ll", "res", " RET", "tail", "def", "rm"], "i": ["ic", "ij", "ini", "chain", "ei", "ci", "b", "it", "im", "cli", "h", "oi", "gi", "mi", "qi", "ip", "li", "p", "si", "ami", "ie", "zi", "g", "n", "is", "iq", "xi", "ind", "index", "o", "ri", "hi", "bi", "pi", "r", "multi", "t", "me", "id", "ui", "ki", "k", "phi", "ir", "ti", "iter", "ix", "ai", "m", "I", "parent", "y", "\u0438", "f", "ia", "io", "sim", "iu", "info", "x", "di", "ii", "l"], "j": ["dj", "ij", "q", "jj", "job", "J", "rel", "aj", "g", "si", "n", "uj", "bi", "jc", "js", "pos", "ji", "ot", "jac", "m", "jump", "jp", "jl", "kj", "z", "lock", "json", "l"], "bx": ["lix", "blx", "dix", "blxx", "dz", "bbx", "abz", "dxe", "bixe", "abx", "nbxe", " bix", "bex", "abix", "biix", "nbix", "dbix", "lw", "bix", " bw", "biw", " bxx", "dx", "bbw", "bw", "dbz", "bz", "blex", "dbxx", "dw", "nbx", "abw", "bxx", "dbw", " bex", "dbex", "blix", "bxe", "lx", "nbw", "dbx", "bbix"], "by": ["db", "as", "user", "By", "how", "b", "it", "when", "type", "ber", "ger", "byn", "then", "br", "just", "nr", "pro", "sys", "ry", "my", "using", "os", "at", "bys", "no", "yes", "is", "with", "or", "on", "index", "range", "key", "bi", "from", "unit", "to", "ly", "each", "sv", "out", "try", "s", "that", "be", "where", "re", "ch", "reg", "browser", "serv", "stable", "bs", "y", "jit", "BY", "us", "sim", "io", "some", "via", "di", "bin"], "dst": ["diffST", "dsset", "diffnd", "bend", " dset", "vst", " dend", "Dend", "dST", "diffst", "Dnet", "dsts", "dsst", "bdset", "dbut", "vST", "Dx", " dsts", "dbnd", "dut", "dbst", "dx", "dend", "dbST", " dx", "bnet", " dest", "diffut", "Dst", "dnet", "dnd", "dsest", "bdst", "vnd", "dest", " dnet", "bdsts", "bst", "dssts", "vut", "bdest", "dset"], "ref": ["mem", "offset", "rel", "ob", "base", "val", "ind", "index", "range", "pos", "id", "rev", "rem", "ef", "re", "vis", "reg", "img", "local", "f", "rec", "Ref", "reference", "def", "loc"], "ref_start": ["ref_inter", "reference_len", "reference_st", "ref_st", "port_end", "port_start", "ref_part", "reference_start", "port_part", "reference_end", "ref_len", "port_inter"], "ref_end": ["reference_target", "ref_ended", "Ref_nd", "refdbend", "refdbtarget", "refdbstart", "refdbended", "reference_ended", "ref_target", "ref_nd", "reference_start", "reference_end", "Ref_end", "Ref_start"], "v": ["iv", "uv", "q", "b", "p", "g", "n", "vert", "var", "val", "t", "r", "sv", "k", "m", "ch", "V", "vis", "vc", "cv", "f", "vt", "conv", "l", "vec"], "col": ["rot", "ct", "cp", "channel", "con", "cor", "sect", "co", "cmd", "val", "row", "fl", "key", "pos", "Col", "fil", "num", "cell", "ch", "dir", "serv", "cat", "param", "icon", "il", "column", "def", "loc", "act"], "scan": ["read", "chain", "match", "cp", "conf", "sys", "Scan", "sc", "ann", "cor", "skip", "map", "stat", "sync", "row", "ner", "range", "scale", "query", "an", "ignore", "k", "watch", "feature", "select", "ch", "vis", "batch", "parse", "cat", "sky", "mask", "can", "filter", "search", "check", "path", "bin"], "xoff": ["exoffs", "exoffset", " xoffset", " xoffs", "dxoff", "xoffset", "dxoffs", "dxoffset", "exoff", "xoffs"], "yoff": ["yyoffset", " yoffset", "xOff", "yyoffs", " yOff", "yoffset", "yOff", "yoffs", " yoffs", "yyOff", "xoffset", "yyoff", "xoffs"], "coordmap": ["pixelmap", "pixelMap", "coordset", "xymap", "charset", "coordMap", "dimmap", " coordmaps", "charmaps", "ordmaps", "coordmaps", "charMap", "ordMap", " coordset", "dimset", "dimMap", "pixelset", "xymaps", "ordset", "pixelmaps", "charmap", "xyMap", "ordmap", " coordMap", "xyset", "dimmaps"], "qp": ["QP", "Qpc", "Qpa", " qpa", "qqp", " qpc", "qpc", "qP", "qqpc", "qqpa", " qP", "qqP", "qpa", "Qp"]}}
{"project": "qemu", "commit_id": "f8c88bbcda76d5674e4bb125471371b41d330df8", "target": 1, "func": "static int get_cpsr(QEMUFile *f, void *opaque, size_t size)\n\n{\n\n    ARMCPU *cpu = opaque;\n\n    CPUARMState *env = &cpu->env;\n\n    uint32_t val = qemu_get_be32(f);\n\n\n\n    env->aarch64 = ((val & PSTATE_nRW) == 0);\n\n\n\n    if (is_a64(env)) {\n\n        pstate_write(env, val);\n\n        return 0;\n\n    }\n\n\n\n    /* Avoid mode switch when restoring CPSR */\n\n    env->uncached_cpsr = val & CPSR_M;\n\n    cpsr_write(env, val, 0xffffffff, CPSRWriteRaw);\n\n    return 0;\n\n}\n", "idx": 7982, "substitutes": {"f": ["fd", "cf", "uf", "q", "b", "xf", "af", "c", "h", "fe", "fx", "lf", "file", "fc", "p", "d", "F", "fp", "t", "r", "rf", "bf", "fac", "v", "ef", "fed", "inf", "fa", "fn", "fb", "tf", "sf", "fs", "fi", "fo", "e", "fr", "ile", "l"], "opaque": ["ipaques", "iparam", "oplque", "boque", "ipaque", "opque", "Opaco", "opin", "opaques", " opacity", "oppin", "oppaque", "boaram", " opin", "oplaram", "oppaco", "opaco", "Opin", " opaco", "ipque", "Opacity", "opacity", "Opaque", "oparam", "boaques", "boaque", "oplaque", "oppacity", "oplaques"], "size": ["empty", "SIZE", "mem", "type", "h", "Size", "len", " Size", "data", "scale", "err", "value", "w", "space", "code", "dim", "args", "alloc", "st", "count", "shape", "ize", "iz", "length", "name"], "cpu": ["CPU", "gc", "node", "mem", "cp", " proc", "c", "pu", "pc", "ctx", "upt", "prof", "anc", "pod", "ka", "ram", "clock", "arch", "p", "util", "stat", "chip", "ec", "process", "hw", "phys", "proc", "mu", "nic", "num", "ork", "processor", "uu", "alloc", "np", "aco", "runner", "core", "obj", "boot", "cu", "rom", "gpu", "conn"], "env": ["uv", "esc", "ei", "scope", "den", "buf", "eg", "addr", "ec", "dev", "enter", "cb", "environment", "en", "ah", "txt", "dn", "estate", "entry", "cur", "ey", "enc", "vv", "vr", "next", "kh", "ve", "er", "context", "eh", "server", "el", "v", "vs", "serv", "priv", "desc", "oe", "db", "ev", "export", "et", "end", "ctx", "eni", "ent", "nc", "var", "viron", "val", "dh", "bar", "pkg", "attr", "eq", "nv", "ote", "cv", "hl", "window", "ov", "here", "eas", "erd", "ext", "cmd", "vp", "ew", "eng", "err", "ef", "ea", "eu", "equ", "vt", "obj", "e", "conn"]}}
{"project": "qemu", "commit_id": "7e2515e87c41e2e658aaed466e11cbdf1ea8bcb1", "target": 0, "func": "static void term_handle_byte(int ch)\n\n{\n\n    switch(term_esc_state) {\n\n    case IS_NORM:\n\n        switch(ch) {\n\n        case 1:\n\n            term_bol();\n\n            break;\n\n        case 4:\n\n            term_delete_char();\n\n            break;\n\n        case 5:\n\n            term_eol();\n\n            break;\n\n        case 9:\n\n            term_completion();\n\n            break;\n\n        case 10:\n\n        case 13:\n\n            term_cmd_buf[term_cmd_buf_size] = '\\0';\n\n\t    term_hist_add(term_cmd_buf);\n\n            term_printf(\"\\n\");\n\n            term_handle_command(term_cmd_buf);\n\n            term_show_prompt();\n\n            break;\n\n        case 27:\n\n            term_esc_state = IS_ESC;\n\n            break;\n\n        case 127:\n\n        case 8:\n\n            term_backspace();\n\n            break;\n\n\tcase 155:\n\n            term_esc_state = IS_CSI;\n\n\t    break;\n\n        default:\n\n            if (ch >= 32) {\n\n                term_insert_char(ch);\n\n            }\n\n            break;\n\n        }\n\n        break;\n\n    case IS_ESC:\n\n        if (ch == '[') {\n\n            term_esc_state = IS_CSI;\n\n            term_esc_param = 0;\n\n        } else {\n\n            term_esc_state = IS_NORM;\n\n        }\n\n        break;\n\n    case IS_CSI:\n\n        switch(ch) {\n\n\tcase 'A':\n\n\tcase 'F':\n\n\t    term_up_char();\n\n\t    break;\n\n\tcase 'B':\n\n\tcase 'E':\n\n\t    term_down_char();\n\n\t    break;\n\n        case 'D':\n\n            term_backward_char();\n\n            break;\n\n        case 'C':\n\n            term_forward_char();\n\n            break;\n\n        case '0' ... '9':\n\n            term_esc_param = term_esc_param * 10 + (ch - '0');\n\n            goto the_end;\n\n        case '~':\n\n            switch(term_esc_param) {\n\n            case 1:\n\n                term_bol();\n\n                break;\n\n            case 3:\n\n                term_delete_char();\n\n                break;\n\n            case 4:\n\n                term_eol();\n\n                break;\n\n            }\n\n            break;\n\n        default:\n\n            break;\n\n        }\n\n        term_esc_state = IS_NORM;\n\n    the_end:\n\n        break;\n\n    }\n\n    term_update();\n\n}\n", "idx": 7992, "substitutes": {"ch": ["ph", "gt", "ic", "q", "sp", "b", "CH", "cp", "channel", "c", "h", "br", "cl", "shift", "i", "sc", "ok", "Ch", "g", "p", "cmd", "ech", "zh", "key", "ach", "str", "th", "tch", "col", " Ch", "che", "k", "code", "v", "change", "character", "sh", "qu", "och", "vc", "cho", "ich", "quit", "y", "wh", "cur", "chan", "comp", "ctr", "z", "j", "com", "x", "chrom"]}}
{"project": "qemu", "commit_id": "92c0bba9a95739c92e959fe478cb1acb92fa5446", "target": 0, "func": "struct omap_l4_s *omap_l4_init(target_phys_addr_t base, int ta_num)\n\n{\n\n    struct omap_l4_s *bus = g_malloc0(\n\n                    sizeof(*bus) + ta_num * sizeof(*bus->ta));\n\n\n\n    bus->ta_num = ta_num;\n\n    bus->base = base;\n\n\n\n#ifdef L4_MUX_HACK\n\n    omap_l4_io_entries = 1;\n\n    omap_l4_io_entry = g_malloc0(125 * sizeof(*omap_l4_io_entry));\n\n\n\n    omap_cpu_io_entry =\n\n            cpu_register_io_memory(omap_l4_io_readfn,\n\n                            omap_l4_io_writefn, bus, DEVICE_NATIVE_ENDIAN);\n\n# define L4_PAGES\t(0xb4000 / TARGET_PAGE_SIZE)\n\n    omap_l4_io_readb_fn = g_malloc0(sizeof(void *) * L4_PAGES);\n\n    omap_l4_io_readh_fn = g_malloc0(sizeof(void *) * L4_PAGES);\n\n    omap_l4_io_readw_fn = g_malloc0(sizeof(void *) * L4_PAGES);\n\n    omap_l4_io_writeb_fn = g_malloc0(sizeof(void *) * L4_PAGES);\n\n    omap_l4_io_writeh_fn = g_malloc0(sizeof(void *) * L4_PAGES);\n\n    omap_l4_io_writew_fn = g_malloc0(sizeof(void *) * L4_PAGES);\n\n    omap_l4_io_opaque = g_malloc0(sizeof(void *) * L4_PAGES);\n\n#endif\n\n\n\n    return bus;\n\n}\n", "idx": 8010, "substitutes": {"base": ["ases", "db", "b", "root", "prefix", "eta", "type", "ma", "i", "offset", "state", "buffer", "ta", "beta", "ip", "p", "pa", "bp", "index", "data", "phys", "bu", "bi", "pi", "scale", "Base", "temp", "bal", "se", "ref", "pos", "id", "ada", "balance", "start", "bid", "bf", "bin", "mb", "m", "block", "a", "area", "address", "size", "boot", "bas", "ase", "bm", "origin", "based", "source", "ba"], "ta_num": [" ta_str", "tu67max", "ta__str", "ta67max", " ta_NUM", "ta_ver", " ta2str", "ta2Num", "TA_um", "ta2um", "tu_snap", " ta_mon", " ta2mon", "tu_mon", "eta_sum", "ta67mon", " ta2num", "ta67num", "ta67snap", "ta2mon", "ta_str", "ta__NUM", "ta__num", "ta_mon", "ta_max", "tu_num", "ta_snap", "TA_ver", "tu67mon", "TA_num", "ta2num", "ta2ver", "ta_NUM", "eta_mon", "TA_Num", "ta2str", "ta_um", "ta_Num", "tu67num", "tu67snap", " ta2NUM", "tu_max", "ta__mon", "eta_num", "eta_um", "ta_sum", "ta2NUM"], "bus": ["init", "cast", "hand", "chain", "b", "mot", " buses", "usb", " BUS", "c", "http", "ctx", "h", "back", "volt", "box", "BUS", "sys", "buf", "state", "buffer", "os", "p", "Bus", "vol", "util", "dev", "lib", " Bus", "used", "data", "full", "phys", "o", "pos", "proc", "board", "device", "out", "gate", "handle", "host", "book", "port", "config", "block", "bridge", "driver", "al", "bs", "controller", "ac", "build", "local", "disk", "cache", "loop", "serial", "us", "gen", "boot", "in", "lock", "interface", "di"]}}
{"project": "qemu", "commit_id": "72cf2d4f0e181d0d3a3122e04129c58a95da713e", "target": 0, "func": "static void qbus_list_bus(DeviceState *dev, char *dest, int len)\n\n{\n\n    BusState *child;\n\n    const char *sep = \" \";\n\n    int pos = 0;\n\n\n\n    pos += snprintf(dest+pos, len-pos,\"child busses at \\\"%s\\\":\",\n\n                    dev->id ? dev->id : dev->info->name);\n\n    LIST_FOREACH(child, &dev->child_bus, sibling) {\n\n        pos += snprintf(dest+pos, len-pos, \"%s\\\"%s\\\"\", sep, child->name);\n\n        sep = \", \";\n\n    }\n\n}\n", "idx": 8018, "substitutes": {"dev": ["ev", "des", "app", "att", "conf", "any", "dep", "md", "av", "pad", "det", "dem", "DEV", "den", "develop", "nt", " device", "sys", "ve", "pro", "die", "d", "cmd", "add", "var", "sd", "del", "ind", "hw", "th", "debug", "proc", "device", "ad", "v", "watch", "Device", "dd", "Dev", " def", "ch", "serv", "off", "build", "exec", "priv", "test", "tech", "unknown", "info", "de", "dis", "wd", "ver", "bus", "conn", "def", "oy", "od"], "dest": ["this", "dc", "loc", "sp", "dat", "src", "end", "target", "est", "buf", "nt", "seq", "prop", "d", "addr", "cmd", "usr", "w", "str", "pos", "rest", "master", "Dest", "out", "gate", "iter", "max", "num", "dist", "transform", "orig", "port", "new", "st", "tmp", "ptr", "lit", "pas", "cat", "ident", "priv", "desc", "gen", "decl", "nom", "origin", "coord", "trans", "deg", "source"], "len": [" lang", "mult", "bytes", "ln", "end", "wid", "mun", "cmp", "Len", "offset", " bl", "compl", "lf", "nt", "seq", " lengths", "n", " el", "del", "fl", "line", "full", " size", "t", "lan", "str", "el", "pos", "coll", "ls", " seq", "en", "lim", "num", " length", "fin", "resp", " en", "le", " le", "size", "length", "ll", "enc", " count", " disp", "nl", " Len", "l", " l", "elt", "vec"], "child": ["all", "Child", "q", "root", "b", "node", "att", "c", "job", "ib", "h", "last", "self", "nt", "row", "sync", "data", "win", "se", "uncle", "sel", "ach", "w", "col", "children", "syn", "unk", "proc", "v", "handle", "sec", "dd", "new", "ch", "block", "cell", "sub", "close", "batch", "parent", "local", "ibling", "f", "obj", "j", "other", "shell", "bus", "fd"], "sep": ["separgment", "separg", " seep", " sem", "sedper", "SEper", " seg", "pseg", "separpar", "cepar", "speg", "sedep", "separ", "cegment", "sedg", "separp", "ceg", " segment", "seep", "SEg", "spem", "SEp", "psep", "speep", "cep", " separ", "sem", "psem", " seper", "pseep", "SEep", "sedp", "spep", "seg", "segment", "seper"]}}
{"project": "qemu", "commit_id": "6817efea3a0d1bf87be815970cdb014c5a64b628", "target": 1, "func": "static int read_directory(BDRVVVFATState* s, int mapping_index)\n\n{\n\n    mapping_t* mapping = array_get(&(s->mapping), mapping_index);\n\n    direntry_t* direntry;\n\n    const char* dirname = mapping->path;\n\n    int first_cluster = mapping->begin;\n\n    int parent_index = mapping->info.dir.parent_mapping_index;\n\n    mapping_t* parent_mapping = (mapping_t*)\n\n        (parent_index >= 0 ? array_get(&(s->mapping), parent_index) : NULL);\n\n    int first_cluster_of_parent = parent_mapping ? parent_mapping->begin : -1;\n\n\n\n    DIR* dir=opendir(dirname);\n\n    struct dirent* entry;\n\n    int i;\n\n\n\n    assert(mapping->mode & MODE_DIRECTORY);\n\n\n\n    if(!dir) {\n\n        mapping->end = mapping->begin;\n\n        return -1;\n\n    }\n\n\n\n    i = mapping->info.dir.first_dir_index =\n\n            first_cluster == 0 ? 0 : s->directory.next;\n\n\n\n    if (first_cluster != 0) {\n\n        /* create the top entries of a subdirectory */\n\n        (void)create_short_and_long_name(s, i, \".\", 1);\n\n        (void)create_short_and_long_name(s, i, \"..\", 1);\n\n    }\n\n\n\n    /* actually read the directory, and allocate the mappings */\n\n    while((entry=readdir(dir))) {\n\n        unsigned int length=strlen(dirname)+2+strlen(entry->d_name);\n\n        char* buffer;\n\n        direntry_t* direntry;\n\n        struct stat st;\n\n        int is_dot=!strcmp(entry->d_name,\".\");\n\n        int is_dotdot=!strcmp(entry->d_name,\"..\");\n\n\n\n        if(first_cluster == 0 && (is_dotdot || is_dot))\n\n            continue;\n\n\n\n        buffer = g_malloc(length);\n\n        snprintf(buffer,length,\"%s/%s\",dirname,entry->d_name);\n\n\n\n        if(stat(buffer,&st)<0) {\n\n            g_free(buffer);\n\n            continue;\n\n        }\n\n\n\n        /* create directory entry for this file */\n\n        if (!is_dot && !is_dotdot) {\n\n            direntry = create_short_and_long_name(s, i, entry->d_name, 0);\n\n        } else {\n\n            direntry = array_get(&(s->directory), is_dot ? i : i + 1);\n\n        }\n\n        direntry->attributes=(S_ISDIR(st.st_mode)?0x10:0x20);\n\n        direntry->reserved[0]=direntry->reserved[1]=0;\n\n        direntry->ctime=fat_datetime(st.st_ctime,1);\n\n        direntry->cdate=fat_datetime(st.st_ctime,0);\n\n        direntry->adate=fat_datetime(st.st_atime,0);\n\n        direntry->begin_hi=0;\n\n        direntry->mtime=fat_datetime(st.st_mtime,1);\n\n        direntry->mdate=fat_datetime(st.st_mtime,0);\n\n        if(is_dotdot)\n\n            set_begin_of_direntry(direntry, first_cluster_of_parent);\n\n        else if(is_dot)\n\n            set_begin_of_direntry(direntry, first_cluster);\n\n        else\n\n            direntry->begin=0; /* do that later */\n\n        if (st.st_size > 0x7fffffff) {\n\n            fprintf(stderr, \"File %s is larger than 2GB\\n\", buffer);\n\n            g_free(buffer);\n\n            closedir(dir);\n\n            return -2;\n\n        }\n\n        direntry->size=cpu_to_le32(S_ISDIR(st.st_mode)?0:st.st_size);\n\n\n\n        /* create mapping for this file */\n\n        if(!is_dot && !is_dotdot && (S_ISDIR(st.st_mode) || st.st_size)) {\n\n            s->current_mapping = array_get_next(&(s->mapping));\n\n            s->current_mapping->begin=0;\n\n            s->current_mapping->end=st.st_size;\n\n            /*\n\n             * we get the direntry of the most recent direntry, which\n\n             * contains the short name and all the relevant information.\n\n             */\n\n            s->current_mapping->dir_index=s->directory.next-1;\n\n            s->current_mapping->first_mapping_index = -1;\n\n            if (S_ISDIR(st.st_mode)) {\n\n                s->current_mapping->mode = MODE_DIRECTORY;\n\n                s->current_mapping->info.dir.parent_mapping_index =\n\n                    mapping_index;\n\n            } else {\n\n                s->current_mapping->mode = MODE_UNDEFINED;\n\n                s->current_mapping->info.file.offset = 0;\n\n            }\n\n            s->current_mapping->path=buffer;\n\n            s->current_mapping->read_only =\n\n                (st.st_mode & (S_IWUSR | S_IWGRP | S_IWOTH)) == 0;\n\n        } else {\n\n            g_free(buffer);\n\n        }\n\n    }\n\n    closedir(dir);\n\n\n\n    /* fill with zeroes up to the end of the cluster */\n\n    while(s->directory.next%(0x10*s->sectors_per_cluster)) {\n\n        direntry_t* direntry=array_get_next(&(s->directory));\n\n        memset(direntry,0,sizeof(direntry_t));\n\n    }\n\n\n\n/* TODO: if there are more entries, bootsector has to be adjusted! */\n\n#define ROOT_ENTRIES (0x02 * 0x10 * s->sectors_per_cluster)\n\n    if (mapping_index == 0 && s->directory.next < ROOT_ENTRIES) {\n\n        /* root directory */\n\n        int cur = s->directory.next;\n\n        array_ensure_allocated(&(s->directory), ROOT_ENTRIES - 1);\n\n        s->directory.next = ROOT_ENTRIES;\n\n        memset(array_get(&(s->directory), cur), 0,\n\n                (ROOT_ENTRIES - cur) * sizeof(direntry_t));\n\n    }\n\n\n\n    /* re-get the mapping, since s->mapping was possibly realloc()ed */\n\n    mapping = array_get(&(s->mapping), mapping_index);\n\n    first_cluster += (s->directory.next - mapping->info.dir.first_dir_index)\n\n        * 0x20 / s->cluster_size;\n\n    mapping->end = first_cluster;\n\n\n\n    direntry = array_get(&(s->directory), mapping->dir_index);\n\n    set_begin_of_direntry(direntry, mapping->begin);\n\n\n\n    return 0;\n\n}\n", "idx": 8021, "substitutes": {"s": ["single", "rs", "service", "sp", "gs", "ses", "b", "csv", "sg", "less", "src", "ns", "c", "h", "sam", "qs", "set", "sys", "comm", "self", "state", "os", "p", "ps", "g", "d", "si", "is", "ts", "ds", "t", "es", "r", "simple", "js", "str", "w", "space", "sv", "span", "sb", "v", "stats", "sl", "m", "spec", "hs", "a", "ss", "bs", "south", "y", "sq", "fs", "e", "S", "sts", "j", "aws", "l", "source"], "mapping_index": ["mapping2address", "mapping2position", "mapper2position", "mapper2index", "mapper_index", "mapping_ind", "mapping_position", "mapper_address", "mapper_ind", "mapper_type", "mapping2ind", "mapper2ind", "mapping_address", "mapper_position", "mapping_type", "mapper2address", "mapping2index"], "mapping": ["mmapping", "omapping", "mapped", "smapped", "laping", "cmapping", "ombinding", "tutation", "manapper", "dapping", "mmapped", "iminding", "omap", "matching", "capper", "smapping", "lapping", "nmapper", " mbinding", " mapped", "Mappings", "Mutation", " maping", "dutation", "cmatching", "smap", "mmbinding", "mmapper", "remapped", "lapped", "Mapper", "congo", "tmapping", "maching", "imapping", "tapped", "mbinding", "Mmap", "Mapping", "lapper", "nmapped", "smapper", "Matching", "nmapping", "capping", "mmap", "cmapper", "tmapper", "map", " mapper", "lappings", "lutation", "dapped", "remongo", "mappings", "tmaching", "Mongo", " maching", "remapper", "Maping", "cmapped", "taping", " mappings", "immap", "tmapped", "taching", "mongo", "manutation", "maping", "mapper", "tapper", "capped", "Map", "omapped", "minding", "Mapped", "manaping", "mutation", "omapper", "manapping", "dmap", "nmatching", "dinding", "remapping", "imapper", "dapper", "Minding", "tapping"], "direntry": ["direnttry", "direnr", "direrentries", "direntEntry", "direncry", "direndEntry", "direnry", "direventEntry", "dererententry", "durenotary", "dirententry", "direrentr", "dirntentry", "direrentary", "dirntr", "direndry", "direnary", "direnotentry", "direentry", "direndentry", "dirncr", "direnotary", "direententry", "direntr", "durentry", "direrentry", "durenotry", "direventry", "direnotr", "derentEntry", "durenotentry", "direvententry", "dererentries", "direrentEntry", "direncr", "direenttry", "dererentEntry", "derentry", "durentr", "direventries", "dirncry", "direnentry", "direrenttry", "durenotr", "direnotry", "dirncentry", "direnctry", "direentr", "dererentry", "durentary", "derententry", "dirntry", "dirnctry", "derentries", "direndries", "durententry", "direrententry", "direncentry", "direntary", "dirnttry", "direntries"], "dirname": ["dNAME", "filename", " dircurrent", "dirame", "diradmin", "diskname", "fileame", "foldername", "pathstring", " directoryadmin", "folderNAME", " directoryName", "pathn", "dpath", "dadmin", "directorypath", " directoryname", "dirNAME", "dircurrent", "dname", "directoryn", "filen", "pathpath", "dstring", " diradmin", "directoryname", " directorypath", "filepath", "pathame", "diskcurrent", "dn", " dirn", "dirn", "dirName", "foldern", "pathNAME", "pathname", " dirName", "diskn", "directorycurrent", "dirpath", "dirstring", "folderstring", "dName", "diskpath", " dirame", " dirpath"], "parent_mapping": ["parent_smapper", "parent_smapping", "parent_lappings", "parent_lapper", "parent_Mapped", "parent_Map", "parent_dapped", "parent_papped", "parent_papper", "parent_smapped", "parent_mapper", "parent_dapper", "parent_dappings", "parent_lapping", "parent_dapping", "parent_Mappings", "parent_mapped", "parent_papping", "parent_map", "parent_pap", "parent_smap", "parent_Mapping", "parent_lapped", "parent_mappings", "parent_Mapper"], "dir": ["folder", "db", "fd", "open", "loc", "sp", "node", "window", "irs", "md", "direction", "def", "tar", "rel", "set", "file", "map", "d", "rect", "add", "dict", "lib", "ds", "ind", "data", "full", " directory", "DIR", "str", "dr", "w", "record", "pos", "zip", "module", "Dir", "ir", "iter", "dim", "dist", "dd", "m", "tmp", "direct", "local", "doc", "desc", "disk", "ptr", "mod", "rec", "in", "directory", "dis", "di", "wd", "name", "path"], "entry": ["existent", "result", "event", "match", "error", "instance", "it", "nt", "ry", "escape", "see", "ent", "ie", "connection", "link", "name", "option", "row", "pair", "data", "ner", "element", "se", "ary", "import", "r", "key", "index", "record", "RY", "attribute", "word", "inter", "section", "byte", "entity", "child", "try", "dd", "command", "cell", "ror", "part", "comment", "item", "doc", "member", "obj", "search", "Entry", "info", "e", "directory", "check", "ace", "def", "image"], "i": ["init", "ic", "ini", "ij", "bis", "uri", "ci", "it", "im", "c", "oi", "mi", "qi", "ip", "li", "si", "inv", "n", "is", "ind", "xi", "index", "ri", "bi", "pi", "limit", "id", "ui", "phi", "ir", "iter", "ti", "ix", "ai", "m", "I", "y", "ia", "fi", "io", "info", "iu", "in", "iri", "j", "di", "x", "ii"], "buffer": ["output", "header", "bytes", "result", "buff", "copy", "empty", "mem", "window", "channel", "binary", "buf", "page", "Buffer", "template", "raw", "table", "base", "screen", "document", "row", "pointer", "data", "queue", "stack", "temp", "limit", "byte", "position", "device", "code", "iter", "v", "memory", "command", "stream", "block", "mb", "clear", "comment", "phrase", "batch", "cache", "address", "message", "size", "length", "text", "shell", "source", "sequence"], "st": [" St", " step", "sp", "ct", "ust", "est", "step", "sth", " status", " ST", " ss", "set", "nd", "sc", "d", "inst", "mt", "stat", " et", "std", "se", "stack", "r", "str", "rest", "sm", "start", "status", "ch", "stable", "ST", " dst", "obj", "ste", "sts", " est", "fr", "ost", "St", " sc"]}}
{"project": "FFmpeg", "commit_id": "dc5d1515681b57a257443ba72bb81fb3e6e6621b", "target": 0, "func": "static int replace_int_data_in_filename(char *buf, int buf_size, const char *filename, char placeholder, int64_t number)\n\n{\n\n    const char *p;\n\n    char *q, buf1[20], c;\n\n    int nd, len, addchar_count;\n\n    int found_count = 0;\n\n\n\n    q = buf;\n\n    p = filename;\n\n    for (;;) {\n\n        c = *p;\n\n        if (c == '\\0')\n\n            break;\n\n        if (c == '%' && *(p+1) == '%')  // %%\n\n            addchar_count = 2;\n\n        else if (c == '%' && (av_isdigit(*(p+1)) || *(p+1) == placeholder)) {\n\n            nd = 0;\n\n            addchar_count = 1;\n\n            while (av_isdigit(*(p + addchar_count))) {\n\n                nd = nd * 10 + *(p + addchar_count) - '0';\n\n                addchar_count++;\n\n            }\n\n\n\n            if (*(p + addchar_count) == placeholder) {\n\n                len = snprintf(buf1, sizeof(buf1), \"%0*\"PRId64, (number < 0) ? nd : nd++, number);\n\n                if (len < 1)  // returned error or empty buf1\n\n                    goto fail;\n\n                if ((q - buf + len) > buf_size - 1)\n\n                    goto fail;\n\n                memcpy(q, buf1, len);\n\n                q += len;\n\n                p += (addchar_count + 1);\n\n                addchar_count = 0;\n\n                found_count++;\n\n            }\n\n\n\n        } else\n\n            addchar_count = 1;\n\n\n\n        while (addchar_count--)\n\n            if ((q - buf) < buf_size - 1)\n\n                *q++ = *p++;\n\n            else\n\n                goto fail;\n\n    }\n\n    *q = '\\0';\n\n    return found_count;\n\nfail:\n\n    *q = '\\0';\n\n    return -1;\n\n}\n", "idx": 8046, "substitutes": {"buf": ["db", "read", "bytes", "uf", "buff", "b", "bn", "ff", "mem", "next", "cp", "pb", "ctx", "br", "h", "bc", "box", "Buffer", "file", "ob", "buffer", "msg", "seq", "cmd", "var", "cb", "used", "queue", "data", "wb", "bu", "err", "rc", "ref", "pkg", "brace", "rb", "iter", "bf", "v", "txt", "cap", "out", "orig", "tmp", "cv", "batch", "xff", "cache", "bl", "cur", "que", "loc", "bin"], "buf_size": ["buf1Size", " buf_Size", "buffer_SIZE", "buffer_size", "buf2SIZE", "buf_Size", " buf_start", "buf8SIZE", "buf1size", "buf8size", "buffer_Size", "buf_SIZE", "buf1name", "buf_ize", " buf_SIZE", " buf_name", "buf8ize", "buf_name", "buf2size", "buf1SIZE", "buffer_name", "buf2Size", "buf2name", "buf8name", "buf_start", " buf_ize"], "filename": ["lua", "uri", "buff", "b", "bn", "prefix", "pen", "file", "files", "buffer", "n", "FN", "fp", "username", "nu", "pkg", "fil", "nil", "nm", "brace", "ren", "txt", "v", "vo", "writer", "fn", "Filename", "socket", "f", "conv", "println", "length", "nl", "json", "names", "name", "path"], "placeholder": [" placezero", "replaceholders", "replacehold", "pleaseholder", "placehold", "replacezero", "Placeholder", " placeolder", "placesfield", " placehold", "replacefield", "pleaseolder", "pleasehold", "replaceholder", "placefield", " placeholders", "placeholders", "Placeolder", "Placehold", "pleasefield", "replaceolder", "Placeholders", "placeolder", "placesolder", "Placezero", "placezero", "placesholder", "placeshold"], "number": [" numbering", "error", "result", " num", "node", "BER", "note", "null", "nr", " document", " numeric", "file", " configuration", " Number", "n", "no", "document", " error", "data", "total", " argument", "record", "byte", "password", "Number", "num", "token", " parameter", "NUM", " length", " integer", "new", "comment", "integer", "version", "count", "umber", "message", " numer", "unknown", "size", "time", "length", "language", "other", "x", "object"], "p": ["post", "pid", "par", "sp", "b", "power", "ar", "wp", "cp", "ping", "pb", "u", "pc", "ctx", "br", "i", "pro", "pt", "self", "progress", "pat", "pa", "d", "bp", "n", "g", "vp", "ps", "php", "op", "o", "fp", "t", "perm", "pi", "r", "pe", "pm", "pos", "pipe", "pkg", "pre", "pg", "ap", "pr", "span", "k", "s", "lp", "v", "port", "m", "part", "per", "y", "jp", "np", "f", "pn", "pp", "P", "point", "info", "j", "a", "tp", "l"], "q": ["ck", "qual", "quer", "uf", "b", "quant", "it", "cp", "quote", "u", "h", "i", "qs", "qi", "g", "d", "n", "iq", "queue", "fp", "Q", "r", "w", "query", "question", "pkg", "qv", "ue", "k", "qa", "eq", "v", "qq", "qu", "dq", "m", "ch", "comment", "quit", "cv", "gz", "aq", "sq", "f", "quest", "que", "ql", "qt", "check", "j", "z", "l"], "buf1": ["buff3", "buf0", " buf0", "buff1", "uf3", "buff0", "uf2", "uf1", "buf2", "buffer3", "buf3", "uf0", "buffer2", "buff2", "buffer1", " buf2", "buffer0", " buf3"], "c": ["cod", "dc", "gc", "chain", "ct", "b", "cp", "u", "cmp", "cl", "bc", "cont", "con", "cs", "fc", "g", "co", "n", "unc", "nc", "lc", "ce", "t", "r", "col", "cc", "go", "rc", "k", "cn", "cr", "v", "cap", "ch", "ac", "ca", "cd", "cache", "count", "f", "can", "cur", "conv", "C", "e", "comp", "com", "cu", "l", "tc"], "nd": ["mn", "ln", "ns", "end", "ond", "md", " ne", "gov", "nt", "nn", "ND", "rn", "wind", "mid", "d", "dl", "n", " sd", "sd", "nc", "ds", "ind", "gn", "std", "wn", "gd", " st", "ng", "max", " ND", "vd", " dd", "dd", "rid", "st", "dk", "und", "nb", "sn", "dn", "wo", "cd", "np", "rd", "pd", "td", "ld", "nl", "ne", "fd"], "len": ["qual", "loc", "ln", "mem", "end", "ell", "gl", "Len", "lin", "rel", "nt", "compl", "lf", "nn", "li", "lon", "dl", "ml", "n", "gn", "nc", "val", "fl", "pl", "line", "kl", "lan", "vl", "Length", "el", "pos", "ls", "lp", "en", "num", "v", "lim", "sl", "fin", "lt", "resp", "fn", "sn", "ret", "L", "size", "hl", "length", "ld", "ll", "nl", "il", "mil", "l", "le", "elt"], "addchar_count": ["addchar_cont", "addchar32counter", "addcharitycounter", "addchar2Count", "addcar_len", "addchar_child", "addchar_c", "addcharaxycount", "addword_count", "addchar_history", "addchar_length", "addChar_length", "addcaritylen", "addcharitychild", "addChar_Count", "addcharityCount", "addconst_count", "addchar_counter", "addcharacter_Count", "addcaritychild", "addmethod_count", "addcharvalcount", "addchar_info", "addchar2length", "addword_code", "addcaritycount", "addchar_name", "addchar2count", "addchar_cache", "addchar32c", "addword_cache", "addmethodaxyhistory", "addcharacter_c", "addconst_length", "addchar_tag", "addcar_child", "addcharacter_counter", "addcharacter2length", "addchar32count", "addcharaxyhistory", "addchar_size", "addcharacter2Count", "addChar_counter", "addcharvalpart", "addchar_Count", "addmethodaxyname", "addchar_len", "addcar_count", "addcharacter_length", "addcharitycount", "addword_c", "addcar_Count", "addmethodaxycount", "addcharityc", "addchar_code", "addconst_1", "addcharaxyname", "addcharitylen", "addcharacter2count", "addchar_1", "addmethod_part", "addmethod_name", "addmethodaxypart", "addcharacter_count", "addcharaxypart", "addChar_count", "addchar_part", "addcharvalhistory", "addChar_tag", "addcharvalname", "addcarityCount", "addmethod_history", "addconst_info"], "found_count": ["foundYcount", "Found_Count", "found_Count", "foundYstat", "Found_num", "foundnesscount", "found_stat", "foundYval", " found_val", " found_stat", "found_num", "foundnessstatus", "founditycount", "founditynum", "foundityCount", "Found_status", "foundnessCount", "found_status", "found_val", " found_Count", "Found_count", "foundYCount"]}}
{"project": "qemu", "commit_id": "db7dfd4c7e4450b10048a53ce67bcac6305ad383", "target": 0, "func": "static void cubieboard_init(QEMUMachineInitArgs *args)\n\n{\n\n    CubieBoardState *s = g_new(CubieBoardState, 1);\n\n    Error *err = NULL;\n\n\n\n    s->a10 = AW_A10(object_new(TYPE_AW_A10));\n\n    object_property_set_bool(OBJECT(s->a10), true, \"realized\", &err);\n\n    if (err != NULL) {\n\n        error_report(\"Couldn't realize Allwinner A10: %s\\n\",\n\n                error_get_pretty(err));\n\n        exit(1);\n\n    }\n\n\n\n    memory_region_init_ram(&s->sdram, NULL, \"cubieboard.ram\", args->ram_size);\n\n    vmstate_register_ram_global(&s->sdram);\n\n    memory_region_add_subregion(get_system_memory(), AW_A10_SDRAM_BASE,\n\n                                &s->sdram);\n\n\n\n    cubieboard_binfo.ram_size = args->ram_size;\n\n    cubieboard_binfo.kernel_filename = args->kernel_filename;\n\n    cubieboard_binfo.kernel_cmdline = args->kernel_cmdline;\n\n    arm_load_kernel(&s->a10->cpu, &cubieboard_binfo);\n\n}\n", "idx": 8049, "substitutes": {"args": ["fields", "gs", "results", "points", "ars", "ants", "orders", "uments", "md", "amps", "ags", "values", "aws", "qs", "apps", "terms", "comm", "aps", "actions", "ians", "cmd", "words", "yes", "ts", "settings", "aux", "arms", "css", "vals", "GV", "js", "atts", "params", "ids", "xs", "Args", "units", "txt", "ras", "ims", "addons", "bits", "ams", "GS", "limits", "parts", "fs", "arg", "flags", "changes", "roots", "arr", "names", "icks"], "s": ["rs", "gs", "sp", "ses", "b", "sw", "sg", "ns", "h", "i", "sys", "store", "set", "comm", "self", "qs", "cs", "ps", "d", "p", "n", "is", "ts", "ds", "se", "es", "t", "temp", "js", "w", "sv", "ls", "sm", "sb", "services", "v", "ims", "iss", "stats", "sh", "sl", "m", "sa", "hs", "ss", "bs", "states", "su", "serv", "y", "sq", "parts", "fs", "S", "sts", "j", "sis", "l", "source"], "err": ["ev", "rs", "eor", "error", "Er", "conf", "fee", "kr", "ger", "gr", "br", "eas", "buf", "aaa", "mr", "msg", "exc", "er", "erd", "rn", "die", "norm", "order", "riot", "n", "notice", "or", "usr", " er", "erb", "r", "attr", "rr", "esp", "try", "cr", "txt", "rb", "cfg", "resp", "ch", "der", "gz", "priv", "cer", "obj", "e", "DERR", "oe", "fr", "arr", "res", "coord", "conn", "elt"]}}
{"project": "qemu", "commit_id": "a8170e5e97ad17ca169c64ba87ae2f53850dab4c", "target": 0, "func": "void esp_init(target_phys_addr_t espaddr, int it_shift,\n\n              ESPDMAMemoryReadWriteFunc dma_memory_read,\n\n              ESPDMAMemoryReadWriteFunc dma_memory_write,\n\n              void *dma_opaque, qemu_irq irq, qemu_irq *reset,\n\n              qemu_irq *dma_enable)\n\n{\n\n    DeviceState *dev;\n\n    SysBusDevice *s;\n\n    SysBusESPState *sysbus;\n\n    ESPState *esp;\n\n\n\n    dev = qdev_create(NULL, \"esp\");\n\n    sysbus = DO_UPCAST(SysBusESPState, busdev.qdev, dev);\n\n    esp = &sysbus->esp;\n\n    esp->dma_memory_read = dma_memory_read;\n\n    esp->dma_memory_write = dma_memory_write;\n\n    esp->dma_opaque = dma_opaque;\n\n    sysbus->it_shift = it_shift;\n\n    /* XXX for now until rc4030 has been changed to use DMA enable signal */\n\n    esp->dma_enabled = 1;\n\n    qdev_init_nofail(dev);\n\n    s = sysbus_from_qdev(dev);\n\n    sysbus_connect_irq(s, 0, irq);\n\n    sysbus_mmio_map(s, 0, espaddr);\n\n    *reset = qdev_get_gpio_in(dev, 0);\n\n    *dma_enable = qdev_get_gpio_in(dev, 1);\n\n}\n", "idx": 8071, "substitutes": {"espaddr": ["epid", "ispaddress", "epname", "evadr", "espadr", " espid", "epaddress", " espaddress", "htmladdress", "espname", "ispname", "evconn", "htmladr", "ispid", "evaddr", " espconn", " espadr", "ispaddr", "espconn", "espid", "evaddress", "htmladdr", "epaddr", " espname", "htmlconn", "espaddress"], "it_shift": ["its_sort", "IT_offset", "IT_shift", "iter_hash", "iter_align", "itTimeshift", "itTimeoffset", "iter_shift", "iter_push", "it_push", "it_drop", "its_drop", "itpoalign", "it_align", "itpohash", "itpopush", "it_hash", "itTimedrop", "IT_hift", "it_offset", "itTimesort", "it_sort", "itposhift", "its_offset", "it_hift", "its_shift"], "dma_memory_read": ["dma_memoryistread", "dma_media_reader", "dma_media_read", "dma_memory__write", "dma_media_query", "dma_memoryistreader", "dma_memoryistquery", "dma_memory__reader", "dma_memory_reader", "dma_media_write", "dma_memory_query", "dma_memoryistwrite", "dma_memory__read"], "dma_memory_write": ["dma_mem_writer", "dma_memory_set", "dma_processor_writ", "dma_memory_put", "dma_management_writ", "dma_mem_store", "dma_processor_put", "dma_memory_writ", "dma_management_write", "dma_memory_store", "dma_memory_post", "dma_management_post", "dma_memory_writer", "dma_mem_write", "dma_processor_write", "dma_management_set", "dma_memory_order", "dma_mem_writ", "dma_processor_order"], "dma_opaque": ["dma_operatile", "dma_ipacity", "dma_opplex", "dma_poraques", "dma_ipatile", "dma_opaques", "dma____okiera", "dma_poriera", "dma_opsity", "dma____opacement", "dma_ipacement", "dma_operaque", "dma_opacity", "dma_operity", "dma_ipaques", "dma_preplex", "dma_operaques", "dma_opacement", "dma_poraque", "dma_opiera", "dma____okacement", "dma____okaque", "dma_okaque", "dma_okacement", "dma_opity", "dma_preatile", "dma_okiera", "dma____okaques", "dma____opiera", "dma_preaques", "dma_opsacity", "dma_opatile", "dma_ipity", "dma_opsatile", "dma_okaques", "dma____opaque", "dma_preaque", "dma____opaques", "dma_poracement", "dma_ipplex", "dma_operplex", "dma_ipaque", "dma_opsaque", "dma_operacity", "dma_ipiera"], "irq": ["mirv", "mirqs", " virqu", " drq", "irf", "irp", " irp", "mirq", "irv", " drp", "mirQ", "irqs", " virq", "IRv", " irf", "IRQ", " irQ", "IRq", " drf", "irqu", " drqu", " virp", "IRqs", " virf", "irQ", " irqs", " irqu", " irv"], "reset": ["init", "destroy", "et", "error", "setup", "empty", "prefix", "end", "ping", "def", "hard", "rep", "offset", "set", "state", "force", "addr", "cmd", "enter", "seek", "zero", "establish", "delete", "push", "ref", "start", "mode", "command", "quiet", "re", "ET", "clear", "ret", "address", "rompt", "check", "res", "kill", "rm"], "dma_enable": ["dma_activate", "dna_display", "dna_enable", "dna_activate", "dma_enabled", "dma_display", "dma_disable", "dna_enabled", "dna_disable"], "dev": ["db", "ev", "des", "sw", "mem", "att", "window", "def", "h", "cam", "pad", "DEV", "sys", "den", "dem", "det", "nt", "ve", "buf", "os", "raw", "d", "p", "dt", "cmd", "addr", "sd", "ds", "val", "tr", "data", "hw", "w", "js", "go", "adv", "device", "out", "ad", "v", "DE", "Device", "dd", "spec", "driver", "dn", "serv", "der", "ptr", "disc", "disk", "priv", "desc", "obj", "hid", "de", "development", "dis", "stick", "res", "Dev", "conn", "env"], "s": ["rs", "sp", "gs", "ssl", "b", "ns", "sol", "c", "its", "ats", "i", "sys", "qs", "cs", "os", "ps", "p", "als", "n", "is", "ts", "ds", "es", "t", "r", "js", "sv", "ls", "sb", "v", "stats", "ss", "bs", "socket", "fs", "us", "sat", "S", "sts"], "sysbus": ["ysboard", " sysBus", "ysbox", "sysboard", " sysBUS", "systembus", "systemus", "Sysbus", "ysspace", "syslock", "sysus", "sysBUS", "sysBus", "ysblock", "ysus", "systemspace", " syslock", "SysBus", "sysblock", "SysBUS", " sysspace", "ysBUS", " sysblock", " sysboard", "sysspace", " sysus", "Sysbox", "ysBus", "systemBus", "sysbox", "ysbus", "systemlock", "Sysboard", "systemblock", "yslock", " sysbox"], "esp": ["ev", "sp", "et", "ei", "ssl", "sw", "sg", "asp", "esc", "less", "ell", "eb", "sol", "eps", "asm", "cli", "eas", "rel", "sys", "alg", "https", "er", "secondary", "elf", "esi", "ps", "p", "ech", "established", "eg", "vp", "ez", "ep", "eds", "es", "rss", "js", "isp", "el", "expr", "rev", "soc", "ess", "v", "ef", "resp", "estate", "ss", "serv", "bs", "pse", "isol", "jp", "xp", "sat", "e", "eph", "eve", "html", "res", "ssh", "esm", "sports", "env", "elt"]}}
{"project": "FFmpeg", "commit_id": "aa6aa2ef091818c2669c48051286ce361401f31b", "target": 0, "func": "static void apply_window_and_mdct(AVCodecContext *avctx, const AVFrame *frame)\n\n{\n\n    WMACodecContext *s = avctx->priv_data;\n\n    float **audio      = (float **) frame->extended_data;\n\n    int len            = frame->nb_samples;\n\n    int window_index   = s->frame_len_bits - s->block_len_bits;\n\n    FFTContext *mdct   = &s->mdct_ctx[window_index];\n\n    int ch;\n\n    const float *win   = s->windows[window_index];\n\n    int window_len     = 1 << s->block_len_bits;\n\n    float n            = 2.0 * 32768.0 / window_len;\n\n\n\n    for (ch = 0; ch < avctx->channels; ch++) {\n\n        memcpy(s->output, s->frame_out[ch], window_len * sizeof(*s->output));\n\n        s->fdsp->vector_fmul_scalar(s->frame_out[ch], audio[ch], n, len);\n\n        s->fdsp->vector_fmul_reverse(&s->output[window_len], s->frame_out[ch],\n\n                                    win, len);\n\n        s->fdsp->vector_fmul(s->frame_out[ch], s->frame_out[ch], win, len);\n\n        mdct->mdct_calc(mdct, s->coefs[ch], s->output);\n\n    }\n\n}\n", "idx": 8085, "substitutes": {"avctx": ["AVctx", " avconn", "afctx", "avtx", "aveconfig", "avetx", "avcp", "ajcontext", "avconn", "ajctx", " avcp", " avcontext", "AVconfig", "AVtx", "apconn", "aftx", "avecontext", "avcontext", "avconfig", "ajcp", "avectx", " avtx", "wavctl", "wavctx", " avconfig", " avctl", "apcp", "wavtx", "avctl", "apctx", "wavcontext", "ajconn", "afcontext", "afctl", "apcontext", "AVcontext"], "frame": ["ence", "header", "rame", "event", "feat", "next", "call", "window", "channel", "Frame", "fram", "framework", "iframe", "file", "scene", "profile", "flow", "zone", "frames", "movie", "t", "data", "range", "word", "v", "video", "feature", "block", "request", "fb", "version", "hello", "response", "show", "f", "message", "sample", "face", "point", "e", "time", "fr", "info", "image", "fw", "sequence"], "s": ["sw", "less", "conf", "c", "http", "h", "state", "sc", "self", "ps", "ports", "ts", "settings", "se", "js", "w", "sb", "services", "ss", "scripts", "rs", "service", "so", "ses", "ants", "os", "ms", "es", "v", "stats", "sa", "vs", "sf", "a", "aws", "ops", "gs", "bis", "ssl", "ns", "ctx", "ats", "cs", "comm", "p", "is", "sv", "hs", "bs", "y", "sq", "parts", "fs", "S", "sp", "b", "eps", "acs", "i", "sys", "qs", "als", "details", "n", "ds", "ins", "space", "ls", "ess", "ims", "sl", "spec", "f", "sts", "z"], "audio": ["about", "sound", "metadata", "http", "av", "speech", "phy", "voice", "image", "binary", "buffer", "wav", "ogram", "archive", "opus", "picture", "aux", "data", "mpeg", "input", "ada", "api", "video", "array", "config", "volume", "xml", "basic", "ac", "hello", "Audio", "sample", " Audio", "music", "text", "a", "media", "audi"], "mdct": ["cmdct", "dmcc", "mtnt", "mmict", "dmnt", "cmdpt", "dmct", "mmcc", "dmuct", "dmict", "cdCT", "mmct", "mdict", " mduct", "mdcc", "cdcc", "cmdcc", "mdCT", "mduct", "mtuct", "dmpt", "cdct", " mdcc", "mtct", "mmpt", "mtCT", "cmdict", "mdpt", "mdnt", " mdnt", " mdCT", "dmCT", "cduct"], "ch": ["chain", "c", "kr", "h", " cho", "ht", "uch", "chip", "w", "och", "batch", "atch", "j", "x", "anch", " y", "ph", "q", "CH", "quant", "ble", "kh", "cha", "ek", "Ch", " col", "pl", "ach", "go", "bat", "el", "v", "chu", " th", "wh", "sch", "chrom", "channel", "gl", "pt", "zh", "ech", "chron", "cht", "tch", "th", "unk", "sk", "qu", "cell", "y", " chunk", " k", "hl", "cho", "hr", " sc", " channel", "cp", "chn", "br", "cl", "i", "arch", "chat", "bt", " err", "col", " Ch", " sch", "sh", "ich", "chan", " c", " count", "z", " chip"], "win": ["draw", "mn", "ln", "window", "wal", "ns", "wp", "wid", "end", "pen", "wx", "nt", "won", "cmd", "n", "gn", "len", "Win", "on", "wn", "wt", "w", "id", "pos", "png", "out", "en", "num", "lim", "man", "fn", "reg", "windows", "local", "size", "gen", "in", "snap", "ll", "wl", "conn", "nw", "bin"]}}
{"project": "FFmpeg", "commit_id": "3932ccc472ad4f4d370dcfc1c2f574b0f3acb88c", "target": 1, "func": "static void diff_pixels_altivec(int16_t *restrict block, const uint8_t *s1,\n\n                                const uint8_t *s2, int stride)\n\n{\n\n    int i;\n\n    vec_u8 perm1 = vec_lvsl(0, s1);\n\n    vec_u8 perm2 = vec_lvsl(0, s2);\n\n    const vec_u8 zero = (const vec_u8)vec_splat_u8(0);\n\n    vec_s16 shorts1, shorts2;\n\n\n\n    for (i = 0; i < 4; i++) {\n\n        /* Read potentially unaligned pixels.\n\n         * We're reading 16 pixels, and actually only want 8,\n\n         * but we simply ignore the extras. */\n\n        vec_u8 pixl  = vec_ld(0,  s1);\n\n        vec_u8 pixr  = vec_ld(15, s1);\n\n        vec_u8 bytes = vec_perm(pixl, pixr, perm1);\n\n\n\n        // Convert the bytes into shorts.\n\n        shorts1 = (vec_s16)vec_mergeh(zero, bytes);\n\n\n\n        // Do the same for the second block of pixels.\n\n        pixl  = vec_ld(0,  s2);\n\n        pixr  = vec_ld(15, s2);\n\n        bytes = vec_perm(pixl, pixr, perm2);\n\n\n\n        // Convert the bytes into shorts.\n\n        shorts2 = (vec_s16)vec_mergeh(zero, bytes);\n\n\n\n        // Do the subtraction.\n\n        shorts1 = vec_sub(shorts1, shorts2);\n\n\n\n        // Save the data to the block, we assume the block is 16-byte aligned.\n\n        vec_st(shorts1, 0, (vec_s16 *)block);\n\n\n\n        s1    += stride;\n\n        s2    += stride;\n\n        block += 8;\n\n\n\n        /* The code below is a copy of the code above...\n\n         * This is a manual unroll. */\n\n\n\n        /* Read potentially unaligned pixels.\n\n         * We're reading 16 pixels, and actually only want 8,\n\n         * but we simply ignore the extras. */\n\n        pixl  = vec_ld(0,  s1);\n\n        pixr  = vec_ld(15, s1);\n\n        bytes = vec_perm(pixl, pixr, perm1);\n\n\n\n        // Convert the bytes into shorts.\n\n        shorts1 = (vec_s16)vec_mergeh(zero, bytes);\n\n\n\n        // Do the same for the second block of pixels.\n\n        pixl  = vec_ld(0,  s2);\n\n        pixr  = vec_ld(15, s2);\n\n        bytes = vec_perm(pixl, pixr, perm2);\n\n\n\n        // Convert the bytes into shorts.\n\n        shorts2 = (vec_s16)vec_mergeh(zero, bytes);\n\n\n\n        // Do the subtraction.\n\n        shorts1 = vec_sub(shorts1, shorts2);\n\n\n\n        // Save the data to the block, we assume the block is 16-byte aligned.\n\n        vec_st(shorts1, 0, (vec_s16 *)block);\n\n\n\n        s1    += stride;\n\n        s2    += stride;\n\n        block += 8;\n\n    }\n\n}\n", "idx": 8103, "substitutes": {"block": ["header", "chain", "error", "sp", "instance", "empty", "prefix", "window", "type", "pack", "offset", "box", "field", "scope", "set", "none", "file", "buffer", "base", "table", "link", "group", "zero", "row", "label", "line", "sync", "range", "index", "stop", "number", "blocking", "position", "repeat", "word", "limit", "list", "space", "byte", "board", "blocks", "device", "rest", "start", "out", "frame", "load", "part", "version", "batch", "parent", "axis", "bl", "mask", "loop", "size", "hash", "check", "lock", "Block", "length", "image"], "s1": ["ins01", "js1", "jsIP", "qs1", "S2", "stsFirst", " s03", "sts1", "s0", "js2", "s03", "ns2", "s3", "cone", "s01", "os01", "SFirst", "ins1", "sone", " s5", "c1", "SIP", "sIP", "stsIP", " s01", "ts3", "S1", "qs2", " s0", "os2", "s5", "qs01", "js03", "S0", "pass1", "S3", "nsName", "sts2", "c01", "pass2", " sone", " s3", "sFirst", "js01", "ns1", "qsone", " sName", "ins2", "pass5", "ins03", "c2", "ts1", "sName", "ts2", "Sone", "osone", "ns5", "os1", "ts01", "stsName", "jsFirst", "S01"], "s2": ["sSecond", "sSplit", "S02", "a2", "S1", "qs2", "s02", "mBlock", "rs6", "stwo", "s120", "rs2", " sblock", "s0002", "e0", "qsSplit", "s0", "s3", " s0002", "a1", "isSecond", "gs62", "mcont", "gsSecond", "s_", " s3", "sBlock", "S120", " s_", "is62", " s6", "s6", "qs3", " s120", "gs2", "osSplit", "rs1", "e3", " s02", "mblock", "os0002", "t02", "S2", "os120", "scont", "ttwo", "Stwo", "e2", " stwo", "e1", "atwo", "m_", "isBlock", "os2", "S0", "S3", "t1", "a6", "sblock", "its62", "s4", "os1", "itsSecond", "os3", " sSplit", " s4", "isblock", "qs0002", "is_", " s0", "its2", " scont", "rstwo", "S4", " sBlock", "is2", "iscont", "t2", "s62"], "stride": ["stringope", "divide", "slide", "strIDE", "STRend", "trend", "stringride", "strime", "stide", "slride", "divride", "stringide", "tride", " strope", "stringider", "slider", "strope", "stringend", " strider", "strider", "STRIDE", " strIDE", "divider", "divime", " strides", "slime", "STRider", "trider", "strend", "stIDE", "strride", "STRride", " strime", "divope", "stides", "STRides", "STRide", "trride", "strides", " strride"], "i": ["init", "counter", "ic", "ini", "q", " bi", " multi", "ci", " ii", "it", " m", "im", " x", "set", " v", "mi", "qi", "ip", "li", "p", "g", "si", "progress", "is", "iq", " t", "xi", "ind", "index", "o", " ti", "pi", " err", " e", " pos", "multi", "bi", "id", "me", "inter", "ui", "mac", " I", "out", " pi", " iter", "abi", "ti", "ix", " j", "status", "m", "ai", "I", "batch", "y", "print", " index", "sim", " k", "ex", "in", "ii", "by", "lock", "j", " self", "x", "di", " s"], "shorts1": ["shifts1", "shorterOne", "shorters1001", "shouts3", "shitches2", "shortL", "shifts5", "shorters3", "shouts2", "thortsone", "shats2", "shroups001", "shrots2", "sheorts3", "shifts2", "ushorts1001", "shortersOne", "ushorts1", "Shouts1", "short001", "whorts1", "shrets001", "shuls1", "shints1", "shopsOne", "shorts1001", "short91", "shors001", "shrets3", "ShortsOne", " shouts01", "Shouts2", "shatsOne", " short01", "shorts001", "sherets2", " shorts91", "sheorts1", "short2", "shintsone", "thopsOne", "shops5", "shouts01", "whorts3", " shops1", "shops3", "sharts1001", "shortsone", "sherets1", "shrots3", "suppitches1", "shrots9", "shorters2", "thorts3", "shorts3", "Shorts1", "shroups01", " shorts9", "shouts001", "shrots001", "usharts001", "supports2", "shorts91", "whributes3", "Shorts3", " short001", "shorter01", "shitches001", "thopsone", "shouts9", "shoutsOne", "shartsOne", "shributes3", " shouts1", "whorts001", " shorts01", "shouts1", "shrets1", "shitches1", "Shouts3", "sherets3", "suppitchesL", "usharts1001", "sharts1", "shitchesL", "shors1", "supports1", "shops1", "shifts91", "thorts1", "shints3", " short1", "short9", " shops2", "shroups1", "short1", " shops91", "supportsL", "whributes001", "thops3", " shorts5", "shintsOne", "shortsOne", "ushortsOne", " shops5", "shrots01", "shops2", "Shorts2", "shuls001", "shortsL", "ushorts001", "sharts001", "usharts1", "sheorts2", " shouts2", "sheorts001", "shors2", "shats3", "thops1", "shorters001", "shats1", "shorter001", " shorts001", "shorter1", "shopsone", "shorts9", "sherets001", "suppitches001", "shops91", "shrets2", "shorts5", "short5", "shorter3", "ShoutsOne", "shrots1", "shributes001", "shorterone", "ushartsOne", "supports001", "shributes1", " shouts9", "thortsOne", "shorsL", "shuls3", "short01", "shorts01", "shorters1", "suppitches2", "whributes1"], "shorts2": ["shiffs2", "shorts02", "shportstwo", "shbits02", "shouts2", "shops4", "shats2", "shats0", "shrots2", " shorter4", "shonds256", "ashorts2", " shorts6", " shorter2", "thortsTwo", "ashorts256", "shapes1", "shortstwo", "shports256", "shresses2", "shorters02", "thorts0", "shressestwo", "thorters2", "thorters1", "shresses256", "shorts42", " shorts02", "shorter2", "ashorts12", "shorts6", "shrotsTwo", "shorts256", "shonds2", "shorters2", "shiffs42", " shorters2", "shbits42", "shports2", "shouts4", "shorts12", "shouts1", "shouts6", "ashondstwo", "shops1", "thorts1", " shorter1", "shortersTwo", " shorts4", "shorters0", " shorters42", "shbits2", "thorters0", "ashonds12", "shorters42", "shorter4", "shresses12", "shortsTwo", "ashortstwo", "thorts2", "shops2", "shondstwo", "shorts4", "shiffs02", " shapes12", " shorts42", "shports12", "shats1", "shorter1", " shapes2", "shops6", "shatsTwo", "shapes2", " shorters02", "shrots0", " shapes1", "shresses1", "shouts12", "shorter6", "thortersTwo", "shrots1", " shorter6", "shonds12", "shapes12", " shorts12", "ashonds256", "ashonds2", "shorters1", "shorts0"]}}
{"project": "FFmpeg", "commit_id": "199d4478de102ca7987adb97f2e66a1820a98ebd", "target": 1, "func": "int ff_thread_get_buffer(AVCodecContext *avctx, AVFrame *f)\n\n{\n\n    PerThreadContext *p = avctx->thread_opaque;\n\n    int *progress, err;\n\n\n\n    f->owner = avctx;\n\n\n\n    ff_init_buffer_info(avctx, f);\n\n\n\n    if (!(avctx->active_thread_type&FF_THREAD_FRAME)) {\n\n        f->thread_opaque = NULL;\n\n        return avctx->get_buffer(avctx, f);\n\n    }\n\n\n\n    if (p->state != STATE_SETTING_UP &&\n\n        (avctx->codec->update_thread_context || (!avctx->thread_safe_callbacks &&\n\n                avctx->get_buffer != avcodec_default_get_buffer))) {\n\n        av_log(avctx, AV_LOG_ERROR, \"get_buffer() cannot be called after ff_thread_finish_setup()\\n\");\n\n        return -1;\n\n    }\n\n\n\n    pthread_mutex_lock(&p->parent->buffer_mutex);\n\n    f->thread_opaque = progress = allocate_progress(p);\n\n\n\n    if (!progress) {\n\n        pthread_mutex_unlock(&p->parent->buffer_mutex);\n\n        return -1;\n\n    }\n\n\n\n    progress[0] =\n\n    progress[1] = -1;\n\n\n\n    if (avctx->thread_safe_callbacks ||\n\n        avctx->get_buffer == avcodec_default_get_buffer) {\n\n        err = avctx->get_buffer(avctx, f);\n\n    } else {\n\n        p->requested_frame = f;\n\n        p->state = STATE_GET_BUFFER;\n\n        pthread_mutex_lock(&p->progress_mutex);\n\n        pthread_cond_signal(&p->progress_cond);\n\n\n\n        while (p->state != STATE_SETTING_UP)\n\n            pthread_cond_wait(&p->progress_cond, &p->progress_mutex);\n\n\n\n        err = p->result;\n\n\n\n        pthread_mutex_unlock(&p->progress_mutex);\n\n\n\n        if (!avctx->codec->update_thread_context)\n\n            ff_thread_finish_setup(avctx);\n\n    }\n\n\n\n    pthread_mutex_unlock(&p->parent->buffer_mutex);\n\n\n\n    return err;\n\n}\n", "idx": 8105, "substitutes": {"avctx": ["afwcs", "ajwcs", "wavcmp", "avheight", "avegp", "awctx", "avevoc", "avtmp", "avcp", "iverca", "avervoc", "ajctx", " avhistory", "avertmp", "avetimeout", "avtc", "avcontext", "aveconn", "avjac", "avhost", "averctl", "wavcfg", "averheight", "avcomp", "avecp", "avwcs", "avcfg", "evcp", "avcu", "avkt", "avergp", "awconn", "ivercu", "averctx", "wavcu", "avnp", "wavpt", "avejp", "avermsg", "averclient", "avcmd", "afctx", " avjp", "navjp", "avejac", "avconn", " avcp", "afcp", "avept", "avecomp", "aveheight", "evctx", "avecontext", "verjp", "avemsg", "navctx", "avewcs", "wavsys", "averconfig", "avhistory", "wavwcs", "avectx", "verctx", "navcu", "avetc", "wavctx", "avaddr", "wavclient", "avercomp", "avertimeout", "averhost", "evgp", "avctl", "ajtmp", "avertx", "wavcontext", "ajaddr", "awcu", "avehost", "avtimeout", "abctl", "navnp", "avca", "avpkg", "wavnp", "avesys", "iverheight", "aveca", "avtx", "aveconfig", "avclient", "avercfg", "awhost", "avgp", "ivervoc", "avercp", "abcontext", "averconn", "avecu", " avcontext", "wavcmd", "averpt", "avercu", "avercontext", "wavconn", "avvoc", " avtx", "iverctx", " avpkg", "avetmp", "avmsg", " avca", " avcfg", " avjac", "avertc", "averjp", " avctl", "wavtx", "ajpkg", "avehistory", "aveclient", "avercmp", "averjac", "avsys", "avpt", "abctx", " avsys", " avcu", "aversys", "evkt", "versys", "afcmp", "navconn", "avercmd", "avecmp", "avjp", "avetx", "navtc", "ajkt", "averwcs", "avecfg", "ivertimeout", " avcmd", "avenp", "avconfig", "abtx", "ajcp", "wavcp", "aveaddr", "verconn", "averhistory", "ivermsg", " avaddr", "avcmp", "wavconfig", "averkt", "avekt", "avepkg", "averca", "navcomp"], "f": ["cf", "form", "uf", "feat", "b", "ff", "xf", "fm", "fff", "conf", "c", "h", "fe", "field", "i", "fx", "lf", "file", "fc", "elf", "d", "g", "F", "foreign", "fl", "o", "fp", "t", "r", "w", "fer", "rf", "bf", "v", "fac", "far", "ef", "df", "frame", "fa", "fn", "fb", "tf", "sf", "fi", "fs", "fo", "ft", "e", "fr", "j", "z", "fd", "fw"], "p": ["policy", "pid", "c", "h", "pro", "ps", "d", "perm", "fp", "t", "pers", "pi", "pe", "tmp", "parent", "jp", "current", "P", "j", "post", "q", "wp", "er", "g", "op", "process", "pl", "pre", "ap", "lp", "v", "command", "m", "part", "per", "local", "parse", "np", "pp", "patch", "l", "power", "pc", "ctx", "pt", "primary", "at", "pa", "r", "pm", "pkg", "debug", "y", "admin", "mp", "sp", "b", "cp", "ping", "pb", "rep", "i", "bp", "n", "vp", "proc", "resp", "cache", "e", "tp"], "progress": ["success", "depth", "par", "result", "sofar", "wait", "mem", "gp", "step", "term", "pc", "gr", "grade", "rep", "pro", "comm", "recent", "skip", "order", "rank", "details", "good", "tr", "data", "history", "range", "r", "scale", "dr", "bar", "proc", "debug", "distance", "rest", "pr", "pkg", "summary", "iter", "tip", "properties", "priority", "dist", "complete", "req", "max", "dim", "status", "resp", "percent", "reg", "done", " Progress", "ptr", "poll", "desc", "count", "xp", "Progress", "roll", "res", "arr", "coord"], "err": ["race", "ev", "eor", "result", "error", "lr", "conf", "fee", "kr", "asm", "c", "br", "buf", "state", "mr", "msg", "exc", "er", "die", "norm", "raw", "timer", "n", "or", "cb", "usr", "ner", "fp", "errors", "r", "str", "dr", "rc", "rr", "attr", "pr", "ERROR", "ir", "iter", "cr", "try", "txt", "code", "inner", "resp", "off", "gz", "ptr", "count", "obj", "oe", "fr", "arr", "res", "Error", "warn", "l", "elt"]}}
{"project": "qemu", "commit_id": "80fb34eda099e7cc519a91e9701ab3c0262717b3", "target": 1, "func": "bool qio_task_propagate_error(QIOTask *task,\n\n                              Error **errp)\n\n{\n\n    if (task->err) {\n\n        error_propagate(errp, task->err);\n\n\n        return true;\n\n    }\n\n\n\n    return false;\n\n}", "idx": 8111, "substitutes": {"task": ["thread", "cast", "form", "chain", "setup", "call", "job", "run", "Task", "nt", "associated", "raw", "table", "cmd", "link", "missing", "dev", "release", "piece", "sync", "process", "future", "t", "func", "bolt", "asks", "think", "master", "commit", "start", "that", "component", "complete", "transform", "req", "trigger", "command", "worker", "load", "project", "block", "tx", "grid", "exec", "maybe", "test", "activity", "ask", "unknown", "check", "work", "journal", "problem", "tc", "rake"], "errp": ["iterpa", "errorbp", "ererpb", "diepo", "errorpb", "ererp", "ererpa", "diep", "ererpo", "errpa", "errpb", "diepb", " errbp", "errorp", "ererbp", "errbp", "iterp", " errpa", "diebp", "errpo", "iterbp", "errorpo"]}}
{"project": "FFmpeg", "commit_id": "9f61abc8111c7c43f49ca012e957a108b9cc7610", "target": 0, "func": "static void hds_free(AVFormatContext *s)\n\n{\n\n    HDSContext *c = s->priv_data;\n\n    int i, j;\n\n    if (!c->streams)\n\n        return;\n\n    for (i = 0; i < s->nb_streams; i++) {\n\n        OutputStream *os = &c->streams[i];\n\n        if (os->out)\n\n            avio_close(os->out);\n\n        os->out = NULL;\n\n        if (os->ctx && os->ctx_inited)\n\n            av_write_trailer(os->ctx);\n\n        if (os->ctx && os->ctx->pb)\n\n            av_free(os->ctx->pb);\n\n        if (os->ctx)\n\n            avformat_free_context(os->ctx);\n\n        av_free(os->metadata);\n\n        for (j = 0; j < os->nb_extra_packets; j++)\n\n            av_free(os->extra_packets[j]);\n\n        for (j = 0; j < os->nb_fragments; j++)\n\n            av_free(os->fragments[j]);\n\n        av_free(os->fragments);\n\n    }\n\n    av_freep(&c->streams);\n\n}\n", "idx": 8112, "substitutes": {"s": ["as", "rs", "gs", "ses", "b", "less", "ns", "its", "ats", "h", "qs", "cs", "p", "ps", "ms", "d", "has", "ts", "is", "ds", "eds", "t", "js", "w", "ins", "ls", "v", "stats", "m", "hs", "a", "ss", "bs", "f", "parts", "fs", "S", "sts", "aws"], "c": ["cf", "dc", "gc", "ct", "b", "cp", "conf", "wcs", "ctx", "cam", "bc", "cont", "con", "cs", "comm", "d", "cm", "co", "g", "p", "n", "ec", "nc", "cb", "o", "lc", "t", "ce", "r", "xc", "cc", "w", "coll", "cn", "v", "m", "ac", "cv", "cd", "cache", "f", "mc", "conv", "C", "e", "enc", "com", "cu", "comments", "l", "tc"], "i": ["ic", "ini", "ij", "chain", " bi", " li", "ci", "ei", " ii", " ki", "it", "im", "ori", " ni", "oi", "gi", "mi", "qi", "my", "ip", "li", "ami", "si", "ms", "zi", "n", "ie", "is", "xi", "ind", "index", "o", "ri", "pi", "bi", "multi", "me", "ui", "id", "ki", "phi", "ti", "iter", "ims", "ix", "ai", " mi", "I", "batch", "y", "print", "fi", "sim", "ex", "iu", "in", "x", "di", "ii", "l"], "j": ["dj", "ja", "ev", "ij", "q", "b", "jo", "bj", "att", "it", "jj", "job", "J", "br", "kid", "pt", "aj", "msg", "er", "p", "g", "ie", "ind", "uj", "bo", "o", "tr", "key", "jas", "jc", "js", "ax", "el", "str", "pos", "ji", "pr", "k", "ng", "oj", "try", "v", "ix", "m", "adj", "jack", "y", "jump", "jp", "jit", "je", "ju", "obj", "jl", "kj", "z", "x", "json", "di", "l", "axy"], "os": ["bytes", "des", "tes", "ori", "bos", "oS", "ps", "ts", "or", "js", "pos", "dos", "io", "otes", "obs", "ost", "mot", "ors", "ants", "ox", "ros", "Os", "ose", "uts", "op", "es", "out", "ow", "ot", "bits", "vs", "windows", "ans", "los", "us", "oids", "ks", "ows", "ops", "oss", "et", "ns", "oos", "vers", "osi", "is", "OS", "o", "osa", "oid", "aos", "bs", "fs", "boot", "rots", "oa", "eps", "sys", "ok", "mes", "yes", "ds", "css", "oes", "ones", "ui", "ls", "ols", "nos", "ims", "mos", "oses", "oops", "obj", "ions"]}}
{"project": "FFmpeg", "commit_id": "ab80d3fb3a7595db44fc143c80f8c2a3480fe28d", "target": 1, "func": "yuv2ya8_2_c(SwsContext *c, const int16_t *buf[2],\n\n            const int16_t *ubuf[2], const int16_t *vbuf[2],\n\n            const int16_t *abuf[2], uint8_t *dest, int dstW,\n\n            int yalpha, int uvalpha, int y)\n\n{\n\n    int hasAlpha = abuf[0] && abuf[1];\n\n    const int16_t *buf0  = buf[0],  *buf1  = buf[1],\n\n                  *abuf0 = hasAlpha ? abuf[0] : NULL,\n\n                  *abuf1 = hasAlpha ? abuf[1] : NULL;\n\n    int  yalpha1 = 4096 - yalpha;\n\n    int i;\n\n\n\n    for (i = 0; i < dstW; i++) {\n\n        int Y = (buf0[i * 2] * yalpha1 + buf1[i * 2] * yalpha) >> 19;\n\n        int A;\n\n\n\n        Y = av_clip_uint8(Y);\n\n\n\n        if (hasAlpha) {\n\n            A = (abuf0[i * 2] * yalpha1 + abuf1[i * 2] * yalpha) >> 19;\n\n            A = av_clip_uint8(A);\n\n        }\n\n\n\n        dest[i * 2    ] = Y;\n\n        dest[i * 2 + 1] = hasAlpha ? A : 255;\n\n    }\n\n}\n", "idx": 8124, "substitutes": {"buf0": ["bag1", "bag2", "buf12", "buff1", "buff0", "bag0", "uf2", "uf1", "buf2", "uf12", "buffer12", "uf0", "buffer2", "buff2", "bag12", "buffer1", "buffer0"], "buf1": ["buff3", "buff1", "uf3", "buff0", "uf2", "uf1", "buf2", "buffer3", "ufn", "buf3", " bufn", "uf0", "buffer2", "buffern", "buff2", "bufn", "buffer1", " buf2", "buffer0"], "abuf0": ["abff3", "labbuf0", "labuf2", "labbuf3", "abff1", "labbuf1", "abuf3", "labuff1", "abuc2", "abuff3", "abbuf3", "abuc3", "abff2", "labuf0", "abuf2", "abff0", "labuff0", "abuff0", "abuc0", "labuf1", "abbuf0", "abuff2", "abbuf1", "labbuf2", "abbuf2", "labuff3", "abuff1", "labuf3", "abuc1", "labuff2"], "abuf1": ["obuf4", "abff3", "acbuf3", "acbuf2", "abbuff4", "obbuf1", "abff1", "acuf3", "abuf4", "abbuff0", "abuf3", "abbuf3", "obuf1", "abff2", "obuf2", "acbuf1", "abuf2", "obuf0", "acbuf0", "abff0", "abuff0", "abbuf4", "abbf0", "acuf0", "acuf2", "abuff4", "abbuff2", "abbf3", "abbuf0", "obbuf4", "abuff2", "acuf1", "obbuf2", "abbuf1", "abbf1", "abbuff1", "obbuf0", "abbuf2", "abuff1", "abbf2"], "i": ["init", "this", "ic", "ini", "ij", "sp", "chain", "ei", "ci", "q", "it", "im", "cli", "gi", "mi", "qi", "ip", "li", "p", "si", "ami", "g", "zi", "n", "is", "name", "ind", "xi", "index", "o", "t", "key", "pi", "bi", "multi", "go", "ri", "me", "id", "ui", "ki", "ji", "slice", "span", "ti", "v", "Ti", "ims", "ix", "ai", "m", "status", "Index", "I", "batch", "y", "\u0438", "fi", "sim", "info", "e", "in", "iu", "point", "j", "x", "di", "ii", "l"], "A": ["SA", "BA", "At", "AA", "Alpha", "JA", "An", "AB", "AM", "TA", "EA", "U", "K", "M", "AT", "ATA", "ACC", "API", "Y", "Ar", "AU", "W", "F", "AR", "As", "AE", "PA", "Array", "D", "AF", "AN", "CA", "ACT", "V", "B", "AAA", "I", "What", "AS", "AL", "GA", "BY", "IA", "L", "P", "C", "AI", "Area", "AH", "S", "LA", "HA", "a", "AC", "G", "AP", "AV"]}}
{"project": "qemu", "commit_id": "f7b879e072ae6839b1b1d1312f48fa7f256397e2", "target": 1, "func": "static void device_unparent(Object *obj)\n\n{\n\n    DeviceState *dev = DEVICE(obj);\n\n    BusState *bus;\n\n\n\n    if (dev->realized) {\n\n        object_property_set_bool(obj, false, \"realized\", NULL);\n\n    }\n\n    while (dev->num_child_bus) {\n\n        bus = QLIST_FIRST(&dev->child_bus);\n\n        object_unparent(OBJECT(bus));\n\n    }\n\n    if (dev->parent_bus) {\n\n        bus_remove_child(dev->parent_bus, dev);\n\n        object_unref(OBJECT(dev->parent_bus));\n\n        dev->parent_bus = NULL;\n\n    }\n\n\n\n    /* Only send event if the device had been completely realized */\n\n    if (dev->pending_deleted_event) {\n\n        g_assert(dev->canonical_path);\n\n\n\n        qapi_event_send_device_deleted(!!dev->id, dev->id, dev->canonical_path,\n\n                                       &error_abort);\n\n        g_free(dev->canonical_path);\n\n        dev->canonical_path = NULL;\n\n    }\n\n}\n", "idx": 8130, "substitutes": {"obj": ["ck", "xy", "bj", "ctx", "cmp", "cont", "objects", "sys", "buf", "comm", "nt", "ob", "mk", "bh", "os", "addr", "cmd", "cb", "bo", "o", "hw", "t", "obo", "js", "go", "str", "ref", "id", "pos", "pkg", "attr", "org", "txt", "ot", "oid", "rt", "resp", "object", "bs", "Obj", "tmp", "serv", "j", "stick", "obs", "tk", "conn", "onet", "act"], "dev": ["dj", "draw", "des", "att", "conf", "prof", "DEV", "pro", "buf", "den", "det", " device", "die", "d", "addr", "w", "device", "watch", "req", "Device", "ack", "comment", "test", "de", "stick", "enc", "mem", "cam", " Dev", "ve", "nt", "prov", "go", "ow", "normal", "v", " def", "serv", "scan", " devs", "exec", "desc", "priv", "info", "patch", "ev", "attach", "end", "dem", "prop", "vol", "sd", "var", "val", "del", "tr", "hw", "dr", "adv", "debug", "rem", "van", "Dev", "build", "fail", "serial", "fo", "tech", "res", "ver", "cho", "oy", "cast", "app", "roller", "av", "cmd", "inv", "eng", "data", "err", "spec", "off", "stable", "doc", "kick", "jump", "gu", "unknown", "wd", "warn", "conn", "def", "develop"], "bus": ["ck", "bur", "chain", "hand", "buff", "way", " BUS", "back", "bc", "BUS", "box", "join", "buf", "store", "buffer", "os", "util", "Bus", "base", "sync", "used", "queue", "bolt", "bal", "zip", "pos", "bar", "board", "mount", "gate", "host", "port", "ack", "block", "driver", "bridge", "vc", "bs", "tx", "pool", "bug", "cache", "cat", "loop", "us", "boot", "lock", "stick", "hold", "loc"]}}
{"project": "qemu", "commit_id": "55e1819c509b3d9c10a54678b9c585bbda13889e", "target": 0, "func": "QBool *qbool_from_bool(bool value)\n\n{\n\n    QBool *qb;\n\n\n\n    qb = g_malloc(sizeof(*qb));\n\n    qb->value = value;\n\n    QOBJECT_INIT(qb, &qbool_type);\n\n\n\n    return qb;\n\n}\n", "idx": 8134, "substitutes": {"value": ["widget", "output", "update", "result", "function", "expression", "b", "instance", "power", "node", "type", "values", "field", " Value", "active", "state", "vector", "p", "val", "property", "label", "data", "key", "total", "index", "input", "w", "bit", "initial", "unit", "position", "attribute", "ue", "always", "v", "feature", "status", "python", "version", "hello", "parent", "Value", "current", "operator", "unknown", "database", "variable", "source", "VALUE", "name", "image", "object", "sequence"], "qb": ["aqb", "aqbe", "qba", "dqbb", "iqa", "qsb", " qsb", "qbe", "qcb", "dqb", "qqb", "qusb", "oxb", "queb", "sqba", " qbe", " qa", " qba", " qbb", "qqbi", "qucb", "qubo", "iqb", "iqrb", "sqbb", "aqa", " qcb", "sqcb", "qqbb", "oxbe", "quba", "oxbb", "oxeb", "qbi", "sqrb", "qbb", "qa", "sqb", "qube", "qbo", "sqbo", "aqrb", "dqbe", "qqsb", "dqeb", " qrb", " qbo", "qeb", "qub", "qrb", "iqbb", "qubb", " qbi", "aqbb", "qubi", "qurb"]}}
{"project": "qemu", "commit_id": "edf779ffccc836661a7b654d320571a6c220caea", "target": 0, "func": "static void setup_rt_frame(int usig, struct emulated_sigaction *ka, \n\n                           target_siginfo_t *info,\n\n\t\t\t   target_sigset_t *set, CPUState *env)\n\n{\n\n\tstruct rt_sigframe *frame = get_sigframe(ka, env, sizeof(*frame));\n\n\tint err = 0;\n\n\n\n#if 0\n\n\tif (!access_ok(VERIFY_WRITE, frame, sizeof (*frame)))\n\n            return 1;\n\n#endif\n\n\t__put_user_error(&frame->info, (target_ulong *)&frame->pinfo, err);\n\n\t__put_user_error(&frame->uc, (target_ulong *)&frame->puc, err);\n\n\terr |= copy_siginfo_to_user(&frame->info, info);\n\n\n\n\t/* Clear all the bits of the ucontext we don't use.  */\n\n\terr |= __clear_user(&frame->uc, offsetof(struct ucontext, uc_mcontext));\n\n\n\n\terr |= setup_sigcontext(&frame->uc.uc_mcontext, /*&frame->fpstate,*/\n\n\t\t\t\tenv, set->sig[0]);\n\n\terr |= __copy_to_user(&frame->uc.uc_sigmask, set, sizeof(*set));\n\n\n\n\tif (err == 0)\n\n\t\terr = setup_return(env, ka, &frame->retcode, frame, usig);\n\n\n\n\tif (err == 0) {\n\n\t\t/*\n\n\t\t * For realtime signals we must also set the second and third\n\n\t\t * arguments for the signal handler.\n\n\t\t *   -- Peter Maydell <pmaydell@chiark.greenend.org.uk> 2000-12-06\n\n\t\t */\n\n            env->regs[1] = (target_ulong)frame->pinfo;\n\n            env->regs[2] = (target_ulong)frame->puc;\n\n\t}\n\n\n\n        //\treturn err;\n\n}\n", "idx": 8145, "substitutes": {"usig": ["usesigs", "cusigma", "usigs", "cusag", "rusiss", "usesiss", "cusigs", " usag", "rusig", "usesigma", "useg", "usesag", "ruseg", "cusig", "usiss", "usigma", "usesig", " usiss", "usag", " usigma", " useg", " usigs", "useseg", "rusigs"], "ka": ["ck", "ema", "kas", "ja", "km", "kr", "eta", "ctx", "kt", "ku", "kk", "ma", "arma", "kat", "ta", "te", "ami", "ker", "ica", "ak", "ke", "ski", "kl", "ki", "KA", "k", "qa", "sk", "ket", "sa", "ko", "ca", "aka", "Ka", "ks", "ha", "gha", "tk"], "info": ["init", "about", "user", " fi", "afi", "information", "ci", "mem", "metadata", "conf", "Info", "ctx", "http", "prof", "i", "recent", "mi", "ip", "si", "stat", "dict", "is", "name", "aux", "tif", "data", " inf", "hi", "history", "rc", "id", "ui", "ki", "inter", "py", "ti", "iter", "txt", "INFO", "inf", "iso", "rt", "meta", "now", "ist", "local", "doc", "priv", "f", "fi", "fo", "check", "text", "auth", "json", "ro", "ii", "def", "loc"], "set": ["init", "result", "et", "error", "setup", "call", "sett", "end", "step", "c", "ctx", "pack", "site", "get", "store", "con", "sc", "state", "msg", "map", "mark", "p", "util", "add", "equal", "use", "Set", "context", "un", "data", "ce", "se", "t", "ut", "push", "sche", "to", "list", "section", "start", "out", "en", "eq", "sh", "reset", "m", "spec", "st", "clear", "ch", "block", "session", "test", "size", "ex", "check", "setting", "SET", "act"], "env": ["init", "db", "ev", "et", "esc", "ei", "sw", "mem", "window", "end", "ov", "ctx", "here", "neck", "den", "conn", "buf", "sc", "self", "store", "buffer", "msg", "er", "te", "erd", "addr", "cmd", "dev", "ec", "ew", "viron", "enter", "context", "environment", "eng", "cb", "vp", "hw", "server", "ner", "err", "stack", "gear", "Environment", "proc", "en", "org", "v", "nv", "ote", "worker", "vs", "ptr", "cv", "exec", "priv", "vt", "obj", "message", "e", "enc", "esm", "ten"], "frame": ["draw", "event", "function", "chain", "step", "iframe", "state", "file", "flow", "ce", "queue", "trace", "word", "module", "role", "iter", "req", "reset", "request", " Frame", "fb", "message", "face", "ence", "feat", "next", "join", "base", "zone", "zero", "context", "process", "reason", "code", "command", "load", "ze", "version", "remote", "time", "one", "ace", "header", "cf", "error", "channel", "Frame", "type", "ctx", "fe", "force", "scene", "dict", "line", "style", "processor", "za", "response", "session", "fi", "AME", "fr", "object", "init", "user", "thread", "cast", "rame", "call", "node", "window", "term", "framework", "none", "profile", "cmd", "frames", "row", "cause", "data", "err", "me", "ref", "commit", "wall", "component", "feature", "new", "block", "shot", "doc", "rule", "f", "point", "e", "lock", "tick", "def", "image", "condition", "sequence"]}}
{"project": "qemu", "commit_id": "25e6a11832bcd0715068f0cc24fb46ec03de676e", "target": 1, "func": "static void spapr_phb_placement(sPAPRMachineState *spapr, uint32_t index,\n\n                                uint64_t *buid, hwaddr *pio,\n\n                                hwaddr *mmio32, hwaddr *mmio64,\n\n                                unsigned n_dma, uint32_t *liobns, Error **errp)\n\n{\n\n    /*\n\n     * New-style PHB window placement.\n\n     *\n\n     * Goals: Gives large (1TiB), naturally aligned 64-bit MMIO window\n\n     * for each PHB, in addition to 2GiB 32-bit MMIO and 64kiB PIO\n\n     * windows.\n\n     *\n\n     * Some guest kernels can't work with MMIO windows above 1<<46\n\n     * (64TiB), so we place up to 31 PHBs in the area 32TiB..64TiB\n\n     *\n\n     * 32TiB..(33TiB+1984kiB) contains the 64kiB PIO windows for each\n\n     * PHB stacked together.  (32TiB+2GiB)..(32TiB+64GiB) contains the\n\n     * 2GiB 32-bit MMIO windows for each PHB.  Then 33..64TiB has the\n\n     * 1TiB 64-bit MMIO windows for each PHB.\n\n     */\n\n    const uint64_t base_buid = 0x800000020000000ULL;\n\n    const int max_phbs =\n\n        (SPAPR_PCI_LIMIT - SPAPR_PCI_BASE) / SPAPR_PCI_MEM64_WIN_SIZE - 1;\n\n    int i;\n\n\n\n    /* Sanity check natural alignments */\n\n    QEMU_BUILD_BUG_ON((SPAPR_PCI_BASE % SPAPR_PCI_MEM64_WIN_SIZE) != 0);\n\n    QEMU_BUILD_BUG_ON((SPAPR_PCI_LIMIT % SPAPR_PCI_MEM64_WIN_SIZE) != 0);\n\n    QEMU_BUILD_BUG_ON((SPAPR_PCI_MEM64_WIN_SIZE % SPAPR_PCI_MEM32_WIN_SIZE) != 0);\n\n    QEMU_BUILD_BUG_ON((SPAPR_PCI_MEM32_WIN_SIZE % SPAPR_PCI_IO_WIN_SIZE) != 0);\n\n    /* Sanity check bounds */\n\n    QEMU_BUILD_BUG_ON((max_phbs * SPAPR_PCI_IO_WIN_SIZE) > SPAPR_PCI_MEM32_WIN_SIZE);\n\n    QEMU_BUILD_BUG_ON((max_phbs * SPAPR_PCI_MEM32_WIN_SIZE) > SPAPR_PCI_MEM64_WIN_SIZE);\n\n\n\n    if (index >= max_phbs) {\n\n        error_setg(errp, \"\\\"index\\\" for PAPR PHB is too large (max %u)\",\n\n                   max_phbs - 1);\n\n        return;\n\n    }\n\n\n\n    *buid = base_buid + index;\n\n    for (i = 0; i < n_dma; ++i) {\n\n        liobns[i] = SPAPR_PCI_LIOBN(index, i);\n\n    }\n\n\n\n    *pio = SPAPR_PCI_BASE + index * SPAPR_PCI_IO_WIN_SIZE;\n\n    *mmio32 = SPAPR_PCI_BASE + (index + 1) * SPAPR_PCI_MEM32_WIN_SIZE;\n\n    *mmio64 = SPAPR_PCI_BASE + (index + 1) * SPAPR_PCI_MEM64_WIN_SIZE;\n\n}\n", "idx": 8154, "substitutes": {"spapr": ["spapar", "spipR", " spipR", " spapcr", "spipr", "spmapar", " spapR", " spapar", "spapscr", "spmapr", "spipcr", "spapsR", "spapsar", "spapcr", "spipar", " spipar", "spmapcr", "spapR", " spipr", "spmapR", " spipcr", "spapsr"], "index": ["open", "negative", "loc", "error", "instance", "prefix", "type", "offset", "find", "page", "active", "cycle", "buffer", "si", "IND", "connection", "n", "location", "link", "document", "ind", "row", "pointer", "context", "key", "height", "input", "number", "value", "position", "connect", "slice", "pos", "id", "style", "level", "timeout", "max", "iter", "num", "handle", "device", "status", "config", "block", "Index", "scan", "version", "batch", "doc", "axis", "capacity", "address", "count", "loop", "test", "size", "info", "in", "point", "length", "lock", "j", "x", "path"], "buid": ["bufId", "bupid", "guid", "guID", "buId", "buit", "baid", "guId", "bapid", "uuid", "bufids", "buID", "bait", "boit", "uuids", "bopid", "buids", "bufID", "boid", "uuId", "uuID", "guids", "uupid", "uuit", "bufid"], "pio": ["Pios", "cpico", "lpio", "Pio", "Pico", "apio", "pico", "jpiop", "apIO", "cpios", "lpIO", "apiol", "piop", "PIO", "jpio", "piol", "apiop", " piop", "lpios", "lpico", "cpio", "pios", " piol", " pIO", "jpiol", "pIO", "cpIO", "jpIO"], "mmio32": [" mmio256", " mmios256", " mmios4", "mmios64", " mmio4", "mmio256", "mmIO32", " mmios32", "mmi4", "mmio4", "mmi32", "mmi64", "mmIO4", "mmios4", " mmios64", "mmios256", "mmi256", "mmios32", "mmIO64", "mmIO256"], "mmio64": ["mmorg64", "mmio63", "mmIO63", "mio64", "mmi63", "mmIO32", "mio63", "mi64", "mmorg63", "mi63", "mio32", "mmi32", "mmi64", "mi32", "mmIO64", "mmorg32"], "n_dma": ["n_daMA", "n__dmad", "n_fMA", "n_fmas", "n_didmad", "n_mna", "n__mmas", "n_damas", "n_dms", "n_mMA", "n_fma", "n_dmad", "n_didms", "n_fmad", "n_dMA", "n__dma", "n_dmas", "n__mms", "n_dana", "n_mmad", "n__dms", "n_mms", "n_fms", "n_dama", "n_didma", "n__dmas", "n_mmas", "n_didmas", "n__mma", "n_fna", "n_dna", "n__mmad", "n_mma"], "liobns": ["liobcs", "lioblds", "liognos", "liobbses", "Liabnos", "Liobnos", "Liobbnos", "Liobds", "Liobvs", "liobscs", "liombcs", "liogvs", "liabns", "Liobbses", "liabds", "liobsns", "liombses", "liobbcs", "liobsses", "lioblnos", "liobbns", "liabnos", "Liabvs", "liombnos", "liobds", "liobbnos", "liogds", "Liobcs", "liabvs", "liobvs", "Liobbcs", "liobnos", "Liobbns", "liogns", "Liobns", "Liabds", "liobses", "liombns", "lioblvs", "Liabns", "liobsnos", "lioblns", "Liobses"], "errp": ["derp", "derpc", "erpa", "derpa", "rrP", "erp", "errpc", " errm", "errr", "errpa", "rrp", "erpc", "err", "rrpa", "Erp", "errP", "erm", " errr", "Err", "derP", "rrpc", "Erm", "errm", "erP"], "i": [" ind", "ic", "ini", "ij", "ico", " bi", "ci", " ii", "it", " m", "im", " x", "yi", "gi", "mi", "qi", "ip", "li", "ami", "si", "p", " n", "n", "zi", "ms", "is", "ind", "xi", " ti", "hi", "pi", " pos", "multi", "bi", "ri", "ui", "id", " I", "phi", "ti", "iter", " iter", "ims", "ix", " j", "ai", "m", "port", "Index", "I", "y", "\u0438", "sim", " k", "iu", "in", "gu", "info", "j", "x", "di", "ii", "l"]}}
{"project": "qemu", "commit_id": "fb6971c110387cf597b58c411658e3d15cc6c6fb", "target": 1, "func": "static void ppc405ep_compute_clocks (ppc405ep_cpc_t *cpc)\n\n{\n\n    uint32_t CPU_clk, PLB_clk, OPB_clk, EBC_clk, MAL_clk, PCI_clk;\n\n    uint32_t UART0_clk, UART1_clk;\n\n    uint64_t VCO_out, PLL_out;\n\n    int M, D;\n\n\n\n    VCO_out = 0;\n\n    if ((cpc->pllmr[1] & 0x80000000) && !(cpc->pllmr[1] & 0x40000000)) {\n\n        M = (((cpc->pllmr[1] >> 20) - 1) & 0xF) + 1; /* FBMUL */\n\n#ifdef DEBUG_CLOCKS_LL\n\n        printf(\"FBMUL %01\" PRIx32 \" %d\\n\", (cpc->pllmr[1] >> 20) & 0xF, M);\n\n#endif\n\n        D = 8 - ((cpc->pllmr[1] >> 16) & 0x7); /* FWDA */\n\n#ifdef DEBUG_CLOCKS_LL\n\n        printf(\"FWDA %01\" PRIx32 \" %d\\n\", (cpc->pllmr[1] >> 16) & 0x7, D);\n\n#endif\n\n        VCO_out = cpc->sysclk * M * D;\n\n        if (VCO_out < 500000000UL || VCO_out > 1000000000UL) {\n\n            /* Error - unlock the PLL */\n\n            printf(\"VCO out of range %\" PRIu64 \"\\n\", VCO_out);\n\n#if 0\n\n            cpc->pllmr[1] &= ~0x80000000;\n\n            goto pll_bypass;\n\n#endif\n\n        }\n\n        PLL_out = VCO_out / D;\n\n        /* Pretend the PLL is locked */\n\n        cpc->boot |= 0x00000001;\n\n    } else {\n\n#if 0\n\n    pll_bypass:\n\n#endif\n\n        PLL_out = cpc->sysclk;\n\n        if (cpc->pllmr[1] & 0x40000000) {\n\n            /* Pretend the PLL is not locked */\n\n            cpc->boot &= ~0x00000001;\n\n        }\n\n    }\n\n    /* Now, compute all other clocks */\n\n    D = ((cpc->pllmr[0] >> 20) & 0x3) + 1; /* CCDV */\n\n#ifdef DEBUG_CLOCKS_LL\n\n    printf(\"CCDV %01\" PRIx32 \" %d\\n\", (cpc->pllmr[0] >> 20) & 0x3, D);\n\n#endif\n\n    CPU_clk = PLL_out / D;\n\n    D = ((cpc->pllmr[0] >> 16) & 0x3) + 1; /* CBDV */\n\n#ifdef DEBUG_CLOCKS_LL\n\n    printf(\"CBDV %01\" PRIx32 \" %d\\n\", (cpc->pllmr[0] >> 16) & 0x3, D);\n\n#endif\n\n    PLB_clk = CPU_clk / D;\n\n    D = ((cpc->pllmr[0] >> 12) & 0x3) + 1; /* OPDV */\n\n#ifdef DEBUG_CLOCKS_LL\n\n    printf(\"OPDV %01\" PRIx32 \" %d\\n\", (cpc->pllmr[0] >> 12) & 0x3, D);\n\n#endif\n\n    OPB_clk = PLB_clk / D;\n\n    D = ((cpc->pllmr[0] >> 8) & 0x3) + 2; /* EPDV */\n\n#ifdef DEBUG_CLOCKS_LL\n\n    printf(\"EPDV %01\" PRIx32 \" %d\\n\", (cpc->pllmr[0] >> 8) & 0x3, D);\n\n#endif\n\n    EBC_clk = PLB_clk / D;\n\n    D = ((cpc->pllmr[0] >> 4) & 0x3) + 1; /* MPDV */\n\n#ifdef DEBUG_CLOCKS_LL\n\n    printf(\"MPDV %01\" PRIx32 \" %d\\n\", (cpc->pllmr[0] >> 4) & 0x3, D);\n\n#endif\n\n    MAL_clk = PLB_clk / D;\n\n    D = (cpc->pllmr[0] & 0x3) + 1; /* PPDV */\n\n#ifdef DEBUG_CLOCKS_LL\n\n    printf(\"PPDV %01\" PRIx32 \" %d\\n\", cpc->pllmr[0] & 0x3, D);\n\n#endif\n\n    PCI_clk = PLB_clk / D;\n\n    D = ((cpc->ucr - 1) & 0x7F) + 1; /* U0DIV */\n\n#ifdef DEBUG_CLOCKS_LL\n\n    printf(\"U0DIV %01\" PRIx32 \" %d\\n\", cpc->ucr & 0x7F, D);\n\n#endif\n\n    UART0_clk = PLL_out / D;\n\n    D = (((cpc->ucr >> 8) - 1) & 0x7F) + 1; /* U1DIV */\n\n#ifdef DEBUG_CLOCKS_LL\n\n    printf(\"U1DIV %01\" PRIx32 \" %d\\n\", (cpc->ucr >> 8) & 0x7F, D);\n\n#endif\n\n    UART1_clk = PLL_out / D;\n\n#ifdef DEBUG_CLOCKS\n\n    printf(\"Setup PPC405EP clocks - sysclk %\" PRIu32 \" VCO %\" PRIu64\n\n           \" PLL out %\" PRIu64 \" Hz\\n\", cpc->sysclk, VCO_out, PLL_out);\n\n    printf(\"CPU %\" PRIu32 \" PLB %\" PRIu32 \" OPB %\" PRIu32 \" EBC %\" PRIu32\n\n           \" MAL %\" PRIu32 \" PCI %\" PRIu32 \" UART0 %\" PRIu32\n\n           \" UART1 %\" PRIu32 \"\\n\",\n\n           CPU_clk, PLB_clk, OPB_clk, EBC_clk, MAL_clk, PCI_clk,\n\n           UART0_clk, UART1_clk);\n\n#endif\n\n    /* Setup CPU clocks */\n\n    clk_setup(&cpc->clk_setup[PPC405EP_CPU_CLK], CPU_clk);\n\n    /* Setup PLB clock */\n\n    clk_setup(&cpc->clk_setup[PPC405EP_PLB_CLK], PLB_clk);\n\n    /* Setup OPB clock */\n\n    clk_setup(&cpc->clk_setup[PPC405EP_OPB_CLK], OPB_clk);\n\n    /* Setup external clock */\n\n    clk_setup(&cpc->clk_setup[PPC405EP_EBC_CLK], EBC_clk);\n\n    /* Setup MAL clock */\n\n    clk_setup(&cpc->clk_setup[PPC405EP_MAL_CLK], MAL_clk);\n\n    /* Setup PCI clock */\n\n    clk_setup(&cpc->clk_setup[PPC405EP_PCI_CLK], PCI_clk);\n\n    /* Setup UART0 clock */\n\n    clk_setup(&cpc->clk_setup[PPC405EP_UART0_CLK], UART0_clk);\n\n    /* Setup UART1 clock */\n\n    clk_setup(&cpc->clk_setup[PPC405EP_UART1_CLK], UART1_clk);\n\n}\n", "idx": 8155, "substitutes": {"cpc": ["cmpce", "pcc", "copsc", "codcc", "httpcin", "cmpcu", "cppf", "gpcat", "cmpcache", "copac", "cppac", "cmpu", "pxc", "pccs", " cpcache", "podcl", "cmpsc", "phpc", "pcs", "pcu", "copce", "cpac", "copn", "phpac", " cpcu", "cmpac", "copcin", "cpcat", "cpcon", "portunc", "pxnc", "cpt", "httpcc", "cpcall", "cvcat", "gpcon", "gpc", " cpcc", "copfc", "cmpn", " cpca", "pxcall", "cmpcl", "cpn", "pccc", " cpx", " cpcs", "privrc", "privcat", "privc", " cpnc", " cpu", "codcall", "cpcl", "ppc", "pirc", "copcache", "pxcache", "cvc", "cpuce", "portcat", "pircall", "httpac", "copcall", "codc", "cpsc", "ippc", "cmpf", "ypcs", "privfc", "cpcache", "cmpfc", "ippcon", "httpcu", "cpnc", "ypc", "portc", "cpf", "pc", "cpunc", "cpcc", "codcin", "cvf", "pt", "cmpc", "cmpct", "cpfc", "cpcs", "cpx", "cpcin", "gpunc", "cpucin", "cpucl", "pccu", "pxcin", "ypu", "pxct", "cmpt", "ypca", " cprc", "cppu", "pxcu", "podcin", "ippcat", "copcu", "phpu", "phpcu", "cpuc", "cppsc", "httpc", "copct", "cmpcin", "httpcall", "pxac", "podc", "cvcu", " cpcin", "ppcc", "pircache", "pxrc", "cpct", " cpn", "cmpcat", " cpt", "cppcu", "cpca", "cprc", "cpcu", "pcca", "cmprc", "podfc", "ippunc", "cmpnc", "copc", "cpun", "pcache", "cpufc", "copf", "cpce", " cpce", "ppcu", "copx", "cppct", "cmpcs", "cpu", "portcon", "copcat", "ppcs", " cpcall", "cppc", "coprc", "cpucu", "pirct", "cmpx"], "CPU_clk": ["CPU_toolks", "CPU2clan", "CPU_toolck", "CPU2blan", "CPU_blks", "CPU_clck", "CPU2clks", "CPU_clks", "CPU_blan", "CPU2blks", "CPU_toolan", "CPU2clk", "CPU2blck", "CPU_blck", "CPU_toolk", "CPU_clan", "CPU_blk", "CPU2clck", "CPU2blk"], "PLB_clk": ["PLB_seqk", "PLB_blk", "PLB_hlka", "PLB_seqkr", "PLB_blkr", "PLB_clkr", "PLB_clck", "PLB_clka", "PLB_seqck", "PLB_hlck", "PLB_blck", "PLB_hlkr", "PLB_blka", "PLB_seqka", "PLB_hlk"], "OPB_clk": ["OPB_clks", "OPB_blck", "OPB_blks", "OPB_plck", "OPB_colark", "OPB_blark", "OPB_plks", "OPB_plk", "OPB_plark", "OPB_colck", "OPB_blk", "OPB_clark", "OPB_colks", "OPB_colk", "OPB_clck"], "EBC_clk": ["EBC_llak", "EBC_chak", "EBC_llK", "EBC_chK", "EBC_llk", "EBC_clK", "EBC_blk", "EBC_chk", "EBC_blak", "EBC_chck", "EBC_blK", "EBC_clak", "EBC_blck", "EBC_clck", "EBC_llck"], "MAL_clk": ["MAL_blk", "MAL_clkk", "MAL_blck", "MAL_blkk", "MAL_flck", "MAL_clck", "MAL_flkg", "MAL_llk", "MAL_flkk", "MAL_blkg", "MAL_flk", "MAL_llkk", "MAL_llkg", "MAL_clkg", "MAL_llck"], "PCI_clk": ["PCI_sltk", "PCI_plik", "PCI_Cltk", "PCI_Clk", "PCI_Clkk", "PCI_slk", "PCI_slkk", "PCI_cltk", "PCI_pltk", "PCI_plkk", "PCI_plk", "PCI_slik", "PCI_clik", "PCI_Clik", "PCI_clkk"], "UART0_clk": ["UART0_glks", "UART0_clck", "UART0_clc", "UART0_clks", "UART0_plk", "UART0_plks", "UART0_glc", "UART0_glk", "UART0_glck", "UART0_blc", "UART0_blks", "UART0_blk", "UART0_blck", "UART0_plc", "UART0_plck"], "UART1_clk": ["UART1_blk", "UART1_shck", "UART1_clkt", "UART1_clck", "UART1_shk", "UART1_blck", "UART1_shkt", "UART1_blkt"], "VCO_out": ["VCo_out", "Vco_off", "VCO_co", "VCO_int", "VCO1output", "VCo_OUT", "VCO2out", "VLC_err", "VCOxnew", "VCOxin", "VLC_out", "VCO_Out", "VCO_off", "VLC_output", "VCO_new", "VCOvaloutput", "VCO2output", "VCOxout", "VCo_handle", "VCOJco", "Vco_out", "VCO_output", "VCO1in", "Vco_new", "VCO_msg", "VCOvalhandle", "VCOvalin", "VLC_in", "Vco_int", "VCO1handle", "VCO2co", "VCO2in", "VCO1out", "VCO_gen", "VCO_in", "VCOvalout", "VCOJoutput", "VCO_err", "VCo_output", "VLC_OUT", "VCOJout", "VCO_handle", "VLC_co", "VCo_gen", "VCo_in", "VCOxoff", "VCOJin", "Vco_in", "VCO_OUT"], "PLL_out": ["PLL___output", "Pll_Out", "Pll_in", "PLL___out", "PLL___cmd", "Pll_cmd", "Pll_out", "PLL_in", "Pll___out", "Pll___output", "PLL_cmd", "Pll_err", "PLL_Out", "Pll_output", "PLL_err", "Pll___cmd", "PLL_output"], "M": ["NM", "MM", "MIT", "MX", "J", "AM", "CM", "T", "U", "K", "MER", "MS", "F", "MED", "Met", "RM", "MAT", "ALL", "TM", "N", "LM", "MO", "MT", "m", "MU", "V", "B", "I", "R", "MN", "L", "P", "MA", "MI", "MC", "C", "DM", "S", "H", "MD", "MAN", "O", "E"], "D": ["DIV", "Den", "LD", "DF", "DO", "T", "U", "Y", "K", "DC", "d", "A", "W", "AND", "F", "Z", "And", "DIR", "DN", "Q", "N", "DR", "Dir", "PD", "DE", "DA", "DD", "DL", "Ds", "V", "Do", "B", "R", "I", "DX", "DS", "FD", "L", "DP", "P", "DT", "C", "DM", "S", "O", "H", "MD", "E", "DB", "DI", "G"]}}
{"project": "FFmpeg", "commit_id": "e6bc38fd49c94726b45d5d5cc2b756ad8ec49ee0", "target": 1, "func": "av_cold void ff_wmv2_common_init(Wmv2Context * w){\n\n    MpegEncContext * const s= &w->s;\n\n\n\n    ff_init_scantable(s->dsp.idct_permutation, &w->abt_scantable[0], ff_wmv2_scantableA);\n\n    ff_init_scantable(s->dsp.idct_permutation, &w->abt_scantable[1], ff_wmv2_scantableB);\n\n}\n", "idx": 8157, "substitutes": {"w": ["aw", "sw", "mem", "window", "wp", "wal", "wa", "c", "wcs", "wx", "we", "p", "d", "W", "words", "rew", "wr", "WC", "wb", "hw", "wt", "rw", "t", "temp", "r", "wu", "lang", "tw", "word", "CW", "kw", "wine", "v", "man", "m", "writer", "config", "wi", "wo", "wh", "ex", "z", "wl", "wd", "a", "nw", "fw"], "s": ["rs", "gs", "ses", "b", "ns", "conf", "c", "u", "wcs", "h", "acs", "ats", "sam", "aws", "i", "sys", " inputs", "qs", "cs", "comm", "self", "os", "d", "g", "ms", "p", "n", "is", "ts", "ds", "o", "t", " ts", "r", "js", "ins", "sv", "ls", "span", "sb", "ess", "v", "ims", "stats", "m", "spec", "hs", "sa", "ss", "serv", "south", "sq", "session", "fs", "ex", "e", "S", "sts", "res", "a", "oss"]}}
{"project": "qemu", "commit_id": "2e50326c44c802ca9b9d591341085e49208927be", "target": 1, "func": "void tap_fd_set_offload(int fd, int csum, int tso4,\n                        int tso6, int ecn, int ufo)\n{\n    unsigned int offload = 0;\n    if (csum) {\n        offload |= TUN_F_CSUM;\n        if (tso4)\n            offload |= TUN_F_TSO4;\n        if (tso6)\n            offload |= TUN_F_TSO6;\n        if ((tso4 || tso6) && ecn)\n            offload |= TUN_F_TSO_ECN;\n        if (ufo)\n            offload |= TUN_F_UFO;\n    if (ioctl(fd, TUNSETOFFLOAD, offload) != 0) {\n        offload &= ~TUN_F_UFO;\n        if (ioctl(fd, TUNSETOFFLOAD, offload) != 0) {\n            fprintf(stderr, \"TUNSETOFFLOAD ioctl() failed: %s\\n\",\n                    strerror(errno));", "idx": 8158, "substitutes": {"fd": ["db", "cf", "pid", "ff", "dat", "ctl", "ctx", "ffff", "lf", "file", "fc", "wind", "d", "dt", "link", "bd", "sd", "gd", "ds", "ind", "dev", "fp", "ock", "id", "ud", "ino", "bf", "handle", "ix", "dd", "df", "fin", "fn", "dir", "fb", "ptr", "cd", "disk", "f", "FD", "fi", "fs", "io", "hd", "ld", "fr"], "csum": ["lsul", "cusumer", "cksumm", "ckssum", "lsumm", "cussum", "cusum", "csumer", "dsum", "cksnum", "dssum", "csul", "dsumm", "cksumer", "cksum", "lsumer", "cssum", "lssum", "csumm", "dsnum", "lsnum", "csnum", "cusul", "lsum", "cksul"], "tso4": ["tico1", "temsocFour", "tsu6", "tsp44", "tso42", "tco42", "Tso42", "Tco44", "tsco8", "temsoc6", "tsofour", "tbo04", "tbofour", "tcofour", "tsp4", "temsoc4", "tso8", "tsp1", "tsoc6", "tsuFour", "temsoFour", "Tso1", "tsso04", "tso1", "tco6", "toto8", "tsp42", "tso44", "tsocFour", "tico44", "Tso4", "tscofour", "Tco42", "toto04", "tsoFour", "toto4", "tico42", "tbo4", "Tco1", "tsco4", "tco04", "Tso44", "tssofour", "totofour", "tico4", "tsco04", "tco4", "tcoFour", "tsu4", "tsoc4", "tsso8", "tbo8", "tso04", "temso4", "tco8", "temso6", "Tco4", "tco44", "tco1", "tsso4"], "tso6": ["sso8", "tiso16", "sco16", "tco8", "tsp8", "tsu6", "tco2", "tso2", "tsp6", "tsi5", "tmo5", " tno2", "tiso6", " tco6", " tno16", "tsu16", "tsp16", "tso8", " tno5", "tsi6", "tso16", "tco6", "tso5", "tiso8", "tsu5", "tno5", " tno6", " tso2", "tmo4", "tno16", " tco16", "tsi2", "sco6", "tno6", " tso5", "tmo16", "sso6", "tco16", "sco8", " tco4", "tsi16", "tco4", "tno2", "tco5", "tsu4", "tmo6", " tco5", " tso16", "sso16"], "ecn": [" eco", "acN", " ecns", "cco", "ecns", "ecc", "rcne", " ecN", "ccN", "escns", "escN", "acn", "ecN", "rcn", "ecne", "acc", "ccn", "epne", "epN", "acne", "esco", "rcN", "escn", "eco", "epc", "epn", "rcc", "ccns"], "ufo": ["fonto", "fontoa", "fonton", "dfo", "lipode", "ufon", "\u00fcoa", "fuol", "\u00fco", "fifol", "lipol", "ufol", "lipo", "dfn", "fifode", "fuo", "fifo", "ufn", "ufode", "fuode", "ufoa", "\u00fcn", "\u00fcon", "dfon", "fuor", "dfoa", "lipor", "fifor", "fontn", "ufor"]}}
{"project": "FFmpeg", "commit_id": "073c2593c9f0aa4445a6fc1b9b24e6e52a8cc2c1", "target": 1, "func": "void ff_mpeg1_encode_init(MpegEncContext *s)\n\n{\n\n    static int done=0;\n\n\n\n    common_init(s);\n\n\n\n    if(!done){\n\n        int f_code;\n\n        int mv;\n\n\tint i;\n\n\n\n        done=1;\n\n        init_rl(&rl_mpeg1);\n\n\n\n\tfor(i=0; i<64; i++)\n\n\t{\n\n\t\tmpeg1_max_level[0][i]= rl_mpeg1.max_level[0][i];\n\n\t\tmpeg1_index_run[0][i]= rl_mpeg1.index_run[0][i];\n\n\t}\n\n        \n\n        init_uni_ac_vlc(&rl_mpeg1, uni_mpeg1_ac_vlc_bits, uni_mpeg1_ac_vlc_len);\n\n\n\n\t/* build unified dc encoding tables */\n\n\tfor(i=-255; i<256; i++)\n\n\t{\n\n\t\tint adiff, index;\n\n\t\tint bits, code;\n\n\t\tint diff=i;\n\n\n\n\t\tadiff = ABS(diff);\n\n\t\tif(diff<0) diff--;\n\n\t\tindex = av_log2(2*adiff);\n\n\n\n\t\tbits= vlc_dc_lum_bits[index] + index;\n\n\t\tcode= (vlc_dc_lum_code[index]<<index) + (diff & ((1 << index) - 1));\n\n\t\tmpeg1_lum_dc_uni[i+255]= bits + (code<<8);\n\n\t\t\n\n\t\tbits= vlc_dc_chroma_bits[index] + index;\n\n\t\tcode= (vlc_dc_chroma_code[index]<<index) + (diff & ((1 << index) - 1));\n\n\t\tmpeg1_chr_dc_uni[i+255]= bits + (code<<8);\n\n\t}\n\n\n\n        mv_penalty= av_mallocz( sizeof(uint8_t)*(MAX_FCODE+1)*(2*MAX_MV+1) );\n\n\n\n        for(f_code=1; f_code<=MAX_FCODE; f_code++){\n\n            for(mv=-MAX_MV; mv<=MAX_MV; mv++){\n\n                int len;\n\n\n\n                if(mv==0) len= mbMotionVectorTable[0][1];\n\n                else{\n\n                    int val, bit_size, range, code;\n\n\n\n                    bit_size = f_code - 1;\n\n                    range = 1 << bit_size;\n\n\n\n                    val=mv;\n\n                    if (val < 0) \n\n                        val = -val;\n\n                    val--;\n\n                    code = (val >> bit_size) + 1;\n\n                    if(code<17){\n\n                        len= mbMotionVectorTable[code][1] + 1 + bit_size;\n\n                    }else{\n\n                        len= mbMotionVectorTable[16][1] + 2 + bit_size;\n\n                    }\n\n                }\n\n\n\n                mv_penalty[f_code][mv+MAX_MV]= len;\n\n            }\n\n        }\n\n        \n\n\n\n        for(f_code=MAX_FCODE; f_code>0; f_code--){\n\n            for(mv=-(8<<f_code); mv<(8<<f_code); mv++){\n\n                fcode_tab[mv+MAX_MV]= f_code;\n\n            }\n\n        }\n\n    }\n\n    s->me.mv_penalty= mv_penalty;\n\n    s->fcode_tab= fcode_tab;\n\n    if(s->codec_id == CODEC_ID_MPEG1VIDEO){\n\n        s->min_qcoeff=-255;\n\n        s->max_qcoeff= 255;\n\n    }else{\n\n        s->min_qcoeff=-2047;\n\n        s->max_qcoeff= 2047;\n\n    }\n\n    s->intra_ac_vlc_length=\n\n    s->inter_ac_vlc_length=\n\n    s->intra_ac_vlc_last_length=\n\n    s->inter_ac_vlc_last_length= uni_mpeg1_ac_vlc_len;\n\n}\n", "idx": 8169, "substitutes": {"s": ["as", "rs", "gs", "ses", "b", "sg", "ns", "c", "ctx", "ats", "cs", "sc", "p", "ps", "n", "ts", "ds", "o", "es", "js", "sv", "sb", "v", "ims", "m", "ss", "bs", "sq", "fs", "e", "S", "sts", "a"], "f_code": ["f_ode", "faccod", "f2codes", " f2code", "f2code", " f_codes", " f2cod", "f2cod", " f_coe", " f_desc", "fbewcod", "faccodes", "f_cd", "fmydesc", "fbewcd", "f__cd", " f2codes", "f_codes", "f_no", " f_no", "fb_code", "f_coe", "f_desc", "fewcode", "fb_cd", " f_ode", "f__no", "f_cod", "faccode", "fb_cod", "fb_no", "fewno", "fmycode", "f__cod", "fewcd", "fewcod", "fmyode", " f_cod", "fmyno", " f_length", "fbewno", "f_length", "f__code", "fbewcode"], "mv": ["mtv", "vv", "dmvi", "rmvi", "Mx", "vvi", " mva", "vx", "mtva", "dmov", "mf", "vmvi", "mtvi", "bvi", "rmvc", "mx", "bv", "vmv", "bV", "nov", "nvc", "nV", "rmov", "vva", "dmx", "mV", "dmv", "rmx", "rmv", "bf", "vmva", " mvc", "nv", "vmf", " mV", "mtf", " mvi", "Mv", "mvc", " mf", "mva", "mvi", "dmvc", "rmf", "dmva", " mx", "rmV", "Mvc", "mov", "dmV", "MV"], "i": ["chain", "ei", "im", "c", "gi", "zi", "ind", "t", "hi", "pi", "I", "batch", "io", "in", "j", "series", "x", "di", "this", "ic", "q", "mi", "g", "xi", "ri", "bi", "ki", "ti", "out", "v", "ai", "m", "PI", "axis", "us", "time", "info", "l", "ci", "it", "ip", "li", "p", "is", "dr", "record", "to", "mount", "y", "fi", "ii", "name", "ini", "ij", "uri", "cli", "si", "ie", "n", "multi", "me", "id", "ui", "ji", "list", "slice", "phi", "ix", "status", "print", "f", "sim", "iu", "point"], "adiff": ["dif", "odelta", "adelta", "madDiff", "adial", "edelta", " adDiff", "difference", "madIFF", "adif", "adison", "dison", "madison", "eddiff", "dDiff", "artif", "ddiff", "artifference", "ddelta", "adddiff", "odifference", "dddiff", "artelta", "ddial", " adison", "delta", "edial", "adDiff", "addiff", "odiff", "madiff", "adifference", " adIFF", "ediff", "odif", "addial", "artiff", "addelta", "adIFF", "dIFF"], "index": ["present", "open", "example", "outer", "chain", "empty", "localhost", "link", "ind", "key", "value", "query", "pos", "level", "num", "iso", "request", "parent", "loop", "test", "operator", "x", "path", "loc", "read", "success", "method", "root", "instance", "page", "vector", "seed", "zero", "bit", "position", "ion", "timeout", "out", "config", "date", "local", "axis", "address", "info", "time", "length", "update", "error", "prefix", "ctx", "offset", "find", "is", "available", "route", "style", "host", "strength", "cond", "shape", "create", "init", "all", "result", "active", "raw", "table", "n", "location", "row", "full", "height", "input", "slice", "id", "list", "ix", "status", "new", "inner", "Index", "point", "lock", "interface", "second", "condition"], "bits": ["members", "boxes", "bands", "jobs", "cod", "bytes", "fields", "odes", "bis", "gs", "chains", "points", "weights", "cells", "pieces", "bots", "items", "nets", "its", "ats", "values", "ints", "locks", "maps", "cats", "cs", "terms", "files", "actions", "pins", "bys", "lines", "details", "bugs", "settings", "fps", "issues", "bit", "js", "ins", "ls", "blocks", "plugins", "bps", "units", "stats", "keys", "tags", "outs", "checks", "codes", "bs", "parts", "heads", "flags", "boot", "changes", "rots", "ions", "faces", "bin"], "code": ["function", "c", "note", "description", "add", "link", "ce", "key", "value", "ch", "comment", "entry", "message", "test", "core", "Code", "zone", "coe", "zip", "go", "bit", "str", "reason", "rice", "be", "cd", "desc", "info", "check", "text", "ode", "header", "ci", "copy", "type", "cs", "scene", "force", "co", "try", "change", "coded", "xxx", "create", "name", "cod", "result", "magic", "cmp", "cont", "te", "cmd", "body", "xx", "data", "_", "cc", "id", "list", "mode", "new", "block", "cache", "def", "condition", "sequence"], "diff": ["fd", "result", "error", "iff", "eff", "conf", "step", "shift", "cmp", "none", "description", "exc", "extra", "d", "fix", "add", "equal", "dl", "missing", "dev", "del", " Diff", " differences", "Diff", "split", " difference", "history", "delete", "value", "slice", "ref", "pos", "inter", "added", "distance", "dx", "level", "mix", "different", "dirty", "change", "commit", "dist", "dust", "df", "config", "new", "part", "comment", "changed", "cond", "disc", "fail", "test", "sum", "comp", "length", "changes", "dis", "patch", "work", "deg", "def", "delay", "Delta"], "len": ["ln", "mem", "Len", "lf", "li", "lon", "n", "var", "t", "lan", "Length", "el", "slice", "limit", "pos", "ls", "max", "en", "lim", "iter", "lp", "num", "dim", "resp", "bl", "size", "length", "ll", "z", "nl", "il", "l", "elt", "vec"], "val": ["b", "est", "ctx", "Val", "valid", "base", "pol", "var", "label", "vals", "sel", "col", "bit", "value", "bal", "start", "v", "sec", "ch", "item", "eval", "VAL", "point", "loc"], "bit_size": [" bit_length", "bit_length", " bit_count", "bit2count", " bit_len", "bit_len", "bit2size", "bit_count", "bit2len", "bit2length"], "range": ["ange", "chain", "region", "prefix", "window", "channel", "pad", "Range", "base", "rank", "row", "label", "bound", "scale", "r", "slice", "ref", "pos", "angle", "frame", "spec", "block", "part", "axis", "mask", "shape", "loc", "bin"]}}
{"project": "FFmpeg", "commit_id": "c9f6eab184cac379c7a44d5899979165798d45d4", "target": 1, "func": "static av_cold int ac3_decode_init(AVCodecContext *avctx)\n\n{\n\n    AC3DecodeContext *s = avctx->priv_data;\n\n    s->avctx = avctx;\n\n\n\n    ff_ac3_common_init();\n\n    ac3_tables_init();\n\n    ff_mdct_init(&s->imdct_256, 8, 1, 1.0);\n\n    ff_mdct_init(&s->imdct_512, 9, 1, 1.0);\n\n    ff_kbd_window_init(s->window, 5.0, 256);\n\n    dsputil_init(&s->dsp, avctx);\n\n    ff_fmt_convert_init(&s->fmt_conv, avctx);\n\n    av_lfg_init(&s->dith_state, 0);\n\n\n\n    /* set scale value for float to int16 conversion */\n\n    s->mul_bias = 32767.0f;\n\n\n\n    /* allow downmixing to stereo or mono */\n\n    if (avctx->channels > 0 && avctx->request_channels > 0 &&\n\n            avctx->request_channels < avctx->channels &&\n\n            avctx->request_channels <= 2) {\n\n        avctx->channels = avctx->request_channels;\n\n    }\n\n    s->downmixed = 1;\n\n\n\n    /* allocate context input buffer */\n\n    if (avctx->error_recognition >= FF_ER_CAREFUL) {\n\n        s->input_buffer = av_mallocz(AC3_FRAME_BUFFER_SIZE + FF_INPUT_BUFFER_PADDING_SIZE);\n\n        if (!s->input_buffer)\n\n            return AVERROR(ENOMEM);\n\n    }\n\n\n\n    avctx->sample_fmt = AV_SAMPLE_FMT_S16;\n\n    return 0;\n\n}\n", "idx": 8171, "substitutes": {"avctx": ["avegc", "AVctx", "avdocument", "avcp", "vrctx", "ajctx", "navcookie", "vtx", "avetimeout", "wavctrl", "avcontext", "avjac", "avcam", "avcomp", "averdocument", "avedocument", "avpid", "avcfg", "devtx", "avcu", "avkt", "averctx", "wavcu", "AVcontext", "devctrl", "vanctx", "ajcu", "avcmd", "AVconn", "afctx", "devcontext", "avejac", "ajpid", "wavjac", "ajcontext", "AVaddr", "avconn", "afcp", "avecontext", "avcookie", "afcam", "navtx", "navctx", "afconn", "avectx", "wavctx", "avaddr", "avertimeout", "vancontext", "avgc", "varpid", "wavcontext", "avertx", "ajaddr", " avkw", "avecmd", "afcu", " avcookie", "avtimeout", "navcontext", " avconn", "avpkg", "vrtx", "afkw", "avtx", "vcontext", "afgc", "avercfg", "afdocument", "avergc", "avercp", "avecu", " avcontext", "aftx", "afcookie", "wavcmd", "avercu", "avercontext", "varcu", "avekw", " avdocument", " avtx", " avpkg", "vantx", "vctx", " avjac", "wavtx", "wavpkg", "vrcontext", " avcomp", "avectrl", "vcomp", "avctrl", "averpid", "navdocument", " avcu", "aftimeout", "navcam", "ajtx", "avercam", "avetx", "avecfg", "ajkt", " avcmd", "varctx", "AVtx", "varkt", "vancomp", "ajcp", " avaddr", "afcfg", "ajcfg", "averkt", "vrjac", "avepkg", "afcontext", "devctx", "avkw"], "s": ["rs", "service", "gs", "sw", "b", "less", "ns", "c", "its", "ats", "h", "sam", "cl", "i", "sys", "set", "qs", "cs", "comm", "os", "ps", "p", "ms", "g", "n", "is", "ts", "sd", "ds", "ports", "t", "se", "es", "js", "sv", "ls", "sm", "sb", "services", "v", "stats", "sl", "bits", "m", "spec", "vs", "hs", "bs", "ss", "serv", "y", "sq", "fs", "obj", "flags", "S", "sts", "j", "sports", "aws", "l", "source"]}}
