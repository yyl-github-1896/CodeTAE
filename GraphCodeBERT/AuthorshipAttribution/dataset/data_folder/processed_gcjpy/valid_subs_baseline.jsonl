{"code": "\"\"\"Usage:\\n      pypy X.py < X-size.in > X-size.out\\n  or sometimes\\n      python X.py < X-size.in > X-size.out\\n  \"\"\"\\n  \\n  def setup(infile):\\n      return locals()\\n  \\n  def reader(testcase, infile, C=None, **ignore):\\n      P = map(int, infile.next().split())\\n      return locals()\\n  \\n  def solver(testcase, N=None, P=None, I=None, T=None, S=None, C=None, **ignore):\\n  \\n      R, C, M = P\\n      MM = M\\n  \\n      F = np.array([['.'] * C] * R)\\n      while M > 0:\\n          if R >= C and M >= C and R > 2:\\n              M -= C\\n              R -= 1\\n              F[R] = '*'\\n          elif C > R  and M >= R and C > 2:\\n              M -= R\\n              C -= 1\\n              F[:, C] = '*'\\n          elif R > 2 and C > 2 and (R > 3 or C > 3 or M == 1):\\n              if M < C - 1:\\n                  R -= 1\\n                  F[R, C - M:C] = '*'\\n              elif M < R - 1:\\n                  C -= 1\\n                  F[R - M:R, C] = '*'\\n              elif M == C - 1:\\n                  R -= 1\\n                  F[R, C - M + 1:C] = '*'\\n                  F[R - 1, C - 1] = '*'\\n              else:\\n                  C -= 1\\n                  F[R - M + 1:R, C] = '*'\\n                  F[R - 1, C - 1] = '*'\\n              M = 0\\n          elif M == R * C - 1:\\n              F[:, :] = '*'\\n              M = 0\\n          else:\\n              return 'Case #%s:\\n%s\\n' % (testcase, 'Impossible')\\n  \\n      F[0, 0] = 'c'\\n      assert (F == '*').sum() == MM\\n      return 'Case #%s:\\n%s\\n' % (testcase, '\\n'.join(''.join(f.tolist()) for f in F))\\n  \\n  if __name__ == '__main__':\\n      T = int(sys.stdin.next())\\n      common = setup(sys.stdin)\\n      for t in xrange(1, T+1):\\n          sys.stdout.write(solver(**reader(t, **common)))\\n", "substitutes": {"infile": ["insfile", "innerfilename", "ginFile", "outFile", "innercase", "outfilename", " inFile", "inputfp", "inscase", " inile", "ginfile", "ginfp", "ginfilename", "infp", "infilename", " infp", "outfp", "outile", "insFile", "inFile", "insfilename", "inile", "outcase", "inputFile", "innerfile", "incase", "outfile", "inputile", "innerFile", "inputfile", " infilename"], "testcase": ["casename", "testCase", "TestCase", "testname", "testkey", "Testcondition", " testCase", " testkey", "casekey", "casecondition", "Testcase", " testcondition", "Testname", "testcondition", "casecase", "Testkey", " testname", "caseCase"], "C": ["D", "CD", "U", "A", "CAR", "IC", "Cl", "CC", "J", "CH", "Z", "VC", "K", "c", "Size", "MC", "CW", "Co", "G", "Ch", "CM", "Cut", "B", "CS", "Cons", "CI", "WC", "Type", "EC", "Config", "CO", "CT", "CG", "CP", "YC", "GC", "JC", "COR", "X", "L", "TC", "CA", "Y", "Cu", "Car", "DC", "Mc", "Cs", "O", "H", "E", "CR", "Q", "Cr", "Col", "SC", "V", "Con", "CB", "W", "CL"], "P": ["D", "p", "O", "G", "TP", "X", "PD", "H", "L", "U", "A", "Q", "E", "PP", "PC", "B", "PT", "J", "Ps", "V", "PA", "Y", "PR", "PO", "CP", "K", "PS", "MP"], "N": ["D", "G", "O", "NN", "X", "H", "L", "E", "NS", "FN", "n", "Ns", "B", "J", "V", "Z", "NT", "Y", "NR", "K", "NC", "Sn"], "I": ["Si", "Is", "G", "O", "TI", "SI", "IT", "LI", "H", "L", "IO", "IL", "IP", "Ni", "B", "IC", "i", "J", "V", "DI", "II", "MI", "Im", "Int", "IS"], "T": ["D", "G", "O", "TP", "TT", "TN", "IT", "Ts", "X", "H", "TM", "L", "E", "Q", "A", "TV", "B", "TC", "TS", "J", "Type", "V", "TF", "Z", "Y", "NT", "GT", "WT", "TR", "K", "W"], "S": ["Si", "G", "O", "TN", "SI", "H", "L", "E", "Q", "NS", "s", "SH", "Ns", "B", "SL", "SN", "V", "SA", "Z", "Y", "SS", "Size", "SU"], "R": ["Range", "D", "G", "O", "Ch", "JR", "Right", "X", "RA", "H", "L", "U", "CR", "Q", "E", "A", "DR", "Br", "RC", "RG", "B", "SR", "Res", "Cl", "AR", "RGB", "HR", "r", " r", "J", "Reader", "V", "RO", "RS", "Rot", "Result", "Z", "Y", "Cor", "RE", "TR", "RR", "Rs", "K", "RM", "RT", "OR", "W", "Rat", "BR", "MR", "All", "Re", "ER", "Dr"], "M": ["D", "G", "O", "VM", "MED", "AM", "Ch", "X", "MA", "H", "TM", "m", "L", "U", "E", "A", "CR", "CM", "MD", "MN", "NM", "OM", "Mon", "MAN", "B", "PM", "AR", "FM", "MX", "MO", "J", "IM", "V", "Man", "Me", "Manager", "Y", "LM", "MF", "RE", "Ms", "MT", "MI", "K", "RM", "Mc", "DM", "W", "OR", "MC", "ME", "MS", "MR", "Mer", "MP"], "MM": ["O", "OC", "X", "MW", "OUR", "MD", "TM", "L", "mm", "MODE", "NM", "Form", "PM", "DF", "CC", "FM", "Full", "IM", "ALL", "Mode", "ANY", "Y", "MB", "MF", "EM", "AME", "mmm", "NO", "Length", "Mem", "MI", "OK", "W", "MC", "MS", "MP"], "F": ["D", "G", "Feed", "FG", "BF", "O", "FC", "Filter", "X", "H", "L", "U", "E", "FT", "Q", "A", "FB", "FN", "Frame", "File", "B", "FP", "RF", "FL", "DF", "Fixed", "FM", "EF", "OF", "GF", "J", "Full", "FO", "V", "TF", "AF", "FI", "WF", "Y", "Fs", "MF", "FF", "IF", "Fi", "FE", "PF", "FK", "FS", "ELF", "CF", "SF", "UF", "W", "Function", "All", "FD"], "Impossible": ["Oppaired", "Oppossible", "Deposed", "Imposed", "Depressed", "Impressed", "Depossible", "Depaired", "Suppossible", "Supposed", "Suppressed", "Opposed", "Suppaired", "Oppressed", "Impaired"], "f": [" fu", "fd", "p", "form", "df", "e", "fe", "m", "fl", " fo", "h", "cf", "uf", "rf", "fb", "field", "lf", "tf", "sf", "i", "xf", "ff", "fm", " fe", "aff", " ff", "x", "fen", "fp", "file", "fc", "c", "fs", "v", "fi", " cf", "test", "alf"], "common": ["partial", "tmp", "custom", "basic", "total", "shared", "tt", "p", "args", "this", "default", "ctx", "m", "public", "standard", "complete", "n", "all", "con", "pretty", "top", "name", "info", "main", "extra", "local", "set", "module", "init", "config", "Common", "table", "x", "tree", "new", "normal", "file", "data", "tc", "test", "com", "inner", "other"], "t": ["trial", "tmp", "tt", "p", "j", "k", "type", "e", "it", "o", "m", "txt", "h", "n", "s", "td", "name", "xt", "ti", "tr", "w", "tf", "y", "i", "r", "typ", "tw", "l", "ty", "x", "tg", "te", "st", "new", "out", "a", "c", "ta", "v", "tc", "rt", "test"]}}
{"code": "\"\"\"Usage:\\n      pypy X.py < X-size.in > X-size.out\\n  or sometimes\\n      python X.py < X-size.in > X-size.out\\n  \"\"\"\\n  \\n  def setup(infile):\\n      return locals()\\n  \\n  def reader(testcase, infile, C=None, **ignore):\\n      N = int(infile.next())\\n      I = [map(int, infile.next().split()) for i in range(4)]\\n      T = int(infile.next())\\n      S = [map(int, infile.next().split()) for i in range(4)]\\n      return locals()\\n  \\n  def solver(testcase, N=None, P=None, I=None, T=None, S=None, C=None, **ignore):\\n  \\n      res = set(I[N-1]) & set(S[T-1])\\n      if len(res) == 1:\\n          res = res.pop()\\n      elif len(res) > 1:\\n          res = 'Bad magician!'\\n      else:\\n          res = 'Volunteer cheated!'\\n      return 'Case #%s: %s\\n' % (testcase, res)\\n  \\n  if __name__ == '__main__':\\n      T = int(sys.stdin.next())\\n      common = setup(sys.stdin)\\n      for t in xrange(1, T+1):\\n          sys.stdout.write(solver(**reader(t, **common)))\\n", "substitutes": {"infile": ["cindata", "invalid", "INline", "intvalid", "cinfile", "outFile", "testfile", "inger", "outfilename", "indata", " inFile", "testdata", "inpath", "newFile", "onfile", "dinfiles", "Infile", "dinfolder", "inlist", "oldFile", " infiles", "dinfile", "onfiles", "onfolder", " inlist", "newfp", "infp", "infilename", " infp", "Infiles", "oldlist", "intdata", "testger", "INile", "cinpath", "newfiles", "outfp", "cinvalid", "infiles", "outfiles", " inpath", "cinline", "cinile", "oldline", "inFile", "INfile", "inile", "intger", " inile", "oldfile", "cinger", "dinFile", "newfile", "inifile", "infolder", "outfile", "inline", "iniline", "dinfilename", "intfile", "testvalid", "Infolder", "inilist", " inline", "INpath", "iniFile", " infilename"], "testcase": ["casename", "casecases", "Testbase", "vertest", "itercase", "testcases", "iterbase", "testconfig", "testCase", "TestCase", "casetest", "vercase", "iterCase", "traincase", "testname", "trainblock", "trainname", "verconfig", " testCase", " testblock", "caseconfig", "testblock", "Testcase", "testtest", " testconfig", " testtest", "testbase", "traincases", "Testtest", " testcases", " testbase", "caseblock", "casecase", "itertest", "vername", " testname"], "C": ["Co", "D", "G", "O", "H", "L", "E", "A", "CM", "R", "CS", "B", "CA", "CC", "CI", "F", "SC", "V", "M", "Ca", "EC", "Config", "Cu", "CO", "CT", "CG", "K", "DC", "GC", "W", "c", "CU", "Cs"], "N": ["D", "G", "NN", "O", "TN", "NA", "X", "H", "L", "A", "NG", "CN", "MN", "NS", "FN", "n", "NM", "R", "Ns", "Ni", "B", "DN", "NL", "NP", "J", "SN", "V", "ND", "M", "NPR", "Y", "NT", "GN", "NR", "NB", "AN", "NC", "NH", "Num"], "I": ["Si", "Is", "IU", "TI", "SI", "LI", "IT", "IB", "H", "U", "L", "A", "IO", "IL", "PI", "IP", "Pi", "R", "IR", "It", "B", "Init", "IC", "You", "IM", "M", "GI", "DI", "In", "IE", "II", "MI", "My", "RI", "Im", "Intel", "IJ", "Int", "IS", "AMI", "IA"], "i": ["gi", "j", "ic", "li", "iy", "io", "iti", "iri", "n", "s", "ri", "ei", "il", "ti", "ini", "si", "xi", "im", "u", "ai", "ip", "x", "pi", "ii", "ij", "di", "zi", "ir", "ci"], "T": ["Time", "D", "G", "O", "TP", "TI", "TT", "TN", "Ts", "X", "H", "L", "TM", "TY", "E", "Q", "TV", "Tab", "R", "TH", "B", "TPS", "AT", "TC", "TS", "TA", "Tem", "PT", "F", "OT", "J", "V", "M", "Z", "Y", "NT", "WT", "GT", "TR", "TB", "CT", "TX", "TO", "VT", "TG"], "S": ["Si", "G", "SI", "SM", "H", "L", "SIM", "A", "Q", "SSL", "Set", "NS", "SB", "s", "R", "SH", "CS", "B", "SQL", "TS", "Sl", "SL", "V", "SA", "M", "RS", "Y", "SS", "SP", "MS", "SER", "States", "PS", "SE", "IS", "SU", "SR"], "P": ["p", "O", "G", "X", "H", "L", "E", "Q", "A", "PP", "IP", "R", "B", "NP", "F", "J", "V", "PA", "M", "Y", "Pro", "CP", "RP"], "res": ["rem", "j", "inv", "str", "rev", "re", "rs", "reg", "ps", "crit", "cond", "ser", "ress", "resource", "repl", "reset", "results", "ro", "success", "req", "zero", "key", "rest", "raw", "rek", "ret", "sol", "pro", "Res", "tx", "exp", "pres", "rez", "result", "chain", "full", "pr", "comp", "RES", "r", "resh", "respons", "expr", "rand", "val", "red", "rep", "rel", "fresh", "resolution", "RE", "mont", "ber", "ch", "ver", "msg", "gr", "out", "cons", "resp", "mem", "mr", "rex", "mot", "right", "des"], "common": ["custom", "total", "basic", "shared", "default", "this", "base", "initial", "long", "m", "util", "standard", "old", "n", "final", "all", "null", "name", "specific", "main", "extra", "local", "set", "names", "current", "my", "config", "generic", "Common", "x", "new", "normal", "stable", "tc", "test", "com", "other"], "t": ["trial", "tt", "p", "j", "k", "one", "type", "it", "o", "time", "m", "h", "n", "g", "td", "f", "name", "ti", "test", "w", "d", "y", " ti", "r", "typ", "ty", "x", "to", "te", "st", "new", "a", "ta", "c", "tc", "tw", "temp"]}}
{"code": " def solve():\\n      h, w, m = map(int, raw_input().split())\\n      if h == 1:\\n          print 'c' + '.' * (h * w - m - 1) + '*' * m\\n      elif w == 1:\\n          for c in 'c' + '.' * (h * w - m - 1) + '*' * m:\\n              print c\\n      elif h * w - m == 1:\\n          print 'c' + '*' * (w - 1)\\n          for _ in xrange(h-1):\\n              print '*' * w\\n      else:\\n          m = h * w - m\\n          for i in xrange(h-1):\\n              for j in xrange(w-1):\\n                  t = (i + 2) * 2 + (j + 2) * 2 - 4\\n                  r = (i + 2) * (j + 2)\\n                  if t <= m <= r:\\n                      a = [['*'] * w for _ in xrange(h)]\\n                      for k in xrange(i+2):\\n                          a[k][0] = '.'\\n                          a[k][1] = '.'\\n                      for k in xrange(j+2):\\n                          a[0][k] = '.'\\n                          a[1][k] = '.'\\n                      for y, x in product(range(2, i+2), range(2, j+2)):\\n                          if y == 1 and x == 1:\\n                              continue\\n                          if t >= m:\\n                              break\\n                          a[y][x] = '.'\\n                          t += 1\\n                      a[0][0] = 'c'\\n                      for s in a:\\n                          print ''.join(s)\\n                      return\\n          print 'Impossible'\\n  for t in xrange(int(raw_input())):\\n      print \"Case #%d:\" % (t + 1)\\n      solve()\\n", "substitutes": {"h": ["hi", "hp", "p", "ho", "hal", "hd", "H", "ih", "o", "hm", "history", "ah", "z", "n", "g", "hh", "ph", "he", "kh", "q", " H", "b", "host", "hs", "l", "home", "hr", "sh", "html", "http", "bh", "oh", "ch", "th", "hl", "ha", "hw", "v", "high", "rh", "ht"], "w": ["p", "win", "word", "nw", "wx", "o", "iw", "z", "n", "g", "f", "kw", "wl", "ws", "wa", "wi", "d", "u", "q", "wm", "width", "sw", "work", "wk", "b", "tw", "wat", "l", "ew", "aw", "wal", " W", "wh", "W", "hw", "v", "wt", "we", "wr", "wb", "rw", "wp", "wd"], "m": ["p", "em", "tm", "e", "ms", "cm", "o", "mm", "mat", "n", "g", "z", "bm", "f", "perm", "mn", "d", "gm", "q", "u", "mi", "mo", "man", "wm", "b", "M", "mt", "mean", "l", "mc", "mu", "met", "sm", "mut", "ma", "mp", "rm", "mr", "mem", "v", "mod", "mag"], "c": ["dc", "p", "ic", "rc", "e", "cut", "mac", "cm", "lc", "ct", "cf", "nc", "conf", "n", "f", "anc", "cu", "d", "sc", "comp", "uc", "b", "ac", "cont", "unc", "cr", "co", "mc", "cc", "cum", "C", "orc", "ca", "fc", "etc", "gc", "tc", "enc", "wb", "com", "ci"], "_": ["p", "valid", "match", "__", "___", "an", "g", "all", "f", "int", "____", "q", "on", "ation", "place", "get", "ex", "W", "ml", "py", "list"], "i": ["gi", "ki", "hi", "ic", "li", "it", "ia", "o", "ih", "ik", "io", "id", "iri", "ri", "phi", "info", "int", "ti", "ini", "bi", "si", "xi", "im", "mi", "u", "ai", "b", "ip", "pi", "ii", "ij", "iu", "ix", "di", "zi", "I", "ie", "ir", "yi", "ind", "ci"], "j": ["ji", "br", "next", "jj", "jl", "it", "jp", "o", "key", "z", "n", "g", "ja", "d", "pr", "uj", "q", "json", "J", "kj", "b", "dj", "l", "oj", "rel", "ij", "jc", "obj", "js", "jump", "v", "aj", "bj"], "t": ["ft", "tt", "p", "type", "tm", "e", "it", "at", "tick", "o", "time", "tn", "ct", "n", "g", "td", " T", "f", "kt", "let", "ti", "test", "tr", "dt", "d", "tf", "set", "tim", "typ", "mt", "l", "ty", "vt", "tp", "ot", "to", "te", "tree", "st", "th", "title", "tu", "tip", "ta", "v", "wt", "ts", "tc", "T", "lat", "pt", "tw"], "r": ["range", "res", "p", "rc", "re", "e", "o", "nr", "ro", "z", "n", "g", "rb", "R", "d", "u", "q", "kr", "b", "l", "rr", "cr", "sr", "rm", "mr", "v", "rd", "rt"], "a": ["ap", "au", "app", "sa", "p", "alpha", "la", "e", "at", "ia", "o", "area", "A", "sta", "an", "z", "n", "all", "att", "xa", "g", "ba", "f", "am", "aa", "era", "va", "aaa", "ao", "another", "na", "ada", "ana", "ai", "each", "aos", "b", "ac", "aff", "ga", "ka", "l", "ae", "ata", "eas", "oa", "aux", "ea", "abs", "ma", "ca", "sha", "ta", "v", "ab", "fa"], "k": ["ki", "ic", "p", "tk", "ks", "ok", "ek", "ijk", "o", "ik", "kind", "key", "z", "n", "id", "ck", "sk", "kid", "g", "dk", "kt", "kw", "kk", "ke", "u", "kh", "q", "kr", "wk", "ka", "kj", "ko", "l", "kn", "ku", "th", "kg", "K", "km", "kar", "v", "unk", "kl", "ak", "ind", "ci"], "y": ["vy", "yt", "ic", "p", "gy", "hy", "iy", "cy", "o", "ies", "yy", "key", "z", "n", "ym", "ny", "ey", "uy", "my", "yn", "b", "sy", "ay", "Y", "ot", "sky", "ye", "ch", "yl", "xy", "wy", "v", "ry", "yi"], "x": ["ux", "p", "ic", "xs", "e", "X", "rx", "it", "at", "wx", "dx", "xp", "o", "ax", "ox", "z", "n", "g", "xc", " xx", "tx", "xt", "mx", "xi", "u", "q", "inx", "xf", "l", "yx", "xe", "xd", "ix", "xy", "ex", "xx", "v", "fx"], "s": ["res", "ns", "args", "p", "sa", "xs", "ges", "os", "ats", "e", "bes", "rs", "ps", "ms", "o", "ss", "ys", "z", "g", "n", "f", "csv", "ls", "eds", "ds", "ws", "ars", "another", "cs", "sw", "its", "b", "actions", "ins", "hs", "l", "abs", "out", "js", "ses", "rows", "v", "es", "eps", "S", "tes", "gs"]}}
{"code": "def solve():\\n      r1 = int(raw_input())\\n      a1 = [map(int, raw_input().split()) for i in xrange(4)]\\n      r2 = int(raw_input())\\n      a2 = [map(int, raw_input().split()) for i in xrange(4)]\\n      ans = -1\\n      for i in xrange(1, 17):\\n          if i in a1[r1-1] and i in a2[r2-1]:\\n              if ans != -1:\\n                  return \"Bad magician!\"\\n              ans = i\\n      if ans == -1:\\n          return \"Volunteer cheated!\"\\n      return ans\\n  for t in xrange(int(raw_input())):\\n      print \"Case #%d:\" % (t + 1), solve()\\n", "substitutes": {"r1": ["sr41", "r81", "rowone", "r0", "sr81", "rc81", "sr0", "rankary", " r0", "rankone", "sr1", "row41", "rone", "row1", "rc0", "rc1", "rary", "srone", "rank41", " r3", "rank1", "rc3", "srary", "r41", "rowary", "sr3", "r3", " r81"], "a1": [" a3", "a3", " a4", "sta3", "ha2", "haone", " a01", "ae1", "staone", "area01", "area1", "ae01", "a4", "a01", "aone", "ha3", " aone", "ae4", "sta2", "sta1", "area4", "ha1"], "i": ["gi", "ki", "hi", "p", "ic", "j", "li", "e", "it", " di", "ia", "ih", "m", "ik", "iti", "iri", "n", "g", "ed", " vi", "f", "ri", "phi", "s", "ei", "eri", "int", "ti", "ini", "ili", "d", "si", "xi", "im", "mi", " mi", "r", "ai", "ip", " bi", "adi", "chi", "l", "x", "pi", "ii", "oi", "iu", "ni", "ati", "di", "zi", "I", "a", "c", "fi", "ir", "ci"], "r2": [" r4", "rc2", "m4", "sr256", "r02", "rc256", "rTwo", "r4", "m02", " r02", "r256", " r256", " rTwo", "l4", "l2", " r3", "rcTwo", "m2", "l3", "srTwo", "m3", "r3", "l02", "sr2"], "a2": ["galet", "gatwo", " a3", "a3", "sta3", " a02", "aatwo", "aalet", "alet", "b1", "b2", "aa2", " alet", "aa02", "b3", "ga2", " atwo", "a02", "atwo", "sta2", "sta1", "ga02"], "ans": ["ants", "tools", "an", "ins", "anas", "orts", "a", "ons", "ions", "actions", "eatures", "ands", "ids", "anic", "s", "annels", "nan", "names", "amps", "ran", "rans", "anks", "ens", " means", "lets", " sans", "es", "values", "ns", "os", "iann", "aces", "ms", "ents", "ANS", "unes", "ann", "ongs", "ars", "vers", "outs", "aints", "aos", "x", "ations", "ros", "\u00e1n", "ags", "lines", "offs", "ones", "ats", "olds", " fans", "ies", "aults", "asms", "eds", "can", "anned", "errors", "uns", "mas", "anes", "irms", "yes", "un", "arts", "ians", "aned", "cons", "ates"], "t": ["tt", "ic", "p", "j", "k", "e", "it", "at", "m", "h", "n", "g", "s", "f", "let", "xt", "int", "ti", "w", "d", "dt", "u", "q", "y", "r", "tim", "rit", "b", "l", "ot", "to", "te", "tin", "ont", "a", "tu", "tip", "c", "ta", "v", "tc", "ts", "T", "rt", "tw"]}}
{"code": " \\n  def makeBoardR(b):\\n  \tnumR, numC, numMines, filledR, filledC = b\\n  \tq = numMines / numR\\n  \tr = numMines % numR\\n  \\n  \tif q <= numC-2 and r == 0:\\n  \t\tboard = [\"*\"*(filledC + numC) for x in range (filledR)]\\n  \t\tboard.append( \"*\"*(filledC+q)+\".\"*(numC-q) )\\n  \t\tboard.append( \"*\"*(filledC+q)+\".\"*(numC-q-1)+\"c\" )\\n  \t\toutput = \"\\n\".join(board)\\n  \telif numMines == numR * numC - 1:\\n  \t\tboard = [\"*\"*(filledC + numC) for x in range (filledR+1)]\\n  \t\tboard.append( \"*\"*(filledC+numC-1)+\"c\" )\\n  \t\toutput = \"\\n\".join(board)\\n  \telse:\\n  \t\toutput = \"Impossible\"\\n  \\n  \treturn output\\n  \\n  def makeBoardC(b):\\n  \tnumR, numC, numMines, filledR, filledC = b\\n  \tq = numMines / numC\\n  \tr = numMines % numC\\n  \\n  \tif q <= numR-2 and r == 0:\\n  \t\tboard = [\"*\"*(filledC+numC) for x in range(filledR+q)]\\n  \t\tfor x in range( numR-1-q ):\\n  \t\t\tboard.append( \"*\"*filledC + \"..\" )\\n  \t\tboard.append( \"*\"*filledC + \".c\" )\\n  \t\toutput = \"\\n\".join(board)\\n  \telif numMines == numR * numC - 1:\\n  \t\tboard = [\"*\"*(filledC+numC) for x in range(filledR+numR-1)]\\n  \t\tboard.append( \"*\"*(filledC+numC-1) + \"c\" )\\n  \t\toutput = \"\\n\".join(board)\\n  \telse:\\n  \t\toutput = \"Impossible\"\\n  \treturn output\\n  \\n  def makeBoard(b):\\n  \tnumR, numC, numMines, filledR, filledC = b\\n  \tq = numMines / (numC-2)\\n  \tr = numMines % (numC-2)\\n  \\n  \tboard = [\"*\"*(numC+filledC) for x in range(filledR)]\\n  \tfor x in range(q):\\n  \t\tboard.append( \"*\"*(numC-2+filledC)+\"..\" )\\n  \tboard.append( \"*\"*(r+filledC)+\".\"*(numC-r) )\\n  \tfor x in range(numR-q-2):\\n  \t\tboard.append( \"*\"*filledC+\".\"*numC )\\n  \tboard.append( \"*\"*filledC + \".\"*(numC-1) + \"c\" )\\n  \treturn \"\\n\".join(board)\\n  \\n  def makeBoard0(b):\\n  \tnumR,numC,numMines,filledR,filledC = b\\n  \tboard = [\"*\"*(numC+filledC) for x in range(filledR)]\\n  \tfor x in range(numR-1):\\n  \t\tboard.append( \"*\"*(filledC)+\".\"*numC )\\n  \tboard.append( \"*\"*(filledC) + \".\"*(numC-1) + \"c\" )\\n  \treturn \"\\n\".join(board)\\n  \\n  f = open( sys.argv[1] )\\n  f.readline()\\n  \\n  numCase = 1\\n  l = f.readline()\\n  while l != \"\":\\n  \tnumR, numC, numMines = [int(x) for x in l.split()]\\n  \\n  \tboards = deque()\\n  \tif numR == 1:\\n  \t\tif numC == 1 and numMines == 0:\\n  \t\t\toutput = \"c\"\\n  \t\telif numC == 1 and numMines > 0:\\n  \t\t\toutput = \"Impossible\"\\n  \t\telse:\\n  \t\t\toutput = \"*\"*numMines + \".\"*(numC-numMines-1) + \"c\"\\n  \telif numC == 1:\\n  \t\toutput = \"\\n\".join(\"*\"*numMines + \".\"*(numR-numMines-1) + \"c\")\\n  \telse:\\n  \t\tboards.append( (numR,numC,numMines,0,0) )\\n  \t\toutput = \"Impossible\"\\n  \\n  \twhile output == \"Impossible\" and len(boards) > 0:\\n  \t\tb = boards.popleft()\\n  \t\tnumR,numC,numMines,filledR,filledC = b\\n  \t\tif numMines == 0:\\n  \t\t\toutput = makeBoard0(b)\\n  \t\t\tbreak\\n  \\n  \t\tif numMines >= numC and numR > 2:\\n  \t\t\tboards.append( (numR-1,numC,numMines-numC,filledR+1,filledC) )\\n  \t\tif numMines >= numR and numC > 2:\\n  \t\t\tboards.append( (numR,numC-1,numMines-numR,filledR,filledC+1) )\\n  \\n  \t\tif numMines <= (numR-2)*(numC-2):\\n  \t\t\toutput = makeBoard(b)\\n  \\n  \t\tif numR == 2:\\n  \t\t\toutput = makeBoardR(b)\\n  \\n  \t\tif numC == 2:\\n  \t\t\toutput = makeBoardC(b)\\n  \t\t\\n  \tprint \"Case #\"+str(numCase)+\":\\n\"+output\\n  \tl = f.readline()\\n  \tnumCase += 1\\n", "substitutes": {"b": ["br", "p", "bl", "bf", "ib", "bo", "ref", "base", "e", "gb", "lab", "t", "o", "m", "fa", "ob", "sub", "h", "pre", "bc", "bb", "self", "rb", "mb", "n", "g", "ba", "lib", "B", "bitcoin", "fb", "bi", "d", "bg", "w", "be", "cb", "pb", "y", "eb", "nb", "db", "lb", "amb", "bs", "erb", "blue", "bool", "bh", "back", "batch", "bis", "obj", "bar", "a", "c", "v", "wb", "ab", "bt", "sb", "bp"], "numR": ["getC", "namM", "umBR", "umM", "numGR", "umR", "umC", "numP", "hotRat", "monG", "timL", " numL", "nR", "numberr", "monr", " numr", "numRat", "numberR", "namA", "monB", "monRO", "getBR", "numBR", "numB", "numG", " numM", " numP", "numberP", " numG", "numr", "umT", "NumC", "numberC", "filledGR", "hotR", "monRat", "umRat", "numT", "nRO", "numD", "timr", "getRO", "monR", "NumG", "namR", "umP", "nBR", "timRO", "timR", "NumR", "NumM", "numA", "monP", "umRO", "numberM", "namC", "getR", "monD", "monT", "numRO", "monGR", "filledr", "monC", "NumA", "NumP", "hotT", " numRO", "numL", "numM", "numberGR", "numberD", " numD", "numberB", "monL", " numA", "nC", "numberL", " numB", "hotC"], "numC": ["entityC", "monS", " numCM", "monJC", "zeroC", "netCs", "NUMC", "numCond", "primC", "numAC", "dotCM", "phoneWC", "moneyCM", "NUMR", "umR", "umC", "netC", "numP", "netWC", "zeroCh", "monG", "omCM", "tenB", "phyCC", "dateCC", "phyC", "umCAR", "dotR", "dateR", "phoneCs", " numL", "numberCC", "namedWC", "entityJC", "tenC", "numberedR", "NumL", "dimC", "currentC", "phyCh", "money10", "numberR", "monB", "dimL", "numberT", "numberCB", "NumCM", " numSC", "currentR", "filledCode", "monCB", " numN", "dotC", "monN", "numB", "numG", "numberAC", "numberG", "numV", " numP", "numc", "zeroR", "monCh", "phoneC", "snapR", "omR", "umAC", " numG", "namedC", "entityP", "umT", "umWC", "NumC", "numberC", "numberedD", "tenR", "monCode", "numJC", "umCC", "numberedCode", "NumSC", "dimR", "tenWC", "currentAC", "numT", "monCond", "numCh", "numD", "numberS", "monc", "NUMG", "zeroV", "omC", "numCs", "numCode", "moneyR", "umG", "number10", "netc", "numCB", "filledCB", "numberedCond", "monCAR", "monR", "num10", " numT", "namedR", "numSC", "numberc", "numberedC", "dotCC", "phyR", "dateB", "dateC", "NumB", "filledG", "numCC", "filledCond", "NumR", "monCM", "primc", "monP", "numWC", "NumJC", "tenc", "zeroc", "numCM", "monWC", "monD", "umB", "entityR", "monCC", "monT", "phonec", "filledD", "monC", "snapC", "NumP", "tenSC", "primR", "numL", "dimCM", "zeroCC", "numN", "um10", "umCM", "numCAR", "numberB", "snapc", "currentT", "numberCM", "monV", "moneyC", "omCC", "numS", "NUMN", "primV", "umS", "namedCAR", "snapCM", "zeroCM", " numB", "tenCs"], "numMines": ["numReminers", "numMine", "numEmines", "numberNined", " numNines", "numChiners", "sumManes", "NumRanes", "numEmins", "numRins", "numEines", "numChine", "NUMminers", "numVists", "numNins", "numMoons", "numberMiners", "numDines", "numberRiners", " numChanes", "numLains", "numNine", "numBines", "numModes", "sumEmoons", "numVelines", "numLelines", "numberMines", "NumRines", "nmMiners", "numberNine", "numminers", "numRiners", "NUMMiners", "NumMined", "numManines", "numMiners", "numDoons", "NUMMessine", "numDites", "numNiners", "numberMelines", "NUMmists", "numNines", " numMined", " numNites", "nmChiners", "numberNiners", "numNists", "NumRelines", "numLists", "numDelines", "sumMelines", "NumMelines", "numberMined", " numNins", "sumMines", "NUMMessians", "numLines", "numLiners", "nummoons", "numVines", "numLins", "nmMines", "numBins", "numRines", "sumEminers", "numRemelines", "numMins", "nmChines", "numEmoons", "numManined", "numMelines", "numEelines", "numChanes", "sumEmanes", "nmChelines", "numberMists", "numRelines", "numPoons", "numManins", "numberNines", "sumEmines", "numPines", "sumMiners", "numNelines", "sumMains", "numDiners", "numPanes", "numberRines", "numLians", " numMins", "numBodes", "NUMMines", "NUMMists", " numManes", "numNined", "NUMMoons", "NUMMessodes", "numDins", "numEminers", "numPiners", "numLined", "NUMmoons", "numManiners", "nmChanes", "numDined", "NumMines", " numModes", "numRemanes", "numberRined", "numberRins", "numberNins", "NUMMine", "numMists", "numChodes", "numChined", "numRoons", "numNodes", "nmManes", "numRists", "sumMoons", "numberMins", "numMessians", "NUMModes", "numChians", "numEanes", "numMined", "numDanes", " numChines", " numChined", "numberNelines", " numNodes", "numChelines", "nmMelines", "numMessines", "numManes", "numEmanes", "numRemines", "numVined", "NUMMians", "NumManes", "numberMine", "numRanes", "numMessodes", "numNites", "nummines", "numNians", "nummists", "numChains", "numMites", "numberNists", "NumRined", "numRine", "numChines", "numDodes", "NUMmines", "numMessine", "numEined", "numBites", "sumMians", " numMites", "numRined", "numMains", "numEmine", " numChine", "NUMMessines", " numMine", "numMians"], "filledR": ["killedR", "illedB", "loadedV", "linkedX", "filledK", "illedP", "killedRight", "builtW", "killedH", "filledW", "linkedRes", " filledP", "packedR", " filledX", "illedR", "killedX", "filledH", "killedP", "occupiedG", "numV", "loadedr", "builtR", "filledV", "numr", "illedK", "packedG", "loadedL", "killedW", "filledRes", "occupiedR", "illedL", " filledL", "killedRes", "builtH", "illedG", "loadedC", "illedH", "filledL", "illedr", "loadedK", "illedRight", "filledG", "occupiedB", "killedC", "illedRes", "illedX", "builtC", "illedV", "filledr", "packedB", "loadedR", "linkedR", "linkedK", "illedW", "filledP", " filledr", "filledX", "linkedC", "filledRight", "illedC", "filledB", " filledRight"], "filledC": ["killedR", "illedB", "ashedCR", "illedA", "illedTC", " filledCNN", "linkedH", "coloredR", "filledCAR", "illedCC", "focusedAC", "builtc", "placedCC", "coloredCR", "filledCo", "illedQ", "poweredCo", "printedChar", "representedCons", "claimedC", "representedC", "loadedSC", "linedc", "ashedR", "keptCC", "illedSC", "registeredR", "illedR", "keptC", "fillSC", "registeredQ", "representedCustom", "coloredCE", "packedCons", "filledA", "filledSC", "builtA", "claimedYC", "filledCons", "filledH", "coloredAC", "filledT", "representedB", "linkedCR", "coloredC", "filledc", "fullCC", "filledChar", "paintedC", "filledCC", "poweredCC", "representedc", "fillC", "claimedc", "linedL", "markedC", "paintedB", "placedCo", "markedL", "filledTC", "illedCons", "filledQ", "fullCAR", "illedL", "linedC", "numT", "loadedCC", "coloredCNN", "poweredC", "printedC", "filledCNN", "keptR", "fillCAR", "loadedC", "loadedCAR", "filledAC", "illedCustom", "connectedCar", "illedH", "connectedC", "illedc", "filledL", "packedc", "illedCR", "illedYC", "illedCNN", "paintedDC", "builtYC", "poweredCAR", "selectedT", "registeredCC", "linkedCC", "ashedC", "focusedCE", "illedAC", "linedTC", "focusedC", "linkedCAR", "representedDC", "markedTC", "illedChar", "killedC", "killedT", "illedCar", "connectedCC", "builtC", "claimedA", "linkedQ", "filledCE", "paintedCustom", "fillR", "filledYC", "filledCR", "connectedChar", "selectedC", "printedCC", "loadedR", "packedA", "illedDC", "filledCustom", "linkedR", "fullCo", "printedCar", " filledCR", "filledDC", "packedC", "ashedCAR", "illedCE", "fullC", "linkedC", "placedCAR", "placedC", "illedCAR", "illedC", "filledB", "registeredC", "representedA", "markedc", "filledCar", "coloredH", "selectedR"], "q": ["p", "count", "er", "re", "e", "ek", "t", "ih", "m", "h", "req", "eq", "w", "d", "ke", "el", "qs", "dq", "sq", "c", "ill", "ql", "iq", "qa", "ik", "ox", "key", "ail", "id", "conf", "ck", "s", "qual", "pe", "kw", "xt", "ph", "u", "ine", "ep", "que", "qt", "ch", "requ", "ix", "ry", "v", "kl", "ht", "alpha", "rc", "qv", "err", "it", "qu", "qq", "z", "n", "g", "ag", "exp", "ock", "y", "i", "query", "ld", "pp", "kg", "quant", "fx", "j", "ile", "ic", "k", "type", "Q", "aq", "ur", "quest", "qi", "ike", "resh", "ue", "fy", "pg", "rm", "rt"], "r": ["range", "res", "br", "p", "j", "ra", "rc", "er", "fr", "str", "e", "err", "rs", "re", "t", "o", "m", "url", "nr", "h", "ro", "run", "id", "n", "g", "all", "ur", "R", "s", "ar", "w", "d", "pr", "rank", "y", "i", "u", "rr", "cr", "hr", "sr", "dr", "a", "c", "v", "rd", "rt", "ir", "right", "pair"], "board": ["band", "deck", "division", "user", "row", "stream", "body", "batch", "box", "Board", "front", "bd", "bo", "word", "beat", "block", "control", "chain", "loop", "lay", "rank", "stone", "bang", "bank", "player", "pool", "back", "stri", "bowl", "out", "bro", "onto", "flo", "form", "bus", "video", "oard", "display", "layout", "stack", "ui", "lib", "wheel", "boat", "channel", "bench", "table", "flow", "runner", "ward", "land", "component", "way", "case", "pair", "ard", "bridge", "bit", "client", "won", "panel", "system", "craft", "book", "uno", "builder", "view", "buffer", "room", "layer", "ack", "boarding", "boot", "bird", "lock", "bot"], "x": ["ux", "post", "xs", "check", "ctx", "X", "rx", "xes", "t", "wx", "dx", "xp", "qu", "ax", "ct", "ox", "h", "z", "n", "xc", "xa", "xt", "tx", "mx", "w", "index", "full", "xi", "y", "sw", "inx", "xf", "on", "ous", "yx", "co", "mix", "ext", "xe", "lex", "xd", "ix", "xy", "wh", "ex", "xx", "xb", "fx", "num"], "output": ["python", "detail", "console", "command", "error", "none", "option", "pretty", "line", "successful", "unknown", "network", "put", "body", "job", "batch", "tree", "writing", "status", "product", "block", "information", "control", "commit", "summary", "monitor", "config", "write", "four", "come", "print", " Output", "out", "production", "response", "values", "answer", "ilo", "outer", "display", "public", "success", "lib", "current", "echo", "content", "channel", "collection", "document", "net", "quiet", "format", "component", "comment", "Output", "exit", "client", "section", "result", "interface", "buffer", "value", "layer", "figure", "input", "string", "text", "object", "message", "list"]}}
{"code": " \\n  if __name__ == \"__main__\":\\n  \tf = open( sys.argv[1] )\\n  \tint(f.readline())\\n  \t\t\\n  \tnum = 1\\n  \tl = f.readline()\\n  \twhile l != \"\":\\n  \t\trow1 = int(l)\\n  \t\trows = [ f.readline() for x in range(4) ]\\n  \t\trow1 = [int(x) for x in rows[row1-1].split()]\\n  \\n  \t\trow2 = int(f.readline())\\n  \t\trows = [f.readline() for x in range(4)]\\n  \t\trow2 = [int(x) for x in rows[row2-1].split()]\\n  \\n  \t\tresult = set(row1) & set(row2)\\n  \t\tif len(result) == 1:\\n  \t\t\toutput = str(result.pop())\\n  \t\telif len(result) > 1:\\n  \t\t\toutput = \"Bad magician!\"\\n  \t\telse:\\n  \t\t\toutput = \"Volunteer cheated!\"\\n  \\n  \t\tprint \"Case #\"+str(num)+\": \"+output\\n  \t\tnum += 1\\n  \t\tl = f.readline()\\n  \t\t\\n", "substitutes": {"f": ["ft", "fd", "j", "bf", "fx", "form", "fr", "load", "df", "e", "it", "t", "o", "fl", "h", "ct", "of", "cf", "conf", "fo", "uf", "g", "af", "elf", "fg", "exp", "fb", "w", "full", "lf", "tf", "sf", "be", "q", "i", "u", "F", "r", "xf", "fm", "ff", "b", "inf", "fed", "fast", "fp", "file", "fc", "fs", "c", "v", "alf"], "num": ["mon", "one", "done", "enum", "count", "su", "total", "numbered", "snap", "unique", "m", "no", "dec", "sim", "id", "n", "zero", "con", "en", "um", "prim", "int", "index", "set", "multi", "tim", "nb", "on", "nu", "nom", "row", "np", "number", "un", "draw", "umber", "NUM", "nm", "date", "msg", "mult", "new", "out", "ident", "sum", "cal", "dim", "serial", "Num"], "l": ["p", "bl", "j", "la", "li", "ll", "t", "lin", "L", "fl", "sl", "lc", "h", "z", "n", "g", "lo", "ls", "rl", "dl", "lit", "u", "line", "i", "ol", "left", "r", "lp", "b", "lb", "el", "nl", "ln", "ld", "ell", "len", "lang", "hl", "tl", "c", "v", "ml", "lock"], "row1": ["room51", "ro1", "ry4", "group01", "ow5", "record11", "row01", "Row51", "room0", "ow11", "record8", "row8", "room1", "ow4", "record01", "RowOne", "ow9", "group1", "record1", "row11", " row11", "Row11", "ow1", " row51", "row4", "ry5", "rowOne", "group8", "row5", "Row1", "ry9", "row0", "ow0", "Row0", "ro5", "roomOne", "group11", "ro9", "row9", "ro4", "ry1", " row8", "owOne", " row0", "row51", " rowOne", " row01"], "rows": ["res", "values", "ns", "heads", "months", "xs", "ges", "rs", "los", "bows", "uds", "obs", "wards", "ways", "ids", "rys", "ys", "results", "bys", "ips", "files", "roots", "blocks", "keys", "ls", "papers", "headers", "rown", "errors", "ws", "users", "flows", "dates", "names", "orders", "runs", "sw", "ods", "workers", "row", "cells", "fields", "groups", "ews", "bs", "rates", "ros", "items", "projects", "vals", "rooms", "ows", "urs", "views", "pages", "frames", "lines", "uploads", "ues", "posts"], "x": ["ux", "hex", "p", "xs", "check", "col", "xxxx", "xxxxxxxx", "rx", "xxx", "xes", "wx", "t", "dx", "xp", "qu", "ax", "ct", "ox", "key", "z", "ross", "xc", "n", "xa", "xt", "tx", "name", "int", "mx", "w", "xi", "y", "i", "inx", "xf", "\u00e7", "row", "yx", "co", "ctx", "ext", "lex", "xe", "xd", "ix", "xy", "ex", "c", "xx", "xml", "v", "xb", "fx", "ci"], "row2": ["rows2", "ro02", "ry4", "rotwo", "ry2", " rowB", " rowtwo", "ow2", "rows4", "ro2", "owtwo", "roll02", "roomB", "roomtwo", "ry02", "rolltwo", "owSecond", "rowB", "owB", "row4", "roll2", "ry5", "rytwo", "ow42", "roll5", "roSecond", "row5", "rollSecond", "ro42", "row3", "ro5", "ry3", "rowSecond", "row02", "room2", " row3", "roll42", "row42", " row4", "rows3", "rowstwo", "rowtwo"], "result": ["res", "answer", "match", "total", "done", "reverse", "su", "report", "correct", "cur", "error", "relation", "complete", "success", "none", "results", "run", "final", "all", "group", "ret", "process", "set", "multi", "r", "successful", "found", "Result", "dict", "table", "collection", "draw", "sequence", "list", "RESULTS", "back", "runner", "new", "date", "different", "iter", "out", "diff", "status", "data", "mate", "first", "search", "response", "test", "valid", "case", "pair"], "output": ["label", "reason", "next", "default", "console", "report", "binary", "prefix", "filename", "cut", "column", "display", "success", "ne", "human", "pretty", "null", "image", "name", "summary", "line", "PUT", "ut", "successful", "write", "unit", "render", "value", "network", "hidden", "comment", "put", "figure", "net", "body", "batch", "four", "input", "position", "connection", "format", "string", "print", "pain", "out", "data", "generation", "component", "response", "text", "Output", "message"]}}
{"code": "t = int(raw_input())\\n  \\n  for case in range(t):\\n  \tprint 'Case #'+str(case+1)+':'\\n  \tr, c, m = raw_input().split()\\n  \tr = int(r)\\n  \tc = int(c)\\n  \tm = int(m)\\n  \\n  \tif m==0:\\n  \t\tprint 'c' + ('.'*(c-1))\\n  \t\tfor i in range(r-1):\\n  \t\t\tprint '.'*c\\n  \telif r == 1:\\n  \t\tprint 'c'+('.'*(c-m-1))+('*'*(m))\\n  \telif c == 1:\\n  \t\tprint 'c'\\n  \t\tfor i in range(r-m-1):\\n  \t\t\tprint '.'\\n  \t\tfor i in range(m):\\n  \t\t\tprint '*'\\n  \telif r == 2:\\n  \t\tif m%2==0 and c>2 and m<r*c-2:\\n  \t\t\tprint 'c'+('.'*(c-m/2-1))+('*'*(m/2))\\n  \t\t\tprint ('.'*(c-m/2))+('*'*(m/2))\\n  \t\telif m == r*c - 1:\\n  \t\t\tprint 'c'+('*'*(c-1))\\n  \t\t\tprint '*'*c\\n  \t\telse:\\n  \t\t\tprint 'Impossible'\\n  \telif c == 2:\\n  \t\tif m%2==0 and r>2 and m<r*c-2:\\n  \t\t\tprint 'c.'\\n  \t\t\tfor i in range(r-m/2-1):\\n  \t\t\t\tprint '..'\\n  \t\t\tfor i in range(m/2):\\n  \t\t\t\tprint '**'\\n  \t\telif m == r*c - 1:\\n  \t\t\tprint 'c*'\\n  \t\t\tfor i in range(r-1):\\n  \t\t\t\tprint '**'\\n  \t\telse:\\n  \t\t\tprint 'Impossible'\\n  \telif c == 3 and r == 3:\\n  \t\tif m == 1:\\n  \t\t\tprint 'c..'\\n  \t\t\tprint '...'\\n  \t\t\tprint '..*'\\n  \t\telif m == 2:\\n  \t\t\tprint 'Impossible'\\n  \t\telif m == 3:\\n  \t\t\tprint 'c..'\\n  \t\t\tprint '...'\\n  \t\t\tprint '***'\\n  \t\telif m == 4:\\n  \t\t\tprint 'Impossible'\\n  \t\telif m == 5:\\n  \t\t\tprint 'c.*'\\n  \t\t\tprint '..*'\\n  \t\t\tprint '***'\\n  \t\telif m == 6:\\n  \t\t\tprint 'Impossible'\\n  \t\telif m == 7:\\n  \t\t\tprint 'Impossible'\\n  \t\telif m == 8:\\n  \t\t\tprint 'c**'\\n  \t\t\tprint '***'\\n  \t\t\tprint '***'\\n  \telif c == 3 and r == 4:\\n  \t\tif m == 1:\\n  \t\t\tprint 'c..'\\n  \t\t\tprint '...'\\n  \t\t\tprint '...'\\n  \t\t\tprint '..*'\\n  \t\telif m == 2:\\n  \t\t\tprint 'c..'\\n  \t\t\tprint '...'\\n  \t\t\tprint '..*'\\n  \t\t\tprint '..*'\\n  \t\telif m == 3:\\n  \t\t\tprint 'c..'\\n  \t\t\tprint '...'\\n  \t\t\tprint '...'\\n  \t\t\tprint '***'\\n  \t\telif m == 4:\\n  \t\t\tprint 'c.*'\\n  \t\t\tprint '..*'\\n  \t\t\tprint '..*'\\n  \t\t\tprint '..*'\\n  \t\telif m == 5:\\n  \t\t\tprint 'Impossible'\\n  \t\telif m == 6:\\n  \t\t\tprint 'c..'\\n  \t\t\tprint '...'\\n  \t\t\tprint '***'\\n  \t\t\tprint '***'\\n  \t\telif m == 7:\\n  \t\t\tprint 'Impossible'\\n  \t\telif m == 8:\\n  \t\t\tprint 'c.*'\\n  \t\t\tprint '..*'\\n  \t\t\tprint '***'\\n  \t\t\tprint '***'\\n  \t\telif m == 9:\\n  \t\t\tprint 'Impossible'\\n  \t\telif m == 10:\\n  \t\t\tprint 'Impossible'\\n  \t\telif m == 11:\\n  \t\t\tprint 'c**'\\n  \t\t\tprint '***'\\n  \t\t\tprint '***'\\n  \t\t\tprint '***'\\n  \telif c == 3 and r == 5:\\n  \t\tif m == 1:\\n  \t\t\tprint 'c..'\\n  \t\t\tprint '...'\\n  \t\t\tprint '...'\\n  \t\t\tprint '...'\\n  \t\t\tprint '..*'\\n  \t\telif m == 2:\\n  \t\t\tprint 'c..'\\n  \t\t\tprint '...'\\n  \t\t\tprint '...'\\n  \t\t\tprint '..*'\\n  \t\t\tprint '..*'\\n  \t\telif m == 3:\\n  \t\t\tprint 'c..'\\n  \t\t\tprint '...'\\n  \t\t\tprint '..*'\\n  \t\t\tprint '..*'\\n  \t\t\tprint '..*'\\n  \t\telif m == 4:\\n  \t\t\tprint 'c..'\\n  \t\t\tprint '...'\\n  \t\t\tprint '...'\\n  \t\t\tprint '..*'\\n  \t\t\tprint '***'\\n  \t\telif m == 5:\\n  \t\t\tprint 'c.*'\\n  \t\t\tprint '..*'\\n  \t\t\tprint '..*'\\n  \t\t\tprint '..*'\\n  \t\t\tprint '..*'\\n  \t\telif m == 6:\\n  \t\t\tprint 'c..'\\n  \t\t\tprint '...'\\n  \t\t\tprint '...'\\n  \t\t\tprint '***'\\n  \t\t\tprint '***'\\n  \t\telif m == 7:\\n  \t\t\tprint 'c..'\\n  \t\t\tprint '...'\\n  \t\t\tprint '..*'\\n  \t\t\tprint '***'\\n  \t\t\tprint '***'\\n  \t\telif m == 8:\\n  \t\t\tprint 'Impossible'\\n  \t\telif m == 9:\\n  \t\t\tprint 'c..'\\n  \t\t\tprint '...'\\n  \t\t\tprint '***'\\n  \t\t\tprint '***'\\n  \t\t\tprint '***'\\n  \t\telif m == 10:\\n  \t\t\tprint 'Impossible'\\n  \t\telif m == 11:\\n  \t\t\tprint 'c.*'\\n  \t\t\tprint '..*'\\n  \t\t\tprint '***'\\n  \t\t\tprint '***'\\n  \t\t\tprint '***'\\n  \t\telif m == 12:\\n  \t\t\tprint 'Impossible'\\n  \t\telif m == 13:\\n  \t\t\tprint 'Impossible'\\n  \t\telif m == 14:\\n  \t\t\tprint 'c**'\\n  \t\t\tprint '***'\\n  \t\t\tprint '***'\\n  \t\t\tprint '***'\\n  \t\t\tprint '***'\\n  \telif c == 4 and r == 3:\\n  \t\tif m == 1:\\n  \t\t\tprint 'c...'\\n  \t\t\tprint '....'\\n  \t\t\tprint '...*'\\n  \t\telif m == 2:\\n  \t\t\tprint 'c...'\\n  \t\t\tprint '...*'\\n  \t\t\tprint '...*'\\n  \t\telif m == 3:\\n  \t\t\tprint 'c..*'\\n  \t\t\tprint '...*'\\n  \t\t\tprint '...*'\\n  \t\telif m == 4:\\n  \t\t\tprint 'c...'\\n  \t\t\tprint '....'\\n  \t\t\tprint '****'\\n  \t\telif m == 5:\\n  \t\t\tprint 'Impossible'\\n  \t\telif m == 6:\\n  \t\t\tprint 'c.**'\\n  \t\t\tprint '..**'\\n  \t\t\tprint '..**'\\n  \t\telif m == 7:\\n  \t\t\tprint 'Impossible'\\n  \t\telif m == 8:\\n  \t\t\tprint 'c.**'\\n  \t\t\tprint '..**'\\n  \t\t\tprint '****'\\n  \t\telif m == 9:\\n  \t\t\tprint 'Impossible'\\n  \t\telif m == 10:\\n  \t\t\tprint 'Impossible'\\n  \t\telif m == 11:\\n  \t\t\tprint 'c***'\\n  \t\t\tprint '****'\\n  \t\t\tprint '****'\\n  \telif c == 4 and r == 4:\\n  \t\tif m == 1:\\n  \t\t\tprint 'c...'\\n  \t\t\tprint '....'\\n  \t\t\tprint '....'\\n  \t\t\tprint '...*'\\n  \t\telif m == 2:\\n  \t\t\tprint 'c...'\\n  \t\t\tprint '....'\\n  \t\t\tprint '....'\\n  \t\t\tprint '..**'\\n  \t\telif m == 3:\\n  \t\t\tprint 'c...'\\n  \t\t\tprint '....'\\n  \t\t\tprint '...*'\\n  \t\t\tprint '..**'\\n  \t\telif m == 4:\\n  \t\t\tprint 'c...'\\n  \t\t\tprint '....'\\n  \t\t\tprint '....'\\n  \t\t\tprint '****'\\n  \t\telif m == 5:\\n  \t\t\tprint 'c...'\\n  \t\t\tprint '....'\\n  \t\t\tprint '...*'\\n  \t\t\tprint '****'\\n  \t\telif m == 6:\\n  \t\t\tprint 'c...'\\n  \t\t\tprint '....'\\n  \t\t\tprint '..**'\\n  \t\t\tprint '****'\\n  \t\telif m == 7:\\n  \t\t\tprint 'c..*'\\n  \t\t\tprint '...*'\\n  \t\t\tprint '...*'\\n  \t\t\tprint '****'\\n  \t\telif m == 8:\\n  \t\t\tprint 'c...'\\n  \t\t\tprint '....'\\n  \t\t\tprint '****'\\n  \t\t\tprint '****'\\n  \t\telif m == 9:\\n  \t\t\tprint 'Impossible'\\n  \t\telif m == 10:\\n  \t\t\tprint 'c.**'\\n  \t\t\tprint '..**'\\n  \t\t\tprint '..**'\\n  \t\t\tprint '****'\\n  \t\telif m == 11:\\n  \t\t\tprint 'Impossible'\\n  \t\telif m == 12:\\n  \t\t\tprint 'c.**'\\n  \t\t\tprint '..**'\\n  \t\t\tprint '****'\\n  \t\t\tprint '****'\\n  \t\telif m == 13:\\n  \t\t\tprint 'Impossible'\\n  \t\telif m == 14:\\n  \t\t\tprint 'Impossible'\\n  \t\telif m == 15:\\n  \t\t\tprint 'c***'\\n  \t\t\tprint '****'\\n  \t\t\tprint '****'\\n  \t\t\tprint '****'\\n  \telif c == 4 and r == 5:\\n  \t\tif m == 1:\\n  \t\t\tprint 'c...'\\n  \t\t\tprint '....'\\n  \t\t\tprint '....'\\n  \t\t\tprint '....'\\n  \t\t\tprint '...*'\\n  \t\telif m == 2:\\n  \t\t\tprint 'c...'\\n  \t\t\tprint '....'\\n  \t\t\tprint '....'\\n  \t\t\tprint '....'\\n  \t\t\tprint '..**'\\n  \t\telif m == 3:\\n  \t\t\tprint 'c...'\\n  \t\t\tprint '....'\\n  \t\t\tprint '...*'\\n  \t\t\tprint '...*'\\n  \t\t\tprint '...*'\\n  \t\telif m == 4:\\n  \t\t\tprint 'c...'\\n  \t\t\tprint '....'\\n  \t\t\tprint '....'\\n  \t\t\tprint '....'\\n  \t\t\tprint '****'\\n  \t\telif m == 5:\\n  \t\t\tprint 'c..*'\\n  \t\t\tprint '...*'\\n  \t\t\tprint '...*'\\n  \t\t\tprint '...*'\\n  \t\t\tprint '...*'\\n  \t\telif m == 6:\\n  \t\t\tprint 'c...'\\n  \t\t\tprint '....'\\n  \t\t\tprint '....'\\n  \t\t\tprint '..**'\\n  \t\t\tprint '****'\\n  \t\telif m == 7:\\n  \t\t\tprint 'c..*'\\n  \t\t\tprint '...*'\\n  \t\t\tprint '...*'\\n  \t\t\tprint '..**'\\n  \t\t\tprint '..**'\\n  \t\telif m == 8:\\n  \t\t\tprint 'c...'\\n  \t\t\tprint '....'\\n  \t\t\tprint '....'\\n  \t\t\tprint '****'\\n  \t\t\tprint '****'\\n  \t\telif m == 9:\\n  \t\t\tprint 'c..*'\\n  \t\t\tprint '...*'\\n  \t\t\tprint '...*'\\n  \t\t\tprint '..**'\\n  \t\t\tprint '****'\\n  \t\telif m == 10:\\n  \t\t\tprint 'c.**'\\n  \t\t\tprint '..**'\\n  \t\t\tprint '..**'\\n  \t\t\tprint '..**'\\n  \t\t\tprint '..**'\\n  \t\telif m == 11:\\n  \t\t\tprint 'c..*'\\n  \t\t\tprint '...*'\\n  \t\t\tprint '...*'\\n  \t\t\tprint '****'\\n  \t\t\tprint '****'\\n  \t\telif m == 12:\\n  \t\t\tprint 'c...'\\n  \t\t\tprint '....'\\n  \t\t\tprint '****'\\n  \t\t\tprint '****'\\n  \t\t\tprint '****'\\n  \t\telif m == 13:\\n  \t\t\tprint 'Impossible'\\n  \t\telif m == 14:\\n  \t\t\tprint 'c..*'\\n  \t\t\tprint '...*'\\n  \t\t\tprint '****'\\n  \t\t\tprint '****'\\n  \t\t\tprint '****'\\n  \t\telif m == 15:\\n  \t\t\tprint 'Impossible'\\n  \t\telif m == 16:\\n  \t\t\tprint 'c.**'\\n  \t\t\tprint '..**'\\n  \t\t\tprint '****'\\n  \t\t\tprint '****'\\n  \t\t\tprint '****'\\n  \t\telif m == 17:\\n  \t\t\tprint 'Impossible'\\n  \t\telif m == 18:\\n  \t\t\tprint 'Impossible'\\n  \t\telif m == 19:\\n  \t\t\tprint 'c***'\\n  \t\t\tprint '****'\\n  \t\t\tprint '****'\\n  \t\t\tprint '****'\\n  \t\t\tprint '****'\\n  \telif c == 5 and r == 3:\\n  \t\tif m == 1:\\n  \t\t\tprint 'c....'\\n  \t\t\tprint '.....'\\n  \t\t\tprint '....*'\\n  \t\telif m == 2:\\n  \t\t\tprint 'c....'\\n  \t\t\tprint '.....'\\n  \t\t\tprint '...**'\\n  \t\telif m == 3:\\n  \t\t\tprint 'c....'\\n  \t\t\tprint '.....'\\n  \t\t\tprint '..***'\\n  \t\telif m == 4:\\n  \t\t\tprint 'c...*'\\n  \t\t\tprint '....*'\\n  \t\t\tprint '...**'\\n  \t\telif m == 5:\\n  \t\t\tprint 'c....'\\n  \t\t\tprint '.....'\\n  \t\t\tprint '*****'\\n  \t\telif m == 6:\\n  \t\t\tprint 'c..**'\\n  \t\t\tprint '...**'\\n  \t\t\tprint '...**'\\n  \t\telif m == 7:\\n  \t\t\tprint 'c..**'\\n  \t\t\tprint '...**'\\n  \t\t\tprint '..***'\\n  \t\telif m == 8:\\n  \t\t\tprint 'Impossible'\\n  \t\telif m == 9:\\n  \t\t\tprint 'c.***'\\n  \t\t\tprint '..***'\\n  \t\t\tprint '..***'\\n  \t\telif m == 10:\\n  \t\t\tprint 'Impossible'\\n  \t\telif m == 11:\\n  \t\t\tprint 'c.***'\\n  \t\t\tprint '..***'\\n  \t\t\tprint '*****'\\n  \t\telif m == 12:\\n  \t\t\tprint 'Impossible'\\n  \t\telif m == 13:\\n  \t\t\tprint 'Impossible'\\n  \t\telif m == 14:\\n  \t\t\tprint 'c****'\\n  \t\t\tprint '*****'\\n  \t\t\tprint '*****'\\n  \telif c == 5 and r == 4:\\n  \t\tif m == 1:\\n  \t\t\tprint 'c....'\\n  \t\t\tprint '.....'\\n  \t\t\tprint '.....'\\n  \t\t\tprint '....*'\\n  \t\telif m == 2:\\n  \t\t\tprint 'c....'\\n  \t\t\tprint '.....'\\n  \t\t\tprint '.....'\\n  \t\t\tprint '...**'\\n  \t\telif m == 3:\\n  \t\t\tprint 'c....'\\n  \t\t\tprint '.....'\\n  \t\t\tprint '.....'\\n  \t\t\tprint '..***'\\n  \t\telif m == 4:\\n  \t\t\tprint 'c...*'\\n  \t\t\tprint '....*'\\n  \t\t\tprint '....*'\\n  \t\t\tprint '....*'\\n  \t\telif m == 5:\\n  \t\t\tprint 'c....'\\n  \t\t\tprint '.....'\\n  \t\t\tprint '.....'\\n  \t\t\tprint '*****'\\n  \t\telif m == 6:\\n  \t\t\tprint 'c...*'\\n  \t\t\tprint '....*'\\n  \t\t\tprint '....*'\\n  \t\t\tprint '..***'\\n  \t\telif m == 7:\\n  \t\t\tprint 'c....'\\n  \t\t\tprint '.....'\\n  \t\t\tprint '...**'\\n  \t\t\tprint '*****'\\n  \t\telif m == 8:\\n  \t\t\tprint 'c..**'\\n  \t\t\tprint '...**'\\n  \t\t\tprint '...**'\\n  \t\t\tprint '...**'\\n  \t\telif m == 9:\\n  \t\t\tprint 'c...*'\\n  \t\t\tprint '....*'\\n  \t\t\tprint '...**'\\n  \t\t\tprint '*****'\\n  \t\telif m == 10:\\n  \t\t\tprint 'c....'\\n  \t\t\tprint '.....'\\n  \t\t\tprint '*****'\\n  \t\t\tprint '*****'\\n  \t\telif m == 11:\\n  \t\t\tprint 'c..**'\\n  \t\t\tprint '...**'\\n  \t\t\tprint '...**'\\n  \t\t\tprint '*****'\\n  \t\telif m == 12:\\n  \t\t\tprint 'c.***'\\n  \t\t\tprint '..***'\\n  \t\t\tprint '..***'\\n  \t\t\tprint '..***'\\n  \t\telif m == 13:\\n  \t\t\tprint 'Impossible'\\n  \t\telif m == 14:\\n  \t\t\tprint 'c.***'\\n  \t\t\tprint '..***'\\n  \t\t\tprint '..***'\\n  \t\t\tprint '*****'\\n  \t\telif m == 15:\\n  \t\t\tprint 'Impossible'\\n  \t\telif m == 16:\\n  \t\t\tprint 'c.***'\\n  \t\t\tprint '..***'\\n  \t\t\tprint '*****'\\n  \t\t\tprint '*****'\\n  \t\telif m == 17:\\n  \t\t\tprint 'Impossible'\\n  \t\telif m == 18:\\n  \t\t\tprint 'Impossible'\\n  \t\telif m == 19:\\n  \t\t\tprint 'c****'\\n  \t\t\tprint '*****'\\n  \t\t\tprint '*****'\\n  \t\t\tprint '*****'\\n  \telif c == 5 and r == 5:\\n  \t\tif m == 1:\\n  \t\t\tprint 'c....'\\n  \t\t\tprint '.....'\\n  \t\t\tprint '.....'\\n  \t\t\tprint '.....'\\n  \t\t\tprint '....*'\\n  \t\telif m == 2:\\n  \t\t\tprint 'c....'\\n  \t\t\tprint '.....'\\n  \t\t\tprint '.....'\\n  \t\t\tprint '.....'\\n  \t\t\tprint '...**'\\n  \t\telif m == 3:\\n  \t\t\tprint 'c....'\\n  \t\t\tprint '.....'\\n  \t\t\tprint '.....'\\n  \t\t\tprint '.....'\\n  \t\t\tprint '..***'\\n  \t\telif m == 4:\\n  \t\t\tprint 'c....'\\n  \t\t\tprint '.....'\\n  \t\t\tprint '.....'\\n  \t\t\tprint '...**'\\n  \t\t\tprint '...**'\\n  \t\telif m == 5:\\n  \t\t\tprint 'c....'\\n  \t\t\tprint '.....'\\n  \t\t\tprint '.....'\\n  \t\t\tprint '.....'\\n  \t\t\tprint '*****'\\n  \t\telif m == 6:\\n  \t\t\tprint 'c....'\\n  \t\t\tprint '.....'\\n  \t\t\tprint '.....'\\n  \t\t\tprint '..***'\\n  \t\t\tprint '..***'\\n  \t\telif m == 7:\\n  \t\t\tprint 'c....'\\n  \t\t\tprint '.....'\\n  \t\t\tprint '.....'\\n  \t\t\tprint '...**'\\n  \t\t\tprint '*****'\\n  \t\telif m == 8:\\n  \t\t\tprint 'c....'\\n  \t\t\tprint '.....'\\n  \t\t\tprint '.....'\\n  \t\t\tprint '..***'\\n  \t\t\tprint '*****'\\n  \t\telif m == 9:\\n  \t\t\tprint 'c...*'\\n  \t\t\tprint '....*'\\n  \t\t\tprint '....*'\\n  \t\t\tprint '....*'\\n  \t\t\tprint '*****'\\n  \t\telif m == 10:\\n  \t\t\tprint 'c....'\\n  \t\t\tprint '.....'\\n  \t\t\tprint '.....'\\n  \t\t\tprint '*****'\\n  \t\t\tprint '*****'\\n  \t\telif m == 11:\\n  \t\t\tprint 'c....'\\n  \t\t\tprint '.....'\\n  \t\t\tprint '....*'\\n  \t\t\tprint '*****'\\n  \t\t\tprint '*****'\\n  \t\telif m == 12:\\n  \t\t\tprint 'c....'\\n  \t\t\tprint '.....'\\n  \t\t\tprint '...**'\\n  \t\t\tprint '*****'\\n  \t\t\tprint '*****'\\n  \t\telif m == 13:\\n  \t\t\tprint 'c....'\\n  \t\t\tprint '.....'\\n  \t\t\tprint '..***'\\n  \t\t\tprint '*****'\\n  \t\t\tprint '*****'\\n  \t\telif m == 14:\\n  \t\t\tprint 'c..**'\\n  \t\t\tprint '...**'\\n  \t\t\tprint '...**'\\n  \t\t\tprint '..***'\\n  \t\t\tprint '*****'\\n  \t\telif m == 15:\\n  \t\t\tprint 'c....'\\n  \t\t\tprint '.....'\\n  \t\t\tprint '*****'\\n  \t\t\tprint '*****'\\n  \t\t\tprint '*****'\\n  \t\telif m == 16:\\n  \t\t\tprint 'c..**'\\n  \t\t\tprint '...**'\\n  \t\t\tprint '...**'\\n  \t\t\tprint '*****'\\n  \t\t\tprint '*****'\\n  \t\telif m == 17:\\n  \t\t\tprint 'c..**'\\n  \t\t\tprint '...**'\\n  \t\t\tprint '..***'\\n  \t\t\tprint '*****'\\n  \t\t\tprint '*****'\\n  \t\telif m == 18:\\n  \t\t\tprint 'Impossible'\\n  \t\telif m == 19:\\n  \t\t\tprint 'c..**'\\n  \t\t\tprint '...**'\\n  \t\t\tprint '*****'\\n  \t\t\tprint '*****'\\n  \t\t\tprint '*****'\\n  \t\telif m == 20:\\n  \t\t\tprint 'Impossible'\\n  \t\telif m == 21:\\n  \t\t\tprint 'c.***'\\n  \t\t\tprint '..***'\\n  \t\t\tprint '*****'\\n  \t\t\tprint '*****'\\n  \t\t\tprint '*****'\\n  \t\telif m == 22:\\n  \t\t\tprint 'Impossible'\\n  \t\telif m == 23:\\n  \t\t\tprint 'Impossible'\\n  \t\telif m == 24:\\n  \t\t\tprint 'c****'\\n  \t\t\tprint '*****'\\n  \t\t\tprint '*****'\\n  \t\t\tprint '*****'\\n  \t\t\tprint '*****'\\n  \telse:\\n  \t\tprint 'Impossible'\\n  \\n", "substitutes": {"t": ["trial", "p", "tt", "j", "type", "tm", "e", "at", "ties", "o", "ct", "z", "n", "g", "s", "f", "tr", "dt", "d", "q", "y", "b", "l", "ot", "te", "a", "ta", "v", "tc", "ts", "T", "rt"], "case": ["trial", "switch", "se", "one", "race", "code", "pe", "ace", "rule", "name", "chain", "cation", "change", "set", "core", "catch", "mode", "me", "cor", "ste", "rial", "Case", "co", "sequence", "hyp", "cases", "ice", "ASE", "ase", "ce", "ion", "tc", "test", "choice", "ind", "ci", "cas"], "r": ["range", "br", "p", "j", "rc", "ra", "er", "re", "e", "adr", "rs", "reg", "it", "o", "rec", "h", "nr", "ro", "an", "rg", "n", "g", "rb", "s", "R", "f", "z", "run", "ar", "ru", "pc", "w", "d", "u", "q", "y", "kr", "b", "l", "rr", "cr", "rar", "x", "sr", "attr", "ch", "ter", "dr", "rm", "mr", "a", "vr", "v", "ry", "rd", "rt", "ir"], "c": ["dc", "p", "ic", "rc", "k", "er", "re", "e", "cp", "cm", "o", "cut", "cur", "lc", "ct", "bc", "h", "an", "cf", "n", "g", "con", "s", "f", "z", "cos", "ar", "pc", "cat", "cu", "d", "w", "arc", "cb", "sc", "q", "cache", "cs", "y", "cin", "u", "uc", "b", "ac", "cl", "l", "unc", "cr", "co", "x", "cc", "mc", "cum", "ch", "C", "ter", "ca", "ce", "a", "v", "tc", "com", "ci"], "m": ["p", "rem", "er", "re", "e", "h", "max", "an", "term", "ar", "d", "q", "module", "fm", "M", "mk", "min", "mom", "mem", "a", "med", "em", "dm", "o", "no", "s", "perm", "span", "mo", "mc", "nm", "ch", "mr", "v", "tm", "ms", "it", "mm", "z", "n", "g", "f", "am", "um", "om", "y", "man", "mt", "l", "x", "sm", "ter", "vm", "arm", "j", "cm", "mat", "pm", "bm", "gm", "im", "mi", "b", "me", "mu", "mut", "ma", "md", "rm"], "i": ["gi", "ki", "p", "ic", "ib", "li", "e", "it", "iy", "ia", "o", "iti", "iri", "ri", "ei", "il", "ti", "ini", "int", "ili", "si", "im", "mi", "\u0438", "cli", "ai", "ip", "itime", "adi", "l", "pi", "ii", "ij", "iu", "oi", "ati", "di", "zi", "ig", "ie", "fi", "ir", "ci"]}}
{"code": "t = int(raw_input())\\n  \\n  for case in range(t):\\n  \tr1 = int(raw_input())\\n  \tc1 = []\\n  \tfor j in range(4):\\n  \t\tc1.append([int(i) for i in raw_input().split()])\\n  \\n  \tr2 = int(raw_input())\\n  \tc2 = []\\n  \tfor j in range(4):\\n  \t\tc2.append([int(i) for i in raw_input().split()])\\n  \\n  \tnum = -1\\n  \tpossibles = 0\\n  \tfor j in c1[r1-1]:\\n  \t\tif c2[r2-1].count(j) == 1:\\n  \t\t\tnum = j\\n  \t\t\tpossibles += 1\\n  \\n  \tif possibles > 1:\\n  \t\tprint 'Case #'+str(case+1)+': Bad magician!'\\n  \telif possibles == 0:\\n  \t\tprint 'Case #'+str(case+1)+': Volunteer cheated!'\\n  \telse:\\n  \t\tprint 'Case #'+str(case+1)+': '+str(num)\\n", "substitutes": {"t": ["trial", "p", "tt", "k", "total", "type", "tm", "e", "it", "o", "m", "time", "h", "z", "n", "g", "s", "f", "test", "w", "d", "q", "r", "l", "x", "te", "out", "c", "ta", "v", "tc", "ts", "T", "pt", "tw", "size"], "case": ["trial", "switch", "p", "one", "race", "cho", "su", "force", "time", "client", "block", "sim", "context", "key", "pe", "code", "ace", "example", "name", "chain", "cation", "section", "line", "set", "core", "catch", "mode", "cor", "bite", "Case", "cycle", "sequence", " Case", "tie", "connection", "hyp", "cases", "ice", "ase", "ce", "ion", "ie", "pair", "test", "size", "ci", "cas"], "r1": ["ro1", "c0", "rc2", "r0", " r0", "r71", "c3", "mr71", "ro001", "r001", "c001", "ro7", "c7", "rc0", "rc1", "mr1", "mr7", " r3", "rc3", "c71", "mr001", "r3", "r7", "ro71"], "c1": ["xc2", "arc7", "ctx", "rc2", "C3", "rcOne", "ct2", "c3", "Ctx", "r001", "arc1", "rOne", "c001", "xc1", "ct3", " cOne", "ct1", "c7", "C1", "xc3", "r3", "rc1", "COne", " ctx", "rc3", "cOne", "arctx", "C7", " c7", "C2", "ct001", "arcOne", "xc001"], "j": ["ji", "br", "p", "jj", "k", "ju", "er", "it", "jp", "o", "jam", "m", "jo", "h", "z", "n", "g", "s", "f", "ja", "name", "item", "bi", "d", "pr", "uj", "q", "y", "json", "r", "J", "opt", "kj", "b", "dj", "l", "value", "oj", "number", "ij", "job", "jc", "ch", "obj", "new", "xy", "js", "jump", "c", "ie", "v", "aj", "bj", "test", "ind", "other"], "i": ["gi", "ki", "ji", "ic", "p", "ib", "li", "it", "ia", "o", "io", "m", "iti", "id", "iri", "n", "ei", "qi", "info", "int", "ti", "ini", "bi", "si", "xi", "im", "mi", "y", "\u0438", "ai", "\u00ed", "ip", "l", "x", "oi", "ii", "ij", "iu", "pi", "di", "zi", "I", "ig", "a", "ie", "v", "ir", "yi", "ci"], "r2": ["R2", "rc2", "rt6", "rc02", "R3", "r02", "c3", "r6", "c02", " r02", "R6", "rt2", "c6", " r3", "R1", "rt1", "rc3", "r3", "rt3"], "c2": ["h02", "pc1", "rc2", "c102", "pc02", "rc02", "ct4", "rtwo", "ctwo", "h2", "r02", "ct2", "c02", "pc2", "r4", "pc102", "tc02", " c02", "rctwo", " c102", "ct1", " c4", "h1", "c4", "rc1", "tc1", "tc102", "htwo", "tc2"], "num": ["p", "total", "count", "su", "snap", "no", "sim", "den", "success", "zero", "n", "conf", "con", "dev", "gnu", "general", "um", "mn", "index", "multi", "serial", "nb", "nu", "nom", "unit", "np", "number", "cum", "NUM", "nt", "alph", "ver", "msg", "gen", "mult", "Num", "ident", "mem", "sum", "cal", "dim", "good", "valid", "comment", "mon", "hom"], "possibles": ["positibles", "Positibles", "passibles", "possibilities", "Passisons", "positBILITIES", "passibility", "passisons", "Passible", "spensibles", "PossBILITIES", "Possisons", "poslings", "Possibilities", "passBILITIES", "penslings", "posible", "Positibilities", "Positible", "possitions", "pensibles", "pensibility", "Passlings", "pensibilities", "passible", "possBILITIES", "posesibles", "positisons", "Passibles", "pensible", "spensibilities", "spossitions", "spensible", "passibilities", "Positibility", "posesBILITIES", "Possible", "possisons", "posslings", "Possibility", "spossible", "positible", "positibilities", "possibility", "passitions", "positibility", "spossibles", "Posslings", "spensitions", "posesisons", "Possibles", "pensitions", "Passibilities", "posititions", "spossibilities", "posesibilities", "PassBILITIES", "posibilities", "posibles", "passlings", "possible"]}}
{"code": "def make_string(R, C, M):\\n      grid = [['.' for j in xrange(C)] for i in xrange(R)]\\n      grid[-1][-1] = 'c'\\n      t = M\\n      for i in xrange(R):\\n          for j in xrange(C):\\n              if M:\\n                  if forbidden(R, C, t, i, j):\\n                      continue\\n                  grid[i][j] = '*'\\n                  M -= 1\\n              else:\\n                  break\\n      s = ''\\n      if M:\\n          return 'Impossible'\\n      for r in grid:\\n          s += ''.join(r)+'\\n'\\n      return s[:-1]\\n  \\n  def forbidden(R, C, M, i, j):\\n      a = M / C\\n      b = M % C\\n      if (R*C - M == 1):\\n          return False\\n  \\n      if i >= (R-2) and j >= (C-2):\\n          return True\\n  \\n      if i >= (R-2) and b:\\n          if b % 2:\\n              return True\\n          if j < b/2:\\n              return False\\n          else:\\n              return True\\n      return False\\n          \\n  \\n  f = open('Csmall.in', 'r')\\n  g = open('outputC.txt', 'w')\\n  \\n  data = [[int(e) for e in line.strip(\"\\n\").split(' ')] for line in f]\\n  T = int(data.pop(0)[0])\\n  for i, case in enumerate(data):\\n      R, C, M = case[0], case[1], case[2]\\n      num_cells = R*C\\n      if (R-1) == 0 or (C-1) == 0:\\n          s = make_string(R, C, M)\\n          g.write('Case #%i:\\n%s\\n' %(i+1,s))\\n          continue\\n      else:\\n          s = make_string(R, C, M)\\n          g.write('Case #%i:\\n%s\\n' %(i+1, s))\\n          \\n  \\n  f.close()\\n  g.close()\\n", "substitutes": {"R": ["Range", "D", "G", "O", "JR", "Right", "X", "RA", "H", "L", "U", "Region", "A", "CR", "MR", "Q", "E", "DR", "RC", "Remote", "IR", "B", "RG", "RF", "Res", "RL", "Random", "RH", "AR", "Mr", "F", "J", "V", "RO", "RS", "Rot", "Row", "Y", "Cor", "N", "NR", "RE", "TR", "RR", "Ring", "Rs", "I", "RM", "P", "RT", "RI", "W", "BR", "S", "SR", "ER"], "C": ["COM", "Co", "D", "G", "O", "CD", "JC", "Ch", "COR", "Control", "H", "L", "U", "CR", "A", "E", "CM", "Cr", "Q", "CN", "Cut", "AC", "Chain", "B", "CS", "Cons", "CA", "TC", "CE", "Cl", "CC", "AR", "CI", "F", "WC", "CON", "J", "Craig", "V", "EC", "Y", "CNN", "N", "CO", "CT", "VC", "CP", "CF", "DC", "K", "I", "Cache", "P", "Mc", "CB", "c", "W", "CL", "MC", "CU", "Cond", "Circ", "S", "Cs", "CW"], "M": ["D", "G", "O", "VM", "Method", "X", "SM", "MA", "H", "TM", "m", "L", "U", "E", "Q", "A", "CM", " m", "MR", "NM", "MAN", "B", "Mi", "PM", "MM", "JM", "MO", "F", "J", "IM", "V", "Manager", "Z", "Y", "LM", "N", "Ms", "MD", "MT", "MI", "K", "I", "RM", "P", "W", "DM", "MC", "MH", "MS", "S", "AM"], "grid": ["res", "range", "tmp", "stock", " Grid", "storage", "er", " grids", "Grid", "reg", "cm", "m", "cur", "time", "client", "cart", "sim", "addr", "rid", "mat", "z", "window", "tile", "node", "code", "close", "chain", "w", "gm", "coord", "lay", "set", "q", "wire", "cs", "ut", "cache", "db", "row", "cells", "rr", "order", "age", "box", "dq", "gr", "map", "out", "c", "sq", "v", "lines", "ts", "lat", "cell"], "j": ["ji", "p", "jj", "k", "jl", "fr", "li", "it", "jp", "o", "m", "h", "key", "id", "z", "n", "ja", "tr", "index", "pr", "uj", "d", "q", "im", "y", "u", "J", "kj", "dj", "l", "bi", "rel", "co", "x", "ij", "ot", "job", "jc", "ch", "obj", "ix", "js", "jump", "ie", "c", "v", "aj", "ir", "bj", "ind", "ci"], "i": ["gi", "ki", "hi", "p", "ic", "ji", "ib", "k", "ami", "li", "it", "ia", "o", "io", "m", "sim", "key", "id", "n", "z", "iri", "ri", "phi", "int", "ti", "ini", "bi", "index", "si", " I", "u", "im", "xi", "init", "y", "ai", "q", "mi", "\u0438", "cli", "ip", "ori", "l", "x", "pi", "ii", "ij", "iu", "ix", "multi", "di", "zi", "I", "c", "ie", "v", "ir", "ind", "ci"], "t": ["tt", "p", "k", "type", "tm", "TT", "it", "o", "TM", "m", "time", "txt", "h", "z", "n", "w", "y", "mt", "l", "tz", "ot", "ta", "c", "v", "ts", "tc", "test"], "s": ["p", "er", "m", "times", "h", "results", "ed", "ls", "w", "d", "set", "ins", "sq", "c", "short", "comments", "less", "ings", "sets", "span", "sc", "ers", "parts", "types", "ix", "conv", "js", "v", "series", "es", "S", "sb", "ns", "os", "str", "err", "dx", "ss", "z", "n", "group", "ds", "its", "l", "sym", "x", "sm", "lines", "sum", "fx", "ats", "sg", "comment", "sts", "sv", "res", "gs", "sd", "single", "space", "rs", "ps", "ies", "us", "eds", "ws", "ims", "si", "cs", "days", "string", "fs", "rows", "ts", "sth", "steps", "tes"], "r": ["res", "range", "br", "p", "ra", "fr", "type", "re", "err", "rs", "reg", "m", "cur", "h", "rid", "run", "z", "n", "ur", "ror", "ri", "ar", "result", "tr", "d", "pr", "w", "q", "runs", "nor", "row", "l", "cr", "rar", "sr", "ring", "c", "v", "rd", "ir", "rh", "right"], "a": ["au", "sa", "alpha", "at", "ia", "area", "o", "m", "A", "an", "xa", "ba", "am", "ar", "aa", "ao", "ai", "ae", "al", "ea", "ma", "ta", "aj", "ab"], "b": ["p", "ib", "o", "m", "h", "bc", "bb", "z", "n", "rb", "bm", "ba", "B", "fb", "w", "d", "bi", "be", "cb", "u", "y", "eb", "nb", " B", "l", "bs", "x", "ot", "c", "v", "ab", "bt", "sb"], "f": ["ft", "fd", "p", "fr", "df", "frame", "o", "fe", "m", "fl", "h", "z", "cf", "fo", "rf", "af", "fg", "fb", "w", "d", "tf", "q", "F", "xf", "fm", "l", "x", "fp", "file", "fc", "c", "fs", "v", "fi", "fa"], "g": ["gi", "G", "og", "go", "it", "reg", "m", "mg", "h", "z", "group", "parent", "gg", "fg", "w", "bg", "d", "gm", "q", "gd", "green", "gz", "ga", "l", "gu", "groups", "gp", "pg", "vg", "gen", "msg", "gr", "out", "ig", "ge", "c", "gc", "v", "gt", "ger", "cfg", "gs"], "data": ["trial", "values", "ns", "empty", "p", "valid", "done", "res", "next", "dat", "DATA", "li", "bytes", "players", "no", "times", "results", "zero", "n", "group", "example", "ds", "info", "result", "users", "d", "dates", "dd", "da", "l", "split", "ata", "mu", "items", "new", "cases", "series", "lines", "details", "text", "test", "Data", "pie", "size", "list"], "e": ["au", "se", "p", "er", "it", "ite", "o", "element", "E", "ele", "pe", "n", "eg", "ed", "ne", "en", "ei", "d", "ze", "ke", "u", "y", "ec", "me", "el", "l", "ae", "est", "x", "eu", "xe", "te", "ea", "ase", "ce", "ge", "ie", "c", "ef", "es", "edge", "ode", "ee"], "line": ["Line", "p", "ic", "ide", "str", "force", "li", "frame", "end", "lin", "block", "code", "n", "pe", "lined", "close", "name", "chain", "ner", "ze", "change", "q", "ine", "set", "write", "link", "row", "point", "l", "val", "cycle", "age", "liner", "iter", "out", "ge", "v", "lines", "et", "cell", "lock", "edge", "ode"], "T": ["Time", "D", "G", "O", "TN", "X", "H", "L", "U", "E", "A", "B", "TS", "F", "J", "Type", "V", "Index", "Z", "Y", "N", "K", "I", "P", "W", "S"], "case": ["trial", "switch", "se", "match", "one", "race", "ide", "lic", "it", "piece", "part", "client", "block", "pe", "code", "ace", "group", "chain", "rule", "section", "condition", "result", "use", "change", "set", "entry", "catch", "me", "row", "Case", "instance", "ch", "connection", "ice", "cases", "ase", "ce", "ex", "exc", "cell", "test", "choice", "cas", "pair"], "num_cells": ["number_lines", "number_cases", "numberofcases", "number_cs", "number_cells", "numofcs", "numberofcs", "numofcells", "numofcases", "num_cases", "numberoflines", "num_lines", "num_cs", "numberofcells", "numoflines"]}}
{"code": "f = open('A.in', 'r')\\n  g = open('outputA.txt', 'w')\\n  data = [[int(e) for e in line.strip(\"\\n\").split(' ')] for line in f]\\n  T = data[0][0]\\n  c = 0\\n  for i in xrange(1, T*10 + 1, 10):\\n      c += 1\\n      choice1 = data[i][0]\\n      choice2 = data[i+5][0]\\n      grid1, grid2 = [], []\\n      for j in xrange(1,5):\\n          grid1.append(data[i+j])\\n  \\n      for j in xrange(6, 10):\\n          grid2.append(data[i+j])\\n  \\n      s1 = set(grid1[choice1-1])\\n      s2 = set(grid2[choice2-1])\\n  \\n      s = s1 & s2\\n      if len(s) == 1:\\n          g.write(\"Case #%i: %i\\n\" %(c, s.pop()))\\n      elif not s:\\n          g.write(\"Case #%i: Volunteer cheated!\\n\" %(c))\\n      else:\\n          g.write(\"Case #%i: Bad magician!\\n\" %(c))\\n  \\n  f.close()\\n  g.close()\\n      \\n", "substitutes": {"f": ["ft", "fd", "p", "bf", "fr", "t", "o", "fe", "fl", "h", "of", "z", "n", "fo", "conf", "rf", "af", "elf", "fg", "fb", "w", "d", "full", "lf", "q", "F", "r", "fm", "ff", "b", "l", "flow", "fast", "fp", "file", "fc", "a", "fs", "v", "fi", "fa", "alf"], "g": ["gi", "G", "og", "gy", "go", "reg", "t", "o", "m", "mg", "greg", "n", "group", "eg", "gg", "w", "bg", "ng", "gm", "q", "gd", "y", "gz", "ga", "l", "gu", "tg", "gp", "gate", "pg", "gre", "msg", "gen", "vg", "gr", "di", "ig", "ge", "gc", "v", "gt", "ger", "cfg", "message", "gs"], "data": ["res", "values", "next", "p", "valid", "done", "images", "dat", "str", "DATA", "t", "history", "times", "array", "results", "zero", "n", "group", "window", "raw", "chain", "ds", "info", "result", "w", "d", "users", "index", "dates", "set", "cache", "apps", "json", "r", "row", "da", "l", "days", "reports", "ata", "table", "mu", "read", "items", "vals", "new", "date", "map", "device", "a", "ta", "series", "lines", "pos", "details", "test", "Data", "good", "list"], "e": ["se", "p", "de", "er", " te", " E", " se", "t", "o", "E", "ele", "pe", "n", "eg", "ed", "ne", "ei", "d", "ze", " ie", "u", "ec", "ine", "r", " fe", "b", "ue", "el", "l", "x", "te", "ea", " be", "a", "ge", "ie", "et", "ef", "es", "ee"], "line": ["Line", "p", "bl", "ide", "str", "li", "ade", "ite", "o", "lin", "block", "code", "n", "pe", "ne", "lined", "let", "ner", "ze", "q", "ine", "r", "write", "link", "row", "el", "l", "nl", "cycle", "draw", "ln", "age", "te", "liner", "string", "iter", "out", "ge", "ie", "v", "lines", "cell", "text", "edge"], "T": ["D", "G", "O", "TP", "TI", "TT", "TN", "X", "t", "H", "L", "E", "Q", "A", "R", "B", "TC", "TS", "TA", "F", "J", "V", "M", "Z", "Y", "N", "C", "K", "I", "P", "W", "S"], "c": ["dc", "p", "ic", "k", "count", "rc", "cp", "cm", "t", "m", "cur", "lc", "ct", "h", "z", "n", "con", "conf", "nc", "cf", "category", "chain", "cation", "toc", "cu", "d", "w", "cb", "u", "sc", "cs", "cache", "uc", "r", "b", "l", "unc", "cr", "mc", "cc", "cum", "ch", "C", "cd", "etc", "ce", "a", "gc", "v", "tc", "ci"], "i": ["gi", "ki", "ic", "p", "ami", "li", "it", "ia", "t", "o", "m", "ik", "iti", "id", " ii", "ei", "name", "exp", "info", "ti", "ini", "bi", "index", "si", "int", "xi", "im", "y", "mi", "q", "ai", "ip", "l", "pi", "ii", "ij", "oi", "iu", "ix", "di", "zi", "I", "ie", "v", "ind", "ci"], "choice1": [" choiceOne", "choiceone", "sequenceed", "sequenceOne", "switch1", "choiceed", "pick2", "ChoiceOne", "Choiceone", " choiceone", "switched", "Choice2", "poseOne", "switchOne", "pickone", "pick1", "pose1", "pickOne", "sequenceone", "poseone", "switchone", "Choice1", "sequence1", "poseed", "choiceOne"], "choice2": ["choiceSecond", "ChoiceSecond", "sequence2", "chain4", "sequence02", "template3", "templateSecond", "template2", " choiceSecond", "sequenceSecond", "Choice2", "chain2", "sequence4", "choice02", "chain02", " choice02", "chainSecond", "Choice1", " choice4", "choice3", "template1", "Choice3", " choice3", "choice4"], "grid1": ["GridOne", "grid71", "layOne", "Grid1", "lay1", "domainOne", "Gridone", "stock1", "lay2", "stockOne", "chain71", " gridone", "gridone", " grid3", "domain2", "stock71", "lay3", "gridOne", "chain1", " grid71", "Grid3", "chain2", "stockone", "domain1", "chainOne", "domainone", "Grid2", "chainone", "grid3", " gridOne"], "grid2": [" grid5", "Grid1", "domaintwo", " grid4", "gate6", "stage6", "gr8", "gridtwo", " grid8", "domain8", "Grid4", "gr4", " gridtwo", "stage2", "gridb", "Grid5", "domain2", " grid6", "stage5", "manager5", "grid4", "domain6", "grid6", "manager2", "gr6", "gate2", "stageb", "managerb", "Grid2", "grtwo", "grid5", "manager6", "gr1", "gate5", "gateb", "grid8", "gr5", "gr2"], "j": ["ji", "br", "p", "jj", "ju", "jl", "k", "li", "it", "jp", "t", "o", "m", "h", "z", "n", "ja", "pr", "uj", "q", "y", "json", "r", "J", "kj", "b", "dj", "l", "oj", "x", "pi", "ij", "job", "jc", "obj", "xy", "js", "jump", "v", "je", "aj", "bj"], "s1": ["space30", "set0", "setone", " s0", "s0", "s5", "S1", "space0", "qs2", "ss1", " s30", "S0", "ss0", "Sone", " s5", "s30", "ss5", "set1", "qsone", "set2", "ss30", "space5", "qs1", "space1", "S2", "qs0", "sone"], "s2": ["s256", "ss3", "str2", "set4", "spl", " s3", "s3", "str256", " s4", "qs2", "s4", " s42", "strpl", "ss2", "ss4", "s42", "set02", "ss02", "set2", "qs256", "s02", "set3", "str42", "qspl", " spl", " s256", "qs42", " s02"], "s": ["ns", "p", "sa", "os", "xs", "ats", "less", "rs", "ms", "ps", "ings", "prints", "ares", "ies", "sb", "ids", "sub", "ss", "strings", "ys", "n", "ls", "eds", "sol", "ds", "ims", "si", "cs", "ers", "parts", "b", "gets", "ins", "simple", "ains", "seconds", "abs", "tes", "views", "als", "js", "services", "a", "ags", "ses", "ts", "es", "S", "sts", "stats", "gs"]}}
{"code": " \\n  if __name__ == \"__main__\":\\n      f = sys.stdin\\n      if len(sys.argv) >= 2:\\n          fn = sys.argv[1]\\n          if fn != '-':\\n              f = open(fn)\\n  \\n      T = int(f.readline())\\n      for _T in xrange(T):\\n          R, C, M = map(int, f.readline().split())\\n  \\n          print \"Case #%d:\" % (_T+1)\\n  \\n          left = R * C - M\\n  \\n          if R == 1:\\n              s = 'c'\\n              s += '.' * (left - 1)\\n              s += '*' * M\\n              print s\\n              continue\\n          if C == 1:\\n              print 'c'\\n              for i in xrange(left - 1):\\n                  print '.'\\n              for i in xrange(M):\\n                  print '*'\\n              continue\\n  \\n          if left == 1:\\n              print 'c' + '*' * (C-1)\\n              for i in xrange(R-1):\\n                  print '*' * C\\n              continue\\n  \\n          if (R == 2 or C == 2) and (M % 2 == 1 or left == 2):\\n              print \"Impossible\"\\n              continue\\n          if R == 2:\\n              assert left not in (2, 3, 5, 7)\\n              assert left >= 4\\n              print 'c' + '.' * (left/2 - 1) + '*' * (M/2)\\n              print '.' + '.' * (left/2 - 1) + '*' * (M/2)\\n              continue\\n          if C == 2:\\n              assert left >= 4\\n              assert left not in (2, 3, 5, 7)\\n              print 'c.'\\n              left -= 2\\n              R -= 1\\n              while left:\\n                  print '..'\\n                  left -= 2\\n                  R -= 1\\n              assert R >= 0\\n              while R:\\n                  print '**'\\n                  R -= 1\\n              continue\\n  \\n          assert R >= 3\\n          assert C >= 3\\n  \\n          if left == 4:\\n              print 'c.' + '*' * (C-2)\\n              print '..' + '*' * (C-2)\\n              for i in xrange(R-2):\\n                  print '*' * C\\n              continue\\n  \\n          if left in (2, 3, 5, 7):\\n              print \"Impossible\"\\n              continue\\n  \\n          assert left >= 6\\n  \\n          cols = max(3, (left + R-1) // R)\\n  \\n          if left % cols == 1:\\n              assert left >= 10\\n  \\n              print 'c' + '.' * (cols - 1) + '*' * (C - cols)\\n              left -= cols\\n              R -= 1\\n  \\n              while left > cols + 1:\\n                  print '.' * cols + '*' * (C - cols)\\n                  left -= cols\\n                  R -= 1\\n              assert left == cols + 1\\n              print '.' * (cols - 1) + '*' * (C - cols + 1)\\n              print '.' * (2) + '*' * (C - 2)\\n              R -= 2\\n  \\n              assert R >= 0\\n  \\n              while R:\\n                  print '*' * C\\n                  R -= 1\\n              continue\\n          else:\\n              assert left >= 6\\n  \\n              print 'c' + '.' * (cols - 1) + '*' * (C - cols)\\n              left -= cols\\n              R -= 1\\n  \\n              while left > cols:\\n                  print '.' * cols + '*' * (C - cols)\\n                  left -= cols\\n                  R -= 1\\n              assert left >= 2\\n              print '.' * (left) + '*' * (C - left)\\n              R -= 1\\n  \\n              assert R >= 0\\n  \\n              while R:\\n                  print '*' * C\\n                  R -= 1\\n              continue\\n  \\n          1/0\\n", "substitutes": {"f": ["ft", "fd", "p", "bf", "open", "fr", "df", "e", "t", "o", "m", "h", "of", "cf", "n", "fo", "g", "uf", "af", "elf", "fb", "w", "d", "lf", "tf", "alf", "sf", "y", "F", "r", "xf", "fm", "b", "ac", "l", "inf", "x", "fast", "feed", "fp", "file", "fc", "fs", "c", "v", "fa", "fw"], "fn": ["function", "fd", "bf", "fr", "TN", "cmd", "filename", "fl", "txt", "FN", "path", "n", "cf", "name", "mn", "full", "sn", "tf", "cn", "fun", "F", "fm", "ff", "typ", "unc", "dn", "np", "ln", "N", "nt", "syn", "nm", "obj", "format", "fp", "rm", "file", "fc", "out", "rn", "fin"], "T": ["D", "G", "O", "TT", "TN", "IT", "X", "t", "H", "L", "TM", "E", "A", "FT", "TH", "B", "TS", "TA", "F", "J", "V", "Z", "Y", "NT", "N", "WT", "TR", "TB", "I", "P", "W", "S"], "_T": ["_R", " _R", "_N", " _Z", "_C", " _C", "_Z", " _N", " _E", "_E"], "R": ["D", "G", "O", "Right", "X", "RA", "Left", "H", "L", "U", "CR", "Q", "E", "A", "DR", "ro", "RC", "B", "RF", "SR", "Res", "RG", "RL", "AR", "F", "r", "J", "V", "RO", "RS", "RN", "Rot", "Row", "Z", "Y", "N", "RE", "right", "TR", "RR", "Rs", "K", "I", "RM", "P", "RT", "W", "BR", "S", "MR", "ER"], "C": ["COM", "Co", "D", "G", "O", "Ch", "COR", "Right", "X", "H", "L", "U", "HC", "CR", "E", "A", "CM", "Chain", "CS", "B", "Cons", "CAR", "Cl", "CC", "WC", "F", "J", "SC", "V", "EC", "Con", "Y", "Config", "N", "Cu", "CO", "CT", "CG", "VC", "CP", "K", "DC", "I", "P", "Mc", "W", "c", "CL", "CCC", "MC", "CU", "S", "Cs", "CW", "Can"], "M": ["D", "G", "O", "X", "MA", "Left", "H", "TM", "m", "L", "U", "A", "Q", "MD", "CM", "E", "NM", "MAN", "B", "PM", "MM", "JM", "F", "J", "V", "Y", "LM", "N", "MT", "MI", "K", "I", "RM", "P", "W", "MC", "ME", "MS", "S", "MR", "MP"], "left": ["empty", "p", "rem", "shift", "check", "t", "lr", "long", "wrong", "le", "m", "LT", "old", "max", "none", "term", "top", "name", "ner", "w", "d", "full", "local", "set", "r", "log", "row", "insert", "to", "tree", "min", "position", "second", "length", "c", "low", "inner", "ft", "open", "LE", "Left", "no", "FT", "ro", "control", "RL", "field", "width", "on", "lt", "rel", "center", "out", "small", "level", "root", "this", "end", "Right", "err", "it", "column", "L", "sp", "path", "n", "before", "rest", "LP", " l", "role", "state", "RO", "limit", "l", "co", "x", "len", "ont", " right", "LL", "file", "ion", "data", "localhost", "right", "size", "range", "j", "start", "cm", "url", " L", "all", "relative", "lo", "location", "last", "condition", "only", "cont", "cl", "value", "just", "text", "nt", "loc", "lower", "ind", "list"], "s": ["scl", "ns", "se", "p", "str", "south", "ats", "e", "re", "rs", "ps", "er", "t", "o", "start", "sp", "m", "ss", "strings", "z", "n", "g", "ls", "w", "d", "only", "cs", "r", "its", "b", "ins", "ing", "just", "sts", "sm", "single", "sv", "ans", "a", "sq", "c", "ts", "es", "S", "sb", "status", "gs"], "i": ["gi", "ki", "ic", "ib", "li", "it", "iy", "ia", "io", "ior", "iti", "iri", "ri", "ei", "il", "ti", "ini", "ili", "si", "xi", "init", "cli", "ai", "ip", "x", "pi", "ii", "ij", "iu", "oi", "ati", "ix", "di", "I", "fi", "ir", "ci"], "cols": ["COLds", "columns", " colords", " colers", "COLs", "Colts", "colds", "colS", "COLords", "Cols", "ColS", "Colords", " colS", "columnts", "columnS", "Colds", "COLts", "colers", "columnds", "COLers", "colts", "Colers", "colords", "COLS"]}}
{"code": " \\n  if __name__ == \"__main__\":\\n      f = sys.stdin\\n      if len(sys.argv) >= 2:\\n          fn = sys.argv[1]\\n          if fn != '-':\\n              f = open(fn)\\n  \\n      T = int(f.readline())\\n      for _T in xrange(T):\\n          a1 = int(f.readline())\\n          l1 = [map(int, f.readline().split()) for _ in xrange(4)]\\n          a2 = int(f.readline())\\n          l2 = [map(int, f.readline().split()) for _ in xrange(4)]\\n  \\n          poss = list(set(l1[a1-1]) & set(l2[a2-1]))\\n  \\n          print \"Case #%d:\" % (_T + 1),\\n          if len(poss) == 0:\\n              print \"Volunteer cheated!\"\\n          elif len(poss) == 1:\\n              print poss[0]\\n          else:\\n              print \"Bad magician!\"\\n", "substitutes": {"f": ["ft", "fd", "p", "bf", "open", "fr", "form", "df", "t", "o", "fa", "fl", "h", "ct", "of", "cf", "n", "fo", "g", "uf", "af", "elf", "fg", "exp", "fb", "w", "d", "full", "lf", "tf", "sf", "q", "i", "y", "F", "r", "xf", "fm", "b", "l", "inf", "x", "fed", "input", "fast", "iter", "hl", "fp", "file", "fc", "fs", "c", "v", "fi", "fx", "fw"], "fn": ["function", "ns", "fd", "bf", "fr", "cmd", "filename", "fl", "txt", "FN", "path", "n", "nc", "cf", "hn", "phy", "mn", "full", "cn", "sn", "lf", "fle", "fun", "fm", "ff", "nu", "typ", "bn", "unc", "dn", "np", "ln", "nt", "syn", "pen", "nm", "obj", "fp", "file", "fc", "rn", "fin"], "T": ["Time", "D", "G", "O", "TT", "TN", "L", "TM", "A", "Q", "E", "R", "TH", "TC", "TS", "TA", "F", "OT", "J", "Type", "V", "M", "Z", "Y", "NT", "N", "WT", "GT", "TR", "TB", "C", "K", "Total", "I", "P", "S"], "_T": ["_N", " _A", "_D", " _TM", " _N", "_A", " _L", "_TM", " _D", "_L"], "a1": ["sa8", " a91", "sa0", "a9", "pa81", "sa9", "l01", "a91", "sa01", "la8", "l0", " a01", "la81", "sa81", "la9", "l91", "a0", "a01", "pa1", "a81", "pa9", "sa91", "pa8", "a8", " a0", "la1", "sa1"], "l1": ["ls1", "l51", "liup", " l01", "ls91", "lc4", "ls51", "llOne", "ll01", "ll1", "l01", "liOne", " lup", "li4", " lOne", "li51", "lc1", "l91", "li91", "l4", "ls4", "lOne", "lc91", "llup", "li01", "li1", "lc51", "lup"], "_": ["D", "j", "__", "___", "t", " __", "g", " the", " time", "M", "mt", "pt", "non"], "a2": ["a12", "pa3", "A2", "l12", "A12", "a3", " a12", "aB", "paB", "la6", "l6", "A8", "pa6", "l8", "pa2", "a6", "A1", "lB", " a8", "la3", "la2", "a8", "l3", "laB"], "l2": [" loder", "n1", "ls2", "n2", "l5", " l4", "ls5", "l02", " l5", "n3", "L3", "loder", "l4", " l3", "aoder", "a02", " l02", "lsoder", "n4", "L1", "L4", "L2", "l3", "ls02", "a5"], "poss": ["Pass", "pose", " ppos", "paitch", "loss", "Poss", "pwn", "mass", "mossible", "mose", "prwn", "spasses", " pOSS", "pross", "paack", "pawn", " pitch", "paoss", "parav", "passes", "Pitch", "pack", "pitch", " pack", "pOSS", "spwn", "lpos", "sprav", "sposs", "Possible", "lOSS", "Pack", "ppos", "prasses", "paossible", "paass", "paose", "prrav", "Pose", "Ppos", "POSS", "prav", "moss", "lose", "possible", "paasses", " pose"]}}
{"code": " \\n  \\n  TEST_CASES = [\\n      (\"\"\"5\\n  5 5 23\\n  3 1 1\\n  2 2 1\\n  4 7 3\\n  10 10 82\\n  \"\"\",\"\"\"Case #1:\\n  Impossible\\n  Case #2:\\n  c\\n  .\\n  *\\n  Case #3:\\n  Impossible\\n  Case #4:\\n  c......\\n  .......\\n  .......\\n  ....***\\n  Case #5:\\n  c........*\\n  .........*\\n  **********\\n  **********\\n  **********\\n  **********\\n  **********\\n  **********\\n  **********\\n  **********\\n  \"\"\"),\\n      (\"\"\"3\\n  5 4 3\\n  5 3 8\\n  5 5 14\\n  \"\"\",\"\"\"Case #1:\\n  c...\\n  ....\\n  ....\\n  ...*\\n  ..**\\n  Case #2:\\n  Impossible\\n  Case #3:\\n  c...*\\n  ....*\\n  ...**\\n  *****\\n  *****\\n  \"\"\")\\n  ]\\n  \\n  IMPOSSIBLE = \"Impossible\"\\n  \\n  \"\"\"\\n  S is number of safe squares = (R*C) - M\\n  If S == 1 then always possible:\\n      Assume click in top left, all else mines\\n  Special cases (R or C is small):\\n  If R == 1 or C == 1 then always possible:\\n      Assume click in top left and all safe squares in a line\\n  Else if R == 2 or C == 2 then possible iff S % 2 == 0:\\n      Assume click in top left and all safe squares are in a 2 * X line\\n  Else if R == 3 or C == 3 then possible if S % 3 == 0 (Assume click in top left and all safe squares are in a 3 * X line)\\n     OR if S % 2 == 0 \\n  \"\"\"\\n  \\n  def parse_input(input_reader):\\n      case_count = int(input_reader.readline())\\n      case_idx = 0\\n      while case_count > case_idx:\\n          case_idx += 1\\n          input_line = [int(x) for x in input_reader.readline().split()]\\n          input_values = {\"case\": case_idx,\\n                          \"R\": input_line[0],\\n                          \"C\": input_line[1],\\n                          \"M\": input_line[2]}\\n          yield input_values\\n  \\n  \\n  def solve_problem(output_writer=sys.stdout, **kwargs):\\n      case = kwargs['case']\\n      rows = kwargs['R']\\n      cols = kwargs['C']\\n      mines = kwargs['M']\\n      safe_squares = ((rows * cols) - mines)\\n      print >> output_writer, \"Case #%d:\" % case\\n      row_string = \"{:*<%ds}\" % cols\\n      impossible = False\\n      if safe_squares == 1:\\n          print >> output_writer, row_string.format(\"c\")\\n          for row in range(1, rows):\\n              print >> output_writer, row_string.format(\"\")\\n      elif rows == 1:\\n          safe_string = \"c\" + (\".\" * (safe_squares - 1))\\n          print >> output_writer, row_string.format(safe_string)\\n      elif cols == 1:\\n          for row in range(rows):\\n              cell = \"\"\\n              if row == 0:\\n                  cell = \"c\"\\n              elif row < safe_squares:\\n                  cell = \".\"\\n              print >> output_writer, row_string.format(cell)\\n      elif safe_squares == 2:\\n          impossible = True\\n      elif rows == 2:\\n          safe_cols, remainder = divmod(safe_squares, 2)\\n          if remainder == 1:\\n              impossible = True\\n          else:\\n              safe_string = \".\" * (safe_cols - 1)\\n              print >> output_writer, row_string.format(\"c%s\" % safe_string)\\n              print >> output_writer, row_string.format(\".%s\" % safe_string)\\n      elif cols == 2:\\n          safe_rows, remainder = divmod(safe_squares, 2)\\n          if remainder == 1:\\n              impossible = True\\n          else:\\n              for row in range(rows):\\n                  cells = \"\"\\n                  if row == 0:\\n                      cells = \"c.\"\\n                  elif row < safe_rows:\\n                      cells = \"..\"\\n                  print >> output_writer, row_string.format(cells)\\n      else:\\n          safe_rows, remainder = divmod(safe_squares, cols)\\n          if remainder == 1 and cols == 3 and safe_rows == 2:\\n              impossible = True\\n          elif safe_rows > 1:\\n              if remainder == 1 and safe_rows == 2:\\n                  mid_safe = \".\" * (cols-2)\\n                  for row in range(rows):\\n                      cell_one = \".\"\\n                      mid_cells = mid_safe\\n                      last_cell = \".\"\\n                      if row == 0:\\n                          cell_one = \"c\"\\n                      elif safe_rows == 0:\\n                          cell_one = \".\"\\n                          mid_cells = \".\" * (remainder + 1)\\n                      elif safe_rows < 0:\\n                          cell_one = \"\"\\n                          mid_cells = \"\"\\n                      if safe_rows < 3:\\n                          last_cell = \"\"\\n                      print >> output_writer, row_string.format(\"%s%s%s\" % (cell_one, mid_cells, last_cell))\\n                      safe_rows -= 1\\n              elif remainder == 1:\\n                  mid_safe = \".\" * (cols-2)\\n                  for row in range(rows):\\n                      cell_one = \".\"\\n                      mid_cells = mid_safe\\n                      last_cell = \".\"\\n                      if row == 0:\\n                          cell_one = \"c\"\\n                      elif safe_rows == 0:\\n                          cell_one = \".\"\\n                          mid_cells = \".\" * remainder\\n                      elif safe_rows < 0:\\n                          cell_one = \"\"\\n                          mid_cells = \"\"\\n                      if safe_rows < 2:\\n                          last_cell = \"\"\\n                      print >> output_writer, row_string.format(\"%s%s%s\" % (cell_one, mid_cells, last_cell))\\n                      safe_rows -= 1\\n              else:\\n                  full_safe = \".\" * cols\\n                  for row in range(rows):\\n                      cells = full_safe\\n                      if row == 0:\\n                          cells = \"c\" + (\".\" * (cols - 1))\\n                      elif row == safe_rows:\\n                          cells = \".\" * remainder\\n                      elif row > safe_rows:\\n                          cells = \"\"\\n                      print >> output_writer, row_string.format(cells)\\n          else:\\n              safe_cols, remainder = divmod(safe_squares, 2)\\n              if remainder == 1 and safe_cols < 4:\\n                  impossible = True\\n              elif remainder == 0:\\n                  print >> output_writer, row_string.format(\"c%s\" % (\".\" * (safe_cols - 1)))\\n                  print >> output_writer, row_string.format(\".\" * safe_cols)\\n                  for row in range(2, rows):\\n                      print >> output_writer, row_string.format(\"\")\\n              else:\\n                  safe_cols -= 1\\n                  print >> output_writer, row_string.format(\"c%s\" % (\".\" * (safe_cols - 1)))\\n                  print >> output_writer, row_string.format(\".\" * safe_cols)\\n                  print >> output_writer, row_string.format(\"...\")\\n                  for row in range(3, rows):\\n                      print >> output_writer, row_string.format(\"\")\\n      if impossible:\\n          print >> output_writer, IMPOSSIBLE\\n  \\n  def solve_inputs(input_reader, output_writer):\\n      \"\"\"\\n      Loop through each problem input in input reader and solve it.\\n  \\n      Outputs responses to output_writer.\\n      \"\"\"\\n      for input_values in parse_input(input_reader):\\n          solve_problem(output_writer=output_writer, **input_values)\\n  \\n  def run_tests():\\n      idx = 0\\n      all_pass = True\\n      for problem_input, expected_output in TEST_CASES:\\n          idx += 1\\n          input_reader = StringIO(problem_input)\\n          output_writer = StringIO()\\n          solve_inputs(input_reader, output_writer)\\n          problem_output = output_writer.getvalue()\\n          if problem_output == expected_output:\\n              print \"Test %d: Success\" % idx\\n          else:\\n              all_pass = False\\n              print \"Test %d: Failure\" % idx\\n              print problem_output\\n          input_reader.close()\\n          output_writer.close()\\n      if all_pass:\\n          print \"All tests were successful!\"\\n      else:\\n          print \"Something didn't match - try again.\"\\n  \\n  def main():\\n      parser = OptionParser()\\n      parser.add_option(\"-f\", \"--file\",\\n                        dest=\"filename_stem\",\\n                        help=\"read input from FILE.in and write to FILE.out\",\\n                        metavar=\"FILE\")\\n  \\n      (options, args) = parser.parse_args()\\n      if options.filename_stem:\\n          print \"Running in file mode.\"\\n          input_reader = open(\"%s.in\" % options.filename_stem, \"r\")\\n          output_writer = open(\"%s.out\" % options.filename_stem, \"w\")\\n          solve_inputs(input_reader, output_writer)\\n      else:\\n          print \"Running in test mode.\"\\n          run_tests()\\n  \\n  if __name__ == \"__main__\":\\n      main()\\n", "substitutes": {"TEST_CASES": ["TEST_cASED", "TEST_cATCHIONS", "TEST_CASEES", "TEST_CODES", "TEST_cATCHES", "TEST_CATCHIONS", "TEST_cASES", "TEST_cATCHED", "TEST_cATCHes", "TEST_CATCHES", "TEST_CASEIONS", "TEST_cASIONS", "TEST_CODED", "TEST_CASIONS", "TEST_cASes", "TEST_CASEED", "TEST_CATCHes", "TEST_CATCHED", "TEST_CASes", "TEST_CASED", "TEST_CASEes", "TEST_CODIONS", "TEST_CODes"], "IMPOSSIBLE": ["IMPOSIVE", "IMPONSIVE", "IMPPONSIBLE", "IMPPOSSibles", "IMPONSIBLE", "IMPPOSSible", "IMPPONSIVE", "IMPONSibles", "IMPOSible", "IMPossible", "IMPOSSIVE", "IMPossibles", "IMPPOSSIVE", "IMPPONSibles", "IMPossIVE", "IMPONSible", "IMPossIBLE", "IMPPONSible", "IMPOSSible", "IMPOSIBLE", "IMPOSSibles", "IMPPOSSIBLE", "IMPOSibles"], "input_reader": ["input2writer", "inputmatwriter", "inputmatloader", " input_writer", "input_writer", "input2liner", "input1liner", " input_liner", " input2liner", "input1reader", "input1writer", "inputfileloader", "inputfilewriter", " input_stream", "input_loader", "input_file", "input2stream", "output_file", "output_loader", "inputmatreader", "output_line", "input1stream", "inputfilefile", "input2reader", "inputfilereader", "input_stream", "output_reader", "inputmatline", " input2stream", " input2writer", "input_liner", " input2reader"], "case_count": ["case1count", "case1length", "case_base", "case_number", "Case_count", "Case_length", "case1number", " case_number", "case_length", "Case_number", "case_code", " case_code", " case_base"], "case_idx": ["case_idv", "case_indx", "case_idw", "case_idex", "case_endx", "case_ridn", "case_Idx", "case_idsv", "case_ridex", "case_idb", "case_idsn", "case_Idn", "case_endex", "case_ridb", "case_idn", "case_indn", "case_ideex", "case_idsx", "case_idxs", "case_index", "case_Idxs", "case_endn", "case_Idw", "case_indxs", "case_indb", "case_ideb", "case_Idv", "case_idsxs", "case_indv", "case_ridxs", "case_Idex", "case_endw", "case_idexs", "case_ridx"], "input_line": [" input_Line", "request_line", "input12line", "input5Line", "output_value", " input_look", "input5line", "output_entry", "request_look", "output_lines", "input_look", "input_word", "input_lines", "input_Line", " input_lines", "inputsline", "input5look", "inputslines", "output_line", "input12liner", "request_liner", "request_lines", " input_word", "input12lines", "input_value", "input_entry", "inputsword", "input12look", "input_liner"], "x": ["ux", "p", "xs", "xxx", "X", "rx", "xes", "t", "wx", "xxxx", "dx", "xp", "ax", "ox", "z", "xc", "xa", " xx", "tx", "xt", "ey", "mx", "ick", "xi", "y", "i", "xf", " ax", "xe", "xd", "ix", "xy", "ex", "px", "nex", "xx", "v", "fx"], "input_values": ["output_lines", "input_value", "input_lines", "output_values", "output_value", "output_vals", "input_vals"], "output_writer": ["input_buffer", "output___wrapper", "output2wrapper", "input_writer", "input_writing", "output___reader", "output_write", "output___writing", "output2reader", "input_write", "output_buffer", "output_reader", "output_wrapper", "output2writer", "output2buffer", "input_wrapper", "output___writer", "output2writing", "output2write", "output_writing"], "case": ["switch", "match", "force", "client", "block", "error", "E", "patch", "path", "ace", "example", "rule", "chain", "section", "condition", "use", "set", "Case", "position", "connection", "ice", "cases", "ase", "ce", "zip", "The", "power", "choice", "cas", "pair"], "rows": ["heads", "values", "xs", "rs", "times", "obs", "words", "roots", "blocks", "rown", "users", "dates", "orders", "cs", "runs", "r", "mins", "boxes", "maps", "groups", "posts", "chains", "ros", "checks", "ows", "cases", "OWS", "pages", "views", "frames", "ries", "lines", "jobs", "states", "tests"], "cols": ["columns", " coles", "colats", "columnats", "COLes", "COLs", "columnins", "COLgs", "Cols", "columngs", " colats", "Colats", " colts", "columnts", "COLts", "Colins", "columnes", " colgs", "Coles", " colins", "coles", "colts", "colins", "colgs"], "mines": ["minies", "minutes", "menies", "sixese", "minoes", "sixes", "minese", "passses", "indexses", "indexeds", "Minovers", "menses", "menes", " minese", "passutes", "sixses", "minses", "sixies", " minies", "amines", "minions", "MINovers", "passeds", "passes", "MINions", "indexes", "indexutes", "MINes", "aminses", "amineds", "mineds", "aminutes", "minovers", "Minoes", "Minions", "Mines", "menese", "MINoes", " minoes", " minses", " minovers", " minions"], "safe_squares": ["safe_squars", "safe_shares", "safe_quales", "safenesssquars", "safe_squales", "safe_quars", "safenessshales", "safe_quares", "safenesssquares", "safe_shales", "safe_shars", "safe_squared", "safenesssquales", "safenessshares", "safe_shared", "safenesssquared", "safenessshared", "safenessshars", "safe_quared"]}}
{"code": " \\n  \\n  TEST_CASES = [\\n      (\"\"\"3\\n  2\\n  1 2 3 4\\n  5 6 7 8\\n  9 10 11 12\\n  13 14 15 16\\n  3\\n  1 2 5 4\\n  3 11 6 15\\n  9 10 7 12\\n  13 14 8 16\\n  2\\n  1 2 3 4\\n  5 6 7 8\\n  9 10 11 12\\n  13 14 15 16\\n  2\\n  1 2 3 4\\n  5 6 7 8\\n  9 10 11 12\\n  13 14 15 16\\n  2\\n  1 2 3 4\\n  5 6 7 8\\n  9 10 11 12\\n  13 14 15 16\\n  3\\n  1 2 3 4\\n  5 6 7 8\\n  9 10 11 12\\n  13 14 15 16\\n  \"\"\",\"\"\"Case #1: 7\\n  Case #2: Bad magician!\\n  Case #3: Volunteer cheated!\\n  \"\"\"),\\n      (\"\"\"1\\n  1\\n  15 9 16 5\\n  6 10 1 3\\n  2 4 12 11\\n  13 14 8 7\\n  1\\n  5 10 9 6\\n  12 15 1 11\\n  14 16 4 2\\n  13 3 8 7\"\"\",\"\"\"Case #1: Bad magician!\\n  \"\"\")\\n  ]\\n  \\n  BAD_MAGIC = \"Bad magician!\"\\n  CHEATING = \"Volunteer cheated!\"\\n  \\n  def parse_input(input_reader):\\n      case_count = int(input_reader.readline())\\n      case_idx = 0\\n      while case_count > case_idx:\\n          case_idx += 1\\n          rows = []\\n          for loop_idx in (1,2):\\n              row_idx = int(input_reader.readline())\\n              for idx in (1,2,3,4):\\n                  if idx == row_idx:\\n                      rows.append(set(input_reader.readline().rstrip(\"\\n\").split(\" \")))\\n                  else:\\n                      input_reader.readline()\\n          input_values = {\"rows\":rows,\\n                          \"case\":case_idx}\\n          yield input_values\\n  \\n  \\n  def solve_problem(output_writer=sys.stdout, **kwargs):\\n      rows = kwargs['rows']\\n      case = kwargs['case']\\n      intersect = rows[0].intersection(rows[1])\\n      if not intersect:\\n          msg = CHEATING\\n      elif len(intersect) == 1:\\n          msg = intersect.pop()\\n      else:\\n          msg = BAD_MAGIC\\n      print >>output_writer, \"Case #%d: %s\" % (case, msg)\\n  \\n  def solve_inputs(input_reader, output_writer):\\n      \"\"\"\\n      Loop through each problem input in input reader and solve it.\\n  \\n      Outputs responses to output_writer.\\n      \"\"\"\\n      for input_values in parse_input(input_reader):\\n          solve_problem(output_writer=output_writer, **input_values)\\n  \\n  def run_tests():\\n      \"\"\"\\n      Check the sample input and output match.\\n      \"\"\"\\n      idx = 0\\n      all_pass = True\\n      for problem_input, expected_output in TEST_CASES:\\n          idx += 1\\n          input_reader = StringIO(problem_input)\\n          output_writer = StringIO()\\n          solve_inputs(input_reader, output_writer)\\n          problem_output = output_writer.getvalue()\\n          if problem_output == expected_output:\\n              print \"Test %d: Success\" % idx\\n          else:\\n              all_pass = False\\n              print \"Test %d: Failure\" % idx\\n          input_reader.close()\\n          output_writer.close()\\n      if all_pass:\\n          print \"All tests were successful!\"\\n      else:\\n          print \"Something didn't match - try again.\"\\n          print problem_output\\n  \\n  def main():\\n      parser = OptionParser()\\n      parser.add_option(\"-f\", \"--file\",\\n                        dest=\"filename_stem\",\\n                        help=\"read input from FILE.in and write to FILE.out\",\\n                        metavar=\"FILE\")\\n  \\n      (options, args) = parser.parse_args()\\n      if options.filename_stem:\\n          print \"Running in file mode.\"\\n          input_reader = open(\"%s.in\" % options.filename_stem, \"r\")\\n          output_writer = open(\"%s.out\" % options.filename_stem, \"w\")\\n          solve_inputs(input_reader, output_writer)\\n      else:\\n          print \"Running in test mode.\"\\n          run_tests()\\n  \\n  if __name__ == \"__main__\":\\n      main()\\n", "substitutes": {"TEST_CASES": ["TEST_CODES", "TEST_CATCHIONS", "TEST_CODINGS", "TEST_CALLIONS", "TEST_CATCHINGS", "TEST_CATCHES", "TEST_SCASes", "TEST_SCATCHES", "TEST_SCASES", "TEST_SCASIONS", "TEST_SCATCHIONS", "TEST_CALLes", "TEST_CASIONS", "TEST_SCASINGS", "TEST_SCATCHes", "TEST_CALLES", "TEST_CATCHes", "TEST_CASes", "TEST_CASINGS", "TEST_CALLINGS", "TEST_CODIONS", "TEST_SCATCHINGS", "TEST_CODes"], "BAD_MAGIC": ["BAD_MagICS", "BAD_MagICK", "BAD_MagICA", "BAD_AGICS", "BAD_MAGICK", "BAD_AGIC", "BADVERMAGIC", "BAD_MAGics", "BAD_AGics", "BAD_MAGICAL", "BADVERMAGICK", "BAD_MEDICAL", "BAD_magIC", "BAD_MagICAL", "BAD_AGICK", "BAD_MAGICA", "BAD_magICA", "BAD_MEDICS", "BAD_MEDIC", "BADVERMAGics", "BAD_MagIC", "BAD_MAGICS", "BAD_Magics", "BAD_magICS", "BAD_magICAL", "BADVERMAGICS", "BAD_MEDICA"], "CHEATING": ["CHeING", "CHeAKING", "CHeating", " CHEING", "CHPEating", " CHPEAKING", "CHPEAKING", "CHEEEATING", "UNCHPEating", "UNCHEATOR", " CHEating", "CHEEating", "CHPEING", " CHPEING", "CHPEATOR", "CHEEEING", "CHPEATING", " CHPEating", "CHEATOR", "CHEAKING", "CHEING", "UNCHEating", "UNCHEATING", "CHeATING", "UNCHPEATOR", "CHEEEAKING", "CHEating", " CHEAKING", "CHEEEating", "UNCHPEING", "CHEEATOR", "CHEEEATOR", "CHEEING", "UNCHPEATING", " CHPEATING", "CHEEATING", "UNCHEING"], "input_reader": ["input_read", " input_writer", "input1readable", " input_stream", "input4driver", "input1driver", "inputsstream", "inputswriter", "input10reader", "output_iterator", "input2writer", "input1writer", "output_read", "input_driver", "input1stream", "input_stream", "input_container", "input4writer", "inputsreader", "output_stream", "input2stream", "input4readable", "output_container", "input10stream", "input10container", "output_reader", "input2read", "inputsread", "input_writer", "output_readable", "output_driver", "input_iterator", "input_readable", "input1reader", "input2driver", " input_read", "input2reader", "input10writer", "input4reader"], "case_count": ["ase2Count", "ase2counter", "case_counter", "caseCcount", "caseCorder", "cycle_count", "ase_counter", "caseCCount", "ase2order", "case7order", "caseCountcount", "caseCountsum", "case2counter", "ase_order", "case_result", "caseCountresult", "case_order", "caseCountcontent", "case2order", "case_Count", "case_sum", "case2Count", "case7Count", "case2count", "ase_Count", "cycle_content", "ase2count", "caseCcounter", "ase_count", "cycle_result", "case_content", "cycle_sum", "case7count", "case7counter"], "case_idx": ["case_errct", "case_inex", "case_IDx", "case_intix", "case_idsxes", "case_Idxi", "case_edxes", "case_idxi", "case_idsex", "case_inx", "case_idz", "case_IDct", "case_initxi", "case_initv", "case_intx", "case_errx", "case_idct", "case_idex", "case_intv", "case_Idct", "case_IDex", "case_index", "case_edex", "case_inct", "case_indc", "case_initct", "case_edxi", "case_idix", "case_randix", "case_intz", "case_rex", "case_indct", "case_randx", "case_Idx", "case_errxi", "case_idsx", "case_randz", "case_rx", "case_IDc", "case_idc", "case_Idv", "case_idsxi", "case_inc", "case_rxi", "case_idv", "case_indx", "case_idxes", "case_initx", "case_edx", "case_randv", "case_rxes", "case_errv"], "rows": ["values", "heads", "works", "issues", "rs", "relations", "uds", "bows", "ids", "words", "bys", "roots", "blocks", "headers", "ds", "ports", "users", "flows", "dates", "orders", "runs", "workers", "docs", "row", "cells", "days", "fields", "reports", "maps", "bs", "groups", "sections", "owners", "rates", "ros", "holders", "points", "checks", "projects", "rooms", "ows", "cases", "views", "pages", "tests", "frames", "lines", "uploads", "drops", "states", "rules", "posts"], "loop_idx": ["loop_dbxs", "loop_indct", "loop_idxf", "loop_indx", "loop_midxf", "loop_midct", "loop_indxf", "loop_midx", "loop_idct", "loop_midxs", "loop_idxs", "loop_indxs", "loop_dbxf", "loop_dbx", "loop_dbct"], "row_idx": ["row_index", "row_ridex", "row_indx", "row_idsy", "row_idsx", "row2indz", "row_idz", "row_Idx", "row_idsz", "row_idsdx", "row_Idz", "row_ridy", "row_indy", "row_ridx", "row2indxc", "row_indxc", "row_idsxc", "row_inddx", "row2indx", "row_Idy", "row2idz", "row2indy", "row_idxc", "row_idsex", "row_idex", "row2idxc", "row2idx", "row_indz", "row_riddx", "row_iddx", "row2idy", "row_idy", "row_Idxc"], "idx": ["idex", "aidxb", "indy", "indx", "aidxa", " idix", "adxa", "adxf", "aidx", "adxb", " idex", " idxf", " idy", " idxa", " idxb", "aidxf", "index", "idix", "indix", "idxf", "midx", "midix", "idy", "idxa", "midy", "idxb", "midex", "adx"], "input_values": ["inputablevalues", " input_vals", "Input_lines", "output_details", " input_lines", "input_Values", "input_value", "Input_value", "input_lines", "Input_vals", "output_values", "output_Values", "input_details", "output_value", "Input_values", "inputableValues", "inputablevalue", " input_value", "inputabledetails", "input_vals"], "output_writer": ["outputpywriter", "input_writer", "outputwoutput", "output_driver", "output_write", "outputPoutput", "input_output", " output_reader", "outputwwriter", "output2reader", "outputwreader", "input_driver", "output_output", "input_write", " output_driver", "outputPreader", "outputPwriter", "outputPdriver", "output_reader", "outputwdriver", "outputpydriver", "output2writer", "output2write", "outputpyreader"], "case": ["switch", "se", "match", "ide", "su", "type", "cp", "command", "division", "client", "block", "error", "cmp", "lc", "seq", "pe", "code", "patch", "ace", "style", "zero", "rule", "chain", "section", "condition", "use", "change", "line", "set", "core", "dd", "state", "mode", "config", "me", "catch", "Case", "cycle", "ase", "ce", "zip", "test", "choice", "cas", "pair"], "intersect": ["overconnect", "intersection", "overlap", "interconnect", "Intersection", "terpol", "overect", "Interect", "diffect", "Intersect", "conect", " intersection", "Interlap", "tersection", "interpol", "INTERsect", "diffsection", "Interconnect", "conlap", "diffsect", "INTERect", "consection", " interconnect", "diffconnect", "oversect", "Interpol", "terconnect", "conconnect", "consect", "interlap", "interect", "tersect", "conpol", "INTERsection", "INTERconnect"], "msg": ["res", "label", "reason", "og", "tag", "str", "buf", "cmd", "err", "prefix", "ms", "col", "mag", "warn", "m", "doc", "txt", "sim", "mg", "cmp", "g", "Msg", "info", "arg", "mn", "char", "bg", "gm", "mess", "summary", "init", "log", "html", "sym", "comment", "pkg", "desc", "title", "md", "gen", "out", "mot", "text", "med", "sg", "cfg", "notice", "message", "status", "gs"]}}
{"code": "__author__ = 'Jeffrey'\\n  \\n  inFileName = \"C:\\\\Users\\\\Jeffrey\\\\IdeaProjects\\\\Google Code Jam 2014\\\\C-small-attempt0.in\"\\n  \\n  outFileName = inFileName[: -2] + \"out\"\\n  \\n  \\n  def parseInput(f):\\n      T = int(f.readline())\\n      L = []\\n  \\n      for i in range(T):\\n          L.append([int(i) for i in f.readline().split()])\\n  \\n      return T, L\\n  \\n  \\n  def calculateOneClick(R, C, M):\\n      size = R * C\\n      if R == 1 or C == 1 and M < size:\\n          return generateWinBoardBaseCase(R, C, M)\\n      elif size - M == 1:\\n          return generateWinBoardBaseCase(R, C, M)\\n      elif size - M >= 4:\\n          return generateWinBoard(R, C, M)\\n      return \"Impossible\"\\n  \\n  def generateWinBoard(R,C,M):\\n      emptySpace = R * C - M - 4\\n      out = \"c\"\\n      if C > 1:\\n          out += \".\"\\n          for i in range(2,C):\\n              if emptySpace > 0:\\n                  out += \".\"\\n                  emptySpace -= 1\\n              else:\\n                  out += \"*\"\\n      if R > 1:\\n          out += '\\n'\\n          out += \".\"\\n          if C > 1:\\n              out += \".\"\\n          for i in range(2,C):\\n              if emptySpace > 0:\\n                  out += \".\"\\n                  emptySpace -= 1\\n              else:\\n                  out += \"*\"\\n      for r in range(2,R):\\n          out += '\\n'\\n          for c in range(C):\\n              if emptySpace > 0:\\n                  out += \".\"\\n                  emptySpace -= 1\\n              else:\\n                  out += \"*\"\\n      return out\\n  \\n  def generateWinBoardBaseCase(R,C,M):\\n      emptySpace = R * C - M - 1\\n      out = \"c\"\\n      if C > 1:\\n          for c in range(1,C):\\n              if emptySpace > 0:\\n                  out += \".\"\\n                  emptySpace -= 1\\n              else:\\n                  out += \"*\"\\n      for r in range(1,R):\\n          out += '\\n'\\n          for c in range(C):\\n              if emptySpace > 0:\\n                  out += \".\"\\n                  emptySpace -= 1\\n              else:\\n                  out += \"*\"\\n      return out\\n  \\n  \\n  def playGame(T, L):\\n      for i in range(T):\\n          result = calculateOneClick(L[i][0], L[i][1], L[i][2])\\n          yield \"Case #\" + str(i + 1) + \":\\n\" + str(result)\\n  \\n  \\n  if __name__ == \"__main__\":\\n      iF = open(inFileName, 'r')\\n      T, L = parseInput(iF)\\n      iF.close()\\n  \\n      print(T)\\n      print(L)\\n  \\n      oF = open(outFileName, \"wb\")\\n      for out in playGame(T, L):\\n          print(out)\\n          oF.write(bytes(out + \"\\n\", 'utf-8'))\\n      oF.close()\\n", "substitutes": {"__author__": ["__creatorname", "__creator_", "_Authorname", "__Author___", "__author_", "__creator__", "__authorname", "_author__", "_Author__", "__Author_", "_Author___", "_Author_", "__creator___", "__Author__", "_author_", "_authorname", "__author___", "__Authorname", "_author___"], "inFileName": ["inFilenameName", "outFileNames", "infileNames", "inSourceFileDir", "inSourceFileName", " infileName", " inFileDir", " inFileNames", "outfilePath", "infileSet", "inFileNames", " inFilePath", "inSourceFileNames", "inFilesSet", "inSourceFilePath", "inFilesName", "infilePath", "infileName", " infilePath", "outfileName", "outfileSet", "outfileNames", "inFileDir", "outFileSet", "inFilePath", "inFileSet", " infileDir", " infileNames", "inFilesPath", "inFilesNames", "infileDir", "inFilenamePath", "inFilenameDir", "inFilenameSet", "outFilePath", "inFilenameNames"], "outFileName": ["outFullSize", "outFileNames", "outFullName", "infileNames", "outFilenameName", "outFilenameNames", "outfilePath", "inFileNames", "outfileSize", "infilePath", "infileName", "inFileSize", "outFileSize", "outfileName", "outFullNames", "outfileNames", "inFilePath", "outFilenameSize", "outFilenamePath", "infileSize", "outFullPath", "outFilePath"], "f": ["ft", "fd", "p", "bf", "form", "fr", "df", "t", "io", "m", "h", "uf", "g", "af", "fb", "w", "d", "lf", "alf", "tf", "sf", "F", "fm", "b", "cont", "l", "inf", "x", "input", "fast", "feed", "fp", "file", "fc", "fs", "v", "fw"], "T": ["D", "G", "O", "TI", "TT", "TN", "X", "t", "H", "TY", "TM", "LT", "A", "E", "TV", "TL", "Len", "TH", "B", "TC", "Tu", "TS", "TA", "F", "OT", "J", "V", "Y", "NT", "N", "GT", "Length", "WT", "TR", "K", "I", "TX", "P", "W", "Size", "Table", "VT", "S"], "L": ["D", "Li", "G", "Line", "LI", "LE", "H", "LT", "E", "A", "IL", "TL", "Len", "LC", "B", "LP", "dL", "FL", "RL", "NL", "SL", " l", "EL", "LD", "F", "VL", "V", "PL", "l", "Lu", "Z", "LM", "N", "LA", "ML", "LL", "List", "I", "DL", "P", "W", "CL", "AL", "LS", "S", "LU"], "i": ["gi", "ji", "ki", "p", "ic", "j", "k", "ib", "ico", "li", "e", "iy", "it", "ia", "t", "il", "m", "iti", "z", "iri", "n", "id", "ri", "phi", "ei", "ar", "int", "ti", "ini", "bi", "d", "si", "index", "cu", "xi", "im", "y", "mi", "\u0438", "cli", "ai", "rit", "b", "cin", "\u00ed", "ip", "l", "x", "pi", "oi", "ii", "iu", "ij", "ati", "di", "I", "zi", "ie", "v", "ir", "yi", "ci"], "R": ["Co", "Range", "D", "G", "O", "Right", "JR", "X", "RA", "H", "U", "CR", "A", "Q", "E", "MR", "Br", "DR", "RC", "Remote", "IR", "RG", "B", "Res", "Root", "Random", "RL", "Rect", "AR", "HR", "F", "Reader", "J", "V", "RO", "RS", "Rot", "Y", "Cor", "N", "RE", "RR", "Rs", "ER", "I", "RM", "P", "RT", "OR", "Rat", "W", "RI", "RW", "BR", "S", "SR", "Role", "Dr"], "C": ["D", "CD", "U", "A", "Count", "Cl", "CC", "Color", "F", "Z", "ARC", "VC", "CF", "K", "Size", "MC", "Container", "Co", "G", "Ch", "HC", "CM", "AC", "Chain", "CS", "B", "CV", "CE", "WC", "CON", "EC", "Config", "CT", "CG", "CP", "CU", "S", "Cache", "Class", "JC", "COR", "X", "Cow", "CA", "You", "Y", "CNN", "Cu", "DC", "P", "Cs", "O", "H", "CR", "E", "Q", "Cr", "LC", "Craig", "SC", "V", "N", "I", "CB", "W", "CCC", "CL"], "M": ["Many", "D", "G", "O", "VM", "X", "Memory", "MA", "H", "m", "E", "A", "U", "CM", "Q", "MAX", "MODE", "NM", "MAN", "B", "Mi", "PM", "MM", "AR", "FM", "MX", "F", "MAC", "J", "Multi", "V", "MU", "Manager", "Z", "Y", "MB", "LM", "EM", "N", "Ms", "MT", "MI", "I", "RM", "P", "Mc", "W", "DM", "Size", "MC", "MS", "S", "AM"], "size": ["empty", "p", "equal", "count", "space", "m", "time", "max", "z", "n", "s", "g", "scale", "capacity", "name", "see", "big", "SIZE", "shape", "sn", "sample", "set", "largest", "year", "ize", "sh", "room", "number", "too", "N", "sized", "position", "len", "height", "second", "gravity", "length", "news", "Size", "sum", "dim", "S", "small", "case", "num"], "emptySpace": ["fullSpace", "EmptyOnly", "emptyZero", "EmptySpace", "completespace", "clearFree", " emptyOnly", "EmptyZero", " emptyPackage", "completeSp", "EmptyFree", "EmptySp", " emptyPlace", "encryptedRoom", "EmptySize", " emptySize", "emptyArea", "missingSlot", "emptyPoint", " emptyZero", "fullSp", "emptyPackage", "emptyPlace", "openString", "emptySlot", "openSp", "zeroService", "missingspace", " emptyPoint", "encryptedPrice", " emptySp", "emptyPrice", "cleanSpace", " emptyspace", "smallSpace", "entityArea", "emptyService", "importantPackage", "emptyspace", "encryptedPackage", "missingSpace", " emptyArea", "cleanspace", "cleanSlot", "enablePrice", "enableSpace", "smallFree", "openSpace", "blankPackage", "emptySp", "zeroSpace", "emptyString", "completePlace", "encryptedSpace", "emptyRoom", "absoluteService", "emptyOnly", "messagespace", " emptyService", "errorspace", "clearSp", "errorPlace", "absolutePoint", " emptyPrice", "completeSize", "encryptedPlace", "fullspace", "EmptyArea", "emptySize", " emptyFree", "completeSpace", "EmptyString", "blankPrice", "clearSpace", "importantSpace", "entitySlot", "smallSp", "absoluteSpace", "emptyFree", " emptyString", "messagePlace", "blankSpace", "entityZero", " emptyRoom", "importantRoom", "zeroPoint", "enablePackage", "cleanPrice", "Emptyspace", " emptySlot", "entitySpace", "missingPrice", "EmptySlot", "messageSpace", "errorSpace", "importantPlace"], "out": ["empty", "cho", "check", "er", "at", "t", "ort", "long", "ent", "error", "att", "option", "pretty", "null", "task", "name", "line", "set", "external", "log", "ot", "to", "batch", "output", "short", "inner", "status", "go", "part", "o", "alt", "no", "block", "append", "conf", "raw", "chain", "json", "over", "pool", "print", "Out", "this", "end", "it", "n", "g", "group", "exp", "outs", "aos", "point", "auto", "timeout", "table", "co", "net", "soft", "format", "ion", "sum", "comment", "res", "post", "one", "cmd", "expression", "ou", "client", "off", "all", "up", "can", "art", "int", "index", "again", "init", "val", "value", "nt", "obj", "OUT", "ex", "text", "com", "list"], "r": ["p", "ic", "rc", "ra", "it", "rin", "rec", "t", "m", "h", "ct", "rb", "g", "ri", "ar", "w", "cu", "pr", "d", "ibr", "b", "l", "rr", "cr", "co", "car", "ir", "rt", "ci"], "c": ["ic", "rc", "col", "cp", "cut", "rec", "cur", "lc", "ct", "n", "g", "con", "xc", "ar", "can", "chain", "pc", "cation", "cat", "cu", "w", "arc", "sc", "cs", "ec", "cin", "ai", "b", "ac", "\u00e7", "cus", "cor", "cl", "unc", "cr", "co", "cc", "car", "ci"], "result": ["res", "function", "total", "df", "url", "success", "results", "all", "ret", "name", "successful", "found", "Result", "table", "number", "mark", "back", "output", "new", "profile", "diff", "length", "data", "test", "list"]}}
{"code": "__author__ = 'Jeffrey'\\n  \\n  inFileName = \"C:\\\\Users\\\\Jeffrey\\\\IdeaProjects\\\\Google Code Jam 2014\\\\A-small-attempt0.in\"\\n  outFileName = \"C:\\\\Users\\\\Jeffrey\\\\IdeaProjects\\\\Google Code Jam 2014\\\\A-small-attempt0.out\"\\n  \\n  \\n  def parseInput(f):\\n      T = int(f.readline())\\n      L = []\\n  \\n      for i in range(T):\\n          picks = []\\n          cards = []\\n          for j in range(2):\\n              picks.append( int(f.readline()))\\n              tempL = []\\n              for k in range(4):\\n                  tempL.append( [int(j) for j in f.readline().split()])\\n              cards.append(tempL)\\n          L.append((picks, cards))\\n  \\n      return T, L\\n  \\n  \\n  def performTrick(picks, cards):\\n      matchFound = False\\n      matchedCard = None\\n      for card in cards[0][picks[0] - 1]:\\n          possibleMatch = card in cards[1][picks[1] - 1]\\n          if possibleMatch and matchFound:\\n              return \"Bad magician!\"\\n          elif possibleMatch:\\n              matchFound = True\\n              matchedCard = card\\n      if matchFound:\\n          return matchedCard\\n      else:\\n          return \"Volunteer cheated!\"\\n  \\n  \\n  def playGame(T,L):\\n      for i in range(T):\\n          result = performTrick(L[i][0], L[i][1])\\n          yield \"Case #\" + str(i + 1) + \": \" + str(result)\\n  \\n  \\n  if __name__==\"__main__\":\\n      iF = open(inFileName, 'r')\\n      T, L = parseInput(iF)\\n      iF.close()\\n  \\n      oF = open(outFileName, \"wb\")\\n      for out in playGame(T, L):\\n          oF.write(bytes(out + \"\\n\",'utf-8'))\\n      oF.close()\\n", "substitutes": {"__author__": ["__name_", "__author_", "__authors____", "__name__", "__authors_", "__authors___", "____author_", "__authors__", "__version__", "__version___", "__name____", "__version____", "__name___", "____authors__", "____author__", "____author___", "____authors____", "__author____", "__version_", "____author____", "____authors___", "__author___", "____authors_"], "inFileName": ["inFilenameName", "inFileSource", "outFileN", " inFileSize", "inQueueName", "inTableSize", "infileNames", "inFilenameSize", " inFileSource", " inFileNames", "inQueueN", "outfileSource", "inFileNames", "inFilenameSource", "inTableSource", "infileSource", "inTableName", "inQueueSource", "infileName", "inFileN", "inFileSize", " inFilenameSize", "outfileName", " inFilenameNames", "inQueueFile", "outFileSource", "outfileN", "infileN", "inFilenameFile", "inFilenameN", " inFilenameName", "inTableNames", "infileFile", "outFileFile", " inFilenameSource", "inFileFile", "outfileFile", "infileSize", "inFilenameNames"], "outFileName": ["inFilenameName", " outFilePath", " outFileNames", "outFileNames", "outFullName", "outFileWrite", "outFilenameName", "outFilenameNames", "outfilePath", "inFileNames", "outFILEPath", "outFILEWrite", " outFileWrite", " outFilenamePath", "outFilenameFile", " outFilenameNames", "outFILEName", "outfileName", "outFullNames", "outfileNames", "outfileWrite", "inFilePath", " outFilenameName", " outFilenameWrite", "inFilenameFile", "outFilenameWrite", "outFilenamePath", "outFileFile", "outFullFile", "outFullPath", "inFilenamePath", "inFileFile", "outfileFile", "outFilePath", "outFILENames", "inFilenameNames"], "f": ["ft", "fd", "p", "bf", "fr", "df", "e", "t", "o", "fe", "fl", "h", "of", "cf", "z", "fo", "s", "g", "af", "lo", "uf", "fg", "fb", "w", "lf", "sf", "tf", "q", "F", "r", "xf", "fm", "b", "cont", "l", "inf", "feed", "fp", "file", "fc", "fs", "c", "ef", "v", "fi", "fn", "fa", "alf"], "T": ["D", "G", "O", "TI", "TT", "TN", "IT", "t", "H", "TM", "U", "ITS", "A", "LT", "E", "FT", "TV", "XT", "TL", "R", "TH", "It", "B", "TC", "Tu", "TS", "TA", "PT", "F", "OT", "TIT", "J", "V", "M", "NT", "Y", "WT", "N", "GT", "Integer", "NB", "TR", "TB", "C", "CT", "K", "I", "P", "W", "VT", "Int", "S", "TG"], "L": ["D", "G", "Li", "O", "LI", "LE", "H", "LT", "E", "TL", "LR", "LB", "LC", "B", "LV", "LP", "dL", "FL", "RL", "NL", "SL", "LD", " l", "F", "J", "LIN", "VL", "V", "M", "Layout", "PL", "l", "LG", "Lu", "Z", "XL", "LM", "N", "C", "ML", "LL", "List", "K", "I", "DL", "P", "W", "LS", "S", "LU"], "i": ["gi", "ki", "ji", "p", "ic", "li", "e", "it", "ia", "t", "o", "m", "h", "iti", "id", "n", "g", "s", " ii", "phi", "int", "ti", "ini", "index", "si", "d", "xi", "im", "y", "u", "mi", "multi", "ai", "r", "b", "ip", "l", "x", "pi", "ii", "ij", "iu", "ix", "di", "I", "zi", "a", "ie", "c", "v", "yi", "ind", "ci"], "picks": ["charts", " pickets", "prixels", "pics", "psickets", "psicking", "psipers", "Picked", "picking", "attricks", "pixels", "attics", " pics", " pipers", "apicks", "prickets", "pipers", "Pricks", "Parts", "tarts", "chricks", " pricks", "Pickets", "aparts", "pricks", "pricking", "Pipers", "ticked", "parts", "attickets", "psixels", "tickets", "chics", "ticks", "psicks", " picking", "psics", "Pics", " parts", "Picks", "apics", "apickets", "tics", "picked", "chicks", "pickets", "Pixels", "apicked", "atticks", " pixels"], "cards": ["days", "comments", "args", "olds", "lists", "lands", "gs", "weights", "packs", "cars", "photos", "ll", "ps", "ands", "games", "Players", "ways", "Credits", "words", "cf", "s", "ls", "letters", "shape", "Card", "outs", "ickets", " Cards", "names", "multi", "lights", "WC", "ards", "tags", "Tokens", "styles", "cats", "boxes", "cells", "fields", "l", "pins", "codes", "holders", "groups", "Lu", "Tickets", "hands", "posts", "bits", "points", "caps", "ARD", "checks", "ends", "clips", "balls", "lets", "cases", "cons", "services", "pieces", "c", "sticks", "lines", "kids", "tests", "cas"], "j": ["ji", "ki", "p", "jj", "ju", "jl", "it", "jp", "t", "o", "m", "fl", "jo", "ik", "h", "key", "z", "n", "g", "ck", "name", "d", "uj", "q", "left", "json", "r", "J", "kj", "b", "dj", "l", "oj", "gu", "ij", "job", "jc", "ch", "js", "jump", "c", "v", "pos", "aj", "ind"], "tempL": ["destLE", "tmpS", "tmpL", "primeLE", " tempP", "empNL", "TempLS", "TempV", "tempP", "tempLS", "TempL", "tmpV", "destL", " tempV", " tempLE", "primeNL", "tempLE", "tempV", "empL", "TempLE", "primeL", "destP", " tempNL", "tempS", "TempP", "destV", "empLE", "primeV", "tmpLS", "empLS", "TempS", "empV", "empS", "tempNL"], "k": ["ki", "kan", "ks", "ek", "ijk", "ik", "key", "ikk", "ck", "sk", "kid", "kt", "kw", "kk", "ke", "kh", "kj", "ka", "ket", "kn", "ake", "ku", "K", "km", "kl", "ak", "unk"], "matchFound": ["matchedfound", " matchValid", "matchPresent", " matchFind", " matchPresent", "caseFind", "matchValid", "matchedFind", "sumFound", "matchedFound", "matchedValid", "fireValid", "fireFind", "resultfound", "Matchfound", "caseValid", "MatchFound", "fireFound", "matchfound", "caseFound", "firePresent", "MatchFind", "sumFind", " matchfound", "matchFind", "sumfound", "firefound", "resultFind", "resultFound", "casefound", "sumPresent", "resultValid"], "matchedCard": [" matchedBand", " matchedCustomer", "matchcard", "atchedCustomer", " unmatchedToken", " unmatchedChip", "matchedToken", " matchedcard", "matchedNode", "successfulCard", " unmatchedPlayer", " matchedToken", "atchedCard", "matchedChip", "matchCard", " matchedChip", "atchedNode", "matchedBand", " unmatchedCard", "atchedToken", "matchedcard", "matchedCustomer", "atchedcard", " matchedNode", "atchedChip", " matchedPlayer", "atchedPlayer", "successfulBand", "successfulNode", "matchCustomer", "atchedBand", "matchedPlayer"], "card": ["ard", "hex", "match", "ticket", "check", "word", "camp", "cp", "piece", "cap", "deck", "token", "cmp", "record", "cf", "node", " Card", "can", "name", "char", "field", "ick", "Card", "index", "byte", "cont", "player", "point", "cl", "board", "co", "cc", "car", "hand", "list", "ord", "wild", "guard", "controller", "cell", "comment", "php", "cas"], "possibleMatch": ["possiblyMatch", "PossibleCapture", "Possibilitymatch", "possiblyCompare", "pualmatch", "possibilitymatch", "possibilityCapture", "possibleCapture", "PossiblyMatch", "pactedmatch", "possiblyCapture", "puppetCard", "possiblymatch", "possiblyCard", "Possiblematch", "puppetmatch", "pactedCard", "impossiblematch", "PossibilityCapture", "pactedCapture", "impuppetMatch", "impuppetmatch", "possibleCard", "puppetMatch", "PossibleCard", "impossibleCard", "pualCompare", "impuppetCard", "PossiblyCard", "possibilityCard", "possibilityMatch", "possiblematch", "PossiblyCompare", "PossibilityMatch", "impossibleMatch", "PossibleMatch", "pualCard", "possibleCompare", "Possiblymatch", "PossibilityCard", "pactedMatch", "pualMatch", "puppetCompare", "PossibleCompare"], "result": ["res", "answer", "cup", "match", "su", "rue", "the", "re", "leader", "correct", "it", "ful", "relation", "success", "complete", "results", "final", "true", "ret", "goal", "case", "r", "successful", "created", "successfully", "Result", "value", "score", "back", "RESULTS", "output", "profile", "data", "mate", "response", "test", "valid", "status"], "iF": ["ioZ", "uDF", "iFO", "ioV", " iDF", "miFF", " iFF", "uZ", "tiFO", "iUF", " iZ", "isC", "tiFP", "xiFF", "ioF", "iDF", "oriFF", "oriFP", "iZ", "xiF", "miUF", "iC", " iV", "xiFO", " iC", "iFP", "iV", "xiFP", " iUF", "miC", "isF", "isUF", "miF", "iFF", "oriF", "uF", "isFF", "tiF", "ioDF", "tiFF", "uV", "oriFO"], "oF": ["outGF", "toGF", "outN", "oV", "toF", "outH", "iT", "toV", "wL", " oV", "oGF", "oM", "wF", "eT", "eL", "oN", "outF", " oFD", "eM", " oH", "iN", "oFD", " oN", "wT", "toH", "outFD", "wM", " oM", " oT", "eF", "oH", "outV", " oL", " oGF", "outT", "iFD", "oT", "oL"], "out": ["O", "os", "cho", "check", "Out", "IN", "it", "at", "t", "io", "o", "outh", "ou", "txt", "n", "s", "OU", "oul", "tx", "dl", "outs", "lt", "log", "l", "co", "x", "In", "ot", "net", "to", "output", "tl", "OUT", "I", "ion", "ex", "ul", "v", "text", "ind"]}}
{"code": " \\n  \\n  def print_basic_board(no_mine, r, c):\\n      printed_c = False\\n      for row in range(0, r):\\n          line = []\\n          for column in range(0, c):\\n              if printed_c:\\n                  if no_mine > 0:\\n                      line.append(\".\")\\n                      no_mine -= 1\\n                  else:\\n                      line.append(\"*\")\\n              else:\\n                  line.append(\"c\")\\n                  no_mine -= 1\\n                  printed_c = True\\n          print \"\".join(line)\\n  \\n  \\n  def print_board(no_mine_row, no_mine_column, rest_no_mine_for_row, rest_no_mine_for_column, r, c):\\n      printed_c = False\\n      for row in range(0, r):\\n          line = []\\n          for column in range(0, c):\\n              if printed_c:\\n                  if row < no_mine_row and column < no_mine_column:\\n                      line.append(\".\")\\n                  elif rest_no_mine_for_column > 0 and column == no_mine_column:\\n                      line.append(\".\")\\n                      rest_no_mine_for_column -= 1\\n                  elif rest_no_mine_for_row > 0 and row == no_mine_row:\\n                      line.append(\".\")\\n                      rest_no_mine_for_row -= 1\\n                  else:\\n                      line.append(\"*\")\\n              else:\\n                  line.append(\"c\")\\n                  printed_c = True\\n          print \"\".join(line)\\n  \\n  \\n  def solve_case(r, c, m, case_number):\\n      print \"Case #%d:\" % case_number\\n      no_mine = r * c - m\\n      if r < 2 or c < 2 or no_mine == 1:\\n          print_basic_board(no_mine, r, c)\\n      else:\\n          no_mine_row_max = int(math.ceil(float(no_mine) / 2))\\n          if no_mine_row_max > r:\\n              no_mine_row_max = r\\n          for no_mine_column in range(2, int(math.ceil(float(no_mine) / 2)) + 1):\\n              if no_mine_column > c:\\n                  break\\n              for no_mine_row in range(2, no_mine_row_max + 1):\\n                  rest_no_mine = no_mine - (no_mine_column * no_mine_row)\\n                  if rest_no_mine < 0:\\n                      continue\\n                  if rest_no_mine == 1:\\n                      continue\\n  \\n                  if rest_no_mine == 0:\\n                      print_board(no_mine_row, no_mine_column, 0, 0, r, c)\\n                      return\\n                  if rest_no_mine <= no_mine_row and no_mine_column < c:\\n                      print_board(no_mine_row, no_mine_column, 0, rest_no_mine, r, c)\\n                      return\\n                  if rest_no_mine <= no_mine_column and no_mine_row < r:\\n                      print_board(no_mine_row, no_mine_column, rest_no_mine, 0, r, c)\\n                      return\\n  \\n                  if rest_no_mine > 3 and no_mine_column < c and no_mine_row < r:\\n                      for rest_no_mine_for_row in range(2, no_mine_column):\\n                          rest_no_mine_for_column = rest_no_mine - rest_no_mine_for_row\\n                          if rest_no_mine_for_column < no_mine_row:\\n                              print_board(no_mine_row, no_mine_column, rest_no_mine_for_row, rest_no_mine_for_column, r, c)\\n                              return\\n  \\n          print \"Impossible\"\\n  \\n  r_file = sys.stdin\\n  \\n  if len(sys.argv) > 1:\\n      r_file = open(sys.argv[1], 'r')\\n  \\n  total_cases = r_file.readline()\\n  for case_number in range(1, int(total_cases) + 1):\\n      values = map(int, r_file.readline().split(' '))\\n      solve_case(values[0], values[1], values[2], case_number)\\n  \\n", "substitutes": {"no_mine": ["no_grade", "NO_graduate", "nolybench", "no_issue", "No_mark", "nojmix", "NO_download", "no_mix", " no_mate", "no2mine", " no_grade", " no_cal", "notmix", "yes_bird", "n___mine", " No_mire", " no_roy", "no_mate", " no_bench", "No_mate", "no_vote", " Nojmire", " No_mine", " Nojmix", "no_meet", " no_date", " no_minute", "no2gray", "no___cal", "nojmire", "no___mine", " Nojmine", "nolymine", "no__mie", "no__mate", " no_mix", "notroy", "yes_gray", "no2bird", "no_date", "noomate", "n___meet", "notmine", "no_cal", " no_mark", "no_download", "noftygraduate", "noftydownload", "no___mark", "nojmine", " No_mix", "No_mie", "no_mire", "NO_mine", "no_bench", "noovote", "NO_issue", "yes_mine", "no__meet", "n_mate", "no_bird", "no_mark", "no2mate", " Nojissue", "no___date", "no___mie", "yes_mate", "n_mie", " no_return", " No_issue", "no_gray", "no_minute", "no_mie", "nolyminute", "n___mie", "no___mate", "noftyissue", "no_return", "noftymine", "no__mine", " no_gray", "noomine", "noomark", " no_vote", "No_mine", "no___meet", "n_mine", "notgrade", "n___mate", "no_roy", "nojissue", "no_graduate", "nolygray", "n_meet"], "r": ["res", "range", "br", "p", "j", "rc", "ra", "er", "fr", "re", "e", "err", "rs", "rx", "k", "t", "rec", "lr", "error", "h", "nr", "ro", "max", "run", "rb", "n", "g", "s", "rest", "R", "f", "ar", "ru", "result", "w", "d", "pr", "u", "q", "i", "y", "ran", "b", "l", "rr", "cr", "hr", "rar", "sr", "dr", "mr", "vr", "a", "rows", "ry", "v", "rd", "rt", "rw", "rh", "right"], "c": ["dc", "p", "ic", "rc", "k", "col", "e", "cp", "cm", "t", "cur", "lc", "ct", "bc", "h", "cf", "n", "g", "con", "s", "f", "conf", "cos", "cat", "cu", "d", "cb", "sc", "u", "cache", "cs", "ec", "y", "cin", "uc", "b", "ac", "cont", "cor", "cl", "l", "cr", "co", "x", "cc", "mc", "cum", "cv", "ch", "C", "cd", "fc", "ca", "ce", "v", "tc", "com", "ci"], "printed_c": ["successful_lc", "printedureci", "printedInc", " Printed_p", "printedurecache", "successful_c", " printed_cation", "printededc", "printedtowncation", "printedpleci", "successful_cn", "printed_cn", "printed_gc", "successfulIc", "printed_p", "printedeffgc", "printedMemcn", "printed_cation", "encrypted_c", "printededcn", "printedeffcn", " Printed_a", "encrypted_ci", "printedolyp", "printedtowne", "broken_gc", "printed_cache", "printedMemlc", " printed_cn", "printedMemc", "successful_nc", "brokenipc", "printedtownc", "printedMemnc", "printedurecv", "brokenipcn", "printedipcn", "printedolydc", "printedipgc", "printedeffcv", "printedIcn", "printedolya", "printedplec", "printedipcv", "printed_cs", "printed_ci", "brokenipcv", "printedplecache", "encrypted_cache", "successfulInc", "broken_cn", "brokenipgc", " Printed_dc", " printed_e", "printed_e", "broken_cv", "printed_lc", "printededcs", "printedplecv", "printedIc", "printed_nc", " printed_cs", "printedolyc", "printedede", "printedurec", "broken_c", " printed_dc", "successfulIcn", "encrypted_cv", "printedIlc", "printedipc", "successfulIlc", "printed_a", " Printed_c", "printedeffc", "printedtowndc", "printed_dc", "printed_cv"], "row": ["range", "p", "day", "rc", "word", "col", "frame", "adr", "block", "ox", "week", "family", "run", "record", "ro", "group", "rown", "name", "page", "char", "tr", "w", "user", "rank", "rot", "entry", "rect", "year", "Row", "board", "cr", "table", "collection", "ow", "number", "month", "order", "ocr", "x", "co", "batch", "box", "roll", "round", "arrow", "rows", "ry", "hour", "cell", "right", "our", "pair"], "line": ["range", "se", "detail", "Line", "cho", "band", "word", "frame", "force", "space", "part", "note", "lin", "le", "LINE", "time", "no", "block", "zone", "site", "stack", "record", "code", "term", "ne", "path", "group", "lo", "shell", "do", "lined", "chain", "page", "ner", "pr", "user", "ine", "entry", "lane", "cli", "email", "dd", "link", "stay", "log", "limit", "auto", "l", "nl", "cle", "query", "call", "co", "ln", "net", "liner", "string", "iter", "profile", "phrase", "print", "trace", "inline", "file", "out", "device", "lines", "lock", "message", "list"], "column": ["label", "day", "word", "col", "cut", "client", "forward", "property", "ct", "path", "td", "variable", "group", "con", "csv", "container", "category", "rown", "name", "section", "condition", "field", "char", "tr", "widget", "width", "current", "character", "member", "table", "collection", "number", "umn", "car", "Column", "pattern", "period", "dimension", "pointer", "arrow", "method", "header", "attribute", "component", "rain", "cell", "paragraph"], "no_mine_row": ["no_mineistnumber", "no_mineistrow", "no_mine_roll", "no_mix_row", "no_mine_word", "no_forge_rows", "no_mix_cell", "no_mine_ro", "no_forge_row", "no_mine_item", "no_mine_cell", "no_forge_column", "no_min_col", "no_mix_column", "no_mine__word", "no_forge_col", "no_mix_ro", "no_mineistroll", "no_mine__col", "no_mine_number", "no_mine_col", "no_mine_rows", "no_mine__row", "no_forge_item", "no_min_word", "no_forge_roll", "no_mine__rows", "no_min_row", "no_forge_number", "no_mineistcolumn", "no_min_rows"], "no_mine_column": ["no_mate_column", "no_mine_label", "no_grade_cell", "no_forge_cell", "no_minetcell", "no_mate_col", "w", "no_mine_double", "no_mine67pointer", "no_mine67column", "no_mine_field", "no_mate_pointer", "no_forge_field", "no_forge_row", "no_grade_number", "no_mine_cell", "no_forge_column", "no_mine67col", "no_such_column", "no_such_col", "no_grade_double", "no_forge_col", "no_mine67row", "no_minetcolumn", "no_grade_column", "no_minetlabel", "no_mine_number", "no_such_cell", "no_mine_col", "no_mine_pointer", "no_mate_row", "chart", "no_such_row", "no_minetcol", "no_forge_label"], "rest_no_mine_for_row": ["rest_no_mine_forxcol", "rest_no_mine_forxrows", "rest_no_mine_for__cell", "rest_no_mine_forxrow", "rest_no_mine_for_col", "rest_no_mine_for__rows", "rest_no_mine_for_cell", "rest_no_mine_for_rows", "rest_no_mine_for__row", "rest_no_mine_forxcell", "rest_no_mine_for__column"], "rest_no_mine_for_column": ["rest_no_mine_for___row", "rest_no_mine_for_character", "rest_no_mine_for___column", "rest_no_mine_for__Column", "rest_no_mine_for__col", "rest_no_mine_for_value", "rest_no_mine_for___character", "rest_no_mine_for__character", "rest_no_mine_for_col", "rest_no_mine_for___col", "rest_no_mine_for___Column", "rest_no_mine_for_Column", "rest_no_mine_for__column"], "m": ["p", "j", "dm", "tm", "re", "mask", "cm", "t", "mm", "h", "mat", "n", "g", "f", "perm", "um", "d", "gm", "q", "im", "i", "mi", "man", "b", "M", "mt", "l", "x", "mc", "month", "mu", "min", "ch", "mut", "rm", "mr", "mate", "v", "mon", "case"], "case_number": ["case_size", "case___no", "case_address", "case___size", " case_no", "case_Number", "case2Number", "Case_number", "case9size", "case_no", "case9number", "Case_address", "case2number", "case9span", "case___span", "case___number", "case9no", "Case_Number", "case_span", " case_span", " case_size", "case2address"], "no_mine_row_max": ["no_mine_col_min", "no_mine_col_MAX", "no_mine_row_min", "no_mine_row_ax", "no_mine_row_mod", "no_mine_col_mod", "no_mine_col_max", "no_mine_col_ax", "no_mine_row_MAX"], "rest_no_mine": ["rest_no_fine", "rest_no__fine", "rest_No_mie", "rest_no___fine", "rest_no__mate", "rest_No_mate", "rest_no___mine", "rest_no_mie", "rest_no___mie", "rest_no__mine", "rest_No_mine", "rest_no__mie", "rest_no_mate", "rest_No_fine", "rest_no___mate"]}}
{"code": " \\n  def solve_case(answers, arrangements_of_cards, case_number):\\n      first_candidates = arrangements_of_cards[0][answers[0] - 1]\\n      second_candidates = arrangements_of_cards[1][answers[1] - 1]\\n      answer = set(first_candidates) & set(second_candidates)\\n      length_of_answer = len(answer)\\n      if length_of_answer > 1:\\n          print \"Case #%d: Bad magician!\" % case_number\\n      elif length_of_answer < 1:\\n          print \"Case #%d: Volunteer cheated!\" % case_number\\n      else:\\n          print \"Case #%d: %d\" % (case_number, answer.pop())\\n  \\n  r = sys.stdin\\n  \\n  if len(sys.argv) > 1:\\n      r = open(sys.argv[1], 'r')\\n  \\n  total_cases = r.readline()\\n  for case_number in range(1, int(total_cases) + 1):\\n      answers = []\\n      arrangements_of_cards = []\\n      answers.append(int(r.readline()))\\n      arrangements_of_cards.append([])\\n      for row in range(0, 4):\\n          arrangements_of_cards[0].append(map(int, r.readline().split(' ')))\\n      answers.append(int(r.readline()))\\n      arrangements_of_cards.append([])\\n      for row in range(0, 4):\\n          arrangements_of_cards[1].append(map(int, r.readline().split(' ')))\\n      solve_case(answers, arrangements_of_cards, case_number)\\n", "substitutes": {"answers": ["answneds", "answritackers", "isreaders", "ansswers", "ansiwants", "iswers", "answriteesters", "answnered", "isreadments", "passwinals", "answritesters", "ansentesters", "annswaters", "ansreadters", "ansenters", "passwers", "ansswered", "answners", "answered", "ansswments", "ansswer", "ansiwinals", "anwered", "answinals", "ansiwackers", "antswERS", "ansewer", "answriter", "answants", "ansewters", "ansendERS", "answriteers", "ansgers", "annweds", "anwters", "ansenders", "ansiwes", "antswritERS", "ansger", "antswackers", "isreader", "answackers", "anwers", "answERS", "ansreaders", "answes", "answesters", "ansentests", "answriters", "ansxer", "passws", "iswer", "ansiws", "ansgters", "ansiwers", "anssweds", "answritERS", "ansswters", "ansawer", "ansgments", "iswters", "answters", "passaws", "anwesters", "ansiwERS", "isreadters", "annsweds", "anweds", "ansxers", "annwants", "antswers", "antswriters", "answaters", "antswritings", "ansawinals", "ansiwings", "annswers", "annswants", "answnants", "annwers", "answriteests", "iswments", "ansiwer", "answests", "passawinals", "passawers", "ansswaters", "ansendings", "answner", "anwer", "ansreadments", "answritings", "answs", "antswings", "ansaws", "ansendackers", "ansxinals", "ansswesters", "anseweds", "answnaters", "ansxs", "antswritackers", "ansiwaters", "passwer", "answments", "answeds", "ansiweds", "ansswants", "answritees", "ansiwesters", "ansentes", "annwaters", "ansiwests", "ansreader", "answnesters", "answnters", "ansawers", "answritered", "passawer", "ansewers", "answings"], "arrangements_of_cards": ["arrangements_Of_files", "arrangements_of_nuts", "arrangements_of_caps", "arrangements_of_cases", "arrangements_of2cards", "arrangements_Of_cards", "arrangements_of_card", "arrangements_of_files", "arrangements_ofxycard", "arrangements_ofxynuts", "arrangements_of2card", "arrangements_of2fields", "arrangements_of_fields", "arrangements_Of_card", "arrangements_Of_fields", "arrangements_Of_caps", "arrangements_Of_nuts", "arrangements_ofxycards", "arrangements_Of_cases"], "case_number": ["case_size", "cycle_number", "case2no", "power9number", "case8version", "cycleplenumber", "case2index", "Case_num", "power_number", "case_name", "casepleversion", "case_node", "casepleno", "case_no", "case9number", "Case_name", "case2number", "case8no", "cycle_no", "issue8number", "caseplesize", "power_no", "power9Number", "issue_no", "case8number", "issue_version", "case_position", "case_version", "issue8size", "caseplenumber", "power_Number", "casepleNumber", "cycle_node", "issue8no", "case_Number", "cyclepleno", "case_index", "Case_size", "cyclepleNumber", "case_num", "Case_index", "Case_no", "case9no", "cycle_Number", " case_Number", "issue_size", "caseplenode", "case8size", "issue8version", "case9position", "power_position", "case9Number", "cycleplenode", " case_no", "case2Number", "case2num", "power9no", "Case_number", " case_num", "issue_number", "Case_Number", "power9position"], "first_candidates": ["first_matants", "first_candidate", "first_caridate", "firstaircanditions", "first_caridates", "first_Candants", "first_genants", "first_Canditions", "first_Candidates", "first_Candidate", "firstaircandidate", "firstairgenidate", "firstairgenitions", "first_candants", "firstairgenidates", "first_candaters", "first_caraters", "first_genidates", "first_Candaters", "first_canditions", "firstaircandants", "first_genitions", "first_matitions", "firstairgenants", "first_matidate", "firstaircandidates", "first_matidates", "first_genidate"], "second_candidates": ["second_qualates", "second_candates", "second_capates", "second_candants", "second_validates", "second_Candidates", "second_validants", "second_valididate", "second_qualents", "second_capidate", "second_qualidates", "second_capidates", "second_capants", "second_valididates", "second_candents", "second_Candents", "second_Candants", "second_candidate", "second_Candates", "second_Candidate", "second_qualidate"], "answer": ["values", "swers", "urn", "form", "word", "space", "mask", "area", "video", "approximately", "array", "words", "address", "record", "vert", "example", "ve", "ask", "eni", " answered", "result", "question", "vote", "archive", "q", "cache", " unanswered", " Answer", "wer", "interpret", "value", "answered", "bench", "query", "remember", "order", "options", "Answer", "established", "after", "oa", "score", "offer", "environment", "agree", "support", "said", "search", "accept", "voice", "response", "description", "say", "message"], "length_of_answer": ["length_of_response", "length_ofptresult", "length_of_output", "length_ofptoutput", "length_of_option", "length_ofptanswer", "length_of_answered", "length_of_question", "length_of_result"], "r": ["res", "br", "p", "rc", "er", "reader", "re", "fr", "err", "rs", "rx", "reg", "t", "rec", "lr", "h", "nr", "ro", "rus", "rg", "n", "rb", "ren", "g", "R", "f", "rate", "ar", "w", "d", "pr", "q", "writer", "kr", "b", "l", "rr", "cr", "hr", "rar", "rel", "usr", "sr", "obj", "dr", "gr", "mr", "vr", "c", "sys", "v", "rd", "rt", "rw", "right"], "total_cases": ["total_boxes", "totalThecases", "otal_sections", "otal10boxes", "totalThetests", " total_tests", "total_sections", "otal10cs", "total2rows", "total10boxes", " total_lines", " total_rows", "otal_cs", "total10cases", " total2cases", "total2cases", "total_tests", "total_cs", "total10sections", "total64boxes", "otal10cases", " total2lines", "total_rows", "total2lines", "totalThelines", "total64sections", " total2tests", "total2tests", "otal10sections", "total64cs", "otal_cases", "otal_boxes", "totalTherows", "total_lines", "total10cs", " total2rows", "total64cases"], "row": ["rc", "bo", "word", "col", "column", "block", "rid", "ro", "run", "week", "record", "key", "rown", "char", "tr", "loop", "line", "set", "sw", "var", "Row", "co", "x", "ow", "draw", "month", "order", "batch", "num", "ver", "ows", "roll", "arrow", "rows", "ry", "sel", "case", "pair"]}}
{"code": " \\n  \\n  DX = (-1, -1, -1, 0, 1, 1, 1, 0)\\n  DY = (-1, 0, 1, 1, 1, 0, -1, -1)\\n  \\n  \\n  def compute(R, C, M):\\n      if M == 0:\\n          return empty(R, C)\\n      free = R * C - M\\n      if free == 1:\\n          return single_free(R, C)\\n      if R == 1:\\n          return single_row(C, M)\\n      if C == 1:\\n          return single_column(R, M)\\n      if R == 2:\\n          return two_rows(C, M)\\n      if C == 2:\\n          return two_columns(R, M)\\n      if free in (2,3,5,7):\\n          return \"\\nImpossible\"\\n      return at_least_three(R, C, M)\\n  \\n  \\n  def make_board(R, C, default='.'):\\n      return [[default for j in xrange(C)] for i in xrange(R)]\\n  \\n  \\n  def to_string(board):\\n      s = \"\"\\n      for i in xrange(len(board)):\\n          s += '\\n' + ''.join(board[i])\\n      return s\\n  \\n          \\n  def empty(R, C):\\n      board = make_board(R, C)\\n      board[0][0] = 'c'\\n      return to_string(board)\\n  \\n  \\n  def single_free(R, C):\\n      board = make_board(R, C, default='*')\\n      board[0][0] = 'c'\\n      return to_string(board)\\n  \\n  \\n  def single_row(C, M):\\n      board = make_board(1, C)\\n      board[0][0] = 'c'\\n      for i in xrange(M):\\n          board[0][C - 1 - i] = '*'\\n      return to_string(board)\\n  \\n  \\n  def single_column(R, M):\\n      board = make_board(R, 1)\\n      board[0][0] = 'c'\\n      for i in xrange(M):\\n          board[R - 1 - i][0] = '*'\\n      return to_string(board)\\n  \\n  \\n  def two_rows(C, M):\\n      if M % 2 != 0:\\n          return \"\\nImpossible\"\\n      if 2 * C - M < 4:\\n          return \"\\nImpossible\"\\n      board = make_board(2, C)\\n      for i in xrange(M / 2):\\n          board[0][C - 1 - i] = '*'\\n          board[1][C - 1 - i] = '*'\\n      board[0][0] = 'c'\\n      return to_string(board)\\n  \\n  \\n  def two_columns(R, M):\\n      if M % 2 != 0:\\n          return \"\\nImpossible\"\\n      if 2 * R - M < 4:\\n          return \"\\nImpossible\"\\n      board = make_board(R, 2)\\n      for i in xrange(M / 2):\\n          board[R - 1 - i][0] = '*'\\n          board[R - 1 - i][1] = '*'\\n      board[0][0] = 'c'\\n      return to_string(board)\\n  \\n  \\n  def finalize(R, C, M, board):\\n      mines = 0\\n      for i in xrange(R):\\n          for j in xrange(C):\\n              if board[i][j] == '0':\\n                  continue\\n              empty = False\\n              for d in xrange(8):\\n                  if i + DX[d] < 0 or i + DX[d] >= R or j + DY[d] < 0 or j + DY[d] >= C:\\n                      continue\\n                  if board[i + DX[d]][j + DY[d]] == '0':\\n                      empty = True\\n                      break\\n              if empty:\\n                  board[i][j] = '.'\\n              else:\\n                  board[i][j] = '*'\\n                  mines += 1\\n      for i in xrange(R):\\n          for j in xrange(C):\\n              if board[i][j] == '0':\\n                  board[i][j] = '.'\\n      board[0][0] = 'c'\\n      if mines != M:\\n          sys.stderr.write(\"mines:%s expected:%s\\n\" % (mines, M))\\n      return to_string(board)\\n  \\n  \\n  def at_least_three(R, C, M):\\n      board = make_board(R, C)\\n      board[0][0] = '0'\\n      free = R * C - M\\n      count = 4\\n      if count == free:\\n          return finalize(R, C, M, board)\\n      board[0][1] = '0'\\n      count += 2\\n      if count == free:\\n          return finalize(R, C, M, board)\\n      board[1][0] = '0'\\n      count += 2\\n      if count == free:\\n          return finalize(R, C, M, board)\\n      for j in xrange(2, C - 1):\\n          if count + 2 > free:\\n              break\\n          board[0][j] = '0'\\n          count += 2\\n      for i in xrange(2, R - 1):\\n          if count + 2 > free:\\n              break\\n          board[i][0] = '0'\\n          count += 2\\n      for i in xrange(1, R - 1):\\n          for j in xrange(1, C - 1):\\n              if count == free:\\n                  return finalize(R, C, M, board)\\n              board[i][j] = '0'\\n              count += 1\\n      sys.stderr.write(\"empty board?\\n\")\\n      return finalize(board)\\n  \\n  \\n  def parse():\\n      R, C, M = map(int, sys.stdin.readline().strip().split())\\n      return R, C, M\\n  \\n  \\n  if __name__ == \"__main__\":\\n      sys.setrecursionlimit(100000)\\n      T = int(sys.stdin.readline().strip())\\n      for i in xrange(T):\\n          sys.stderr.write(\"case:%s\\n\" % (i + 1))\\n          data = parse()\\n          result = compute(*data)\\n          print \"Case #%d: %s\" % (i + 1, result)\\n", "substitutes": {"DX": ["WH", "DH", "CD", "DT", "X", "dx", "WD", "DR", "OX", "DP", "YE", "RH", "XY", "IX", "XX", "DK", "DI", "UX", "EX", "FX", "DD", "Xi", "DC", "TX", "DL", "DS", "YD", "DW", "TD"], "DY": ["DEYY", "DPYD", "DEY", "DPY", "DYY", " DYY", "DYD", "DEX", " DYD", "DEYD", "DPX", "DPYY"], "R": ["Range", "D", "G", "O", "Right", "JR", "X", "RA", "H", "L", "U", "CR", "A", "E", "MR", "DR", "Br", "RC", "REM", "ROM", "B", "RG", "Res", "RL", "Root", "Random", "AR", "HR", "F", "r", "KR", "J", "Reader", "RON", "V", "RO", "RS", "Rot", "Row", "Y", "Cor", "N", "NR", "RE", "TR", "GR", "RR", "Rs", "I", "RM", "P", "RT", "OR", "W", "RI", "RW", "S", "BR", "IR", "SR", "Re", "ER"], "C": ["D", "BC", "CD", "One", "U", "A", "CAR", "Cl", "IC", "CC", "F", "r", "J", "VC", "CF", "K", "c", "MC", "CW", "Co", "G", "Ch", "HC", "CM", "CN", "AC", "CS", "B", "CV", "CE", "CI", "WC", "CON", "EC", "Config", "CO", "CT", "CG", "CP", "YC", "CU", "S", "JC", "X", "L", "RC", "CA", "RS", "Y", "CNN", "RE", "DC", "P", "Cs", "COM", "O", "H", "CR", "E", "Cr", "SC", "V", "Con", "N", "I", "CB", "W", "CCC", "CL", "BR"], "M": ["D", "the", "U", "m", "A", "MN", "none", "_", "F", "J", "Z", "K", "void", "RM", "a", "MC", "G", "TM", "CM", "REM", "MAN", "B", "left", "MR", "S", "AM", "X", "Memory", "L", "n", "NM", "Mi", "IM", "Y", "LM", "RE", "AN", "MT", "new", "P", "VM", "O", "H", "E", "Q", "all", "Mon", "MM", "b", "V", "N", "MI", "I", "W", "DM", "MS", "com"], "free": ["res", "clear", "total", "valid", "done", "equal", "open", "de", "re", "space", "ms", "mask", "used", "MA", "m", "no", "sp", "error", "given", "none", "zero", "fine", "con", "f", "close", "nil", "only", "full", "available", "left", "set", "F", "blank", "occupied", "fee", "over", "co", "Free", "min", "MI", "new", "Only", "out", "void", "mem", "mate", "floor", "c", "non", "are", "FREE", "size", "good"], "default": ["switch", "label", "p", "menu", "root", "de", "password", "df", "force", "initial", "m", "error", "FAULT", "aults", " Default", "none", "g", "key", "self", "option", "f", "null", "name", "field", "dt", "slot", "choice", "left", "optional", "help", "current", "r", "config", "grid", "b", "value", "release", "primary", "DE", "right", "delay", "new", "normal", "fixed", "Default", "c", "weight", "description"], "j": ["ji", "ki", "k", "fr", "cm", "ri", "ja", "ei", "jac", "bi", "pr", "uj", "q", "y", "r", "J", "ai", "b", "rel", "co", "ij", "jc", "di", "zi", "ion", "iaz", "fi", "aj"], "i": ["gi", "ki", "p", "ic", "k", "ib", "li", "e", "it", "iy", "ia", "t", "o", "m", "ik", "h", "iti", "z", "n", "id", "f", "ri", "phi", "ish", "il", "ti", "ini", "bi", "index", "si", "xi", "im", "mi", "y", "u", "r", "ai", "\u0438", "b", "ip", "l", "x", "pi", "ii", "ij", "iu", "oi", "irin", "ati", "di", "I", "zi", "ig", "c", "ie", "v", "fi", "ir", "yi", "ind", "ci"], "board": ["menu", "piece", "foot", "command", "deck", "node", "full", "line", "local", "row", "sequence", "stream", "body", "clean", "san", "box", "door", "fc", "Board", "library", "front", "inner", "bd", "bo", "part", "block", "disk", "ro", "control", "chain", "loop", "lay", "rank", "hub", "stone", "bank", "player", "pool", "back", "stri", "out", "flo", "form", "bus", "butt", "video", "oard", "display", "public", "array", "layout", "style", "ui", "lib", "database", "league", "pb", "ac", "poll", "join", "channel", "member", "hole", "bench", "table", "draw", "card", "runner", "ward", "bar", "land", "controller", "way", "design", "test", "bin", "case", "ard", "bit", "client", "won", "system", "book", "core", "builder", "cross", "b", "view", "pad", "buffer", "room", "stick", "ack", "string", "boarding", "boot", "black", "bird", "roller", "bug", "lock", "bot", "game", "list"], "s": ["ns", "comments", "p", "os", "ats", "str", "ments", "e", "rs", "ps", "t", "o", "m", "h", "ss", "n", "g", "f", "ls", "ds", "ws", "w", "sets", "cs", "sw", "r", "its", "b", "changes", "ins", "bits", "bs", "ends", "sv", "conv", "js", "a", "c", "sys", "ts", "es", "S", "sb", "stats", "gs"], "empty": ["clear", "delete", "fill", "equal", "open", "missing", "initial", "util", "complete", "none", "zero", "address", "example", "null", "nil", "exclusive", "Empty", "full", "optional", "blank", "unknown", "export", "occupied", "une", "simple", " Empty", "table", "negative", "filled", "clean", "execute", "quiet", "make", "void", "inline", "mate", "valid", "size", "flush"]}}
{"code": " \\n  \\n  def compute(r1, m1, r2, m2):\\n      valid1 = set(m1[r1 - 1])\\n      valid2 = set(m2[r2 - 1])\\n      valid = valid1 & valid2\\n      if len(valid) == 0:\\n          return 'Volunteer cheated!'\\n      if len(valid) > 1:\\n          return 'Bad magician!'\\n      return valid.pop()\\n  \\n  \\n  def parse_single():\\n      r = int(sys.stdin.readline().strip())\\n      m = []\\n      for i in xrange(4):\\n          m.append(map(int, sys.stdin.readline().strip().split()))\\n      return r, m\\n  \\n  def parse():\\n      r1, m1 = parse_single()\\n      r2, m2 = parse_single()\\n      return r1, m1, r2, m2\\n  \\n  \\n  if __name__ == \"__main__\":\\n      sys.setrecursionlimit(100000)\\n      T = int(sys.stdin.readline().strip())\\n      for i in xrange(T):\\n          data = parse()\\n          result = compute(*data)\\n          print \"Case #%d: %s\" % (i + 1, result)\\n", "substitutes": {"r1": ["R2", " r5", "r64", "m64", "m51", "rd001", " r64", "ar1", "m5", "mone", "rd1", "r001", "rOne", "mrone", "mr5", " r51", "r5", " rone", "rd01", "r51", "ar01", "R001", "r01", "rone", "rd2", " rOne", "mOne", "ar2", "mr1", " r3", "R01", "ROne", "R1", "mr3", "m3", "r3", "mr51", "ar001", "mr64"], "m1": ["M1", "M3", " m11", "r0", "pm3", "M10", "p1", " m3", "m51", "p3", "m0", "p2", "r10", "pm51", "r51", " m01", "r01", "m11", "p11", "m01", " m0", "m10", "M01", "M2", "r11", " m51", "m3", "pm1", "M0", " m10", "r3"], "r2": ["R02", "rt02", "r14", "R2", "artwo", " rtwo", "mnt", "l12", "rttwo", "resnt", "R3", "rtwo", "mtwo", " r14", "r8", "m14", "ar14", "res2", "r02", " r12", "m12", "ar1", "m02", "rtnt", "r12", " r02", "rt2", "restwo", "l2", "l8", "rnt", "m8", "ar2", " r3", " r8", "R1", "m3", "l1", "res02", "r3"], "m2": ["M1", "mall", "Mall", "Mto", "m4", "t22", "r0", "mt2", "t1", "rall", " mall", "mt1", "l0", " mto", "r6", "m22", "r4", "m0", "l6", "mr4", "mt6", "m6", "mto", "r22", "l2", "rto", " m0", "M2", "t4", "t2", "mr2", "M0", "mr22", "l1", "mr1", "mt0"], "valid1": [" validOne", "validOne", "goodOne", "val0", "valOne", "good1", "ok1", "val1", "ok2", "good2", "okOne", "valid0", " valid0", "good0", "val2"], "valid2": ["full4", " valid6", "m4", "good02", "visibleTwo", "full6", "visible4", "val02", "good1", " valid4", "m02", "val1", "full2", "val2", "val4", "valid02", "good2", "fullTwo", " validTwo", "visible6", "valid6", "visible2", "validTwo", "good4", "valid4"], "valid": ["Valid", "empty", "open", "check", "li", "ok", "used", "long", "util", "public", "error", "complete", "defined", "id", "bad", "all", "true", "f", "dev", "null", "spec", "present", "active", "only", "full", "available", "local", "set", "multiple", "multi", "current", "same", "my", "visible", "val", "l", "required", "bid", "al", "allowed", "num", "md", "iter", "normal", "new", "void", "v", "non", "good", "free", "test", "status", "list"], "r": ["res", "br", "p", "rc", "fr", "re", "rs", "rec", "lr", "t", "nr", "h", "ro", "rb", "n", "g", "R", "ret", "ar", "d", "pr", "q", "u", "kr", "rect", "l", "cr", "rel", "rar", "sr", "dr", "mr", "c", "v", "rd", "rt"], "m": ["p", "em", "dm", "tm", "ms", "mask", "cm", "t", "mac", "o", "mm", "h", "n", "s", "bm", "f", "perm", "um", "d", "gm", "mi", "multi", "fm", "b", "me", "M", "mt", "l", "mc", "mu", "mut", "md", "mp", "mun", "rm", "mr", "a", "c", "v", "ml", "vm", "arm"], "i": ["gi", "ki", "hi", "p", "ic", "j", "li", "e", "it", "id", "z", "iri", "s", "n", "f", "ri", "phi", "ei", "ti", "ini", "bi", "index", "si", "d", "xi", "im", "y", "mi", "ai", "me", "x", "pi", "oi", "ix", "di", "I", "zi", "c", "v", "yi", "ind", "ci"], "T": ["Time", "D", "G", "TT", "TN", "IT", "t", "TM", "L", "E", "Q", "R", "TH", "B", "TIME", "TS", "TA", "J", "Type", "V", "M", "Z", "Y", "NT", "N", "TR", "C", "K", "Total", "I", "P", "W", "S"], "data": ["partial", "ns", "next", "done", "dat", "str", "DATA", "frame", "times", "no", "results", "zero", "window", "all", "group", "raw", "chain", "ds", "d", "extra", "size", "dates", "multiple", "cache", "features", "json", "rew", "row", "reports", "ata", "mu", "items", "batch", "series", "details", "text", "Data", "inner", "da"], "result": ["res", "function", "tmp", "reason", "total", "su", "the", "report", "correct", "fully", "ful", "success", "results", "final", "f", "ret", "pro", "summary", "current", "successful", "successfully", "Result", "value", "html", "met", "output", "new", "RET", "profile", "performance", "mate", "first", "text", "test", "message", "status"]}}
{"code": " \\n  def read_line():\\n      return sys.stdin.readline().rstrip( '\\n' )\\n  \\n  def read_integer():\\n      return int( read_line() )\\n  \\n  def read_integers():\\n      return [ int( x ) for x in read_line().split() ]\\n  \\n  def flip( grid ):\\n      return [ bytearray( ''.join( chr( grid[ row ][ column ] ) for row in range( len( grid ) ) ) ) for column in range( len( grid[ 0 ] ) ) ]\\n  \\n  def grow( R, C, M ):\\n      grid = [ bytearray( C*[ '*' ] ) for row in range( R ) ]\\n      b = R*C - M\\n      if C > R:\\n          R, C, grid = C, R, flip( grid )\\n          flipped = True\\n      else:\\n          flipped = False\\n      if b < 2*C:\\n          if b == 1:\\n              grid[ 0 ][ 0 ] = 'c'\\n          elif b == 3 and C >= 3:\\n              grid[ 0 ][ : 3 ] = bytearray( '.c.' )\\n          elif b % 2:\\n              return\\n          else:\\n              grid[ 0 ][ : b//2 ] = bytearray( b//2*'.' )\\n              grid[ 1 ][ : b//2 ] = bytearray( b//2*'.' )\\n              grid[ 0 ][ 0 ] = 'c'\\n      else:\\n          r = 0\\n          while b >= C:\\n              grid[ r ] = bytearray( C*[ '.' ] )\\n              b -= C\\n              r += 1\\n          if b:\\n              if b >= 2:\\n                  grid[ r ][ : b ] = b*'.'\\n              elif C > 2 and r > 2:\\n                  grid[ r - 1 ][ -1 ] = '*'\\n                  grid[ r ][ : 2 ] = '..'\\n              else:\\n                  return\\n          grid[ 0 ][ 0 ] = 'c'\\n      return flip( grid ) if flipped else grid\\n      \\n  T = read_integer()\\n  for t in range( T ):\\n      print 'Case #%i:' % ( t + 1 )\\n      R, C, M = read_integers()\\n      grid = grow( R, C, M )\\n      print '\\n'.join( str( row ) for row in grid ) if grid else 'Impossible'\\n", "substitutes": {"x": ["ux", "xs", "xxxx", "xxxxxxxx", "rx", "xes", "X", "wx", "ctx", "dx", "xp", "ax", "ox", "xc", "xa", "tx", "ey", "xt", "mx", "xi", "y", "i", "xf", "yx", "xe", "xd", "ix", "xy", "px", "ex", "xx", "xb", "fx", "zx"], "grid": ["raid", "func", "switch", "function", "band", "er", "cut", "MA", "m", "domain", "secure", "old", "h", "ordan", "fine", "node", "window", "ed", "wrapper", "jac", "q", "local", "cache", "set", "module", "line", "when", "hold", "network", "sequence", "car", "age", "tif", "box", "dq", "iter", "debug", "c", "gc", "rain", "lat", "cell", "gru", "G", "stock", "mA", "default", "prefix", "gb", "reg", "util", "mg", "CM", "manager", "lc", "id", "final", "tile", "remote", "chain", "lay", "rank", "config", "ga", "back", "pipe", "grain", "gr", "out", "device", "mr", "good", "MR", "filter", "form", "modified", "graph", "cart", "stack", "zero", "g", "group", "f", "grow", "coord", "work", "cells", "table", "query", "card", "net", "gate", "new", "fixed", "map", "file", "lag", "bar", "data", "queue", "way", "dim", "test", "gray", "bin", "case", "res", "range", "bridge", "next", "storage", "start", "Grid", "cm", "gain", "client", "CR", "Q", "cgi", "addr", "rid", "mat", "ace", "tr", "gm", "wire", "multi", "cli", "db", "scroll", "adj", "GR", "ma", "rm", "ge", "bag", "sys", "mod", "windows", "list"], "row": ["range", "word", "col", "re", "e", "rs", "block", "ox", "ro", "key", "run", "id", "record", "week", "con", "lo", "rown", "name", "char", "item", "tr", "index", "w", "user", "line", "rot", "entry", "sw", "rect", "Row", "board", "co", "ow", "month", "order", "to", "batch", "th", "roll", "ward", "length", "may", "round", "arrow", "rows", "pos", "cell"], "column": ["day", "col", "cut", "block", "key", "node", "td", "variable", "csv", "group", "con", "top", "chain", "rown", "char", "field", "w", "index", "item", "line", "left", "width", "current", "entry", "character", "scroll", "value", "channel", "table", "number", "umn", "Column", "position", "height", "length", "pointer", "c", "arrow", "header", "rain", "cell", "right"], "R": ["D", "G", "Right", "X", "Grid", "RA", "H", "L", "U", "CR", "Q", "A", "MR", "DR", "B", "RG", "Res", "RL", "RH", "AR", "Mr", "V", "RO", "RS", "Row", "Y", "N", "NR", "RE", "TR", "GR", "RR", "Rs", "I", "RM", "P", "RT", "RI", "S", "SR", "ER"], "C": ["Co", "D", "G", "O", "JC", "Ch", "One", "COR", "X", "H", "L", "U", "CR", "Q", "A", "CM", "E", "Cr", "CBS", "Count", "CS", "B", "CAR", "CA", "Cl", "CC", "CI", "WC", "F", "CON", "V", "CH", "EC", "Z", "Y", "CNN", "N", "CO", "CT", "CG", "VC", "CP", "DC", "K", "I", "P", "YC", "CB", "W", "c", "CCC", "CL", "MC", "CU", "S", "Cs"], "M": ["D", "G", "O", "X", "H", "L", "m", "TM", "U", "E", "Q", "A", "CM", "MN", "MAN", "B", "MM", "F", "J", "V", "Z", "Y", "EM", "N", "Ms", "MT", "MI", "I", "RM", "P", "My", "Mc", "W", "DM", "MC", "MS", "S", "MR"], "b": ["br", "p", "j", "bf", "bit", "ib", "base", "it", "gb", "o", "m", "h", "bc", "bb", "z", "rb", "g", "n", "f", "ba", "bound", "B", "fb", "bi", "d", "w", "cb", "u", "be", "y", "i", "eb", "nb", "db", "on", " B", "lb", "l", "bs", "erb", "body", "to", "batch", "back", "a", "c", "v", "wb", "ab", "bt", "bin", "sb", "bp", "bu"], "flipped": ["Flipper", "slipper", "fiped", " flipper", " fliped", " flip", "FLipped", "sliped", "fipping", "slipping", "fliped", "flip", "slip", "slipped", "flipper", "FLipper", "Flipping", "FLip", "flipping", "fipper", "Flip", "FLipping", " flipping", "fipped", "Flipped"], "r": ["res", "br", "p", "j", "rem", "k", "rc", "er", "re", "e", "err", "rs", "it", "o", "m", "h", "nr", "ro", "z", "n", "g", "rb", "rest", "ar", "result", "w", "d", "pr", "q", "rank", "i", "u", "y", "l", "rr", "cr", "usr", "sr", "dr", "out", "mr", "a", "c", "v", "rd", "rt", "right", "radius"], "T": ["D", "G", "O", "TT", "TN", "TM", "L", "E", "Q", "B", "TC", "TS", "TA", "F", "V", "Z", "Y", "N", "WT", "GT", "TR", "TB", "K", "ID", "I", "P", "W", "S"], "t": ["ft", "tt", "p", "total", "e", "m", "h", "ct", "n", "g", "td", "s", "f", "let", "int", "ti", "tr", "w", "d", "dt", "_", "y", "i", "typ", "l", "ty", "tz", "ot", "tree", "out", "tu", "tap", "ta", "c", "v", "tc", "wt", "ts", "tw"]}}
{"code": " \\n  def read_line():\\n      return sys.stdin.readline().rstrip( '\\n' )\\n  \\n  def read_integer():\\n      return int( read_line() )\\n  \\n  def read_integers():\\n      return [ int( x ) for x in read_line().split() ]\\n  \\n  def read_string():\\n      return read_line().strip()\\n  \\n  def read_strings():\\n      return read_line().split()\\n  \\n  def input_string_stack():\\n      data = []\\n      for line in sys.stdin.readlines():\\n          data.extend( line.split() )\\n      data.reverse()\\n      return data\\n  \\n  def input_integer_stack():\\n      return [ int( x ) for x in read_string_stack() ]\\n  \\n  class memoized( object ):\\n     def __init__( self, function ):\\n        self.function = function\\n        self.cache = {}\\n     def __call__( self, *arguments ):\\n        try:\\n           return self.cache[ arguments ]\\n        except KeyError:\\n           value = self.function( *arguments )\\n           self.cache[ arguments ] = value\\n           return value\\n  \\n  T = read_integer()\\n  for t in range( T ):\\n      row = read_integer()\\n      candidates = set( [ read_integers() for index in range( 4 ) ][ row - 1 ] )\\n      row = read_integer()\\n      candidates &= set( [ read_integers() for index in range( 4 ) ][ row - 1 ] )\\n      print 'Case #%i:' % ( t + 1 ), candidates.pop() if len( candidates ) == 1 else 'Bad magician!' if len( candidates ) > 1 else 'Volunteer cheated!'\\n", "substitutes": {"x": ["ux", "hex", "p", "xs", "k", "xxxx", "xxx", "rx", "xes", "xxxxxxxx", "wx", "X", "dx", "xp", "ctx", "ax", "ox", "key", "z", "xc", "xa", " xx", "xt", "ey", "tx", "mx", "xi", "y", "i", "inx", "xf", "on", "yx", "lex", "xe", "xd", "ix", "xy", "ex", "px", "c", "xx", "v", "xb", "fx", "ci"], "data": ["values", "ns", "next", "clear", "done", "images", "dat", "reader", "DATA", "this", "str", "buf", "bytes", "no", "array", "key", "results", "append", "window", "n", "all", "group", "raw", "keys", "info", "result", "d", "extra", "multiple", "left", "rew", "join", "content", "buffer", "ata", "table", "read", "items", "batch", "output", "input", "new", "pieces", "first", "lines", "steps", "details", "text", "Data", "step", "list"], "line": ["Line", "word", "li", "frame", "source", "lin", "le", "LINE", "eline", "block", " Line", "code", "style", " lin", "lined", "stroke", "name", "page", "section", "drive", " l", "ine", " slide", "entry", "lane", "link", "log", "l", "ln", " linen", "pipe", "liner", " lines", "string", " le", "inline", "file", "lines", " inline", "cell", "text"], "self": ["app", "python", "empty", "tmp", "p", "error", "h", "req", "wrapper", "close", "shape", "w", "full", "q", "local", "eth", "user", "writer", "cert", "unknown", "ae", "instance", "attr", "output", "mp", "diff", "by", "details", "policy", "private", "agg", "txt", "cmp", "s", "github", "parent", "remote", "params", "dd", "config", "np", "rel", "pkg", "th", "resp", "also", "attribute", "response", "context", "form", "this", "load", "rec", "your", "public", "responsible", "n", "pub", "wn", "conn", "my", "sw", "co", "add", "new", "round", "first", "student", "links", "pair", "access", "ref", "client", "request", "properties", "all", "ren", "dev", "subject", "static", "ws", "init", "me", "cl", "sh", "replace", "nt", "you", "obj", "look", "get", "weak", "ex", "object", "py", "Self"], "function": ["partial", "func", "form", "functional", "word", "service", "operator", "expression", "tool", "force", "command", "handler", "relation", "resource", "family", "code", "variable", "f", "kernel", "effect", "operation", "closure", "system", "driver", "section", "condition", "action", "description", "fun", "module", "feature", "role", "interface", "network", "hole", "table", "call", "figure", "document", "position", "connection", "string", "format", "normal", "definition", "device", "evaluate", "file", "callback", "method", "library", "Function", "component", "fn", "object"], "cache": ["default", "storage", "tag", "api", "force", "master", "store", "history", "memory", "metadata", "modules", "wrapper", "remote", "driver", "chain", "spec", "ache", "module", "core", "state", "config", "db", "ac", "hidden", "aches", "table", "cycle", "sequence", "order", "options", "template", "batch", "format", "map", "Cache", "c", "sum", "component", "parse", "details", "context", "hash", "filter", "temp", "list"], "value": ["python", "values", "vector", "total", "default", "type", "operator", "expression", "property", "success", "key", "variable", "true", "example", "raw", "name", "see", "widget", "item", "field", "result", "current", "json", "VAL", "entry", "unknown", "write", "unit", "content", "Value", "val", "number", "text", "hello", "instance", "to", "output", "string", "format", "place", "VALUE", "v", "attribute", "description", "test", "object", "pair"], "arguments": ["argument", "statutes", "strument", "Arguments", "aggument", "agguments", "commets", "commctions", "documents", "statument", "statands", "igutes", "argeters", "Argument", "argensions", "argsets", "igument", "reguments", "commuments", "docgments", "Argeters", "regument", "argsensions", "docets", "argands", "paramuments", "strets", "arggments", "iguments", "regutes", "statuments", "argutes", "Argets", "argctions", "argentials", "paramentials", "aggensions", "paramensions", "igands", "streters", "argsentials", "igctions", "docctions", "regands", "iggments", "aggentials", "igets", "paramument", "argsument", "argets", "struments", "argseters", "commgments", "argsuments"], "T": ["Time", "D", "G", "O", "TT", "L", "TY", "TM", "A", "E", "Count", "R", "TH", "B", "TABLE", "TC", "TS", "TA", "F", "V", "M", "Row", "Z", "Y", "NT", "N", "GT", "TR", "TB", "C", "K", "Total", "I", "P", "S"], "t": ["tt", "p", "j", "k", "total", "tm", "m", "ct", "ox", "z", "n", "g", "td", "s", "f", "name", "ti", "tr", "w", "d", "dt", "u", "y", "i", "r", "l", "tri", "te", "title", "tl", "out", "tu", "a", "tip", "c", "ta", "v", "tc", "test"], "row": ["range", "post", "day", "col", "frame", "course", "column", "block", "ser", "ox", "week", "ro", "key", "record", "node", "rown", "page", "field", "tr", "w", "rank", "set", "r", "tab", "Row", "table", "server", "ow", "order", "batch", "box", "iter", "ows", "roll", "offset", "round", "rows", "pos", "cell", "pair", "step", "num"], "candidates": ["candicates", "validles", "centents", "continidates", " candidate", "Candicates", "predids", " Candidate", "continles", "Candabilities", " candels", "predidates", " candates", "condidates", "continents", "continates", "validents", "Candidates", "condidate", "Candates", "predles", "condeters", " Candates", "validids", "candeters", "charances", "carsabilities", "Candeters", "carsidates", "Candidate", "charidates", " candabilities", "charidate", "candles", "centidates", " Candles", "carsidate", " candicates", "candances", "Candances", "candels", "candabilities", "valididates", "chareters", " Candids", "centles", "Candels", "carsicates", "centates", " Candidates", "candents", "candates", "condances", "validates", "predates", " Candels", "candidate", "candids"], "index": ["range", "se", "label", "match", "fail", "column", "error", "ox", "node", "rown", "see", "condition", "loop", "axis", "each", "link", "where", "Index", "val", "insert", "draw", "loc", "find", "position", "height", "connect", "slice", "ix", "second", "length", "ion", "ex", "cell", "select", "valid", "ind", "size"]}}
{"code": "def Trivial(R,C,char):\\n      for i in range(R):\\n          Ans = '';\\n          for j in range(C):\\n              if (i==j==0):\\n                  Ans += 'c';\\n              else:\\n                  Ans += char;\\n          print Ans;\\n  \\n  \\n  def Draw1(R,C,Blank):\\n      Ans = \"c\";\\n      for i in range(Blank-1):\\n          Ans += '.';\\n      for i in range(R*C-Blank):\\n          Ans += '*';\\n      if (R == 1):\\n          print Ans;        \\n          return;\\n      if (C == 1):\\n          for i in range(len(Ans)):\\n              print Ans[i];\\n  \\n  def Draw2(R,C,Blank):\\n      if (Blank%2 != 0) or (Blank == 2):\\n          print \"Impossible\";\\n          return;\\n      Row1 = '.'*(Blank/2) + '*'*(Mine/2);\\n      Row0 = 'c' + Row1[1:];\\n      if R==2:\\n          print Row0;\\n          print Row1;\\n      else:\\n          for i in range(len(Row0)):\\n              print Row0[i]+Row1[i];\\n      return;\\n  \\n  \\n  def Generate(R, C, Blank):\\n      TODO = Blank;\\n      Spaces = [0]*R;\\n      if TODO <= 2*C:\\n          if TODO%2 == 0:\\n              Spaces[0] = TODO/2;\\n              Spaces[1] = TODO-Spaces[0];\\n          else:\\n              if (TODO == 7):\\n                  Spaces[0] = 3;\\n                  Spaces[1] = 2;\\n                  Spaces[2] = 2;\\n              else:\\n                  Spaces[0] = (TODO-3)/2;\\n                  Spaces[1] = (TODO-3)/2;\\n                  Spaces[2] = 3;\\n      else:\\n          row = 0;\\n          if (TODO >= 2*C+2):\\n              Spaces[0] = C;\\n              Spaces[1] = C;\\n              TODO -= 2*C;\\n              row = 2;\\n              \\n          while TODO > C+1:\\n              if (TODO == 2*C+1) and (C != 3):\\n                  Spaces[row] = C-1;\\n                  Spaces[row+1] = C-1;\\n                  Spaces[row+2] = 3;\\n                  TODO = 0;\\n              else:\\n                  Spaces[row] = C;\\n                  TODO -= C;\\n                  row += 1;\\n          if (TODO == C+1):\\n              Spaces[row] += C-1;\\n              Spaces[row+1] = 2;\\n              TODO = 0;\\n          Spaces[row] += TODO;\\n  \\n      for r in range(R):\\n          Ans = '.'*Spaces[r] + '*'*(C-Spaces[r]);\\n          if r == 0:\\n              Ans = 'c'+Ans[1:];\\n          print Ans;\\n  \\n  \\n  def Solve(R, C, M):\\n      Blank = R*C-M;\\n      if Blank == 0:\\n          print \"Impossible\";\\n          return;\\n  \\n      if (Blank == 1):\\n          Trivial(R,C,'*');\\n          return\\n      if (Blank == R*C):\\n          Trivial(R,C,'.');\\n          return\\n  \\n      if (R == 1) or (C == 1):\\n            Draw1(R,C,Blank);\\n            return\\n  \\n      if (R-2)*(C-2) == 0:\\n          Draw2(R,C,Blank);\\n          return\\n  \\n      if Blank in [2,3,5,7]:\\n          print \"Impossible\";\\n          return;\\n      \\n      if (R >= 3) and (C >= 3):\\n          Generate(R, C, Blank);\\n  \\n      return;\\n  \\n  \\n  T = int(raw_input());\\n  for q in range(T):\\n      [Row,Col,Mine] = map(int, raw_input().split());\\n  \\n      Blanks = Row*Col - Mine;\\n      \\n      print \"Case #%d:\" % (q+1)\\n      Solve(Row, Col, Mine);\\n      \\n          \\n", "substitutes": {"R": ["Range", "D", "G", "O", "COR", "JR", "Right", "X", "RA", "H", "L", "U", "A", "CR", "E", "Q", "Reg", "DR", "RC", "Remote", "B", "RG", "Res", "RL", "HR", "F", "J", "Reader", "V", "RO", "RS", "Rot", "Y", "Cor", "N", "RE", "TR", "GR", "Char", "RR", "Rs", "K", "VR", "I", "RM", "P", "RT", "Rat", "W", "RI", "RW", "BR", "S", "SR", "ER"], "C": ["Co", "D", "G", "O", "CD", "JC", "Ch", "BC", "COR", "FC", "X", "Cow", "L", "H", "U", "HC", "CR", "E", "Q", "CM", "A", "Cr", "AC", "Chain", "CS", "B", "CA", "CV", "CE", "IC", "CC", "Color", "CI", "WC", "F", "J", "Craig", "Custom", "SC", "V", "CON", "CH", "EC", "Con", "Y", "CNN", "N", "CO", "Char", "CT", "CG", "CP", "CF", "K", "DC", "I", "P", "Cache", "CB", "YC", "c", "CCC", "Com", "CHAR", "CU", "Charlie", "W", "S", "Cs"], "char": ["Ch", "str", "word", "col", "type", "start", "cur", "ind", "true", "f", "Letter", "name", "int", "index", "character", "ctr", "float", "cr", "String", "ch", "Char", "string", "Character", "CHAR", "a", "c", "cell", "text", "letter", "ci"], "i": ["gi", "ki", "ic", "p", "k", "ib", "li", "e", "col", "it", "ia", "t", "o", "io", "m", "h", "iti", "key", "id", "n", "g", "s", "iri", "ri", "phi", "ei", "name", "int", "ti", "il", "ini", "index", "si", "u", "im", "y", "mi", "xi", "ai", "b", "\u00ed", "ip", "l", "x", "oi", "ii", "pi", "iu", "ij", "ati", "ix", "di", "ice", "I", "zi", "a", "c", "ie", "v", "fi", "ir", "ind", "ci"], "Ans": ["ants", " ansi", "Paincons", "Yourments", "ANns", "Acss", "Conis", "Acns", "As", "Acls", "Pains", " Aners", "ANsd", "Anss", "Accs", "Anes", "Canns", "arens", " Ancs", "Ais", " Ants", "Ann", " Anps", "Anis", "Cans", "Arsd", "Annes", "Anners", "Arts", "Anps", "Anls", "Cons", "Aris", "Acps", "ANls", "Ats", " Anns", "Ants", "Ancons", "Anns", "Painments", " anS", "ANps", "ANsi", "Ansd", " ancs", "Arsi", " anps", "ANS", "Acs", "anls", "ANn", " annS", "Aners", " ans", "Yourcons", " Anis", "Concs", "Yourcs", "Conr", "Caners", " Ancons", "ANcs", "Annns", "ans", "ANr", "ANses", " annsi", " annses", "Canes", "Yours", "Acts", "ANts", "Ars", " Anments", "Arcs", "arenses", "Arn", "ANs", " Anr", " ansd", " ann", "Ansi", "ANis", " Anes", "AcS", "anss", "arensi", "AnS", "Anr", "arenS", "Paincs", " anns", "Anses", "Conts", "Ancs", "ANss", "Anments"], "j": ["ji", "br", "p", "jj", "k", "jl", "JC", "col", "e", "it", "t", "o", "bc", "z", "n", "s", "g", "f", "name", "jac", "bi", "d", "uj", "J", "kj", "b", "cor", "l", "oj", "ij", "jc", "ch", "out", "I", "a", "uni", "c", "iaz", "v", "aj", "cell", "ind"], "Blank": ["Clan", " Blink", "Brocked", "Branking", "BLanks", "Branks", "Slanking", "Blake", "blanking", "BLocked", "BLank", "Blanking", "BlANK", "Plank", "Flanking", "blANK", "BLANK", " BlANK", "blanks", "PlANK", "Brunk", "Plake", "BLunk", "BLan", "Brank", "BLink", "SlANK", "BrANK", "Clack", "Clank", "BLack", "BLanking", " Blake", "Flank", "Black", "Clanking", "blank", "Blink", "Planking", "Slunk", "blink", "Flan", "Brake", "Blocked", "Blan", "Slank", " Blanking", "Flack", "Bran", "Slocked", "blan", "Blunk"], "Row1": ["Row3", " RowOne", "row10", "Line10", "Line2", "RowOne", " Row3", "rowOne", "row0", "Line3", " Row2", "row1", "Row2", "row3", " Row10", "Line1", "row2", "Row10", "Line0", "LineOne"], "Row0": ["Row3", "R2", " RowZero", "RowZero", "Rowzero", "Linezero", "Line4", "row10", "Line10", "Line2", " Row3", " Rowzero", "R0", "row4", "row0", "Line3", "Row4", "row1", "row3", " Row4", "Row2", " Row2", " Row10", "LineZero", "RecordZero", "Record0", "R1", "Recordzero", "Line1", "row2", "Row10", "Line0", "Record1"], "TODO": ["TADOE", "tENTOO", " TIDOS", "TOTOS", "TADo", "TODGO", " TIDOTA", "TODOE", " TADO", "TOPGO", "NOKOE", "VODOS", " TADOO", "TodOD", "TOKOE", "TOTOD", "TPDO", "TEGDO", "TDOTA", "TANDOG", "TENTPO", "TLODO", "TOTOA", "OTodo", " TODOS", "NODO", "TADOC", "tODO", "VodPO", "VODOD", "VIDO", "TOTO", "TPDPO", "NODOE", "TDo", " TODOs", "TLODo", "OTodOD", "VodOS", "TEGOs", "TOTTOD", "TOROTA", "TOKOS", "TENTE", "TANDOS", "TODOG", " TOTO", "TODOC", "NODPO", "OTODOA", "TODE", "TZOA", "TZo", "TOKo", "TodE", "TLODOA", "OTODo", "TANDPO", "tANDPO", "NOKO", "TZOD", " TADo", "TBDO", "TIDo", "TUDOO", "TTLOO", "TOTo", "Todo", "TLODOD", "tENTE", "NODOO", "TOMOA", "tODOD", "tENTPO", "NODOC", "TOKPO", " TOKOC", "TodOO", "TTLOE", "NODOA", "TOPo", "TOKO", "OTodOA", "TodOC", "TPDOG", "TOTTOTA", "NOKOC", "TODOS", "TADO", "TODo", "TODDO", "TUDOS", "OTodO", "TOROG", " TODo", "TOMOS", " TOTOO", "TOTPO", "NOKPO", " TODPO", "TIDOTA", "TOKOO", "TOKOA", "TBDOS", " TODGO", "tANDO", "TLODOTA", "TOTTOS", "TLODOs", " TODOO", "TLODPO", " TODDO", "TODOA", "OTODOD", " TOTPO", " TOTOD", "VODo", "tODPO", "TUDO", "TodOs", "TOTTO", "TORO", " TOTOS", "OTODO", "VODO", " TOKO", " TOTDO", "TADOO", " TOKGO", "TOMPO", "TodOA", "VIDOD", "tENTO", "TOROS", "TBDPO", "tODOO", "TODOD", "TODPO", "VODOTA", " TADOC", "TODOTA", "tANDOG", "TOKOC", "TANDOs", "TTLO", "TDO", "TEGPO", "VIDo", "TOPOC", "TORPO", "TodOS", "tODE", "TENTO", " TIDO", "TPDOD", "TOTDO", "TOTOs", "VODPO", "Vodo", "TIDOS", "TOKE", "TodGO", "TEGO", "NOKOO", "TTLOC", "TDOD", "TENTOO", "NODOS", "TOTOO", " TIDOD", "TOMO", "TIDO", "tANDOD", "TODOO", " TODOC", " TOKo", "TBDo", " TODOD", "VIDOTA", "TODOs", "TANDOD", "TodO", "TodPO", "TIDOD", "NOKOS", "TOROD", "TANDO", "TOKGO", "TLODDO", "NOKOA", "TZO", "VodO", "TOPO", "tODOG", " TODOTA", " TOTOs"], "Spaces": ["Stouses", "Scels", "Prouses", "Stacs", "Splaces", "Chaps", "Spapes", "SPacing", "spacing", " Spacing", "spices", "Pepaces", "Prpaces", " Spaps", "Slans", "Spices", "Briles", "Infacs", "SPices", "Sppaces", " Spouses", "Staps", "Prels", "Straces", "Squans", " Spans", "Shacs", "Strouses", "Exaps", "Braps", "Squaces", "Spepaces", "Shpaces", "Peaps", "Stiles", "Exans", "SPacs", "spanks", "SPaps", "Slices", " Spanks", "Blans", "Infaces", " Sprites", "Shaces", "Spiles", "Scices", "Spouses", "Sprites", "Pracs", "SPaces", "Blices", "Stels", "Infpaces", "Squpaces", "Shices", "spaces", "spapes", "Chaces", "spans", "spacs", "Scpaces", "Expices", "Strices", " Spices", "spouses", "Stices", "Stapes", "Speaces", "Prans", "Slpaces", "Scacs", "Spacs", "Prices", "Expouses", "Peacing", "Splpaces", "Spaps", "Splans", "Splrites", "Speans", "Praces", "Exppaces", "Spans", "Scans", "Brpaces", "Exaces", "Peaces", " Spapes", "Spanks", "Speices", "SPpaces", "Slaces", "Scaces", "Expaces", "Stacing", " Sppaces", "spaps", "sppaces", "Chices", "SPiles", "Spels", "Strpaces", "Staces", "Infices", "Braces", "Chacing", "Squrites", "Stpaces", "SPans", "Spacing", "Blaces"], "row": ["count", "col", "week", "term", "page", "item", "user", "line", "set", "head", "ow", "batch", "box", "iter", "length", "c", "cell", "num", "word", "block", "ro", "key", "run", "record", "raw", "field", "loop", "left", "rot", "number", "ver", "out", "ry", "edge", "level", "total", "rc", "column", "ser", "zero", "sw", "co", "x", "table", "server", "month", "runner", "bar", "round", "pos", "right", "size", "range", "post", "next", "type", "frame", "start", "all", "lo", "tr", "index", "entry", "scroll", "tab", "cycle", "roll", "offset", "rows", "high", "bug"], "Mine": ["empty", "Ram", "COR", "Max", "MAX", "Cr", "self", "Buffer", "White", "Cap", "Random", "margin", "Copy", "RAM", "Double", "Writing", "Center", "Content", "Cat", "red", "Coin", "Roman", "Fill", "Red", "Ring", "RAW", "black", "MC", "Ruby"]}}
{"code": "T = int(raw_input());\\n  for q in range(T):\\n      R1 = int(raw_input());\\n      Data1 = [];\\n      for i in range(4):\\n          Data1.append( map(int, raw_input().split()) );\\n          \\n      R2 = int(raw_input());\\n      Data2 = [];\\n      for i in range(4):\\n          Data2.append( map(int, raw_input().split()) );\\n  \\n      Ans = [];\\n      for entry in Data1[R1-1]:\\n          if entry in Data2[R2-1]:\\n              Ans.append(entry);\\n  \\n      print \"Case #%d:\" % (q+1),;\\n  \\n      if len(Ans) == 0:\\n          print \"Volunteer cheated!\";\\n      if len(Ans) == 1:\\n          print Ans[0];\\n      if len(Ans) > 1:\\n          print \"Bad magician!\"\\n          \\n", "substitutes": {"T": ["Time", "D", "G", "O", "TI", "TN", "X", "t", "H", "L", "TM", "E", "Q", "R", "B", "TS", "TA", "F", "J", "V", "M", "Z", "Y", "N", "NB", "TR", "C", "K", "Total", "I", "P", "W", "S"], "q": ["j", "p", "k", "count", "qv", "iq", "quality", "t", "m", "qu", "Q", "seq", "ox", "aq", "qq", "id", "z", "g", "n", "R", "f", "eq", "qi", " Q", "question", "quit", "d", "u", "r", "query", "qs", "qt", "requ", "dq", "c", "v", "quant", "ind", "num"], "R1": ["M1", "T4", "RA001", "T1", "Res001", "R9", "RFirst", "RA1", "RA9", "T2", "M4", "R0", "RAFirst", "R4", " R0", "Res9", "Res1", "R001", "RO1", "ROFirst", " R4", "M2", "RO9", "ResFirst", "M0", "RO001", "T0"], "Data1": ["DATA2", "DATAOnce", " DataOnce", " DataFirst", "DatFirst", "dataOne", "DataOne", "data1", "DATAA", "data10", "DATA10", " DataOne", " Data10", "DatA", "data2", "DATAOne", "Data10", "DataOnce", "DATA1", " DataA", "Dat1", "DataFirst", "DATAFirst", "DataA", "DatOnce", "Dat10"], "i": ["gi", "ic", "li", "it", "iy", "iti", "iri", "ri", "ei", "il", "ti", "ini", "xi", "im", "ai", "ip", "x", "pi", "ii", "ij", "iu", "ati", "iter", "di", "zi", "I", "ie", "ir", "ci"], "R2": ["RO2", "RE2", " R5", "RO12", " Rtwo", "T12", " R12", "RO5", "T1", "T7", "T2", "ROtwo", "RE5", "REtwo", "R12", "Rtwo", "RO1", "R7", " R7", "R5", "RO7"], "Data2": ["DataL", "List102", "DATA2", "UsersL", "List2", "ListTwo", "DATA02", "Data36", "data3", "Data3", "data1", " Data102", " Data02", "DATA102", "data10", "DATA10", " Data10", "data36", " Data3", "data2", "DatTwo", "DataTwo", "Data102", "dataL", "UsersTwo", "Data10", "Dat36", "DATA1", "Data02", "dataTwo", "List02", " DataTwo", "DATA3", "Users2", "Users36", "Dat2", "DatL", "DATATwo"], "Ans": ["ants", "anS", "Anv", "SANs", " Anv", " Angs", "ANsi", "Angs", "ANts", "Antts", "ANns", " Ann", "Antns", "ANS", "Asi", "As", "ANxs", " Anls", "Anls", "An", "ANs", "ANn", "Ansi", "Qualn", " AnS", "Quals", "anv", "ANc", "SANsi", "ANgs", "Antxs", "SANns", " Anc", "ANls", "Antgs", " Anns", "Ants", "Anxs", "AnS", "Anc", "ANv", "anxs", "AntS", "SANn", "ans", " Ants", "Antn", "Antls", "Ann", "Anns", "Qualc"], "entry": ["ient", "rue", "reader", "word", "the", "element", "RY", "ent", "article", "chapter", "key", "rent", "record", "necessary", "ant", "system", "ault", " Entry", "name", "Entry", "char", "slot", "index", "existent", "cue", "line", "ket", "row", "value", "channel", "insert", "notation", "instance", "nt", "rance", "you", "connection", "string", "feed", "void", "a", "data", "ie", "enter", "ry", "ener", "ence", "cell", "letter", "pair"]}}
{"code": " \\n  \\n  \\n  def show_board(board):\\n      for row in board:\\n          print ''.join(row)\\n  \\n  \\n  N = int(sys.stdin.readline())\\n  \\n  for T in range(1, N+1):\\n      (R, C, M) = map(int, sys.stdin.readline().split(' '))\\n      E = R*C-M # empty\\n      possible, reverse, need_adjust, column_base = (False, False, False, False)\\n      if C > R:\\n          (R, C) = (C, R)\\n          reverse = True\\n  \\n      W = 0\\n      lastRow = 0\\n      if E == 0:\\n          pass\\n      elif E == 1 or M == 0:\\n          W = C\\n          possible = True\\n      elif C == 1:\\n          W = 1\\n          if E > 0:\\n              possible = True\\n      elif C == 2:\\n          W = 2\\n          lastRow = int(E / 2) + 1   # 1 base\\n          if E % 2 == 0 and E >= 4:\\n              possible = True\\n      elif C >= 3:\\n          for w in range(2, C+1):\\n              lastRow = int(E / w) + 1   # 1 base\\n              if lastRow > R: continue\\n              lastRowNum = E % w\\n              \\n              if lastRow == 2 and lastRowNum == 0:\\n                  pass\\n              elif lastRow == 2:   # lastRow == 1 => impossible\\n                  if lastRowNum == 0:\\n                      W = w\\n                      possible = True\\n                      break\\n              elif lastRow >= 3:\\n                  if lastRowNum >= 2 or lastRowNum == 0:\\n                      W = w\\n                      possible = True\\n                      break\\n                  elif C >= 4 and lastRowNum == 1 and R >= 3:\\n                      W = w\\n                      possible = True\\n                      need_adjust = True\\n                      break\\n          if not possible:\\n              for w in range(2, R+1):\\n                  lastRow = int(E / w) + 1   # 1 base\\n                  if lastRow > R: continue\\n                  lastRowNum = E % w\\n                  if lastRow == 2 and lastRowNum == 0:\\n                      pass\\n                  elif lastRow == 2:   # lastRow == 1 => impossible\\n                      if lastRowNum == 0:\\n                          W = w\\n                          possible = True\\n                          column_base = True\\n                          break\\n                  elif lastRow >= 3:\\n                      if lastRowNum >= 2 or lastRowNum == 0:\\n                          W = w\\n                          possible = True\\n                          column_base = True\\n                          break\\n                      elif C >= 4 and lastRowNum == 1 and R >= 3:\\n                          W = w\\n                          possible = True\\n                          need_adjust = True\\n                          column_base = True\\n                          break\\n                                  \\n      if not possible:\\n          if reverse:\\n              R, C = (C, R)        \\n          ans = 'Impossible %sx%s M=%s' % (R, C, M)\\n          print 'Case #%(T)s: %(ans)s' % locals()\\n          continue\\n  \\n      board = [['*'] * C for i in range(R)]\\n      for i in range(E):\\n          if not column_base:\\n              c = i % W\\n              r = i / W\\n          else:\\n              r = i % W\\n              c = i / W            \\n          board[r][c] = '.'\\n      if need_adjust:\\n          board[lastRow-1][1], board[lastRow-2][-1] = board[lastRow-2][-1], board[lastRow-1][1]\\n      if reverse:\\n          board = map(list, zip(*board))\\n          R, C = (C, R)\\n  \\n      clicked = False\\n      for r in range(R):\\n          if clicked: break\\n          for c in range(C):\\n              cell = board[r][c]\\n              if cell != '.': continue\\n              if E == 1:\\n                  board[r][c] = 'c'\\n                  clicked = True\\n                  break\\n              \\n              if r >= 1  and c >= 1  and board[r-1][c-1] == '*': continue\\n              if r >= 1              and board[r-1][c]   == '*': continue\\n              if r >= 1  and c < C-1 and board[r-1][c+1] == '*': continue\\n              if             c >= 1  and board[r][c-1]   == '*': continue\\n              if             c < C-1 and board[r][c+1]   == '*': continue\\n              if r < R-1 and c >= 1  and board[r+1][c-1] == '*': continue\\n              if r < R-1             and board[r+1][c]   == '*': continue\\n              if r < R-1 and c < C-1 and board[r+1][c+1] == '*': continue\\n              board[r][c] = 'c'\\n              clicked = True\\n              break\\n  \\n      ans = 'Possible' if possible else 'Impossible'\\n      print 'Case #%(T)s:' % locals()\\n      show_board(board)\\n", "substitutes": {"board": ["menu", "bit", "form", "bo", "word", "frame", "course", "oard", "ob", "array", "ro", "window", "node", "lo", "case", "full", "lay", "line", "b", "pad", "buffer", "table", "stream", "body", "back", "boards", "box", "boarding", "ward", "fc", "Board", "bro", "paste", "cell", "past", "comment", "game", "list"], "row": [" instance", "range", "post", " rows", " star", " prow", "word", "col", "frame", "prefix", " cur", "block", "OW", "ro", "tty", "record", "node", " each", " cell", " user", "star", "user", "line", "entry", "rect", "each", " cursor", "Row", "table", "ow", " ro", "to", " re", "th", " rc", "ows", "roll", " word", " su", "ward", "rows", " f", "cell", " dow", " Row", " tr"], "N": ["D", "NN", "O", "NA", "H", "L", "Q", "NS", "NW", "n", "NV", "NM", "Ns", "B", "Ni", "NL", "NP", "NE", "SN", "V", "ND", "Z", "NPR", "NT", "NR", "NUM", "NO", "NB", "NF", "I", "P", "NC", "S", "NI"], "T": [" O", "O", " Y", " TD", " L", " D", " X", " each", " ki", " K", " Q", " Z", " J", " I", " B", " P", "IX", "Y", " U", " w", " W", "K", "I", " F", " S", " Li", " Xi"], "R": ["D", "G", "X", "RA", "H", "L", "U", "A", "RC", "RG", "B", "AR", "HR", " r", "r", "J", "F", "V", "RO", "RS", "Repl", "Y", "RE", "TR", "GR", "RR", "K", "I", "RM", "P", "W", "S", "SR"], "C": ["Co", "D", "G", "JC", "Cow", "L", "H", "U", "A", "CR", "CM", "B", "Cons", "CS", "CA", "CE", "CC", "F", "CON", "V", "CNN", "CO", "CT", "CG", "CP", "K", "P", "YC", "c", "Cond", "CU", "S", "Cs"], "M": ["D", "G", "O", "X", "H", "L", "m", "U", "A", "Q", "MN", "MAN", "B", "PM", "JM", "MM", "F", "J", "V", "Z", "Ms", "MT", "K", "I", "P", "W", "MC", "S"], "E": ["D", "G", "O", "e", "X", "H", "L", "Q", "B", "EF", "F", "J", "V", "EC", "Z", "ES", "I", "P", "W", "EEE", "AE", "EN", "ET", "S"]}}
{"code": " \\n  \\n  N = int(sys.stdin.readline())\\n  \\n  for T in range(1, N+1):\\n      first_ans = int(sys.stdin.readline())\\n      first_grid = []\\n      for i in range(4):\\n          row = [int(v) for v in sys.stdin.readline().split(' ')]\\n          first_grid.append(row)\\n      first_list = set(first_grid[first_ans-1])\\n      \\n      second_ans = int(sys.stdin.readline())\\n      second_grid = []\\n      for i in range(4):\\n          row = [int(v) for v in sys.stdin.readline().split(' ')]\\n          second_grid.append(row)\\n      second_list = set(second_grid[second_ans-1])\\n  \\n      intersection = first_list.intersection(second_list)\\n  \\n      if len(intersection) == 1:\\n          ans = intersection.pop()\\n      elif len(intersection) == 0:\\n          ans = 'Volunteer cheated!'\\n      else:\\n          ans = 'Bad magician!'\\n  \\n      print 'Case #%(T)s: %(ans)s' % locals()\\n", "substitutes": {"N": ["D", "NN", "O", "TN", "NA", "L", "A", "NG", "MN", "NS", "n", "NV", "NM", "Count", "R", "Ns", "Ni", "SIZE", "NP", "NE", "J", "SN", "V", "M", "Z", "NT", "NUM", "NR", "NO", "NB", "C", "K", "I", "P", "NC", "NH", "S", "Num", "NI"], "T": ["D", "O", " Y", "X", "L", "E", " X", "R", " M", " K", " TT", "F", "J", "V", " t", "M", " P", "Y", " V", "Ti", "C", "K", "I", "P", " S", "S"], "first_ans": ["first9ins", "first2ars", "quick9ls", "first_ls", "first2ls", "first0ars", "first2ans", "first9ars", "first0ins", "first_ann", "first9ans", "first_ars", "first_ANS", "quick9ins", " first_ann", " first_ANS", "quick_ans", "first0ls", "first_ens", "quick9ans", "quick_ars", "quick_ins", "first9ls", "quick9ars", "first2ins", " first_ens", "first_ins", "first0ans", "quick_ls"], "first_grid": ["first_multi", "firstxGrid", "first___grid", " first_Grid", "firstxlat", "first64grid", "first_gru", " first_wire", "first64row", "firstlygrid", "first_Grid", " first_gru", "first___row", "firstlygru", "first_wire", "firstlymulti", "firstlystack", " first_stack", "second_Grid", "second_group", "first_row", "first64Grid", "firstxgroup", "first64wire", "first___wire", "firstxgrid", "first_stack", "first_group", " first_row", "second_lat", " first_multi", "first___Grid", "first_lat"], "i": ["gi", "ic", "li", "it", "ia", "io", "ik", "iw", "iti", " ii", "ri", "ei", "il", "ti", "ini", "int", "si", "xi", "im", "ai", "ip", "x", "oi", "ii", "ij", "pi", "di", "I", "ir", "yi", "ci"], "row": ["range", "post", "form", "bo", "load", "ref", "hor", "block", "ro", "week", "record", "node", "group", "raw", "grow", "page", "field", "wheel", "tr", "user", "line", "set", "rot", "entry", "rect", "r", "sw", "link", "tab", "port", "Row", "server", "ow", "month", "batch", "wo", "pixel", "box", "ows", "roll", "bar", "arrow", "rows", "ry", "low", "way", "cell", "bug", " Row", "our", "pair"], "v": ["j", "p", "inv", "k", "qv", "li", "t", "cap", "m", "qu", "lv", "z", "n", "vert", "f", "ve", "ov", "dev", "va", "div", "w", "q", "vin", "y", "vc", "V", "vi", "env", "var", "ev", "value", "vv", "vid", "val", "vt", "tv", "x", "cv", "vs", "nv", "ver", "vp", "conv", "vd", "c", "uv", "vm", "iv", "sv"], "first_list": ["first_set", " first_set", "First_group", "first_net", " first_del", "first_del", "First_grid", " first_net", "First_list", "First_set", "first_group"], "second_ans": ["two_lines", "second__ns", "second_ats", "second__ans", "second__lines", "second_ants", "second__ants", "first_ANS", "first_ats", "second_ons", "two_ans", "second_lines", "two_ns", "two_ants", "second_ANS", "second_ns", "first_ons"], "second_grid": [" second_windows", "two_windows", "two_grid", "second___grid", " second_Grid", "second_row", "two_list", "two_row", "second_Grid", "two_lay", "second___Grid", "second_stock", "two_stock", "second_windows", " second_lat", "second_lat", "second_lay", "second___windows", "second___lat"], "second_list": [" second_set", "second_List", "second_log", " second_log", "secondParList", "second_group", "secondParlog", " second_group", " second_listed", "second_listed", " second_List", "second_set", "second_lists", "secondParlist", " second_lists", "secondParset"], "intersection": ["Intersector", "ersect", "erlap", "interconnect", "Intersection", " interval", "intersconnect", "INTERection", "Intersect", "INTERsector", "itersect", "Interval", "preconnect", "Interlap", " interdivision", "intersections", "interdivision", "INTERval", "interval", "Intersections", "interssection", "presection", "interssect", "INTERsect", "intersector", " intersections", "ersection", "Interconnect", "presections", "INTERdivision", "interection", "interssections", "Interdivision", "itersector", "ersector", "intersect", "iterlap", "Interection", "interlap", " intersect", "interssector", "itersection", "INTERsections", " intersector", "INTERsection", "presect"], "ans": ["ants", "ams", "ns", "ks", "utters", "iann", "aus", "beans", "ms", "ents", "leans", "ANS", "lan", "an", "ann", "asms", "eds", "uns", "ars", "nan", "ces", "na", "amps", "aos", "ras", "anes", "ins", "irms", "anas", "posts", "anks", "ens", "angs", "ean", "arts", "vals", "san", "wan", "ians", " means", "ons", "books", "helps", "said"]}}
{"code": " \\n  def solve(W, H, M):\\n    board = [['*' for x in xrange(H)] for x in xrange(W)]\\n    board[0][0] = 'c'\\n    \\n    S = [((H*W)-1, board, 0, 0, set())]\\n    H -= 1\\n    W -= 1\\n    while len(S) > 0:\\n      state = S.pop()\\n      mines = state[0]\\n      board = deepcopy(state[1])\\n      x = state[2]\\n      y = state[3]\\n      visited = deepcopy(state[4])\\n      visited.add((x, y))\\n      \\n      if mines == M:\\n        s = ''\\n        for row in board:\\n          s += ''.join(row)\\n          s += '\\n'\\n        return s\\n      \\n      elif mines > M:\\n        if x > 0 and board[x-1][y] == '*':\\n          board[x-1][y] = '.'\\n          mines -= 1\\n        \\n        if x < W and board[x+1][y] == '*':\\n          board[x+1][y] = '.'\\n          mines -= 1\\n        \\n        if y > 0 and board[x][y-1] == '*':\\n          board[x][y-1] = '.'\\n          mines -= 1\\n        \\n        if y < H and board[x][y+1] == '*':\\n          board[x][y+1] = '.'\\n          mines -= 1\\n        \\n        if x > 0 and y > 0 and board[x-1][y-1] == '*':\\n          board[x-1][y-1] = '.'\\n          mines -= 1\\n        \\n        if x > 0 and y < H and board[x-1][y+1] == '*':\\n          board[x-1][y+1] = '.'\\n          mines -= 1\\n        \\n        if x < W and y > 0 and board[x+1][y-1] == '*':\\n          board[x+1][y-1] = '.'\\n          mines -= 1\\n        \\n        if x < W and y < H and board[x+1][y+1] == '*':\\n          board[x+1][y+1] = '.'\\n          mines -= 1\\n        \\n        if x > 0 and not (x-1, y) in visited:\\n          S.append((mines, board, x-1, y, visited))\\n        \\n        if x < W and not (x+1, y) in visited:\\n          S.append((mines, board, x+1, y, visited))\\n        \\n        if y > 0 and not (x, y-1) in visited:\\n          S.append((mines, board, x, y-1, visited))\\n        \\n        if y < H and not (x, y+1) in visited:\\n          S.append((mines, board, x, y+1, visited))\\n        \\n        if x > 0 and y > 0 and not (x-1, y-1) in visited:\\n          S.append((mines, board, x-1, y-1, visited))\\n        \\n        if x > 0 and y < H and not (x-1, y+1) in visited:\\n          S.append((mines, board, x-1, y+1, visited))\\n        \\n        if x < W and y > 0 and not (x+1, y-1) in visited:\\n          S.append((mines, board, x+1, y-1, visited))\\n        \\n        if x < W and y < H and not (x+1, y+1) in visited:\\n          S.append((mines, board, x+1, y+1, visited))\\n    return 'Impossible'\\n  \\n  T = int(raw_input())\\n  for t in range(T):\\n    W, H, M = map(int, raw_input().split())\\n    print 'Case #%i:\\n%s' % (t+1, solve(W, H, M).strip())\\n", "substitutes": {"W": ["WH", "D", "G", "Win", "X", "MW", "WM", "L", "HT", "WA", "E", "A", "EW", "U", "OW", "Sw", "Q", "NW", "R", "TH", "WP", "B", "Wr", "Width", "Wil", "w", "WC", "F", "Sh", "V", "VW", "SW", "TW", "BW", "Z", "Y", "N", "WT", "WW", "FW", "C", "K", "Word", "I", "P", "WS", "DW", "Wh", "RW", "Weight", "We", "All", "WR", "CW"], "H": ["WH", "G", "His", "Win", "Haw", "X", "L", "HM", "HT", "HC", "A", "Q", "E", "h", "Eh", "Sw", "GH", "HS", "TH", "R", "SH", "HTML", "B", "Host", "He", "WR", "w", "Her", "F", "Where", "J", "Sh", "V", "HE", "Th", "HL", "Z", "HTTP", "Y", "Hi", "Here", "N", "HH", "C", "HK", "K", "I", "OH", "P", "wh", "MH", "HA", "Wh", "HD", "HB", "HI"], "M": ["D", "G", "O", "X", "MA", "WM", "m", "L", "TM", "E", "Q", "U", "CM", "A", "NM", "R", "MAN", "B", "MM", "F", "J", "V", "Z", "Y", "N", "C", "MI", "K", "I", "P", "MC"], "board": ["empty", "p", "menu", "win", "check", "base", "deck", "error", "window", "node", "fine", "null", "down", "w", "full", "user", "line", "set", "cache", "r", "hold", "sequence", "stream", "body", "clean", "position", "door", "box", "Board", "rain", "inner", "bo", "word", "block", "disk", "ox", "ro", "record", "cam", "control", "image", "chain", "loop", "lay", "rank", "left", "rot", "hub", "config", "player", "bank", "number", "back", "ows", "out", "device", "good", "square", "form", "radio", "video", "oard", "public", "layout", "zero", "style", "database", "lib", "wheel", "boat", "work", "poll", "join", "channel", "hole", "table", "flow", "card", "runner", "ward", "bar", "land", "controller", "test", "bin", "ard", "post", "bit", "well", "frame", "client", "panel", "planet", "system", "up", "book", "core", "cross", "builder", "b", "view", "pad", "buffer", "room", "chart", "boards", "ack", "boarding", "black", "bug", "lock", "message", "game", "list"], "x": ["p", "col", "e", "ctx", "at", "m", "h", "name", "item", "w", "q", "r", "xf", "el", "to", "xd", "a", "c", "ie", "lat", "step", "status", "ux", "xs", "xxx", "xxxx", "wx", "o", "xp", "ax", "ct", "ox", "key", "id", "xa", " xx", "image", "xt", "tx", "xi", "u", "left", "axis", "on", "yx", "lex", "ix", "xx", "v", "xml", "edit", "X", "column", "dx", "time", "z", "n", "g", "path", "f", "exp", "i", "inx", "point", "l", "content", "xe", "fixed", "data", "pos", "fx", "zx", "j", "one", "k", "bit", "act", "rx", "lon", "xc", "ace", "mx", "only", "index", "ip", "xy", "ex", "px"], "S": ["Si", "D", "O", "SI", "L", "A", "Set", "NS", "SB", "R", "B", "State", "SEC", "TS", "SQL", "Sl", "SL", "STATE", "BS", "V", "SW", "SA", "Sub", "Row", "VS", "N", "C", "SS", "SP", "seconds", "I", "P", "WS", "SE", "SU"], "state": ["se", "function", "p", "seed", "root", "tag", "type", "er", "count", "space", "start", "store", "area", "block", "zone", "resource", "key", "success", "n", "node", "event", "close", "spec", "State", "rule", "info", "section", "index", "loop", "user", "local", "set", "cache", "STATE", "monitor", "r", "config", "stats", "stat", "role", "unit", "player", "port", "dict", "job", "list", "runner", "queue", "test", "hash", "states", "step", "status", "pair"], "mines": ["MINuses", "menensions", "times", "minsers", "minsensions", "manovers", "minsces", "minses", "minsees", "memales", "raines", "smallES", "Minces", "monsales", "minsies", "memensions", "Minions", "coolions", "verses", "minsions", "mineions", "miners", "mintales", "timses", "minces", "minuses", "mintels", "manes", "minsales", "minsels", "memes", "timales", "MINies", "minions", "minises", "timions", "rainels", "versers", "monsions", "minties", "servces", "MINes", "minovers", "manees", "miniales", "rainovers", "mintses", "mintes", "Minedes", "minsES", "MinES", "mations", "memions", "mintuses", "minsesi", "coolales", "rainions", "versis", "smallses", "MINets", "memesi", "serves", "minES", "minis", "minsis", "MINions", "mineis", "cooles", "menions", "mates", "smallions", "minsuses", "Mines", "rainees", "minsedes", "servions", "monses", "minsets", "minies", "monsesi", "menales", "minensions", "minales", "menes", "Minses", "manions", "versions", "servedes", "minets", "matets", "minsovers", "matis", "rainies", "mineers", "minesi", "minels", "miniions", "minedes", "MINis", "smalles", "coolses", "minees", "minsses", "mintions"], "y": ["p", "er", "col", "at", "io", "m", "aily", "yy", "h", "hot", "top", "ny", "axy", "page", "uy", "isy", "w", "iley", "html", "ory", "to", "height", "zy", "ya", "by", "cell", "status", "yt", " Y", "o", "no", "ox", "key", "id", "any", "rot", "on", "sy", "ery", "kit", "ly", "ley", "sky", "ch", "yl", "out", "v", "ry", "hy", "ady", "gy", "cy", "time", "yr", "z", "n", "lib", "i", "my", "year", "l", "ay", "Y", "icy", "table", "ye", "file", "more", "dy", "wy", "sat", "size", "vy", "j", "fill", "k", "type", "iy", "iny", "client", "ies", "hey", "ym", "up", "ey", "index", "oy", "yn", "b", "scroll", "ip", "yes", "ty", "fy", "yer", "xy", "yd", "yi", "py"], "visited": ["viewITED", "VISited", "Visitted", "visit", "VisITED", "visiting", "Visiting", "visITED", "waitted", "waiting", "viewed", "VISitted", "viewited", "Vised", "Visit", "VISed", "Visited", "viewitted", "waited", "visitted", "vised", "viewiting", "VISit", "waITED", "viewit"], "s": ["ns", "p", "str", "ats", "e", "rs", "ps", "long", "m", "h", "ss", "strings", "n", "g", "f", "all", "ls", "eds", "sol", "ws", "w", "_", "i", "cs", "set", "r", "its", "b", "stat", "ins", "l", "bits", "bs", "abs", "tes", "ows", "sv", "als", "a", "ses", "c", "rows", "v", "ts", "short", "es", "states", "sb", "stats", "gs"], "row": ["word", "col", "rx", "error", "ox", "week", "ro", "record", "path", "node", "raw", "name", "item", "wheel", "index", "w", "star", "user", "line", "set", "rot", "sc", "entry", "rect", "r", "sw", "scroll", "Row", "server", "order", "box", "runner", "ows", "roll", "ward", "bar", "arrow", "rows", "cell", "pair"]}}
{"code": "T = int(raw_input())\\n  for i in range(T):\\n    index = int(raw_input())\\n    X = []\\n    for j in range(4):\\n      X.append(map(int, raw_input().split()))\\n    x1 = X[index-1]\\n    index = int(raw_input())\\n    X = []\\n    for j in range(4):\\n      X.append(map(int, raw_input().split()))\\n    x2 = X[index-1]\\n    ans = set(x1).intersection(set(x2))\\n    if len(ans) == 0:\\n      print 'Case #%i: Volunteer cheated!' % (i+1)\\n    elif len(ans) == 1:\\n      print 'Case #%i: %i' % (i+1, ans.pop())\\n    else:\\n      print 'Case #%i: Bad magician!' % (i+1)\\n", "substitutes": {"T": ["D", "G", "O", "TI", "TT", "TN", "t", "L", "TM", "E", "Q", "Tab", "R", "B", "TS", "TA", "F", "J", "V", "M", "Z", "Y", "NT", "N", "WT", "GT", "TB", "C", "K", "Total", "I", "P", "S"], "i": ["gi", "ic", "p", "li", "it", "ia", "m", "ik", "sim", "iti", "id", "g", "f", "phi", "ei", "chain", "info", "int", "ti", "ini", "bi", "si", "d", "xi", "im", "y", "multi", "mi", "init", "my", "b", "me", "ip", "x", "pi", "ii", "ij", "ix", "di", "I", "zi", "ie", "c", "v", "ind", "ci"], "index": ["level", "seed", "count", "update", "exit", "ctx", "long", "time", "no", "error", "success", "key", "id", "address", "n", "zero", "example", "can", "then", "see", "int", "condition", "loop", "set", "axis", "row", "Index", "point", "timeout", "x", "cycle", "number", "IND", "instance", "find", "loc", "list", "position", "thread", "connection", "connect", "slice", "iter", "date", "second", "ix", "new", "height", "ice", "pos", "context", "select", "ind", "status", "prime"], "X": ["Many", "G", "One", "Cross", "Right", "L", "Once", "Q", "A", "E", "Take", "XT", "Sax", "OX", "TH", "R", "ZX", "Exit", "MX", "Matrix", "You", "J", "V", "DX", "Index", "ANY", "Content", "XP", "XXX", "IX", "Z", "Tx", "XL", "XM", "Y", "XX", "x", "Array", "N", "UX", "EX", "FE", "C", "ML", "Rex", "List", "Xi", "TX", "I", "P", "Int", "S", "All"], "j": ["ji", "p", "jj", "k", "jl", "str", "ju", "li", "it", "jp", "jo", "z", "n", "g", "f", "ja", "uj", "q", "y", "J", "kj", "b", "dj", "l", "oj", "ij", "job", "jc", "ix", "ie", "iaz", "v", "ind"], "x1": ["tx01", "tx2", "lex1", "xxOne", "xx1", "tx1", "ixOne", "Xone", "xOne", "xxone", "xone", "X2", " xOne", "ix1", " xone", "x01", "X01", "ixone", "X1", "lexone", "lex01", "txone", "lex2"], "x2": ["xsTwo", "xs2", "uxtwo", "uxTwo", "exTwo", "xiTwo", "xi1", " x22", "ux2", "extwo", "ox2", "oxTwo", "xitwo", "ox22", " xTwo", "xTwo", "xtwo", "ex1", "xi2", "xs22", "ux1", "x22", "ex2"], "ans": ["ants", "ams", "ns", "olds", "ks", "xs", "os", "ones", "aps", "rs", "ms", "aus", "ings", "ents", "leans", "unders", "ANS", "ys", "us", "an", "ann", "asms", "ls", "aunts", "uns", "ars", "vers", "outs", "names", "cs", "amps", "ames", "aos", "ras", "there", "ins", "anes", "anas", "ads", "anks", "nos", "ros", "ens", "arts", "ates", "ians", "nets", "aned", "ums", "ses", "ases", "ons", "authors", "ats", "said"]}}
{"code": " \\n  def all_grids(R,C,M, lp=0,placed=0):\\n      rem = R*C-lp\\n      if M-placed >= rem:\\n          if M-placed > rem:\\n              return None\\n          \\n          res = set()\\n          for i in range(lp, R*C):\\n              res.add(i)\\n          return [res]\\n          \\n      if placed == M:\\n          return [set()]\\n  \\n      res = []\\n      for i in range(lp, R*C):\\n          sub_sol = all_grids(R,C,M,i+1, placed+1)\\n          if sub_sol is None:\\n              continue\\n              \\n          for s in sub_sol:\\n              s.add(i)\\n              res.append(s)\\n      return res\\n  \\n  def adj(R,C,i):\\n      \\n      res = []\\n      left_edge = i % C == 0\\n      top_edge = i // C == 0\\n      right_edge = (i+1) % C == 0\\n      bottom_edge = i // C == R-1\\n      \\n      if not left_edge:\\n          res.append(i-1)\\n          if not top_edge:\\n              res.append(i-1-C)\\n          if not bottom_edge:\\n              res.append(i+C-1)\\n              \\n      if not right_edge:\\n          res.append(i+1)\\n          if not top_edge:\\n              res.append(i+1-C)\\n          if not bottom_edge:\\n              res.append(i+1+C)\\n              \\n      if not bottom_edge:\\n          res.append(i+C)\\n      if not top_edge:\\n          res.append(i-C)\\n      return res\\n          \\n      \\n      \\n      \\n  def solution(R,C,g):\\n      M = R*C\\n      res = []\\n      num_zeroes = 0\\n      for i in range(M):\\n          if i in g:\\n              res.append('x')\\n              continue\\n          x = 0\\n          for a in adj(R,C,i):\\n              if a in g:\\n                  x += 1\\n          if x == 0:\\n              num_zeroes += 1\\n          res.append(x)\\n          \\n      for i in range(M):\\n          if i in g:\\n              continue\\n          r = res[i]\\n          if r == 0 and num_zeroes == 1:\\n              continue\\n          connected = False\\n          for a in adj(R,C,i):\\n              if res[a] == 0:\\n                  connected = True\\n                  break\\n          if not connected:\\n              return None\\n      \\n      return res.index(0)\\n  \\n  def transcribe(R,C, g, sol):\\n      res = []\\n      for i in range(R):\\n          r = []\\n          for j in range(C):\\n              x = i*C+j\\n              if x in g:\\n                  r.append('*')\\n              elif x == sol:\\n                  r.append('c')\\n              else:\\n                  r.append('.')\\n          res.append(r)\\n      return res\\n  \\n  def printed_sol(transcript):\\n      if transcript is None:\\n          return \"Impossible\"\\n      else:\\n          return \"\\n\".join(\"\".join(row) for row in transcript)\\n  \\n  def solve(R,C,M):\\n      if M == R*C-1:\\n          g = []\\n          for i in range(R*C-1):\\n              g.append(i)\\n          return transcribe(R,C, g, R*C-1)\\n      \\n      for g in all_grids(R,C,M):\\n          sol = solution(R,C,g)\\n          if sol is None:\\n              continue\\n          return transcribe(R,C, g, sol)\\n      return None\\n              \\n      \\n  def output_grid(R,C,g):\\n      for i in range(R):\\n          for j in range(C):\\n              if i*C+j not in g:\\n                  sys.stdout.write(\".\")\\n              else:\\n                  sys.stdout.write(\"*\")\\n          sys.stdout.write(\"\\n\")\\n  \\n  if __name__ == \"__main__\":\\n      T = int(raw_input())\\n      for i in range(1,T+1):\\n          R,C,M = map(int, raw_input().split())\\n          print \"Case #%d:\" % i\\n          print printed_sol(solve(R,C,M))\\n", "substitutes": {"R": ["Range", "D", "G", "Right", "JR", "X", "Rel", "Rank", "RA", "H", "L", "U", "CR", "A", "E", "Br", "DR", "Remote", "LR", "RG", "B", "SR", "Res", "RF", "Root", "AR", "Mr", "HR", "F", "V", "RO", "RS", "Rot", "Repl", "Red", "Cor", "N", "NR", "RE", "right", "RR", "Ring", "Rs", "I", "RM", "P", "RT", "Rat", "BR", "S", "MR", "Role", "RP"], "C": ["Co", "Ct", "D", "G", "O", "BC", "JC", "Ch", "CD", "COR", "Cow", "L", "H", "CR", "A", "E", "CM", "CN", "CBS", "Count", "Chain", "CS", "B", "Cons", "CAR", "TC", "CV", "CE", "Cl", "CC", "CI", "WC", "F", "CON", "Craig", "SC", "V", "CH", "EC", "Con", "Y", "Config", "CNN", "Cor", "N", "Cu", "CO", "Car", "CT", "CG", "VC", "Cache", "CF", "CP", "DC", "K", "I", "P", "YC", "CB", "W", "c", "CCC", "CL", "CU", "S", "Cs", "CW"], "M": ["D", "G", "O", "AM", "X", "MA", "H", "L", "m", "TM", " m", "E", "Q", "A", "CM", "MN", "REM", "NM", "Mon", "MAN", "B", "PM", "Mi", "Mat", "JM", "MM", "FM", "F", "Multi", "V", "Man", "Y", "LM", "N", "RE", "MT", "MI", "K", "MS", "I", "RM", "P", "W", "DM", "Size", "MC", "Rem", "S", "MR", "MP"], "lp": ["ap", "p", "Li", "ic", "li", "lip", "LI", "cp", "isi", "lik", "lic", "lr", "L", "m", "sp", "lis", "lc", "lv", "LR", "ls", "joined", "LP", "pc", "il", "dl", "pr", "si", "xi", "left", "mi", "pl", "lb", "ip", "lt", "PL", "l", "LG", "np", "nl", "LM", "pi", "pa", "gp", "pp", "ln", "BP", "mp", "fp", "rm", "GP", "mr", "pert", "ill", "ml", "illed", "bp", "list"], "placed": ["selected", "p", "matched", "mounted", "powered", "linked", "priced", "LI", "reg", "used", "paid", "L", "m", "Place", "listed", "played", "ed", "Pl", "pr", "registered", "left", "mi", "holder", "pl", "reported", "led", "found", "lb", "there", "occupied", "PL", "l", "inged", "oved", "aid", "marked", "filled", "Position", "changed", "loc", "position", "balanced", "represented", "place", "stated", "apped", "aced", "P", "added", "pos", "illed", "pressed", "places", "said"], "rem": ["p", "em", "ref", "re", "ms", "reg", "ps", "cm", "lr", "m", "sp", "remove", " Rem", "xp", "mm", "pers", "lim", "fine", "REM", "n", "pm", "rest", "remote", "ret", "pres", "mn", "pr", "gm", "registered", "l", "rep", "hr", "rel", "RE", "loc", "resp", "rm", "mr", "mem", "recent", "pos", "Rem", "rom"], "res": ["rev", "re", "m", "times", "reset", "results", "none", "req", "blocks", "ret", "nil", "pres", "pr", "full", "set", "ins", " Res", "bits", "rates", "terms", "mem", "ons", "css", "details", "eps", "helps", "des", "xs", "reg", "ids", "ress", "pers", "rek", "Res", "ers", "fields", "rep", "bs", "groups", "rel", "resolution", "points", "back", "vals", "gr", "out", "resp", "js", "mr", "conv", "alg", "als", "we", "es", "S", "rex", "arr", "level", "values", "ns", "os", "err", "ms", "powers", "gas", "cond", "rest", "exp", "rez", "els", "RES", "conn", "grid", "ras", "expr", "pas", "l", "fresh", "ris", "vec", "resources", "right", "gs", "range", "next", "finals", "rs", "ps", "rx", "us", "all", "ri", "ws", "result", "only", "cs", "ires", "resh", "yes", "val", "usr", "obj", "abs", "Rs", "rm", "cons", "frames", "fs", "ts", "list"], "i": ["asi", "ki", "hi", "p", "li", "e", "t", "m", "iti", "pc", "ai", "pi", "ii", "ati", "zi", "c", "ie", "ir", "ci", "gi", "ji", "o", "ik", "id", "ini", "bi", "xi", "pl", "adi", "ij", "iu", "ix", "di", "v", "it", "z", "n", "rest", "ui", "info", "il", "ti", "y", "l", "oi", "bp", "ic", "iy", "ia", "aii", "iri", "ri", "phi", "ei", "int", "ims", "index", "si", "im", "mi", "multi", "cli", "b", "ip", "ori", "I", "fi", "yi", "ind"], "sub_sol": ["Sub_sg", "submatres", "Sub_res", "subsubsol", "sub_sim", "sub_site", "sub_Sol", "sub2sol", "Sub_sim", "subsubsite", "subsubsel", "submatSol", "submatsg", "Sub_s", "sub_res", "subsubSol", "sub2sim", "sub2Sol", "sub2s", "Sub_sol", "Sub_site", "sub_sel", "sub_sg", "submatsol", "Sub_sel", "sub_s", "Sub_Sol"], "s": ["ns", "p", "sa", "xs", "os", "ats", "single", "e", "rs", "ps", "ms", "sp", "m", "ss", "us", "f", "ls", "exp", "ds", "sing", "ws", "ims", "si", "set", "its", "stat", "ins", "l", "sym", "bs", "sm", "iss", "js", "sq", "ts", "es", "S", "sg", "sb", "stats", "gs"], "left_edge": [" left_ink", " left_device", "leftingline", "leftinggate", "left_ink", "leftingedge", "top_gate", "left_line", "left_device", "left_gate", "top_line"], "top_edge": ["toppyee", "bottom_hop", "top67edge", "middle_relation", "top_node", "top2edge", "top2link", "left_link", "top_link", "middle_field", "top2Edge", "toplyrelation", "toppyhop", "middle67edge", "toppyedge", "middle67field", "toplyedge", "top_Edge", "top_ee", "toplyfield", "top67relation", "bottom_node", "top_hop", "top2node", "bottom_Edge", "top_relation", "bottom_ee", "middle67relation", "left_node", "top67field", "toppynode", "top_field", "middle_edge"], "right_edge": ["right_ee", "right_device", "rightlyedge", "top_node", "right_link", "top_link", "rightlydevice", "rightlyee", "rightlynode", "left_node", "left_device", "left_ee", "right_node"], "bottom_edge": [" bottom_node", "floor_route", "bottom_route", "bottom___relation", "floor_edge", "bottom2link", "bottom_relation", "bottom5edge", "bottom2Edge", "floor___route", " bottom_ee", "top_Edge", "bottom_ee", "bottom5node", "bottom5route", "top_node", "floor_relation", "bottom_node", "bottom_Edge", "bottom___edge", "bottom_link", "bottomTheroute", "bottom2edge", "bottomTheedge", "bottomTheevidence", "floor___relation", "bottomTherelation", "bottom___route", "top_route", "floor___edge", "top_link", "floor___evidence", "bottom_evidence", "bottom___evidence", "floor_evidence"], "g": ["gi", "G", "p", "ic", "gn", "og", "e", "go", "reg", "o", "m", "mg", "h", "rg", "z", "n", "eg", "group", "gg", "ag", "leg", "w", "d", "bg", "gm", "u", "gd", "y", "b", "ga", "l", "gu", "gp", "gate", "gre", "gh", "gen", "msg", "gr", "ig", "ge", "c", "ged", "v", "gc", "gt", "ger", " G", "gray", "cfg", "erg", "gs"], "num_zeroes": ["num_zenoes", "num_zmes", "num_zerones", "num_erosodes", "num_erosoes", "num_zeroones", "num_zenones", "num_erones", "num_erodes", "num_zerooes", "num_eroes", "num_zerooms", "num_erosoms", "num_zeros", "num_zeroos", "num_zenmes", "num_ermes", "num_zeroms", "num_erosos", "num_zermes", "num_zenos", "num_zoes", "num_zerodes", "num_eros", "num_zones", "num_zos", "num_eroms", "num_zodes", "num_zeroodes"], "x": ["p", "xs", "re", "e", "xxx", "X", "rx", "xes", "t", "wx", "dx", "xp", "m", "xxxxxxxx", "ax", "ox", "z", "n", "xc", "xa", "xt", "tx", "mx", "w", "xi", "u", "y", "inx", "xf", "yx", "xe", "ix", "xy", "ex", "px", "c", "xx", "v", "xml", "fx"], "a": ["au", "ap", "sa", "p", "ra", "er", "li", "e", "err", "at", "ia", "t", "o", "m", "A", "sta", "za", "aq", "an", "z", "n", "ed", "xa", "ba", "ri", "ar", "aa", "va", "ao", "wa", "aaa", "action", "na", "u", "y", "ana", "ai", "ka", "b", "ac", "ga", "adi", "ae", "apa", "pa", "ij", "ea", "ma", "ha", "di", "ca", "ta", "c", "ie", "ach", "ab", "fa", "ua"], "r": ["rage", "p", "er", "re", "e", "adr", "rs", "rx", "t", "o", "m", "h", "nr", "z", "n", "ed", "rb", "f", "ar", "w", "d", "u", "b", "l", "rr", "rar", "sr", "mr", "c", "v", "ry", "rd", "rt"], "connected": ["open", "powered", "functional", "linked", "modified", "induced", "graph", "cond", " bonded", "z", "n", "con", "ed", "chron", "shown", "close", "closed", "encrypted", "active", "rolled", "condition", "index", "conn", "loaded", "state", "wired", "created", "visible", "charged", "ended", "colored", "filled", "established", " disconnected", "essential", "directed", "connection", "connect", "balanced", "broken", "normal", "opened", "scribed", "out", "c", "valid", "num"], "sol": ["sa", "str", "Sol", "err", "ps", "sp", "mol", "vol", "mg", "ls", "rl", "jac", "gm", "xi", "ol", "rol", "val", "rel", "ln", "gp", "msg", "gr", "mr", "sg", "pos", "sat", "sel", "gs"]}}
{"code": "def solve(c1, g1, c2, g2):\\n      row_1 = g1[c1-1]\\n      row_2 = g2[c2-1]\\n      inter = set(row_1) & set(row_2)\\n      if len(inter) == 0:\\n          return \"Volunteer cheated!\"\\n      if len(inter) > 1:\\n          return \"Bad magician!\"\\n      return str(inter.pop())\\n  \\n  if __name__ == \"__main__\":\\n      T = int(raw_input())\\n      for i in range(1,T+1):\\n          c1 = int(raw_input())\\n          g1 = []\\n          for j in range(4):\\n              g1.append(map(int, raw_input().split()))\\n          c2 = int(raw_input())\\n          g2 = []\\n          for j in range(4):\\n              g2.append(map(int, raw_input().split()))\\n          print \"Case #%d: %s\" % (i, solve(c1,g1,c2,g2)) \\n          \\n      \\n", "substitutes": {"c1": ["cach", "g91", "c0", " c001", "gach", "c91", "rcOne", "gOne", "ct2", "cuOne", "lc001", "rc91", "cat1", "cat9", "g9", "chain1", "c9", "c001", "chain91", "gary", "lc1", "chainary", "cu1", "cu91", "cu0", "g001", "ct0", "ct1", "cat91", "cary", "C1", "C0", "rc1", "chain9", "lcach", "rc0", "lc2", "g0", "cOne", "C2", " cach", "catary"], "g1": ["ggA", "gc1", "g11", "ggOne", " g0", " g01", "c10", "g91", "c0", "c11", "G10", "c91", "gg91", "rg8", "g10", "deg81", "gOne", "rg1", "rg001", "gcOne", "ggone", "c81", "gg1", "deg01", "gA", " gone", "g01", "deg11", " gOne", "g8", "G1", "G0", "deg1", "c001", " g001", "gg0", "c8", "g001", "gcA", "gcone", "c01", " g81", "gone", " g11", " gA", "g0", " g8", "G91", "gg2", "g81", " g10", "G2"], "c2": ["uc02", "cp02", "ec02", "vc2", "g52", "g02", "ec52", "ec1", "ctwo", "vc1", "g4", "gTwo", "uc1", "g42", "cp2", "com2", "comTwo", "c02", "mctwo", "vc52", "com02", "cTwo", " c02", "uc52", "cp42", "gtwo", "uc2", "ec2", "com4", "c42", "c4", "mc2", "cpTwo", "com42", "comtwo", "mc4", "vc02", " c52", "c52"], "g2": ["G20", "G4", " g20", " g3", "g22", "g02", "gg02", "ctwo", "g4", "v22", "c3", " g02", "g5", "c02", " gtwo", "G3", " g182", "G1", " g4", " gly", "eg5", "egtwo", "vtwo", " g5", "g3", "gtwo", "g20", "c182", "c4", "g182", "eg2", "gg5", "v2", "c22", "ggtwo", "cly", "eg02", "gly", "Gly", "v182", "gg2", "G02", " g22", "c20", "G2"], "row_1": ["set21", "set_1", "row23", "row_0", "row_11", "row21", "row_3", "set_0", " row_01", "row_01", "set23", "set20", " row_11", "row20", "set_3"], "row_2": ["row_102", "Row_2", "row__2", "row__102", "Row_3", "row_02", "Row_4", "row_3", "row_4", " row_02", "row__1", " row_102", "row__02", "Row_1"], "inter": ["trans", "INTER", "er", "dial", "quad", "ser", "sub", "pre", "intern", " Inter", "lo", "ar", "nil", "arel", "int", "char", "ner", "tr", "si", "interface", "ai", "rect", "ary", "ip", "cont", "Inter", "el", "over", "rel", "tri", "internal", "sur", "inst", "tif", "air", "arp", "ter", "iter", "ver", "conv", "may", "ex", "pointer", "inters", "war", "ir", "pair", "test", "inner", "iso", "prime"], "T": ["D", "G", "TI", "TP", "TT", "TN", "t", "H", "TM", "TY", "L", "Q", "TV", "R", "TH", "B", "TC", "Tu", "TS", "TA", "F", "J", "V", "M", "N", "TR", "TB", "C", "K", "Total", "I", "P", "W", "VT", "S"], "i": ["gi", "p", "ic", "k", "li", "e", "t", "m", "ik", "key", "id", "n", "g", "s", "f", "phi", "ti", "bi", "d", "si", "q", "im", "y", "xi", "mi", "r", "ai", "b", "ip", "l", "x", "pi", "ii", "ij", "oi", "ix", "di", "I", "c", "v", "ind", "ci"], "j": ["ji", "br", "p", "jj", "k", "ju", "str", "fr", "it", "jp", "t", "jo", "z", "n", "g", "f", "ja", "uj", "q", "y", "b", "dj", "l", "oj", "x", "ij", "ot", "jc", "ch", "iaz", "v", "je", "bj"]}}
{"code": " \\n  \\n  tCase = int(sys.stdin.readline())\\n  \\n  \\n  def map(R, C, Bombs):\\n  \tm = [[\".\" for x in xrange(C)] for x in xrange(R)]\\n  \tprint Bombs\\n  \tm[R-1][C-1] = 'c'\\n  \tlastSkip = False\\n  \tfor i in xrange(R):\\n  \t\tfor j in xrange(C):\\n  \t\t\tif Bombs == 0:\\n  \t\t\t\tbreak\\n  \t\t\t\\n  \t\t\tif lastSkip:\\n  \t\t\t\tm[i][j] = 'f'\\n  \t\t\t\tcontinue\\n  \t\t\t\\n  \t\t\tif R - i == 2 or C - j == 2:\\n  \t\t\t\tif Bombs == 1:\\n  \t\t\t\t\tm[i][j] = 'f'\\n  \t\t\t\t\tlastSkip = True\\n  \t\t\t\t\tcontinue\\n  \t\t\t\\n  \t\t\t\t\\n  \t\t\tm[i][j] = '*'\\n  \t\t\tBombs -= 1\\n  \t\t\tlastSkip = False\\n  \t\tlastSkip = False\\n  \t\t\t\t\\n  \t\\n  \t\\n  \tfor line in m:\\n  \t\tfor c in line:\\n  \t\t\tprint c,\\n  \t\tprint\\n  \t\t\\n  \t\t\\n  def imprimir(m):\\n  \tfor line in m:\\n  \t\tfor c in line:\\n  \t\t\tprint c,\\n  \t\tprint\\n  \t\t\\n  def map2(R, C, Bombs):\\n  \tm = [[\".\" for x in xrange(C)] for x in xrange(R)]\\n  \tm[R-1][C-1] = 'c'\\n  \tlastSkip = False\\n  \t\\n  \tii = 0\\n  \tjj = 0\\n  \twhile Bombs > 0:\\n  \t\tfor j in xrange(jj, C):\\n  \t\t\tif Bombs >= (C - j) or Bombs <= (C - j - 2) and Bombs > 0:\\n  \t\t\t\tm[ii][j] = '*'\\n  \t\t\t\tBombs -= 1\\n  \t\t\telse:\\n  \t\t\t\tcontinue\\n  \t\t\\n  \t\t\\n  \t\tfor i in xrange(ii+1, R):\\n  \t\t\tif Bombs >= (R - i) or Bombs <= (R - i - 2) and Bombs > 0:\\n  \t\t\t\tm[i][jj] = '*'\\n  \t\t\t\tBombs -= 1\\n  \t\t\telse:\\n  \t\t\t\tif Bombs > 0:\\n  \t\t\t\t\tprint \"Impossible\"\\n  \t\t\t\t\treturn\\n  \t\t\t\tcontinue\\n  \t\tjj += 1\\n  \t\tii += 1\\n  \timprimir(m)\\n  \t\\n  \t\t\t\t\\n  \t\\n  \t\\n  \\n  \t\t\\n  def main(R, C, M):\\n  \tvazios = R * C - M\\n  \\n  \tif R == 1 or C == 1 or vazios == 1 or vazios >= 4:\\n  \t\tmap2(R, C, M)\\n  \telse:\\n  \t\tprint \"Impossible\"\\n  \\n  \treturn \"\"\\n  \t\t\\n   \\n  if __name__ == '__main__':\\n  \tfor i in xrange(tCase):\t\\n  \t\t\\n  \t\tR, C, M = [int(x) for x in sys.stdin.readline().split(' ')]\\n  \t\tprint \"Case #%d:\" % (i + 1)\\n  \t\tmain(R, C, M)\\n", "substitutes": {"tCase": ["Tcase", " tNow", "TCase", "dNow", "TNow", "dcase", "gcase", "gTest", " tcase", " tCons", "gCase", "tCons", "TCons", "TTest", "dTest", "tNow", "gCons", " tTest", "tcase", "dCase", "tTest"], "R": ["Range", "D", "G", "O", "Right", "Ren", "X", "JR", "RA", "H", "U", "CR", "A", "MR", "Q", "Reg", "DR", "Br", "RC", "Remote", "B", "RG", "RF", "Res", "RP", "RL", "RH", "AR", "Mr", "RGB", "HR", "Reader", "r", "J", " r", "F", "Rec", "V", "RO", "RS", "Rot", "RB", "Row", "Y", "Red", "N", "NR", "RE", "GR", "RR", "Ref", "Rs", "ER", "I", "RM", "P", "RT", "RI", "W", "Rat", "RW", "T", "S", "BR", "IR", "SR", "Re", "Role", "Dr"], "C": ["D", "CD", "BC", "A", "Count", "Cl", "IC", "CC", "F", "J", "VC", "CF", "K", "Charlie", "CW", "Co", "G", "Ch", "Rh", "HC", "CM", "CN", "AC", "Chain", "CS", "B", "Cons", "CE", "CI", "Custom", "WC", "CON", "EC", "Config", "CT", "CG", "CP", "YC", "CU", "S", "Cache", "JC", "COR", "X", "Cow", "L", "CA", "TC", "Y", "CNN", "Cu", "DC", "P", "Mc", "Cs", "H", "CR", "E", "Cr", "CBS", "Craig", "SC", "V", "Con", "N", "I", "CB", "W", "CCC", "CL", "T"], "Bombs": ["Bomes", "Blockrones", "bombs", "BWatos", " Baos", "Bguns", "Bashes", "Blaxies", "Rotos", "Tombs", "Berombs", "Tombies", "Gombies", " Bguns", " BCBS", "Berombies", "VBombies", "CBaos", " Baxies", "Dombs", "Blockobs", "Bomb", "Brones", "Bbusters", "Debogs", "Blockicals", " Bobs", " Bounces", "BWombies", "Robaos", " Bitis", "bumps", "NBumps", "VBombs", "bitis", "bomb", "Bootounces", "Gumps", "CBguns", "Bicals", "Gombs", " Bumps", "Batos", "VBomes", "Debogens", "BWombs", "Debombies", "Abombies", " Bomes", "Rbusters", "Bombies", "IBumps", "bombies", "Tashes", "IBomb", "Tbusters", "Vashes", "Gomb", "Abashes", "Abombs", "Butashes", "Blusters", "Bootombies", "IBaos", "CBombies", "NBombies", "bogens", "Blounces", "BRatos", "Gotos", "Busters", " Busters", "Bumps", "NBguns", "Blockombs", "Tatos", "Blockusters", "Bitis", "Debrones", "IBombs", "Baxies", "NBobs", "Vbusters", "BCBS", "Blumps", "Butounces", " Batos", "Abounces", "Butombies", "Blombies", "Dbusters", "VBatos", "Titis", "Bogens", " Bogens", "BRombies", "Baos", "Bootaxies", "Debbusters", " Brones", " Bashes", "NBomb", "Tumps", "Blockbusters", "Botos", " Bogs", "BRombs", "Blogens", "Bobs", "Vombs", " Bombies", "Rombs", "NBombs", "Debombs", "Vumps", "Tomes", "Gounces", "Gaos", " Bbusters", "Berotos", "Dombies", "Bogs", "Blombs", "Butombs", "BRCBS", "NBicals", "Dotos", "Robombs", "Bootombs", "BWCBS", "bogs", " Botos", "Gbusters", "CBombs", "Debusters", "Robguns", "Robombies", "Bounces", "Berounces", "Blockguns", "Rombies", " Bomb", " Bicals"], "m": ["app", "p", "e", "t", "mac", "h", "w", "d", "ze", "wm", "r", "fm", "mk", "body", "mark", "mp", "mem", "a", "em", "dm", "o", "s", "params", "perm", "mc", "mit", "nm", "come", "mr", "v", "tm", "ms", "mm", "n", "g", "asm", "f", "esm", "am", "um", "mn", "y", "man", "mode", "mt", "l", "sm", "map", "mail", "vm", "memory", "arm", "cm", "hm", "mat", "pm", "bm", "mx", "gm", "im", "mi", "multi", "db", "b", "me", "mut", "ma", "md", "rm", "km", "mos", "ml", "mod"], "x": ["ux", "p", "fill", "k", "check", "xs", "e", "ctx", "X", "rx", "xes", "t", "wx", "at", "dx", "time", "ax", "ct", "ox", "key", "fix", "z", "n", "xc", "id", "xa", "f", "tx", "xt", "int", "mx", "w", "ction", "full", "pr", "change", "xi", "index", "y", "r", "xf", "inx", "byte", "on", "\u00e7", "cl", "yx", "co", "mix", "xe", "lex", "ont", "ix", "rox", "xy", "get", "a", "ex", "v", "xml", "plex", "xx", "lat", "fx", "ci", "php"], "lastSkip": ["LastMiss", "firstScan", "nextPass", "basePass", " lastCopy", "firstSkip", " lastMiss", "firstCopy", "baseCopy", "baseKill", "scopeCopy", "firstPass", " lastKill", "baseSkip", "lastKill", "LastCopy", " lastStep", "lastCopy", "nextKill", "LastScan", "nextSkip", " lastScan", "LastPass", "lastStep", "lastMiss", "LastSkip", "scopeMiss", "firstKill", " lastPass", "scopeStep", "nextCopy", "lastScan", "LastStep", "LastKill", "lastPass", "scopeSkip"], "i": ["gi", "ji", "ki", "ic", "p", "hi", "ib", "ami", "li", "e", "it", "ia", "o", "io", "ik", "h", "iti", "z", "id", "iri", "f", "ri", "ish", "ei", "info", "int", "ti", "ini", "bi", "d", "index", "si", "item", "xi", "im", "y", "mi", "q", "r", "ai", "u", "b", "ori", "ip", "l", "pi", "ij", "iu", "ix", "II", "di", "zi", "I", "ie", "v", "fi", "ir", "iv", "ind", "ci"], "j": ["ji", "p", "k", "jl", "fr", "rev", "li", "col", "er", "it", "ju", "jp", "t", "o", "h", "key", "z", "n", "g", "f", "ja", "jac", "item", "bi", "index", "pr", "uj", "q", "y", "json", "r", "J", "ai", "kj", "b", "dj", "l", "oj", "ij", "job", "jc", "obj", "ix", "di", "zi", "js", "jump", "ion", "ie", "v", "je", "jas", "aj", "bj", "ci"], "line": ["range", "se", "Line", "ile", "fill", "ide", "check", "open", "load", "frame", "li", "go", "ite", "note", "lin", "store", "no", "eline", "block", "online", "code", "lo", "do", "lined", "let", "chain", "rule", "see", "page", "use", "ner", "only", "ze", "change", "verse", "loop", "ine", "set", "live", "main", "write", "link", "mode", "ste", "point", "l", "cl", "co", "call", "cycle", "draw", "stream", "to", "skip", "liner", "ward", "inline", "icate", "file", "ase", "lining", "ge", "now", "lines", "parse", "side", "lock", "ode", "list"], "c": ["dc", "p", "ic", "er", "e", "it", "cm", "o", "lc", "ct", "bc", "h", "z", "n", "xc", "con", "g", "f", "nc", "ar", "chain", "cation", "pc", "can", "cat", "cu", "cod", "w", "d", "u", "cs", "cache", "y", "r", "ac", "\u00e7", "cont", "cl", "unc", "l", "cr", "co", "cc", "mc", "call", "orc", "out", "fc", "a", "gc", "v", "icc", "ci"], "ii": ["ji", "ki", "hi", "tti", "jl", "iann", "ami", "li", "obi", "iy", "ia", "ih", "iw", "nr", "iri", "ios", "ui", "ja", "ei", "qi", "aa", "ti", "ini", "bi", "aaa", "si", "uj", "xi", " iii", "ai", "iii", "iona", "pi", "ij", "iu", "ni", "II", "ix", "di", "I", "zi", "hai", "IJ", "ie", "ir", "yi", "ci"], "jj": ["ji", "JC", "jl", "ju", "fr", "JR", "xxx", "it", "jp", "ia", "ijk", "Ja", "obs", "nr", "yy", "bb", "aq", "ordan", "jad", "isa", "ja", "JJ", "jac", "aa", "cu", "CC", "uj", "json", " iii", "r", "J", "kj", "b", "iii", "dj", "iona", "Jr", "jit", "john", "jack", "cc", "ij", "iu", "jc", "gh", "II", "nn", "I", "jump", "jas", "IJ", "Ju", "jobs", "aj", "bj", "jah", "ci"], "M": ["D", "G", "O", "X", "H", "L", "U", "E", "Q", "A", "CM", "NM", "Mon", "MAN", "B", "PM", "MM", "F", "J", "Multi", "V", "Z", "Y", "N", "Ms", "MT", "MI", "K", "I", "RM", "P", "W", "MC", "T", "MS", "S", "AM"], "vazios": ["vAZios", "vagios", "lazio", "vozio", "tvAZios", "mizians", "tvAZians", "lozians", "miziers", "vuzians", "lozio", "vagillas", "maziers", "vziers", "vAZials", "mizios", "mizies", "vagians", "mazios", "vozies", "vzians", "loziers", "lozios", "tvazials", "vazio", "vizies", "tvAZillas", "tvAZials", "vizians", "tvazillas", "vAZillas", "vizios", "vazies", "vazillas", "vuzials", "vzios", "vaziers", "lazios", "vazials", "vzio", "lazians", "laziers", "voziers", "vuzios", "tvazians", "vuzio", "mazies", "viziers", "vuzillas", "vzies", "vagials", "vAZians", "vozios", "vozians", "mazians", "vazians", "tvazios", "vuziers"]}}
{"code": " \\n  \\n  \\n  class Test(unittest.TestCase):\\n  \tdef test_1(self):\\n  \t\tself.assertEqual(main(5, 2, 2, [2,1]), 12)\\n  \tdef test_2(self):\\n  \t\tself.assertEqual(main(5,2,2,[1,2]), 12)\\n  \tdef test_3(self):\\n  \t\tself.assertEqual(main(3,3,4,[4,1,3,5]), 39)\\n  \tdef test_4(self):\\n  \t\tself.assertEqual(main(5,2,4,[5, 1, 1, 5]), 51)\\n  \\n  \\n  tCase = int(sys.stdin.readline())\\n  \\n  def main(A, B, AList, BList):\\n  \tresp = 0\\n  \tA = A - 1\\n  \tB = B - 1\\n  \tAlist = AList[A*4:A*4+4]\\n  \tBList = BList[B*4:B*4+4]\\n  \tcont = 0\\n  \tfor aa in Alist:\\n  \t\tif aa in BList:\\n  \t\t\tresp = aa\\n  \t\t\tcont += 1\\n  \t\t\\n  \tif cont == 1:\\n  \t\treturn resp\\n  \telif cont == 0:\\n  \t\treturn \"Volunteer cheated!\"\\n  \telse:\\n  \t\treturn \"Bad magician!\"\\n  \t\t\\n   \\n  if __name__ == '__main__':\\n  \tfor i in xrange(tCase):\t\\n  \t\t\\n  \t\tA = [int(x) for x in sys.stdin.readline().split(' ')][0]\\n  \t\tNList = [int(x) for x in sys.stdin.readline().split(' ')]\\n  \t\tNList += [int(x) for x in sys.stdin.readline().split(' ')]\\n  \t\tNList += [int(x) for x in sys.stdin.readline().split(' ')]\\n  \t\tNList += [int(x) for x in sys.stdin.readline().split(' ')]\\n  \t\tB = [int(x) for x in sys.stdin.readline().split(' ')][0]\\n  \t\tBList = [int(x) for x in sys.stdin.readline().split(' ')]\\n  \t\tBList += [int(x) for x in sys.stdin.readline().split(' ')]\\n  \t\tBList += [int(x) for x in sys.stdin.readline().split(' ')]\\n  \t\tBList += [int(x) for x in sys.stdin.readline().split(' ')]\\n  \t\tprint \"Case #%d: %s\" % (i + 1, main(A, B, NList, BList))\\n", "substitutes": {"self": ["python", "se", "args", "func", "rem", "tk", "ref", "this", "private", "rec", "compl", "util", "your", "public", "h", "cmp", "n", "s", "ren", "github", "parent", "raw", "sis", "subject", "bind", "w", "full", "q", "local", "user", "eth", "nd", "my", "sw", "me", "cl", "rel", "don", "mix", "nt", "you", "py", "obj", "make", "new", "mp", "md", "print", "th", "debug", "weak", "also", "xml", "details", "test", "small", "Self"], "tCase": ["wtCase", "wtcase", "Tcase", "testcase", "testTest", "TCase", "testCase", " tOrder", " tRest", "TOrder", "TClass", " tcase", "TTest", "tOrder", "tClass", "TRest", " tTest", "tRest", "tcase", "wtClass", "testOrder", " tClass", "wtRest", "tTest"], "A": ["G", "AM", "Al", "BA", "NA", "MA", "AA", "H", "L", "AI", "U", "ATA", "E", "As", "AC", "Am", "AST", "R", "An", "Ar", "AU", "Ac", "CA", "Ag", "AT", "AR", "TA", "Af", "Art", "V", "PA", "SA", "M", "AB", "AF", "GA", "ACC", "At", "N", "Array", "AY", "AN", "LA", "C", "AS", "Av", "I", "JA", "P", "AV", "a", "EA", "AE", "Ax", "Ass", "AL", "HA", "T", "S", "Alpha", "IA", "AP"], "B": ["D", "G", "BC", "VB", "BI", "BA", "Two", "IB", "H", "L", "FB", "SB", "WB", "BM", "Bs", "Bar", "OB", "R", "LB", "Be", "JB", "BU", "BB", "Blue", "BY", "J", "BS", "b", "V", "M", "Builder", "RB", "AB", "Y", "BG", "N", "NB", "TB", "C", "EB", "BT", "CB", "Big", "BE", "BO", "T", "DB", "BR", "Other", "S", "Bern", "GO", "Bi"], "AList": ["ALelist", "ARist", "IALIST", "ELLIST", "ELLelist", "ARisting", "ILet", "SANist", "ARIST", " ALIST", "IAListing", "SANIST", "ELList", "IAList", "IALet", "SANelist", "ARelist", "ILIST", " AListing", "IList", "AListing", "ALet", "SANisting", " ALet", "ELListing", "ALIST", "IListing"], "BList": ["LFilter", "STable", "GList", "OTable", "BChan", "NBChan", " BLIST", "BObj", "SLIST", " BCopy", "LObj", "LLIST", "OList", " BTable", "BSt", "Tlist", "LTable", "IL", "VList", "GSet", "NBists", "Glist", "LChan", " BChan", "Bists", "SList", "VType", "BFilter", "OType", "LSet", "BRL", "BType", "BRCopy", " BFilter", "TList", " BObj", "NBList", " BSet", "BCopy", "ILIST", " Blist", "BLIST", "IList", "NBSet", "BBlist", "SObj", "BRList", " BL", "TFilter", "NBSt", "Llist", " Bists", " BType", "Vlist", " BSt", "BBList", "BTable", "ICopy", "BBSet", "BL", "Blist", "NBlist", "TSet", "VTable", "LList", "BRLIST", "LSt", "Olist", "BSet", "BBists"], "resp": ["res", "tmp", "next", "ref", "soc", "rev", "err", "respond", "reg", "rec", "rend", "snap", "compl", "txt", "cond", "cmp", "repl", "none", "success", "asm", "req", "acc", "rest", "cong", "null", "ret", "Res", "comm", "index", "comp", "RES", "conn", "unknown", "respons", "esp", "tab", "red", "Resp", "rep", "rel", "adj", "andre", "obj", "new", "Response", "eff", "conv", "mem", "pos", "response", "good"], "Alist": ["AlList", " Allist", " Aliste", "alist", "Allist", "AListe", "AListed", " Alis", "ALlist", "Aliste", "PlList", "Pliste", "ALis", "ALList", "Plist", "Alisted", "Alis", "alList", "allist", "alisted", " AlList", " Alisted", "Plis"], "cont": ["rc", "circ", "act", "count", "col", "chlor", "cm", "crit", "compl", "cur", "txt", "cond", "cart", "cmp", "ct", "success", "CONT", "code", "nc", "acc", "con", "control", "cong", "int", "cod", "comp", "const", "cert", "ctr", "cor", "content", "contin", "cr", "co", "critical", "cc", "nt", " Cont", "ont", "compliance", "contact", "mult", "mom", "cons", "Cont", "ce", "c", "ind", "ci", "list"], "aa": ["au", "app", "Na", "alpha", "atha", "act", "ref", "err", "account", "AA", "area", "qa", "aii", " ba", "aq", "\u00e4", "acc", "AC", "xa", " va", "ba", "f", "ja", "va", "aaa", "arr", "action", "change", "na", "eeee", "ana", "ai", "aff", "b", "ac", "iona", "da", "aka", "aaaa", "ae", "Va", "apa", "pa", "Ta", "aha", "ea", "ma", "agree", "ya", "ca", "a", "data", "xx", "ave", " fa", "fa", "aye"], "i": ["gi", "j", "li", "e", "id", "ri", "ei", "il", "ti", "ini", "xi", "y", "init", " ti", "ai", "xf", "ip", "pi", "ii", "ij", "ix", "di", "I", "zi", "ex", "yi", "ci"], "x": ["p", "check", "e", "ctx", "xes", "h", "ross", "ware", "w", "xf", "batch", "xd", "ya", "c", "lat", "ci", "ux", "hex", "xs", "xxxx", "xxx", "wx", "foo", "xp", "disk", "ax", "ox", "ct", " xx", "xt", "tx", "xi", "on", "cox", "yx", "lex", "ix", "rox", "xx", "v", "xml", "ho", "X", "history", "dx", "qu", "mm", "z", "n", "exp", "y", "my", "work", "inx", "l", "co", "mix", "hello", "ext", "xe", "nox", "nex", "now", "plex", "fx", "fill", "rx", "rax", "xc", "sex", "ey", "int", "mx", "index", "\u00e7", "xy", "wh", "ex", "px"], "NList": ["NArray", "NiList", "N3", "NSet", "APart", "LLIST", " NLIST", " Nlist", "NiTable", "NPart", "NALIST", "DLIST", " NSet", "LArray", "NTable", "LSet", " NArray", "NATable", "NiSet", "ASet", "Nlist", "L3", "B3", "NAList", " NPart", "LPart", "Llist", " N3", "Blist", " NTable", "LList", "NiLIST", "DList", "DSet", "NLIST", "BArray", "NASet"]}}
{"code": " \\n  def debug(v):\\n      pass#print(v)\\n  \\n  def read(f):\\n      t = tuple(int(v) for v in f.readline().split())\\n      debug(t)\\n      return t\\n  \\n  def readf(f):\\n      t = tuple(float(v) for v in f.readline().split())\\n      debug(t)\\n      return t\\n  \\n  def answer(f, X, ans):\\n      out = \"Case #{}:\\n{}\".format(X, ans)\\n      f.write(out)\\n      f.write(\"\\n\")\\n      print(out)\\n  \\n  def answer_cells(f, X, cells):\\n      out = \"Case #{}:\".format(X)\\n      f.write(out)\\n      f.write(\"\\n\")\\n      print(out)\\n      for row in cells:\\n          out = \"\".join(row)\\n          f.write(out)\\n          f.write(\"\\n\")\\n          print(out)\\n  \\n  def main(inf, outf):\\n      T, = read(inf)\\n      for casenmbr in range(1, T + 1):\\n          R, C, M = read(inf)\\n  \\n          if M == 0:\\n              cells = [['.'] * C for i in range(R)]\\n              cells[0][0] = 'c'\\n              answer_cells(outf, casenmbr, cells)\\n              continue\\n  \\n          empty = R * C - M\\n  \\n          if empty == 1:\\n              cells = [['*'] * C for i in range(R)]\\n              cells[0][0] = 'c'\\n              answer_cells(outf, casenmbr, cells)\\n              continue\\n  \\n          if R == 1 or C == 1:\\n              cells = [['.'] * C for i in range(R)]\\n              m = 0\\n              for r in range(R):\\n                  for c in range(C):\\n                      cells[r][c] = '*'\\n                      m += 1\\n                      if m == M:\\n                          break\\n                  else:\\n                      continue\\n                  break\\n              cells[-1][-1] = 'c'\\n              answer_cells(outf, casenmbr, cells)\\n              continue\\n  \\n          if empty in (2, 3, 5, 7):\\n              answer(outf, casenmbr, \"Impossible\")\\n              continue\\n  \\n          if (R == 2 or C == 2) and empty % 2:\\n              answer(outf, casenmbr, \"Impossible\")\\n              continue\\n  \\n          cells = [['*'] * C for i in range(R)]\\n  \\n  \\n          cells[0][0] = 'c'\\n          empty -= 1\\n          cc = 1\\n          rr = 1\\n          while empty > 0:\\n              if cc < C:\\n                  for r in range(rr):\\n                      if empty == 2 and r == rr - 1:\\n                          break\\n                      cells[r][cc] = '.'\\n                      empty -= 1\\n                      if empty == 0:\\n                          break\\n                  cc += 1\\n              if rr < R and empty > 0:\\n                  for c in range(cc):\\n                      if empty == 2 and c == cc - 1:\\n                          break\\n                      cells[rr][c] = '.'\\n                      empty -= 1\\n                      if empty == 0:\\n                          break\\n                  rr += 1            \\n  \\n          answer_cells(outf, casenmbr, cells)\\n  \\n  \\n  if __name__==\"__main__\":\\n      infname = sys.argv[1]\\n      outfname = os.path.splitext(infname)[0] + \".out\"\\n      with open(infname, \"r\") as inf:\\n          with open(outfname, \"w\") as outf:\\n              main(inf, outf)\\n", "substitutes": {"v": ["p", "k", "qv", "t", "o", "m", "h", "z", "n", "g", "f", "w", "d", "q", "u", "y", "r", "b", "V", "env", "value", "vv", "vt", "x", "a", "c", "uv", "sv"]}}
{"code": " \\n  def debug(v):\\n      pass #print(v)\\n  \\n  def read(f):\\n      t = tuple(int(v) for v in f.readline().split())\\n      debug(t)\\n      return t\\n  \\n  def answer(f, X, ans):\\n      out = \"Case #{}: {}\".format(X, ans)\\n      f.write(out)\\n      f.write(\"\\n\")\\n      print(out)\\n  \\n  \\n  \\n  def main(inf, outf):\\n      T, = read(inf)\\n      for X in range(1, T + 1):\\n          row1, = read(inf)\\n          cards1 = tuple(read(inf) for i in range(4))\\n          row2, = read(inf)\\n          cards2 = tuple(read(inf) for i in range(4))\\n  \\n          kouho = set(cards1[row1 - 1]).intersection(cards2[row2 - 1])\\n  \\n          if kouho:\\n              if len(kouho) == 1:\\n                  ans = kouho.pop()\\n              else:\\n                  ans = \"Bad magician!\"\\n          else:\\n              ans = \"Volunteer cheated!\"\\n  \\n          answer(outf, X, ans)\\n  \\n  \\n  if __name__==\"__main__\":\\n      infname = sys.argv[1]\\n      outfname = os.path.splitext(infname)[0] + \".out\"\\n      with open(infname, \"r\") as inf:\\n          with open(outfname, \"w\") as outf:\\n              main(inf, outf)\\n", "substitutes": {"v": ["p", "k", "qv", "t", "o", "m", "h", "z", "n", "g", "f", "w", "d", "q", "u", "y", "r", "b", "V", "env", "value", "vv", "vt", "x", "a", "c", "uv", "sv"]}}
{"code": " \\n  if __name__ == \"__main__\":\\n      f = sys.stdin\\n      if len(sys.argv) >= 2:\\n          fn = sys.argv[1]\\n          if fn != '-':\\n              f = open(fn)\\n  \\n      t = int(f.readline())\\n      for _t in range(t):\\n  \\n          R, C, M = [int(x) for x in f.readline().split()]\\n          free_spots = R * C - M - 1\\n  \\n          if M == 0:\\n              answer = [[\".\" for x in range(C)] for y in range(R)]\\n              answer[0][0] = \"c\"\\n          elif R == 1:\\n              answer = [[\"c\"] + [\".\" for x in range(free_spots)] + [\"*\" for m in range(M)]]\\n          elif C == 1:\\n              answer = [[\"c\"] + [\".\" for x in range(free_spots)] + [\"*\" for m in range(M)]]\\n              answer = zip(*answer[::-1])\\n          elif free_spots >= 3: # and M % R >= 2:\\n              answer = [[\"*\" for x in range(C)] for y in range(R)]\\n              answer[0][0] = \"c\"\\n              answer[0][1] = \".\"\\n              answer[1][1] = \".\"\\n              answer[1][0] = \".\"\\n              free_spots -= 3\\n              tr, br, c = 0, 1, 2\\n              if c >= C:\\n                  tr, br, c = 2, 3, 0\\n              for _i in range(free_spots):\\n                  if answer[tr][c] == \"*\":\\n                      answer[tr][c] = \".\"\\n                  elif answer[br][c] == \"*\":\\n                      answer[br][c] = \".\"\\n                      if c < C-1:\\n                          c+=1\\n                      else:\\n                          tr, br = tr + 2, br + 2\\n                          c = 0\\n                          if br == R:\\n                              br, tr = br-1, tr-1\\n                  \\n          else:\\n              answer = [\"Impossible\",]\\n  \\n          \\n          \\n          print (\"Case #\" + str(_t+1) + \":\")\\n          for _i in answer:\\n              print \"\".join(_i)\\n      \\n  \\n", "substitutes": {"f": ["ft", "fd", "p", "bf", "open", "fr", "df", "e", "o", "h", "cf", "n", "g", "fo", "af", "elf", "fg", "fb", "w", "d", "lf", "tf", "alf", "sf", "q", "F", "r", "xf", "fm", "b", "l", "fed", "input", "iter", "feed", "fp", "file", "fc", "fs", "c", "v", "fa", "fw"], "fn": ["function", "ns", "fd", "bf", "fr", "filename", "o", "orig", "fl", "txt", "ct", "FN", "path", "n", "nc", "cf", "wl", "hn", "nil", "mn", "full", "sn", "lf", "tf", "fun", "fm", "ff", "nu", "fil", "typ", "unc", "dn", "nl", "ln", "nt", "syn", "pen", "nm", "obj", "fp", "rm", "file", "fc", "rn", "fs", "fin", "kl"], "t": ["tt", "p", "total", "tm", "e", "it", "ties", "time", "z", "n", "g", "int", "ti", "tr", "dt", "w", "i", "r", "l", "ty", "vt", "tp", "tz", "ot", "to", "te", "tu", "c", "ta", "v", "ts", "tc", "T", "tw"], "_t": ["_r", " _r", " _T", " _n", "_n", "_T"], "R": ["D", "G", "X", "RA", "H", "L", "CR", "Q", "A", "E", "RG", "B", "RF", "Res", "SR", "F", "r", "J", "V", "RO", "RS", "Y", "N", "RE", "TR", "GR", "RR", "Rs", "I", "RM", "P", "RT", "W", "T", "BR", "S", "MR", "ER"], "C": ["Co", "D", "G", "O", "Ch", "COR", "X", "H", "L", "CR", "Q", "A", "CM", "E", "Cr", "CS", "B", "Cons", "CV", "CE", "CC", "You", "F", "WC", "CON", "V", "Y", "CNN", "N", "CO", "CT", "CP", "K", "I", "P", "CB", "Cs", "c", "W", "CL", "MC", "Charlie", "CU", "T", "S", "Cache"], "M": ["D", "G", "O", "AM", "X", "MA", "H", "L", "TM", "Q", "CM", "MAN", "B", "Mi", "MM", "F", "J", "V", "Me", "MU", "Z", "Y", "N", "MT", "MI", "Maker", "I", "RM", "P", "Mc", "W", "DM", "MC", "T", "MS", "S", "MR"], "x": ["ux", "p", "xs", "k", "fx", "e", "X", "rx", "at", "xes", "wx", "dx", "xp", "ax", "ct", "ox", "h", "z", "n", "xc", "xa", "tx", "name", "xt", "ey", "mx", "w", "xi", "q", "i", "yi", "_", "cross", "xf", "on", "\u00e7", "l", "yx", "co", " ax", "xe", "mut", "ix", "ma", "xy", "ex", "px", "c", "v", "xx", "xml", "lat", "xb", "rex", "zx"], "free_spots": ["free1storeots", "free_spaceot", "free1storeot", "free_potes", "free_staticaces", "free_sploms", "free_Spaces", "free_splots", "free_splicks", "free_shents", "free_spotic", "free1spics", "free1spents", "free_bspots", "free_spotes", "free_spices", "free_paces", "free_spot", "free_snapots", "free_snapaces", "free_pics", "free_pot", "free_storeents", "free_sprots", "free_spaceotic", "free_picks", "free_Spotes", "free_spaceots", "free_spaceents", "free_storeot", "free_pices", "free1snapaces", "free_storeotic", "free_staticrots", "free_shots", "free_spents", "free_spicks", "free_bspices", "free_snaprots", "free_spoms", "free1snapics", "free_staticics", "free1spot", "free_shotic", "free_shot", "free1sprots", "free_Spoms", "free_pots", "free_splot", "free_splotes", "free1spots", "free_poms", "free_snapics", "free1snapots", "free_prots", "free1storeents", "free_spics", "free_splices", "free_Spots", "free_storeots", "free1storeotic", "free_staticots", "free_bspicks", "free_spaces", "free_bspot", "free1spaces", "free1snaprots", "free_splaces", "free1spotic"], "answer": ["range", "urn", "next", "cho", "form", "e", "expression", "issue", "array", "turn", "reply", "record", "window", "vert", "option", "ve", "eni", "do", "see", "era", "rez", "result", "section", "question", "ze", "vote", "be", "archive", "oe", "cache", "q", "set", "entry", " Answer", " unanswered", "wer", "ue", "install", "answered", "rep", "message", "query", "don", "remember", "sequence", "order", "ee", "consider", "Answer", "field", "equ", "position", "ell", "offer", "place", "zip", "said", "search", "accept", "queue", "response", "test", "iterator", "say", "interpret", "list"], "y": ["yt", "re", "e", "ho", "cy", "o", "yy", "yr", "ys", "z", "yu", "ym", "ey", "mx", "w", "im", "my", "yn", "on", "ay", "Y", "ye", "yer", "yl", "xy", "yd", "ry", "yi"], "m": ["em", "ms", "cm", "mm", "h", "ct", "z", "xc", "pm", "ym", "am", "perm", "um", "mn", "mx", "w", "d", "gm", "q", "im", "man", "on", "me", "mt", "l", "sm", "mut", "ma", "md", "c", "v", "ml"]}}
{"code": " \\n  if __name__ == \"__main__\":\\n      f = sys.stdin\\n      if len(sys.argv) >= 2:\\n          fn = sys.argv[1]\\n          if fn != '-':\\n              f = open(fn)\\n  \\n      t = int(f.readline())\\n      for _t in range(t):\\n          X = int(f.readline())\\n          cardsX = [[int(y) for y in f.readline().split()] for x in range(4)]\\n          row = cardsX[X-1]\\n          Y = int(f.readline())\\n          cardsY = [[int(y) for y in f.readline().split()] for x in range(4)]\\n          column = cardsY[Y-1]\\n          card = [x for x in row if x in column]\\n          if len(card) > 1:\\n              answer = \"Bad magician!\"\\n          elif len(card) == 0:\\n              answer = \"Volunteer cheated!\"\\n          else:\\n              answer = str(card[0])\\n          print (\"Case #\" + str(_t+1) + \": \" + answer)\\n      \\n  \\n", "substitutes": {"f": ["ft", "fd", "p", "bf", "fx", "j", "open", "fr", "form", "df", "o", "fig", "fe", "fl", "cond", "h", "of", "cf", "n", "fo", "g", "uf", "af", "fu", "elf", "z", "fg", "fb", "w", "full", "lf", "tf", "sf", "q", "i", "fer", "F", "r", "xf", "fm", "ff", "b", "ac", "l", "inf", "fed", "fast", "iter", "fp", "fac", "file", "fc", " F", "fs", "c", "v", "et", "ference", "fi", "fa", "alf"], "fn": ["function", "ns", "fd", "bf", "fr", "cmd", "filename", "orig", "fl", "txt", "that", "FN", "path", "n", "cf", "con", "wl", "hn", "mn", "full", "cn", "sn", "pn", "lf", "fun", "fm", "ff", "typ", "fil", "bn", "unc", "dn", "np", "ln", "syn", "pen", "nm", "obj", "fp", "file", "fc", "rn", "fs", "fin"], "t": ["tt", "p", "j", "total", "type", "tm", "it", "ties", "m", "ct", "z", "n", "name", "ti", "tr", "dt", "w", "d", "i", "r", "typ", "l", "ty", "tp", "tz", "ot", "to", "te", "tu", "c", "ta", "v", "ts", "tc", "T", "tw"], "_t": [" _tp", " _tu", "_z", " _y", "_y", "_n", "_tu", "_tp"], "X": ["One", "Cross", "Left", "H", "L", "TY", "U", "A", "ox", "XT", "OX", "R", "TH", "Ex", "ZX", "MX", "Location", "EL", "XY", "DX", "V", "XP", "XXX", "IX", "Z", "Row", "XL", "XX", "N", "UX", "XXXX", "EX", "C", "I", "TX", "T", "TD"], "cardsX": ["tagsXL", " cardsXX", "cardsUX", " cardsXL", "cardZX", "tagsY", "tagsXX", "cardX", "fieldsX", "cardsXL", "tagsX", "fieldsXL", "cardUX", "ardsY", "cardsXX", "fieldsXX", " cardsZX", "cardY", "ardsX", "ardsZX", "ardsUX", "fieldsY", " cardsUX", "cardsZX"], "y": ["vy", "yout", "yt", "j", "p", "gy", "col", "iy", "cy", "o", "aily", "ies", "yy", "yr", "ys", "z", "n", "yu", "ym", "ny", "ey", "uy", "w", "oy", "i", "yk", "yn", "b", "sy", "l", "ay", "ty", "fy", "yahoo", "ly", "ye", "yer", "yo", "yl", "xy", "yd", "ky", "c", "wy", "v", "ry", "yi", "py"], "x": ["ft", "ux", "p", "xs", "check", "e", "ctx", "rx", "xes", "wx", "dx", "xp", "no", "ax", "ct", "ox", "key", "z", "ross", "xc", "xa", "sex", "xt", "tx", "mx", "w", "index", "xi", "_", "i", "q", "inx", "xf", "cox", "l", "yx", "co", "mix", "ext", "checked", "xe", "lex", "mut", "ix", "xy", "wh", "ex", "c", "xx", "v", "xml", "lat", "fx", "ci"], "row": ["range", "rue", "word", "frame", "col", "begin", "ox", "ro", "family", "run", "record", "node", "group", "rown", "section", "field", "index", "user", "line", "rank", "r", "rect", "role", "tab", "Row", "board", "ow", "month", "order", "batch", "ows", "roll", "ase", "round", "arrow", "rows", "ry", "cell", "pair"], "Y": ["G", "O", "TN", "H", "RY", "TY", "IL", "MY", "NS", "Bar", "R", "TH", "By", "Py", "B", "MX", "BY", "J", "XY", "EY", "V", "M", "Row", "Z", "YA", "YS", "N", "YY", "Year", "Column", "Cy", "C", "I", "YC", "My", "YD", "IJ", "T"], "cardsY": ["cardsT", "lettersYY", "lettersT", "cardX", "holdersYY", "fieldsX", "holdersX", "holdersY", "cardsB", " cardsB", "holdersT", "cardsYY", "lettersX", "cardYY", "cardB", "fieldsT", "cardY", "fieldsB", "cardT", " cardsT", "fieldsY", "lettersY"], "column": ["label", "type", "word", "col", "cut", "command", "time", "display", "client", "key", "path", "variable", "group", "category", "widget", "char", "field", "page", "condition", "index", "section", "width", "character", "scroll", "table", "number", "umn", "Column", "output", "child", "height", "title", "pattern", "pointer", "round", "header", "attribute", "cell", "text"], "card": ["empty", "ard", "bit", "word", "battle", "piece", "note", "cap", "crit", "cards", "deck", "winner", "cf", "do", "name", "chain", "condition", "field", "result", "Card", "char", "cat", "be", "arc", "line", "ad", "byte", "pad", "cont", "who", "player", "board", "co", "cc", "draw", "car", "back", "ARD", "ord", "box", "place", "roll", "ca", "ce", "controller", "cell", "play", "comment", "case"], "answer": ["swers", "issue", "approximately", "request", "reply", "record", "about", "ace", "quest", "ve", "example", "ask", "do", "image", "era", "result", "ache", "vote", "question", "ze", "archive", "again", "affle", " Answer", "onse", "notice", "me", "wer", "echo", "over", "install", "answered", "ae", "message", "rep", "query", "remember", "sequence", "oa", "agent", "Answer", "review", "consider", "come", "offer", "know", "average", "onder", "said", "attribute", "accept", "response", "description", "comment", "say", "interpret", "ee"]}}
{"code": " \\n  '''\\n  Input\\n  The first line of the input gives the number of test cases, T. T lines follow. \\n  Each line contains three space-separated integers: R, C, and M (Rows, Columns, Mines).\\n  \\n  Output\\n  For each test case, output a line containing \"Case #x:\", where x is the test case number. \\n  On the following R lines, output the board configuration with C characters per line, \\n  using '.' to represent an empty cell, '*' to represent a cell that contains a mine, \\n  and 'c' to represent the clicked cell. If there is no possible configuration, \\n  then instead of the grid, output a line with \"Impossible\" instead. \\n  If there are multiple possible configurations, output any one of them.\\n  \\n  Limits\\n  0 <= M < R * C.\\n  \\n  Small dataset\\n  1 <= T <= 230.\\n  1 <= R, C <= 5.\\n  \\n  Large dataset\\n  1 <= T <= 140.\\n  1 <= R, C <= 50.\\n  \\n  Sample\\n  ---Input \\n  5\\n  5 5 23\\n  3 1 1\\n  2 2 1\\n  4 7 3\\n  10 10 82\\n  \\n  ---Output \\n  Case #1:\\n  Impossible\\n  Case #2:\\n  c\\n  .\\n  *\\n  Case #3:\\n  Impossible\\n  Case #4:\\n  ......*\\n  .c....*\\n  .......\\n  ..*....\\n  Case #5:\\n  **********\\n  **********\\n  **********\\n  ****....**\\n  ***.....**\\n  ***.c...**\\n  ***....***\\n  **********\\n  **********\\n  **********\\n  \\n  \\n  '''\\n  \\n  \\n  f = open(sys.argv[1])\\n  def input(): return f.readline().strip();\\n  \\n  def genBoards(R, C, M):\\n      for mines in combinations( product(range(R), range(C)), M):\\n          board = [ ['.'] * C + [''] for _ in range(R) ]\\n          for row, col in mines:\\n              board[row][col] = '*'\\n          yield board + [[''] * (C+1)]\\n      pass\\n  \\n  def oneClickSolution(R, C, M):\\n      for bd in genBoards(R, C, M):\\n          minTile = 10\\n          for r in range(R):\\n              for c in range(C):\\n                  if bd[r][c] == '.':\\n                      n = sum(bd[r+i][c+j]=='*' for i in (-1,0,1) for j in (-1,0,1))\\n                      bd[r][c] = `n`\\n                      if n <= minTile:\\n                          minTile = n\\n                          minR, minC = r, c\\n          if minTile < 10:\\n              queue = [ (minR, minC) ]\\n              nOpen = 0\\n              while queue:\\n                  r,c = queue.pop()\\n                  if bd[r][c] == '0':\\n                      for i in -1,0,1:\\n                          for j in -1,0,1:\\n                              if i or j: # we don't add the one we popped back\\n                                  queue.append( (r+i, c+j) )\\n                  if bd[r][c] not in '.*':\\n                      bd[r][c] = '.'\\n                      nOpen += 1\\n              if M + nOpen == R*C:\\n                  bd[minR][minC] = 'c'\\n                  return '\\n'.join( ''.join(row[:-1]) for row in bd[:-1] )\\n  \\n      return 'Impossible'\\n  \\n  \\n  clk = clock()\\n  \\n  for caseNo in xrange(1, int(input())+1):\\n      R, C, M = map(int, input().split())\\n      print >>sys.stderr, caseNo, R, C, M #, oneClickSolution(R, C, M)<>'Impossible'\\n      print 'Case #%d:' % caseNo  \\n      print oneClickSolution(R, C, M)\\n      \\n  print >>sys.stderr, 'time= %.1f seconds' % (clock()-clk )\\n  \\n", "substitutes": {"f": ["ft", "fd", "p", "bf", "fr", "df", "e", "t", "o", "m", "h", "cf", "g", "uf", "af", "rf", "fg", "fb", "w", "d", "tf", "sf", "F", "fm", "b", "l", "x", "input", "fp", "file", "fc", "a", "fs", "v", "fn", "fa", "fw"], "R": ["Range", "D", "G", "Right", "JR", "X", "RA", "Review", "H", "U", "L", "A", "CR", "Q", "Reg", "Br", "DR", "RC", "Remote", "RG", "B", "SR", "Res", "RL", "Rect", "AR", "Mr", "F", "V", "RO", "RS", "Rot", "Row", "Y", "N", "NR", "RE", "Tr", "TR", "RR", "Rs", "I", "RM", "P", "Rat", "RT", "OR", "W", "T", "S", "BR", "IR", "MR", "Dr"], "C": ["Co", "D", "G", "O", "CD", "JC", "Ch", "COR", "X", "Cow", "L", "H", "U", "HC", "CR", "E", "A", "CM", "Q", "CN", "AC", "Chain", "CS", "B", "CA", "CV", "Cl", "CE", "CC", "F", "CON", "Craig", "SC", "V", "EC", "Y", "CNN", "N", "CT", "CG", "VC", "CF", "DC", "K", "I", "YC", "P", "CB", "Cs", "W", "CL", "MC", "Size", "CCC", "T", "S", "Cache"], "M": ["D", "O", "X", "H", "L", "m", "TM", "E", "Q", "A", "CM", "MN", "NM", "OM", "B", "PM", "MM", "JM", "MX", "Matrix", "F", "J", "IM", "V", "Mode", "Manager", "Y", "LM", "N", "Ms", "MT", "MI", "K", "I", "RM", "P", "DM", "MC", "T", "MS", "S", "AM"], "mines": ["passed", "minese", "Minis", "minsed", "Minses", "minses", "Mined", "minis", "minsis", "mined", "passes", "Minese", " minedes", "passese", "minsese", "minedes", "passis", "Mines", " minses", " minis", "minsses", "minsedes", "Minedes"], "board": ["ard", "flo", "bo", "bus", "deck", "oard", "block", "ro", "layout", "fine", "window", "node", "control", "wheel", "loop", "be", "lay", "line", "core", "b", "bank", "buffer", "plate", "table", "room", "flow", "sequence", "card", "body", "back", "boards", "ack", "comb", "box", "boarding", "runner", "boot", "ward", "Board", "bar", "button", "bro", "cell", "lock", "bin"], "_": ["ct", "ox", "an", "all", "ner", "line", "ac", "val", "un", "ation", "ix", "ge", "non", "ml"], "row": ["br", "color", "p", "rc", "re", "rs", "ox", "key", "ro", "lo", "rown", "char", "item", "w", "tr", "index", "line", "rot", "rect", "Row", "co", "x", "ow", "box", "th", "roll", "vr", "bar", "rows", "ry", "pos", "cell", "our", "pair"], "col": ["label", "br", "color", "day", "win", "count", "COL", "cp", "foot", "column", "fl", "coll", "cond", "client", "ct", "ox", "key", "path", "con", "icol", "Col", "name", "cat", "coord", "left", "rot", "ol", "y", "prop", "el", "val", "channel", "co", "loc", "ch", "obj", "box", "th", "roll", "fc", "pt", "pos", "cell", "fn", "mon"], "bd": ["fd", "br", "bf", "bl", "band", "bo", "pd", "dm", "de", "bes", "gb", "hd", "fl", "ob", "bc", "bb", "bm", "ba", "ds", "bind", "fb", "d", "dt", "cb", "be", "bos", "dd", "nb", "db", "b", "dj", "bn", "da", "ond", "bs", "ben", "hands", "ld", "dis", "bh", "boards", "edd", "bis", "box", "BD", "cd", "deb", "bar", "vd", "bet", "bro", "bj", "bt", "des"], "minTile": ["minimumTile", "maxTile", "minPixel", "MinCell", "minimumThumbnail", " mintile", "minimumFeature", " minPixel", " minEntry", "lowerTile", " minCell", "maxEntry", " minTI", "minTI", "MinEntry", "maxtile", " minThumbnail", "maxPixel", "minimumtile", "minFeature", "minimumPixel", "minThumbnail", "nCell", "MinTile", "mintile", "minCell", "nTI", "MinTI", "lowerFeature", "nTile", "Mintile", "minimumEntry", "minEntry", "lowerThumbnail", " minFeature"], "r": ["res", "range", "br", "p", "rc", "root", "er", "fr", "re", "e", "rs", "rx", "reg", "rec", "t", "o", "m", "h", "nr", "ro", "rg", "z", "rb", "ur", "g", "rl", "ar", "ru", "w", "d", "pr", "q", "y", "kr", "b", "l", "rr", "cr", "hr", "rar", "x", "usr", "sr", "attr", "dr", "gr", "mr", "vr", "rn", "v", "rd", "ir", "rt", "rh"], "c": ["dc", "p", "k", "rc", "e", "cp", "cm", "cut", "t", "m", "cur", "lc", "ct", "bc", "z", "g", "con", "xc", "cf", "can", "chain", "pc", "cat", "w", "cu", "cn", "cb", "sc", "u", "cache", "ec", "vc", "cin", "uc", "cs", "b", "ac", "cor", "cl", "l", "unc", "cr", "co", "x", "cc", "mc", "jc", "ch", "cd", "fc", "ca", "ce", "v", "tc", "cell", "com", "ci"], "n": ["ns", "p", "inner", "t", "o", "m", "nat", "nr", "z", "s", "g", "nc", "all", "Ni", "nan", "w", "d", "sn", "cn", "current", "nb", "b", "nu", "l", "dn", "np", "nl", "number", "un", "ni", "N", "ln", "nt", "nm", "min", "len", "v", "fn", "nn", "size", "num"], "i": ["gi", "hi", "p", "ic", "k", "ib", "li", "e", "it", "iy", "ia", "rin", "o", "io", "m", "ik", "h", "iti", "z", "iri", "ri", "phi", "ei", "ti", "ini", "bi", "si", "u", "q", "y", "im", "mi", "ai", "ip", "l", "x", "pi", "ii", "ij", "iu", "ni", "ix", "di", "I", "ig", "zi", "ie", "v", "fi", "ir", "yi", "ci"], "j": ["ji", "br", "p", "jj", "k", "ju", "fr", "li", "e", "jp", "t", "o", "h", "z", "g", "ja", "d", "uj", "q", "u", "y", "json", "J", "ai", "kj", "b", "dj", "l", "oj", "x", "ij", "job", "jc", "ch", "out", "js", "jump", "serv", "jas", "v", "je", "ie", "aj", "bj", "cell", "py", "ci"], "minR": ["maxS", "smallC", "minRange", "minT", " minRange", "commonR", "smallR", "commonr", "minS", "MinC", "MinT", " minS", "commonS", "minr", "maxr", "maxR", "maxRange", " minT", "smallT", " minr", "commonRange", "MinR"], "minC": ["mineCl", "minT", "minB", "mineT", "MinM", "MinC", "MinT", " minCl", "MinCl", "MinB", "MINT", " minT", "minM", "MINCl", "mineM", " minM", "MINC", "minCl", "mineC", " minB", "MINB"], "queue": ["next", "menu", "qv", "count", "flush", "buf", "priority", "force", "worker", "store", "block", "wait", "Q", "stack", "lot", "free", "ques", "ued", "result", "quit", "q", "line", "set", "forced", "entry", "grid", "me", "late", "ue", "enabled", "buffer", "channel", "required", "ume", "bench", "server", "Queue", "sequence", "que", "pen", "batch", "position", "vr", "button", "timer", "checked", "select", "tube", "message", "case", "list"], "nOpen": [" nopen", "nbClose", "numopen", "numOpen", "nbTotal", " nTotal", " nClose", "nbopen", "numClose", "nopen", "nbOpen", "numTotal", "nTotal", "nClose"]}}
{"code": " \\n  '''\\n  ---Input \\n  3\\n  2\\n  1 2 3 4\\n  5 6 7 8\\n  9 10 11 12\\n  13 14 15 16\\n  3\\n  1 2 5 4\\n  3 11 6 15\\n  9 10 7 12\\n  13 14 8 16\\n  2\\n  1 2 3 4\\n  5 6 7 8\\n  9 10 11 12\\n  13 14 15 16\\n  2\\n  1 2 3 4\\n  5 6 7 8\\n  9 10 11 12\\n  13 14 15 16\\n  2\\n  1 2 3 4\\n  5 6 7 8\\n  9 10 11 12\\n  13 14 15 16\\n  3\\n  1 2 3 4\\n  5 6 7 8\\n  9 10 11 12\\n  13 14 15 16\\n  \\n  ---Output \\n  Case #1: 7\\n  Case #2: Bad magician!\\n  Case #3: Volunteer cheated!\\n  '''\\n  \\n  \\n  \\n  \\n  \\n  f = open(sys.argv[1])\\n  def input(): return f.readline().strip();\\n  \\n         \\n  \\n  \\n  for caseNo in xrange(1, int(input())+1):\\n      row_no = int(input())\\n      for i in 1,2,3,4:\\n          row = input()\\n          if i == row_no:\\n              nums = set(row.split())\\n              \\n      row_no = int(input())\\n      for i in 1,2,3,4:\\n          row = input()\\n          if i == row_no:\\n              nums &= set(row.split())\\n  \\n      if not nums:\\n          res = 'Volunteer cheated!'\\n      elif len(nums) > 1:\\n          res = 'Bad magician!'        \\n      else:\\n          res = nums.pop()\\n      print 'Case #%d:' % caseNo, res\\n      \\n  \\n", "substitutes": {"f": ["ft", "fd", "p", "bf", "fr", "e", "t", "o", "m", "h", "cf", "s", "g", "af", "fg", "fb", "w", "d", "lf", "sf", "F", "r", "fm", "b", "l", "ma", "fp", "file", "fc", "a", "c", "fs", "v", "fn", "fa", "fw"], "caseNo": ["CaseNO", " caseNO", "CaseNum", " caseNum", "aseNum", "caseNum", "caseno", "aseNo", "aseNO", "aseno", "Caseno", "CaseNo", "caseNO", " caseno"], "row_no": [" row_No", "col_No", " row2nos", " row_nos", "row_go", "Row_do", "col_by", "row_NO", "Row_No", "row2no", "row_by", "row_nos", "row2nos", "Row_NO", "col_NO", " row_nr", "Row_no", " row2no", " row_go", "row2No", "col_no", "row_do", " row2No", "row_No", "row_nr"], "i": ["gi", "j", "ic", "li", "it", "o", "m", "ik", "iti", "n", " ii", " vi", "ri", "phi", "ei", "int", "ti", "iat", "ini", "il", "si", "xi", "im", "\u0438", "mi", "y", "ai", "\u00ed", "ip", "ori", "l", "x", "pi", "ii", "ij", "iu", "ni", "ati", "di", "zi", "I", "ir", "yi", "ci"], "row": ["range", "post", "hex", "rc", "form", "bo", "str", "col", "frame", "no", "block", "ser", "ob", "ro", "week", "record", "lo", "raw", "rl", "item", "tr", "index", "full", "line", "set", "sw", "r", "entry", "tab", "Row", "rep", "co", "ow", "nt", "list", "batch", "th", "box", "iter", "ows", "roll", "feed", "rows", "ry", "pos", "cell", "sel", "pair"], "nums": ["enames", " num", "enum", " noms", "Names", "nsoms", " numbers", " nales", "Nums", "lnumbers", "Naps", "Numbers", " names", "enaps", "nsumbers", "naps", "lnums", "enumbers", "names", " nues", " naps", "lnum", "lnoms", "Noms", "nues", "nsales", "enums", "noms", "Nues", "Nales", "nsues", "numbers", "nsums", "nales", "Num", "nsum", "num"], "res": ["rem", "str", "rev", "re", "err", "reg", "rend", "crit", "cond", "success", "reset", "results", "req", "rest", "rek", "ret", "sol", "chain", "Res", "pro", "pres", "rez", "result", "pr", "RES", "euro", "r", "respons", "rand", "val", "yes", "rep", "rel", "resolution", "nt", "net", "clus", "obj", "resp", "gr", "cons", "out", "sum", "response", "des"]}}
{"code": "t = int(input())\\n  \\n  VIDE = 0\\n  MINE = 1\\n  CURSEUR = 2\\n  \\n  def test_position(arr, lignes, cols, y, x):\\n      def voisinage_libre(arr, y, x):\\n          if y > 0:\\n              if x > 0 and arr[y-1][x-1] == MINE:\\n                  return False\\n              if arr[y-1][x] == MINE:\\n                  return False\\n              if x < cols - 1 and arr[y-1][x+1] == MINE:\\n                  return False\\n  \\n          if x > 0 and arr[y][x-1] == MINE:\\n              return False\\n          if x < cols - 1 and arr[y][x+1] == MINE:\\n              return False\\n  \\n          if y < lignes - 1:\\n              if x > 0 and arr[y+1][x-1] == MINE:\\n                  return False\\n              if arr[y+1][x] == MINE:\\n                  return False\\n              if x < cols - 1 and arr[y+1][x+1] == MINE:\\n                  return False\\n  \\n          return True\\n  \\n      def remplissage_rec(arr, y, x):\\n          if x < 0 or y < 0 or x >= cols or y >= lignes:\\n              return\\n          elif arr[y][x] == CURSEUR:\\n              return\\n  \\n          arr[y][x] = CURSEUR\\n          if voisinage_libre(arr, y, x):\\n              remplissage_rec(arr, y-1, x-1)\\n              remplissage_rec(arr, y-1, x)\\n              remplissage_rec(arr, y-1, x+1)\\n              remplissage_rec(arr, y, x-1)\\n              remplissage_rec(arr, y, x+1)\\n              remplissage_rec(arr, y+1, x-1)\\n              remplissage_rec(arr, y+1, x)\\n              remplissage_rec(arr, y+1, x+1)\\n  \\n      if arr[y][x] != VIDE:\\n          return False\\n  \\n      arr2 = [ [ arr[i][j] for j in range(0, cols) ] for i in range(0, lignes) ]\\n  \\n      remplissage_rec(arr2, y, x)\\n  \\n      for i in range(0, lignes):\\n          for j in range(0, cols):\\n              if arr2[i][j] == VIDE:\\n                  return False\\n      return True\\n  \\n  def dfs(arr, lignes, cols, mines, y, x):\\n      cases_restantes = (cols - x) + ((lignes - y) * cols)\\n  \\n      if cases_restantes < mines:\\n          return None\\n      elif mines <= 0:\\n          for i in range(0, lignes):\\n              for j in range(0, cols):\\n                  if test_position(arr, lignes, cols, i, j):\\n                      return (i, j)\\n      elif x >= cols:\\n          return dfs(arr, lignes, cols, mines, y+1, 0)\\n      elif y >= lignes:\\n          return None\\n      else:\\n          res = dfs(arr, lignes, cols, mines, y, x+1)\\n          if res != None:\\n              return res\\n  \\n          arr[y][x] = MINE\\n          res = dfs(arr, lignes, cols, mines-1, y, x+1)\\n          if res != None:\\n              return res\\n  \\n          arr[y][x] = VIDE\\n          return None\\n  \\n  for i in range(0, t):\\n      ligne  = input().split(\" \")\\n      lignes = int(ligne[0])\\n      cols   = int(ligne[1])\\n      mines  = int(ligne[2])\\n  \\n      arr = [ [VIDE] * cols for _ in range(0, lignes) ]\\n  \\n      res = dfs(arr, lignes, cols, mines, 0, 0)\\n  \\n      print (\"Case #\"+str(i+1)+\":\")\\n  \\n      if res == None:\\n          print (\"Impossible\")\\n      else:\\n          (y, x) = res\\n  \\n          for i in range(0, lignes):\\n              for j in range(0, cols):\\n                  if i == y and j == x:\\n                      print('c', end='')\\n                  elif arr[i][j] == VIDE:\\n                      print('.', end='')\\n                  else:\\n                      print('*', end='')\\n  \\n              print('', end='\\n')\\n", "substitutes": {"t": ["p", "tt", "total", "e", "o", "m", "time", "h", "z", "n", "g", "s", "f", "w", "d", "dt", "q", "r", "b", "l", "tp", "a", "c", "ta", "v", "ts", "T"], "VIDE": ["VISEE", " VIDEA", "VERSE", "VERSe", "VIDe", "VISIE", "VISEA", "VIDEA", "VERSEE", "VDe", "VDIE", "VIDIE", "VDE", "VIDEE", " VIDe", "VERSIE", " VIDIE", "VERSEA", "VISe", "VDEE", "VISE"], "MINE": ["Finite", " Mines", "IMIDE", "WMine", "MIIDE", "GINE", "MINK", "FFINE", " MINK", "DMIDE", " MIME", "IMIM", "DMINE", "MIINE", "MCinite", "FIME", "VID", "MANFINE", "Ginite", " MIM", "MCINE", "MITE", "MIDE", "FID", "FINE", "MIM", "MCine", "HFINE", " MIDE", "FALE", "Minite", "Hinite", "CINE", "CIM", " MITE", "MIME", "MID", "MANIM", "DMine", "IMinite", " Mine", " MALE", " MID", "MFINE", "SMINE", "IMine", "Cinite", "MIINK", "SMines", "VIME", "IMINE", "HINE", "Vine", "MANINE", "Mines", " MFINE", "WMITE", "GALE", "IMINK", "Cine", "SMine", "VINE", "DMIM", "MANinite", "MANine", "MIine", "FIM", "Gine", "Fine", "Hine", "Mine", "FIDE", "MCIM", " Minite", "WMINE", "MALE", "WMines", "SMITE"], "CURSEUR": ["CURGEUD", "COUGEUR", "CURGEURE", "CURCLEURL", "COUSEUR", "CURSEur", "CURGEur", "CURGEURL", "CURGEURR", "CURseur", "CURGEUR", "CADGEURR", "COUGEURR", "CURTHur", "COUSEur", "CADSEURL", "CURseOR", "CURSEUD", "CURGEOR", "CURseUR", "CURSEURE", "CURCLEUD", "COUGEur", "CURTEUR", "COUSEOR", "CADSEURR", "CADSEUR", "COUseur", "CURSEOR", "CURTEur", "COUGEOR", "CURseUD", "CURCLEUR", "CURseURR", "COUSEURR", "CADGEUD", "COUseUR", "COUseURR", "CURSEURR", "COUseURE", "CADGEUR", "CURTEURR", "CURSEURL", "CURCLEURR", "CURTHURR", "CURseURE", "CURTHUR", "CURseURL", "CURTHURE", "COUSEURE", "CADSEUD", "CURTEOR", "CADGEURL"], "arr": ["app", "func", "args", "p", "adv", "fr", "at", "warn", "irm", "window", "req", "att", "ar", "aa", "proc", "r", "row", "var", "attr", "batch", "par", "plot", "enc", "cell", "dat", "agg", "vol", "block", "mg", "ax", "conf", "ck", "raw", "hist", "pl", "gz", "rr", "np", "rel", "ij", "Array", "inst", "ell", "ix", "dr", "gr", "out", "resp", "alg", "kl", "br", "bl", "str", "err", "it", "img", "ll", "array", "ait", "z", "rad", "rest", "ag", "arb", "arg", "comm", "work", "expr", "ay", "dict", "map", "bar", "data", "ab", "arm", "aug", "au", "buf", "compl", "urg", "addr", "mat", "all", "art", "int", "aaa", "db", "emb", "rand", "cl", "val", "days", "deg", "usr", "adj", "arch", "nt", "ray", "elt", "ack", "obj", "msg", "py", "good", "list"], "lignes": ["ligES", "lsignses", "Lignates", "lligists", "lliges", "loadies", "lgns", "lgnes", "longions", "Lignes", "Lgnes", "lsignies", "lsoads", "loads", "linsets", "linses", "linnes", "llignets", "longets", "lignses", "lsoadies", "linss", "lignmentates", "lligES", "lignies", "lgnES", "lignmentes", "linsES", "llignES", "lignments", "lgnates", "linsists", "Lgns", "linsions", "lignmenties", "longes", "lgnions", "linnates", "lignES", "Lignets", "Lgnions", "Lignions", "lignmentES", "ligns", "loades", "lligets", "lignates", "LgnES", "llignists", "ligets", "ligists", "Lgnets", "lgnses", "loadses", "lignets", "linns", "Ligns", "lsigns", "lignists", "lgnies", "linnets", "longs", "lignions", "lgnets", "linnists", "linnES", "lignmentses", "lsoadses", "Lgnates", "llignes", "liges", "LignES", "lsignes", "lsoades"], "cols": ["ylats", "ctsd", "cts", "columns", " coles", "columnns", "ignns", "colats", "columnats", "colns", "COLes", "COLs", "colps", "Colts", "Colps", "colxs", "ctss", "colds", "COLgs", "COLats", " colsd", "Cols", "columngs", "colsd", "colsb", " colats", "Colats", " colss", " colts", "igns", "llsb", " colns", "yles", " colps", "yls", "columnts", "columnxs", " colxs", "ignts", "Colds", "colss", "COLxs", "llsd", "ylds", "ignxs", "columnps", " colsb", "columnes", " colgs", "Coles", "llss", "coles", "ctsb", "colts", "colgs", "lls", " colds"], "y": ["p", "er", "col", "m", "yy", "ny", "axy", "uy", "w", "ot", "zy", "ya", "by", "c", "yt", "o", "ox", "key", "yu", "any", "sy", "ery", "yx", "kit", "ly", "sky", "yo", "yl", "out", "v", "ry", "hy", "gy", "cy", "yr", "z", "n", "g", "my", "year", "ay", "Y", "icy", "table", "ye", "ky", "wy", "yz", "vy", "iy", "ia", "ies", "hey", "ys", "ym", "ey", "index", "oy", "yk", "yn", "b", "yes", "fy", "ty", "yer", "xy", "yd", "sys", "yi", "py"], "x": ["p", "check", "e", "xes", "m", "max", "h", "name", "exclusive", "w", "d", "q", "xf", "el", "c", "lat", "step", "status", "ux", "color", "xs", "xxxx", "xxx", "wx", "o", "xp", "no", "ax", "ct", "ox", "key", "pe", "id", "true", "xa", "xt", "tx", "any", "xi", "left", "width", "on", "yx", "lex", "ix", "out", "xx", "v", "xml", "X", "history", "dx", "time", "mm", "z", "n", "g", "path", "f", "exp", "inx", "content", "l", "ext", "hello", "net", "xe", "ice", "fixed", "data", "fx", "right", "ic", "fill", "k", "rx", "xc", "ey", "mx", "only", "index", "yn", "yes", "xy", "ex", "px"], "arr2": ["err1", " arr4", "arrayelse", "arrif", "arrayif", "arr1", "arrTrue", " arrif", "arrayTrue", " arr8", "arr4", "arbelse", "arbTrue", "array4", "arb8", "err3", "arr8", " arrelse", " arr3", " arrTrue", " arr1", "array8", "arrelse", "array1", "arbif", "err2", "arr3", "err4", "array2", "array3"], "i": ["p", "ic", "li", "e", "it", "o", "io", "m", "h", "z", "n", "s", "id", "ti", "ini", "bi", "int", "si", "il", "xi", "u", "mi", "im", "ai", "on", "l", "pi", "ii", "ij", "ix", "di", "I", "zi", "c", "ie", "v", "ir", "ind", "ci"], "j": ["ji", "p", "jj", "k", "jl", "li", "col", "it", "jp", "o", "ijk", "m", "h", "key", "z", "n", "g", "ja", "bi", "si", "uj", "u", "J", "kj", "b", "dj", "l", "ij", "job", "jc", "ch", "ix", "di", "xy", "js", "c", "ie", "v", "ci"]}}
{"code": " \\n  \\n  data Test = Test {\\n        choix1 :: Int\\n      , table1 :: [[Int]]\\n      , choix2 :: Int\\n      , table2 :: [[Int]]\\n      } deriving Show\\n  \\n  data Solution = Bonne Int | BadMag | Cheat\\n  \\n  instance Show Solution where\\n      show (Bonne i) = show i\\n      show BadMag    = \"Bad magician!\"\\n      show Cheat     = \"Volunteer cheated!\"\\n  \\n  main = do\\n      interact (unlines . map showCase . zip [1..] . map (resoudre) . goTest . tail . lines)\\n  \\n    where\\n      goTest [] = []\\n      goTest ls =\\n          let (c1, t1, ls')  = goTable ls\\n              (c2, t2, ls'') = goTable ls'\\n          in Test c1 t1 c2 t2 : goTest ls''\\n  \\n      goTable (n:ls) =\\n          let c = read n\\n              (t, ls') = splitAt 4 ls\\n          in (c, map goLigne t, ls')\\n  \\n      goLigne = map read . words\\n  \\n      showCase :: (Int, Solution) -> String\\n      showCase (i, s) = printf \"Case #%d: %s\" i (show s)\\n  \\n  resoudre :: Test -> Solution\\n  resoudre Test {..} =\\n      let choisis1 = table1 !! (choix1 - 1)\\n          choisis2 = table2 !! (choix2 - 1)\\n          communs  = filter (`elem` choisis1) choisis2\\n      in case communs of\\n          [x]     -> Bonne x\\n          (_:_:_) -> BadMag\\n          []      -> Cheat\\n", "substitutes": {"Test": ["Runner", "Check", "Sample", "Study", "Score", "Filter", "New", "EST", "Dev", "Log", "Set", "Proof", "Ser", "Testing", "Example", "File", "It", "Query", "Save", "Root", "Point", "Empty", "Fixed", "This", "Reader", "Full", "Code", "Type", "Rest", "Sub", "Master", " test", "Result", "Split", "Spec", "Index", "Case", "Config", "Use", "Model", "Temp", "Ver", "Script", "Train", "Main", "Feature", "Fix", "Base", "Long", "Bed", "Node", "Section", "Val", "Default", "Handler", "Store", "Server", "Unit", "Site", "Transfer", "Def", "Table", "Title", "Target", "Start", "T", "Write", "test", "Data", "The", "All", "Top"], "data": ["partial", "next", "one", "default", "type", "reader", "DATA", "base", "source", "de", "go", "initial", "this", "graph", "time", "no", "family", "id", "zero", "bad", "example", "dev", "do", "meta", "name", "action", "full", "sample", "line", "unknown", "me", "when", "ata", "table", "read", "date", "debug", "di", "new", "file", "get", "ge", "Data", "da"], "show": ["se", "shift", "check", "esh", "store", "error", "how", "scale", "then", "see", "use", "set", "help", "when", "html", "skip", "disable", "by", "handle", "default", "open", "report", "How", "source", "toggle", "id", "raw", "dd", "where", "drop", "hand", "spect", "ch", "ows", "print", "select", "update", "str", "load", "display", "eye", "SH", "info", "she", "Sh", "echo", "hide", "message", "sche", "draw", "find", "make", "connect", "add", "new", "Show", "test", "size", " shows", "isl", "do", "shown", "last", "bind", "only", "index", "view", "shows", "sh", "figure", "include", "look", "get", "lower", "screen", "ind", " Show", "list"], "main": ["total", "mid", "root", "done", "day", "exit", "part", "start", "foo", " Main", "alt", "long", "sub", "id", "all", "example", "section", "full", "lay", "line", "left", "set", "blank", "home", "Main", "mult", "cd", "www"], "goTest": ["moSub", "goT", "Gotest", "GOTest", "GoSub", "GoSer", "GOTesting", "moFilter", " goTesting", "moSer", "moTable", "goSet", " goSample", " goSet", "moSet", "GoFilter", "goSub", " gotest", "GoTable", "goTable", "GoTest", "moT", " goRead", "goFilter", "coTest", "GOTable", "GoT", "goSample", "GoTesting", "GoSample", "coRead", "gotest", "goSer", "GoSet", "coTable", "goTesting", " goT", "moTest", "GOSample", "goRead", "cotest", "GoRead", " goFilter", " goSub", " goSer", " goTable"]}}
{"code": "def get_a(r, c, f='.'):\\n      A = []\\n      for i in xrange(r):\\n          A.append([f] * c)\\n      return A\\n  \\n  \\n  def apply(A, r, c, B):\\n      for i, b in enumerate(B):\\n          for j, v in enumerate(b):\\n              A[r + i][c + j] = v\\n  \\n  \\n  def draw(A):\\n      if A is None:\\n          return '\\nImpossible'\\n      res = ['']\\n      for a in A:\\n          res.append(''.join(a))\\n      return '\\n'.join(res)\\n  \\n  \\n  def trans(A):\\n      if not A:\\n          return None\\n      B = get_a(len(A[0]), len(A))\\n      for i, a in enumerate(A):\\n          for j, v in enumerate(a):\\n              B[j][i] = v\\n      return B\\n  \\n  \\n  def check(A, m, r, c):\\n      if A is None:\\n          return True\\n      cnts = {'c': 0, '*': 0, '.': 0}\\n  \\n      assert len(A) == r\\n      for i in xrange(r):\\n          assert len(A[i]) == c\\n          for j in xrange(c):\\n              cnts[A[i][j]] += 1\\n      assert cnts['*'] == m\\n      assert cnts['c'] == 1\\n      assert cnts['.'] == r * c - m - 1\\n  \\n  \\n  def CASE(IN):\\n      def rstr():\\n          return IN.readline().strip()\\n  \\n      def rint():\\n          return int(rstr())\\n  \\n      def rints():\\n          return map(int, rstr().split())\\n      r, c, m = rints()\\n      A = solve(m, r, c)\\n      if A:\\n          A[-1][-1] = 'c'\\n      check(A, m, r, c)\\n      return draw(A)\\n  \\n  \\n  def solve(m, r, c):\\n      if r > c:\\n          return trans(solve(m, c, r))\\n      assert r <= c\\n      assert m != r * c\\n      e = r * c - m\\n      if e == 1:\\n          A = get_a(r, c, '*')\\n          return A\\n      if r == 1:\\n          A = get_a(1, c, '.')\\n          for i in xrange(m):\\n              A[0][i] = '*'\\n          return A\\n      if r == 2:\\n          if e == 2 or e % 2 == 1:\\n              return None\\n          A = get_a(2, c, '.')\\n          assert m % 2 == 0\\n          for i in xrange(m / 2):\\n              A[0][i] = A[1][i] = '*'\\n          return A\\n      assert r >= 3\\n      A = get_a(r, c, '*')\\n      if e in (2, 3, 5, 7):\\n          return None\\n      E = [c] * (e / c) + ([e % c] if e % c else [])\\n      if sum(E) < e:\\n          E.append(e % c)\\n          assert sum(E) == e\\n      if len(E) == 1:\\n          E = [e / 2] * 2\\n          if sum(E) < e:\\n              e.append(1)\\n      if E[0] != E[1]:\\n          s = sum(E[:2])\\n          E[0] = E[1] = s / 2\\n          if sum(E[:2]) != s:\\n              assert len(E) == 2\\n              E.append(1)\\n      if E[-1] == 1:\\n          if len(E) > 3:\\n              E[-2] -= 1\\n              E[-1] += 1\\n          else:\\n              E[0] -= 1\\n              E[1] -= 1\\n              E[2] += 2\\n      for i in xrange(len(E)):\\n          for j in xrange(E[i]):\\n              A[-i - 1][-j - 1] = '.'\\n      return A\\n  \\n  \\n  def RUN(IN, OUT):\\n      t = int(IN.readline().strip())\\n      for i in xrange(1, t + 1):\\n          OUT.write(\"Case #%i: %s\\n\" % (i, CASE(IN)))\\n  \\n  if __name__ == \"__main__\":\\n      RUN(sys.stdin, sys.stdout)\\n", "substitutes": {"r": ["range", "br", "p", "rc", "ra", "er", "re", "err", "rs", "it", "o", "lr", "h", "nr", "ro", "rg", "z", "n", "rb", "g", "R", "ri", "ar", "ru", "w", "d", "tr", "u", "q", "l", "rr", "cr", "rar", "x", "sr", "attr", "dr", "mr", "rd", "rt", "ir"], "c": ["dc", "p", "ic", "rc", "k", "col", "cp", "cm", "o", "cur", "lc", "ct", "h", "cf", "n", "z", "con", "g", "cos", "ar", "cat", "cu", "d", "w", "cb", "u", "sc", "cs", "ec", "q", "cin", "uc", "y", "ac", "l", "cr", "co", "x", "cc", "mc", "ch", "C", "ca", "fc", "ce", "gc", "tc", "com", "ci"], "f": ["ft", "p", "k", "o", "fl", "h", "fab", "cf", "n", "g", "rf", "fg", "fb", "w", "d", "sf", "tf", "u", "fun", "q", "F", "ff", "fm", "l", "float", "fp", "fac", "fc", "ef", "fi", "fa"], "A": ["func", "D", "One", "Al", "MA", "U", "of", "As", "R", "Abs", "AT", "AR", "_", "F", "J", "SA", "M", "Z", "call", "At", "App", "K", "Av", "void", "Ax", "AL", "G", "NA", "AI", "AC", "AU", "Res", "GA", "Array", "C", "ACT", "JA", "S", "AM", "Alpha", "AP", "What", "form", "X", "RA", "L", "Bar", "Am", "Not", "CA", "You", "Art", "Y", "AN", "If", "new", "P", "AV", "And", "The", "All", "O", "ref", "BA", "New", "AA", "H", "Q", "all", "An", "Ar", "Ag", "only", "This", "RAM", "V", "Ab", "cont", "AB", "AF", "Some", "just", "N", "Answer", "LA", "obj", "AS", "I", "W", "AE", "HA", "T"], "i": ["gi", "ki", "hi", "ic", "p", "ji", "k", "ib", "li", "it", "ia", "o", "ik", "h", "id", "n", "z", "g", "ri", "phi", "ar", "ei", "int", "ini", "bi", "ti", "si", "u", "im", "mi", "xi", "y", "ai", "q", "ip", "l", "x", "pi", "ii", "ij", "iu", "di", "I", "zi", "ie", "ir", "ci"], "B": ["BF", "G", "O", "BC", "D", "BI", "BA", "IB", "H", "L", "U", "Br", "SB", "WB", "Bs", "BM", "Bar", "R", "Be", "Bo", "BB", "F", "J", "BS", "V", "Ab", "M", "RB", "AB", "Z", "Y", "N", "Array", "NB", "TB", "C", "Bu", "EB", "I", "P", "CB", "W", "BE", "BO", "DB", "T", "BR", "S", "Bern"], "b": ["br", "p", "bl", "o", "h", "bc", "bb", "z", "rb", "n", "g", "ba", "ar", "bi", "d", "w", "be", "u", "y", "db", "l", "bs", "ch", "ab"], "j": ["ji", "br", "p", "jj", "k", "fr", "li", "it", "jp", "o", "h", "z", "n", "g", "ja", "bi", "d", "pr", "uj", "q", "u", "y", "J", "kj", "dj", "l", "cr", "x", "ij", "ch", "obj", "js", "aj", "bj"], "v": ["br", "p", "bl", "qv", "o", "h", "z", "n", "vert", "g", "ve", "w", "u", "q", "y", "vc", "V", "vi", "var", "ev", "l", "val", "value", "vt", "vs", "ver", "uv", "iv", "av", "sv"], "res": ["rem", "p", "os", "inv", "str", "ra", "re", "er", "err", "rs", "ps", "ms", "reg", "rev", "ress", "rys", "ro", "reset", "results", "us", "rest", "R", "ret", "Res", "pres", "rez", "result", "na", "q", "RES", "ras", "pas", "ins", "RS", "ac", "rel", "gr", "out", "resp", "arr"], "a": ["ap", "au", "sa", "p", "la", "er", "re", "at", "area", "o", "h", "aq", "reset", "\u00e4", "ara", "n", "all", "xa", "an", "ba", "z", "ja", "ei", "aa", "ama", "ar", "am", "va", "ao", "w", "action", "d", "na", "u", "y", "ana", "ai", "ac", "ga", "l", "ae", "apa", "ata", "x", "pa", " ra", "oa", "aw", "al", "ea", "ca", "sha", "aj", "ach", "ak", "ab", "fa", "av"], "m": ["p", "k", "er", "fr", "re", "tm", "ms", "cm", "o", "mm", "h", "an", "z", "n", "g", "am", "ar", "perm", "um", "w", "d", "gm", "q", "u", "mi", "y", "im", "M", "mt", "l", "co", "x", "mc", "sm", "ma", "rm", "mr"], "cnts": ["cptS", "countjs", "cntjs", "cptns", "cctls", " cptjs", "csntps", "cctds", "cptds", "cCounts", "cCountS", "ccountjs", " cntps", "crentjs", "cptentials", "cCountns", " countps", "csNTs", "counts", "ccounts", "cntps", "csNTps", "ccts", "csntS", "crypts", " cntjs", "csNTls", "cNTls", "ccountentials", "cptls", " cntls", "dcnts", "cNTps", "csnts", " cptls", " cptentials", "conts", "cctS", "cNTns", "countps", "cryptps", "dcntS", " cntentials", "crents", "cntls", "dcntns", "cryptjs", "contls", "cptjs", " counts", "cntS", " cptps", "cNTjs", " cptds", "dcntxs", "dcNTS", "csNTS", "cNTS", "dcNTxs", "contps", "cctps", "cryptentials", "dcNTns", "cptps", "cptxs", "cntxs", "dcNTs", "cNTxs", "csntls", "cntentials", "cpts", "cNTs", "cntds", "contds", "cntns", "ccountps", " cntds", " cpts", "cCountxs", " countjs", "crentps"], "IN": ["TEXT", "Out", "DATA", "SOURCE", "PIN", "LINE", "ST", "IL", "MN", "UL", "R", "OM", "OU", "IC", "LIN", "INS", "STR", "USER", "IND", "INT", "In", "EX", "AN", "ML", "DERR", "Input", "RAW", "BL", "FILE", "EN", "HEAD", "INE", "IR", "inner", "ER", "READ"], "e": ["se", "p", "er", "type", "err", "re", "it", "o", "pe", "n", "g", "z", "en", "ei", "oe", "d", " ie", "u", "y", "ec", "me", "ue", "l", "ae", "x", "eu", "eff", "ce", "ate", "es", "ee"]}}
{"code": "def CASE(IN):\\n      def rstr(): return IN.readline().strip()\\n      def rint(): return int(rstr())\\n      def rints(): return map(int, rstr().split())\\n      def rr():\\n          x = rint()\\n          m = [rints() for i in xrange(4)]\\n          return set(m[x-1])\\n      s = rr().intersection(rr())\\n      if not s:\\n          return \"Volunteer cheated!\"\\n      if len(s) == 1:\\n          return s.pop()\\n      return \"Bad magician!\"\\n  \\n  \\n  def RUN(IN, OUT):\\n      t = int(IN.readline().strip())\\n      for i in xrange(1,t+1):\\n          OUT.write(\"Case #%i: %s\\n\" % (i, CASE(IN)))\\n  \\n  if __name__ == \"__main__\":\\n      RUN(sys.stdin, sys.stdout)\\n", "substitutes": {"IN": ["NULL", "TEXT", "Out", "DATA", "IT", "SOURCE", "GER", "FIL", "ST", "PIN", "LINE", "IL", "WD", "MN", "MODE", "UL", "TH", "OU", "STDOUT", "MM", "URL", "ON", "LIN", "ALL", "INS", "NAME", "INC", "STR", "USER", "LOC", "DIR", "USE", "IND", "INT", "In", "RE", "MIT", "AN", "DERR", "LL", "Input", "RAW", "BL", "out", "VALUE", "FILE", "CL", "ILL", "EN", "AL", "INE", "S", "GEN", "IR", "inner", "ER", "READ"], "x": ["p", "xs", "e", "X", "rx", "xes", "wx", "dx", "xp", "ax", "max", "ox", "z", "n", "xc", "xa", "xt", "tx", "mx", "index", "xi", "y", "xf", "xd", "ch", "ix", "xy", "ex", "c", "xx", "v"], "m": ["p", "em", "dm", "ms", "cm", "o", "mm", "hm", "n", "bm", "f", "mx", "d", "gm", "y", "mi", "mas", "r", "b", "M", "mt", "l", "mk", "mc", "sm", "mut", "ma", "mp", "mis", "mr", "c", "v"], "i": ["gi", "j", "ic", "p", "k", "li", "e", "it", "o", "key", "id", "n", "z", "ri", "name", "il", "ti", "ini", "index", "si", "d", "xi", "im", "y", "q", "counter", "r", "ai", "mi", "b", "ip", "u", "l", "pi", "ii", "ij", "ix", "di", "I", "zi", "c", "yi", "ind", "ci"], "s": ["res", "ns", "args", "sa", "xs", "ats", "sels", "aps", "rs", "ms", "ps", "ies", "sb", "ys", "ss", "strings", "n", "ls", "eds", "sol", "ds", "ws", "ims", "w", "d", "cs", "acts", "r", "its", "parts", "b", "ets", "ins", "hs", "l", "bs", "has", "uts", "rates", "ations", "ates", "ains", "abs", "js", "a", "sq", "ses", "c", "ries", "ts", "ches", "S", "sts", "gs"], "OUT": ["NULL", "O", "TEXT", "Out", "TN", "IT", "SOURCE", "ST", "IO", "Writer", "TH", "OU", "STDOUT", "AT", "TABLE", "PUT", "OT", "UT", "NAME", "V", "STR", "PATH", "USER", "DIR", "NT", "INT", "NR", "DERR", "RET", "RAW", "out", "FILE", "TO", "EN", "GROUP", "S", "Output"], "t": ["tt", "total", "p", "j", "tm", "it", "time", "z", "n", "g", " T", "f", "ti", "w", "dt", "y", "l", "ty", "tz", "ot", "te", "tu", "c", "ta", "v", "ts", "tc", "wt", "T", "pt", "tw"]}}
{"code": " \\n  \\n  \\n  class Minesweeper_2014_QC(puzutils.CodeJamProblem):\\n    def __init__(self, inputFilename):\\n      puzutils.CodeJamProblem.__init__(self, inputFilename)\\n  \\n      self.T = None\\n  \\n    def load(self):\\n      \"\"\"\\n        input:\\n  \\n        T (number of test cases)\\n  \\n        R C M (integers)\\n  \\n      \"\"\"\\n  \\n      self.tests = []\\n  \\n      with open(self.inputFilename, \"rt\") as file:\\n        self.T = int(file.readline().strip())\\n  \\n        for i in xrange(self.T):\\n          (R,C,M) = [int(x) for x in file.readline().split(' ')]\\n  \\n          self.tests.append([R,C,M])\\n  \\n      return True\\n  \\n    def boardToString(self, board):\\n      retval = \"\"\\n  \\n      for row in board:\\n        retval = retval + \"\\n\" + \"\".join(row)\\n  \\n      return retval\\n  \\n    def executeTest(self, test):\\n      \"\"\"\\n        Run a test and return output.\\n      \"\"\"\\n  \\n      (R,C,M) = test\\n  \\n      spaces = R * C\\n      blanks = spaces - M\\n  \\n      if (blanks <= 0):\\n        return \"Impossible\"\\n  \\n      board = [['.' for x in range(C)] for y in range(R)]\\n  \\n      board[R-1][C-1] = \"c\"\\n  \\n      badpositions=[]\\n      positions=[]\\n  \\n      for x in xrange(C):\\n        for y in xrange(R):\\n          if (x == (C-1)) and (y == (R-1)):\\n            continue\\n          if (x == (C-1)) and (y == (R-2)):\\n            badpositions.append((x,y))\\n            continue\\n          if (x == (C-2)) and (y == (R-1)):\\n            badpositions.append((x,y))\\n            continue\\n          if (x == (C-2)) and (y == (R-2)):\\n            badpositions.append((x,y))\\n            continue\\n  \\n          positions.append((x,y))\\n  \\n      positions.reverse()\\n  \\n      for x in badpositions:\\n        positions.insert(0, x)\\n  \\n      m = M\\n  \\n      while (m > 0):\\n        if len(positions) <= 0:\\n          return \"Impossible\"\\n  \\n        pos = positions.pop()\\n        (x,y) = pos\\n  \\n        if (board[y][x] != \".\"):\\n          return \"Impossible\"\\n  \\n        board[y][x] = '*'\\n        m = m - 1\\n  \\n      mines = sum([x.count('*') for x in board])\\n  \\n      if (mines != M):\\n        return \"Impossible\"\\n  \\n      if (blanks > 1):\\n        if (R > 1):\\n          if board[R - 2][C - 1] == \"*\":\\n            return \"Impossible\"\\n  \\n        if (C > 1):\\n          if board[R - 1][C - 2] == \"*\":\\n            return \"Impossible\"\\n  \\n        if (R > 1) and (C > 1):\\n          if board[R - 2][C - 2] == \"*\":\\n            return \"Impossible\"\\n  \\n      return self.boardToString(board)\\n  \\n  with Minesweeper_2014_QC(sys.argv[1]) as problem:\\n    problem.load()\\n  \\n    problem.run()\\n", "substitutes": {"self": ["app", "se", "python", "tmp", "p", "console", "e", "error", "h", "complete", "Test", "wrapper", "ls", "close", "spec", "name", "w", "shape", "ng", "full", "q", "local", "eth", "user", "r", "cert", "dig", "ins", "network", "ae", "instance", "review", "output", "debug", "details", "handle", "sub", "cmp", "s", "final", "github", "remote", "params", "config", "np", "rel", "pkg", "lex", "th", "print", "resp", "hw", "also", "response", "context", "sel", "form", "this", "reader", "rec", "time", "your", "public", "asm", "n", "info", "my", "sw", "table", "co", "add", "make", "new", "au", "res", "ref", "rs", "compl", "client", "request", "ren", "dev", "subject", "ws", "db", "me", "cl", "sh", "nt", "you", "input", "obj", "author", "sys", "object", "ind", "py", "other", "Self"], "inputFilename": ["baseSourceFile", "sourcefilename", "InputSourceFile", "outputFiles", "baseFilename", "imagefilename", "InputFiles", "imageFilename", "sourceFiles", " inputSourceFile", "outputfilename", "imageFile", "Inputfilename", "inputFiles", "outputFilename", "imageSourceFile", "InputFilename", " inputfilename", "basefilename", "inputFile", "sourceFilename", "InputFile", "inputfilename", " inputFile", "inputSourceFile", "outputFile", "baseFile", "sourceFile"], "T": ["Time", "D", "G", "O", "TT", "TN", "X", "t", "H", "TM", "L", "E", "Q", "A", "TV", "TL", "Test", "B", "TC", "TS", "TA", "PT", "F", "J", "V", "Z", "Y", "NT", "N", "WT", "GT", "Length", "TR", "TB", "CT", "K", "I", "P", "VT", "Int", "TED", "S", "TG"], "tests": ["values", "lists", "issues", "tested", "tools", "units", "times", "ctors", "drivers", "strings", "results", "suits", "testers", "modules", "files", "ests", "errors", "forms", "features", "runs", "tags", "classes", "boxes", "reports", "codes", "groups", "sections", "items", "types", "checks", "cases", "rows", "lines", "steps", "rules"], "i": ["ic", "ico", "e", "it", "io", "ior", "id", "z", "n", "ri", "int", "ti", "ini", "xi", "im", "r", "ai", "ip", "ix", "I", "ex", "ie", "ir", "ind", "ci"], "R": ["Range", "D", "G", "O", "COR", "Right", "New", "X", "JR", "Rank", "RA", "H", "L", "Reference", "U", "A", "CR", "Q", "Reg", "E", "DR", "RC", "Remote", "REM", "IR", "RG", "B", "RF", "Res", "SR", "Random", "AR", "RGB", "RES", "RAM", "Reader", "r", "J", "F", "Type", "V", "RO", "RS", "Rot", "Row", "Z", "Y", "PR", "Cor", "N", "NR", "RE", "TR", "GR", "RR", "ER", "K", "I", "RM", "P", "OR", "RT", "BR", "S", "MR", "Re", "Role"], "C": ["D", "CD", "BC", "Control", "U", "A", "Cl", "IC", "CC", "F", "CH", "Z", "VC", "CF", "K", "c", "MC", "Cond", "CW", "Category", "Co", "G", "Ch", "CM", "CN", "AC", "Chain", "CS", "Cons", "B", "From", "CV", "CE", "CI", "CON", "EC", "CO", "CT", "CG", "CP", "YC", "CU", "S", "Cache", "OC", "JC", "COR", "X", "L", "CA", "Y", "CNN", "DC", "P", "Cs", "O", "H", "CR", "Q", "E", "Cr", "Cos", "Craig", "SC", "V", "N", "I", "CB", "W", "CCC", "CL"], "M": ["D", "G", "VM", "Other", "O", "X", "cm", "MA", "GM", "TM", "L", "Q", "H", "CM", "E", "A", "MN", "MAX", "NM", "OM", "Mon", "MAN", "B", "PM", "MM", "JM", "MO", "F", "J", "IM", "Multi", "V", "Mode", "Manager", "Z", "Y", "LM", "N", "Length", "Ms", "MT", "MI", "ML", "OK", "Maker", "K", "I", "RM", "P", "Mc", "DM", "Size", "MC", "ME", "MS", "S", "AM", "MP"], "x": ["p", "check", "e", "ctx", "at", "t", "h", "name", "item", "w", "r", "xf", "el", "xd", "a", "c", "lat", "step", "ux", "hex", "xs", "xxx", "xxxx", "wx", "o", "xp", "ax", "ox", "key", "id", "xa", "xt", "tx", "ick", "xi", "on", "yx", "lex", "ch", "ix", "v", "xx", "xml", "rex", "X", "dx", "time", "z", "n", "f", "exp", "inx", "l", "xe", "xb", "fx", "zx", "one", "k", "act", "rx", "xc", "sex", "mx", "index", "xy", "ex", "px"], "board": ["menu", "bit", "form", "bo", "reader", "frame", "word", "background", "deck", "block", "error", "ro", "layout", "code", "window", "system", "control", "chain", "condition", "wheel", "loop", "line", "rank", "rot", "core", "mode", "bank", "player", "buffer", "channel", "table", "room", "sequence", "stream", "body", "back", "clip", "boards", "ack", "box", "runner", "void", "ward", "length", "Board", "bar", "controller", "bug", "lock", "comment", "case", "list"], "retval": ["alteval", "revals", "retbal", "retVal", " retVAL", "RETVAL", " retvalue", "RetVal", " retVal", " retvals", "returnval", " reteval", "RetVAL", "reteval", " Retval", "altval", " Retbal", "returnVal", "retvalue", "reVAL", "retVAL", "Retval", "Reteval", "Retbal", " retbal", " RetVal", "altVal", "RETval", "RETvals", "RETeval", "altVAL", "reval", "returnvals", "Retvalue", "reeval", "Retvals", "retvals", "returnvalue", "RETVal"], "row": ["form", "word", "col", "block", "error", "OW", "key", "ro", "run", "record", "raw", "name", "item", "wheel", "loop", "field", "tr", "user", "line", "entry", "r", "rect", "bow", "Row", "table", "ow", "order", "instance", "box", "runner", "ows", "roll", "feed", "bar", "arrow", "rows", "bug", "cell", "case", "pair"], "test": ["select", "function", "match", "bit", "open", "check", "form", "correct", "it", "master", "t", "command", "foo", "testing", "long", "txt", "block", "sub", "old", "key", "run", "script", "node", "Test", "true", "example", "control", "f", "ests", "top", "task", "section", "result", "loop", "sample", "set", "train", "write", "mode", "unit", " Test", "value", "val", "fake", "est", "query", "call", "ester", "instance", "message", "ctor", "mark", "te", "input", "execute", "string", "iter", "runner", "new", "second", "length", "mate", "valid", "py", "case"], "spaces": ["Spaces", "Spanks", "paces", "panks", "bspanks", "spans", "spaps", " spanks", "spanks", " spaps", "blans", "spacing", " spans", "pans", "blaces", "Spaps", "bspans", "bspaces", "Spacing", "pacing", "blacing", "Spans", "bspaps"], "blanks": ["BLacks", "blances", " blaces", "BLanks", "spances", "Blanks", "spacks", "spanks", "illands", "illaces", " blacks", "blacks", " blands", "Blacks", "blaces", "Blaces", "Blands", "blands", "BLaces", "BLances", "illanks", "illacks", "Blances"], "y": ["vy", "yt", "j", "story", "gy", "er", "iy", "cy", "t", "o", "ies", "hey", "yr", "yy", "h", "key", "z", "g", "ed", "hot", "ym", "ny", "ey", "uy", "my", "r", "yn", "b", "sy", "l", "ay", "ty", "ly", "Y", "you", "ye", "ch", "yer", "yl", "xy", "out", "yd", "by", "ya", "c", "wy", "ry", "v", "sys", "yi", "py"], "badpositions": [" badposits", " badnegresses", "badcompions", "badproables", " badposables", "badproitions", "goodPositions", "badproions", "badposresses", "badcondations", "badgenentials", "disabledgenitions", "badposentials", "badgenitions", "goodPosations", "badpoations", " badnegations", "bugposments", "badPosables", "badPositions", " badproits", "badpoitions", "badcompits", "badposments", "bugpositions", "badPOSresses", "badPOSations", "bugcondations", "disabledposions", "badPOSions", "goodPosresses", "bugcondions", "badcondions", "disabledpositions", "badPOSitions", "badcondresses", "badnegresses", " badnegions", "badPositiveness", "badposits", "disabledpositiveness", " badposions", "goodposresses", "bugposations", "badtopations", " badproables", " badproions", "badtopresses", "badtransitions", "badcondments", " badproitions", "badtransentials", "badPosresses", "badgenitiveness", "goodpositions", "badgenions", "badconditions", "badpoions", "disabledgenentials", " badposresses", "badcompitions", "badPosentials", "badPosits", "badpositiveness", "badposions", "badpoments", "badtransions", "disabledposentials", "badnegations", "badnegions", "badPosments", "goodposions", "badPosations", "badposables", "bugconditions", "disabledgenions", " badposations", "bugposions", " badnegitions", "badposations", "badPosions", "goodPosions", "badtopitions", "badnegitions", "disabledgenitiveness", "bugcondments", "badcompables", "badtransitiveness", "badtopions", "badproits", "goodposations"], "positions": ["Posions", " posers", "conditives", "formions", "posions", "osentials", "posentials", "Posations", "positionations", "ositions", "positionitions", " positives", "condions", "condations", "condits", "positives", "conditions", "posusters", "Posits", "condusters", "POSations", "ositives", "formitors", "Positors", "positors", "condentials", " positors", " posentials", "conditors", " posions", "Posers", " posations", "POSitions", "posits", "ositors", "POSions", "formitions", "posers", "conders", "positionions", "Posusters", "formits", "posations", " posusters", "Positions"], "m": ["p", "dm", "tm", "ms", "cm", "t", "mm", "n", "g", "bm", "f", "perm", "mn", "d", "gm", "im", "mi", "multi", "man", "r", "wm", "fm", "mt", "l", "mc", "mu", "sm", "mut", "mis", "mr", "c", "v"], "pos": ["po", "tmp", "os", "cho", "trans", "ps", "cond", "mat", "n", "Pos", "pro", "spec", "pres", "POS", "comp", "fun", "positive", "respons", " Pos", "nos", "options", "dis", "loc", "position", "diff", "lines", "neg"]}}
{"code": " \\n  \\n  \\n  class Magic_2014_QA(puzutils.CodeJamProblem):\\n    def __init__(self, inputFilename):\\n      puzutils.CodeJamProblem.__init__(self, inputFilename)\\n  \\n      self.T = None\\n  \\n    def load(self):\\n      \"\"\"\\n        input:\\n  \\n        T (number of test cases)\\n  \\n        A (answer to first question)\\n        x x x x\\n        x x x x\\n        x x x x\\n        x x x x\\n        B (answer to second question)\\n        x x x x\\n        x x x x\\n        x x x x\\n        x x x x\\n  \\n      \"\"\"\\n  \\n      self.tests = []\\n  \\n      with open(self.inputFilename, \"rt\") as file:\\n        self.T = int(file.readline().strip())\\n  \\n        for i in xrange(self.T):\\n          a = int(file.readline().strip())\\n          test = {'a': a}\\n          board = []\\n          \\n          for j in xrange(4):\\n            line = file.readline().strip()\\n            row = set([int(x) for x in line.split(' ')])\\n            board.append(row)\\n  \\n          test['aboard'] = board\\n  \\n          b = int(file.readline().strip())\\n          test['b'] = b\\n          board = []\\n          \\n          for j in xrange(4):\\n            line = file.readline().strip()\\n            row = set([int(x) for x in line.split(' ')])\\n            board.append(row)\\n  \\n          test['bboard'] = board\\n  \\n          self.tests.append(test)\\n  \\n      return True\\n  \\n    def executeTest(self, test):\\n      \"\"\"\\n        Run a test and return output.\\n      \"\"\"\\n  \\n  \\n      rowA = test['aboard'][test['a'] - 1]\\n      rowB = test['bboard'][test['b'] - 1]\\n  \\n  \\n      intersect = rowA.intersection(rowB)\\n  \\n  \\n      if (len(intersect) == 1):\\n        (element,) = intersect\\n        return element\\n      elif (len(intersect) == 0):\\n        return \"Volunteer cheated!\"\\n      else:\\n        return \"Bad magician!\"\\n  \\n  with Magic_2014_QA(sys.argv[1]) as problem:\\n    problem.load()\\n  \\n    problem.run()\\n", "substitutes": {"self": ["app", "se", "tmp", "p", "rem", "console", "settings", "h", "peer", "wrapper", "ls", "close", "spec", "w", "shape", "full", "q", "user", "eth", "local", "writer", "r", "instance", "body", "output", "mp", "debug", "details", "handle", "der", "soc", "private", "sub", "cmp", "sql", "selves", "record", "conf", "s", "final", "github", "parent", "params", "remote", "tx", "rou", "left", "config", "np", "rel", "pkg", "th", "print", "resp", "mr", "hw", "also", "response", "context", "sel", "ns", "form", "this", "reader", "worker", "err", "rec", "your", "time", "sp", "public", "asm", "n", "conn", "my", "sw", "so", "co", "table", "make", "new", "news", "au", "res", "ref", "rs", "compl", "client", "ren", "all", "dev", "subject", "ws", "builder", "view", "me", "cl", "nt", "you", "obj", "sys", "ind", "py", "Self"], "inputFilename": ["InputSourceFile", "imagefilename", "outputSourceFile", "imageFilename", "InputPath", " inputSourceFile", "outputfilename", "imageFile", "Inputfilename", "imagePath", "outputFilename", "imageSourceFile", "InputFilename", " inputfilename", "inputPath", "inputFile", "InputFile", "inputfilename", " inputFile", "inputSourceFile", "outputFile", " inputPath"], "T": ["D", "G", "TP", "TT", "TN", "t", "TM", "TY", "L", "A", "Q", "E", "TV", "TL", "R", "TH", "B", "TC", "TS", "TA", "PT", "F", "OT", "J", "V", "M", "NT", "N", "TR", "TB", "C", "CT", "TION", "K", "I", "P", "VT", "TED", "S", "TG"], "tests": ["packs", "tested", "tools", "times", "drivers", "stores", "results", "suits", "testers", "modules", "files", "ests", "fits", "ors", "ters", "outs", "apps", "features", "runs", "workers", "storms", "classes", "gets", "boxes", "downs", "reports", "groups", "codes", "sections", "types", "checks", "scripts", "locks", "cases", "lets", "services", "rows", "dds", "lines", "steps", "uploads", "videos", "rules"], "i": ["p", "li", "e", "it", "at", "ia", "t", "o", "io", "dx", "ox", "id", "z", "n", " y", "xi", " e", "y", "ai", "ij", "ix", "I", "ind", "ci"], "a": ["au", "app", "sa", "access", "alpha", "p", "la", "ami", "at", "ia", "t", "area", "m", "A", "sta", "an", " A", "am", "aa", "u", "ai", "aff", "ac", "ga", "auto", "ae", "instance", "aux", "ea", "add", "ma", "c", "admin"], "test": ["se", "label", "tmp", "check", "store", "t", "old", "sync", "node", "Test", "task", "spec", "rule", "full", "user", "set", "prop", "link", "port", "instance", "thread", "box", "iter", "search", "handle", "num", "match", "report", "testing", "key", "tx", "tf", "sample", "config", "each", "player", "pred", "est", "setup", "read", "ver", "device", "valid", "delete", "tag", "tested", "master", "cond", "zero", "ve", "info", "trip", "same", "train", "two", "server", "query", "ter", "file", "comment", "temp", "case", "pair", "trial", "type", "single", "fail", "dev", "section", "result", "tr", "index", "feature", "cross", "cont", "unit", "tab", "val", "pack", "te", "trace", "tc", "lock", "py"], "board": ["level", "bridge", "flo", "well", "bit", "bo", "bus", "butt", "beat", "oard", "deck", "ud", "ston", "block", "ro", "layout", "zero", "window", "fine", "control", "uro", "hang", "stroke", "chain", "loop", "be", "lay", "set", "head", "builder", "hold", "bang", "bank", "buffer", "bench", "room", "pool", "body", "back", "boards", "ack", "door", "box", "boarding", "runner", "bowl", "boot", "ward", "Board", "bar", "land", "floor", "bro", "black", "bug", "lock", "bd", "pair"], "j": ["ji", "p", "jj", "k", "ju", "li", "it", "jp", "t", "ct", "ox", "z", "n", "g", "ja", "w", "uj", "q", "_", "y", "r", "J", "dj", "el", "l", "oj", "ij", "ot", "jc", "ch", "ix", "js", "ion", "v", "bj", "ind"], "line": ["range", "Line", "day", "str", "word", "frame", "e", "col", "li", "piece", "lin", "linux", "no", "eline", "cond", "block", "LINE", " Line", "pe", "n", "lo", "stroke", "lined", "chain", "section", "page", "ner", "lay", "ine", "set", "dd", "entry", "byte", "link", "el", "cl", "point", "eno", "nl", "l", "co", "val", "ln", "xe", "lex", "liner", "string", "th", "iter", "vision", "phrase", "xy", "inline", "file", "v", "lines", "handle", "lock", "cell", "pair"], "row": ["range", "post", "day", "bo", "word", "frame", "col", "block", "ser", "ob", "ro", "key", "record", "node", "group", "field", "tr", "loop", "ner", "set", "dd", "r", "rect", "entry", "link", "scroll", "Row", "port", "co", "ow", "list", "batch", "box", "iter", "ows", "roll", "ward", "bar", "floor", "rows", "ry", "low", "way", "bug", "cell", "pair"], "x": ["hex", "xs", "check", "e", "xxx", "xxxx", "rx", "ctx", "xes", "wx", "X", "dx", "xp", "ax", "ct", "ox", "z", "n", "xc", "xa", " xx", "xt", "tx", "item", "w", "index", "ction", "xi", "inx", "xf", "on", "\u00e7", "l", "yx", "ln", "ij", "lex", "xe", "xd", "ix", "xy", "ex", "c", "xx", "v", "fx", "ci"], "b": ["p", "bit", "k", "bo", "e", "base", "t", "o", "bb", "bc", "z", "n", "g", "rb", "ba", "B", " eb", "bi", "d", "w", "be", "cb", " l", "y", "r", "nb", "lb", "bank", "l", "body", "c", "v", "wb", "ab", "bd", " db"], "rowA": ["boardA", "RowAn", "boardAR", "RowAE", "pairB", "rollA", "rowAE", "rollAn", "RowAR", "rowAn", " rowAE", "rowAR", "rollAE", "pairAE", " rowAn", "boardAE", "rollB", "rollAR", "pairA", "boardAn", "pairAn", "RowA"], "rowB": ["ryBI", " rowBI", " rowBC", "ryBR", "rowBI", "roB", "roBI", "rollA", "rowS", "roBR", "rowsA", "rowBR", "roS", "rollBC", " rowG", "rowBC", "rowsB", " rowS", "rollB", "ryB", " rowBR", "rollG", "ryS", "rowsBC", "rowG", "rowsG"], "intersect": ["intersection", "pairect", "interconnect", "Interrupt", "Intersection", "Interect", "Interchange", "Intersect", "conect", " intersection", "conrupt", "interaction", " interect", "pairsect", "consections", "intersections", "pairsection", "tersection", "Intersections", "interrupt", " intersections", "diffsection", "Interconnect", "diffchange", "diffsect", "consection", "pairaction", "conchange", "conaction", "Interaction", "terchange", "conconnect", "consect", "interect", "tersect", "terconnect", "diffrupt", "interchange"], "element": ["empty", "vector", "match", "lements", "er", "this", "e", "le", "article", "ele", "node", "group", "null", "section", "item", "field", "result", "sample", "set", "entry", "join", "el", "value", "val", "ment", "sect", "text", "sequence", "instance", "lement", "elt", "air", "string", "data", "component", "cell", "pair", "edge", "object", "Element"]}}
{"code": " \\n  f = open(sys.argv[1])\\n  T = int(f.readline())\\n  for test in range(T):\\n      R, C, M = map(int, f.readline().strip().split())\\n      Rorig = R\\n      Corig = C\\n      impossible = False\\n      grid = [['.' for i in range(C)] for j in range(R)]\\n  \\n      curr_coord = [0,0]\\n      while M > 0 and not impossible:\\n          if (C > R): # more columns - fill one in\\n              num_mines_in_column = R\\n              if M < R:\\n                  num_mines_in_column = min(R - 2, M)\\n              if num_mines_in_column <= 0:\\n                  impossible = True\\n                  break\\n              for ii in range(num_mines_in_column):\\n                  grid[curr_coord[0] + ii][curr_coord[1]] = '*'\\n              C -= 1\\n              curr_coord[1] += 1\\n              M -= num_mines_in_column\\n          else:\\n              num_mines_in_row = C\\n              if M < C:\\n                  num_mines_in_row = min(C - 2, M)\\n              if num_mines_in_row <= 0:\\n                  impossible = True\\n                  break\\n              for ii in range(num_mines_in_row):\\n                  grid[curr_coord[0]][curr_coord[1] + ii] = '*'\\n              R -= 1\\n              curr_coord[0] += 1\\n              M -= num_mines_in_row\\n  \\n      print \"Case #%d:\" % (test + 1)\\n      if impossible:\\n          print \"Impossible\"\\n      else:\\n          for ii in range(Rorig):\\n              for jj in range(Corig):\\n                  if grid[ii][jj] == '.':\\n                      if ii - 1 >= 0 and grid[ii-1][jj] == '*':\\n                          grid[ii][jj] = 'dirty'\\n                      elif jj - 1 >= 0 and grid[ii][jj-1] == '*':\\n                          grid[ii][jj] = 'dirty'\\n                      elif jj - 1 >= 0 and ii - 1 >= 0 and grid[ii-1][jj-1] == '*':\\n                          grid[ii][jj] = 'dirty'\\n  \\n          for ii in range(Rorig):\\n              for jj in range(Corig):\\n                  if grid[ii][jj] == 'dirty':\\n                      if ii + 1 < Rorig and grid[ii+1][jj] == '.':\\n                          grid[ii][jj] = '.'\\n                      elif jj + 1 < Corig and grid[ii][jj+1] == '.':\\n                          grid[ii][jj] = '.'\\n                      elif jj + 1 < Corig and ii + 1 < Rorig and grid[ii+1][jj+1] == '.':\\n                          grid[ii][jj] = '.'\\n                      else:\\n                          if ii != Rorig - 1 or jj != Corig - 1:\\n                              impossible = True\\n  \\n          if impossible:\\n              print \"Impossible\"\\n          else:\\n              grid[Rorig-1][Corig-1] = 'c'\\n  \\n              for ii in range(Rorig):\\n                  print \" \".join([val for val in grid[ii]])\\n  \\n  \\n", "substitutes": {"f": ["ft", "fd", "p", "bf", "fx", "fr", "df", "t", "o", "sp", "h", "cf", "uf", "fo", "af", "fg", "fb", "lf", "sf", "tf", "F", "r", "xf", "fm", "b", "l", "inf", "x", "feed", "fp", "file", "fc", "fs", "c", "v", "fn", "fa"], "T": ["D", "G", "TT", "TN", "X", "t", "L", "TM", "E", "Q", "TV", "XT", "TL", "TH", "B", "TS", "TA", "F", "J", "V", "Z", "Y", "NT", "N", "GT", "TR", "TB", "K", "I", "TX", "P", "W", "S"], "test": ["tt", "TT", " E", "t", " TD", "TM", " D", "Test", " X", "tr", " trial", " tmp", " TT", " temp", " J", " Tr", " ti", " iT", " N", " time", " Test", " P", " RT", " TM", "ter", " tc", " Ti", " tr"], "R": ["D", "G", "O", "X", "RA", "H", "L", "CR", "Q", "A", "E", "DR", "RG", "B", "RF", "Res", "SR", "F", "r", "J", "V", "RO", "RS", "Y", "N", "NR", "RE", "TR", "RR", "Rs", "K", "I", "RM", "P", "RT", "S", "MR"], "C": ["Co", "D", "G", "O", "JC", "COR", "L", "CR", "E", "A", "CM", "CN", "CS", "B", "Cos", "TC", "CE", "CC", "CI", "F", "WC", "CON", "J", "V", "Con", "N", "CO", "CT", "CP", "CF", "K", "I", "P", "YC", "CB", "c", "CL", "MC", "CU", "S", "Cs"], "M": ["D", "G", "VM", "H", "L", "m", "TM", "Mass", "E", "CM", "MN", "NM", "MAN", "B", "PM", "MM", "F", "J", "Multi", "V", "LM", "N", "MT", "MI", "I", "RM", "P", "DM", "MC", "MS", "S", "MR", "MP"], "Rorig": [" Roriginal", "Tcap", "GOrig", "TOrig", "Gorig", "Toriginal", "Rcap", " Rcap", "ROrig", "Torig", "Goriginal", "Roriginal", " ROrig", "Gcap"], "Corig": ["torig", " CorIG", "qualbit", "qualun", " Corun", "torbit", "torIG", "corun", "corIG", "qualig", "qualIG", " Corbit", "corbit", "torun", "corig"], "impossible": ["impure", "Impausible", " impacted", "depossible", "impossibility", " impossibility", "Impure", "expausible", "deport", "expure", " impure", "Impacked", "Impacted", "Import", "impacted", "Impossible", " impausible", "expossible", "depacked", "Impossibility", "impacked", " impacked", "depossibility", "expacted", "impausible"], "grid": [" Grid", "check", " grids", "Grid", "mask", "sim", "addr", "rid", "stack", "mat", "id", "code", "g", "tile", "scale", "chain", "cb", "cache", "cale", "work", "db", "complex", "dq", "debug", "xy", "cell", "dim", "num"], "i": ["gi", "ic", "k", "li", "ia", "o", "io", "z", "n", "s", "ei", "ti", "q", "u", "y", "im", "r", "b", "l", "x", "iu", "I", "c", "ie", "v", "ci"], "j": ["ji", "p", "k", "fr", "e", "jp", "o", "m", "h", "nr", "z", "n", "g", "d", "q", "r", "J", "b", "l", "un", "ij", "jc", "ch", "di", "ie", "v", "ir"], "curr_coord": ["curend_pos", "curr_loc", "curr_pos", "curend_loc", "curend_num", "curr_num", "curend_coord"]}}
{"code": " \\n  f = open(sys.argv[1])\\n  T = int(f.readline())\\n  for test in range(T):\\n      first_row_index = int(f.readline())\\n      first_row = []\\n      for ii in range(4):\\n          if (ii + 1) == first_row_index:\\n              first_row = f.readline().strip().split()\\n          else:\\n              f.readline()\\n      second_row_index = int(f.readline())\\n      second_row = []\\n      for ii in range(4):\\n          if (ii + 1) == second_row_index:\\n              second_row = f.readline().strip().split()\\n          else:\\n              f.readline()\\n      combined = [val for val in first_row if val in second_row]\\n  \\n      print \"Case #%d:\" % (test + 1), \"Bad magician!\" if len(combined) > 1 else \"Volunteer cheated!\" if len(combined) == 0 else combined[0]\\n  \\n  \\n", "substitutes": {"f": ["ft", "fd", "p", "bf", "form", "fr", "df", "t", "o", "fa", "fl", "h", "ct", "of", "cf", "fu", "uf", "z", "fo", "af", "rf", "fg", "exp", "fb", "full", "lf", "sf", "q", "tf", "i", "F", "r", "xf", "fm", "b", "l", "inf", "pi", "fed", "fast", "feed", "fp", "fac", "file", "fc", "fs", "c", "v", "fi", "fx", "fw"], "T": ["D", "G", "O", "TI", "TT", "TN", "X", "t", "L", "TM", "E", "Q", "Test", "R", "B", "TC", "TS", "TA", "F", "V", "M", "Y", "N", "GT", "TR", "C", "K", "I", "P", "S"], "test": ["trial", "j", "type", "this", "li", "single", "ite", "t", "time", "sim", "pe", "id", "Test", "true", "scale", "see", "int", "index", "trip", "set", "train", "tim", "unit", "est", "tri", "tif", "py", "te", "ver", "iter", "ter", "ice", "di", "ie", "tc", "fi", "show", "ind", "size", "tests", "case", "num"], "first_row_index": ["first_col_position", "first_row_Index", "first_col_Index", "first_col_key", "first_col_index", "first_row_position", "first_row_key"], "first_row": [" first_block", "firsttRow", "first_block", " first_rows", " first_line", "first_col", "primary_col", " first_rown", "primary_roll", "primary_rows", "firsttrows", " first_col", "first_rows", "firsttblock", "first_line", "first_roll", "first_Row", "first_rown", "firsttrow", " first_Row", "primary_row"], "ii": ["gi", "ki", "igi", "jj", "ami", "li", "ia", "nai", "aii", "iti", "irm", "iri", "isa", "umi", "sci", "phi", "ei", "qi", "see", "ti", "ini", "iat", "index", "si", "xi", "ina", "i", "mi", "ai", "iii", "vi", "iona", "chi", "vid", "ski", "pi", "ni", "ati", "tif", "II", "di", "zi", "oci", "fi", "yi", "iom", "ci", "sv"], "second_row_index": ["second_col_name", "second_row_address", "second_Row_position", "second_row_i", "second_col_Index", "second_row_Index", "second_Row_Index", "second_Row_index", "second_col_index", "second_Row_address", "second_row_name", "second_row_position", "second_col_i"], "second_row": ["second_col", "secondlyrow", "two_column", "second_column", "second___rows", " second_line", "secondlycolumn", "two_rows", " second_rows", "two_row", "second_pixel", "second_line", "two_line", "secondlycol", "two_col", "second___row", "two_pixel", "two_record", "second_record", "second___line", "secondlypixel", "second___record", "second_rows"], "combined": ["Combmented", "decline", "buffined", "combination", "comines", "comination", "buffmented", "combmented", "combinated", "Combination", "combines", "Comboded", "comoded", "clinated", "comboded", "comined", "Combine", "Combined", "Combinated", "combine", "declined", "cline", "clined", "declinated", "buffination", "clines", "cominated", "choinated", "declmented", "choines", "commented", "chomented", "buffoded", "comine", "choined", "clmented"], "val": ["gi", "vo", "ki", "cho", "col", "li", "t", "crit", "txt", " aval", "key", "id", "gold", "all", "true", "iff", "eq", "tx", "div", "item", "vet", "aval", "index", "sil", "i", "VAL", "gem", "rol", "pol", "iii", "aul", "typ", "var", "el", "value", "gu", "x", "viol", "bid", "vals", "new", "Val", "data", "v", "fi", "valid", "ind", "sel", "ci"]}}
{"code": "\"\"\"\\n  Google Code Jam 2014 Qualification Problem C\\n  Usage:\\n      python c.py < input.txt > output.txt\\n  \"\"\"\\n  \\n  \\n  def iter_neighbors(x, y, cells):\\n      columns = len(cells[0])\\n      rows = len(cells)\\n  \\n      if y > 0:\\n          if x > 0:\\n              yield x - 1, y - 1\\n          yield x, y - 1\\n  \\n          if x + 1 < columns:\\n              yield x + 1, y - 1\\n  \\n      if x > 0:\\n          yield x - 1, y\\n  \\n      if x + 1 < columns:\\n          yield x + 1, y\\n  \\n      if y + 1 < rows:\\n          if x > 0:\\n              yield x - 1, y + 1\\n  \\n          yield x, y + 1\\n  \\n          if x + 1 < columns:\\n              yield x + 1, y + 1\\n  \\n  \\n  def try_to_click(x, y, cells, remaining):\\n      if remaining == 0:\\n          return cells\\n  \\n      recent = []\\n  \\n      opened = 0\\n  \\n      for n_x, n_y in iter_neighbors(x, y, cells):\\n          if cells[n_y][n_x] == \"?\":\\n              cells[n_y][n_x] = \".\"\\n              opened += 1\\n              recent.append((n_x, n_y))\\n  \\n      if opened == remaining:\\n          return cells\\n  \\n      if opened > remaining:\\n          return []\\n  \\n      for n_x, n_y in recent:\\n          solution = try_to_click(n_x, n_y, copy.deepcopy(cells), remaining - opened)\\n          if solution:\\n              return solution\\n  \\n      return []\\n  \\n  \\n  def solve_problem(rows, columns, mines):\\n  \\n      for x in xrange(columns):\\n          for y in xrange(rows):\\n              cells = [[\"?\" for i in xrange(columns)] for j in xrange(rows)]\\n              cells[y][x] = \"c\"\\n              solution = try_to_click(x, y, cells, rows * columns - mines - 1)\\n  \\n              if solution:\\n                  return \"\\n\".join([\"\".join(row) for row in solution]).replace(\"?\", \"*\")\\n  \\n      return \"Impossible\"\\n  \\n  \\n  if __name__ == \"__main__\":\\n      num_of_cases = int(sys.stdin.readline().strip())\\n      for i in xrange(1, num_of_cases + 1):\\n  \\n          rows, columns, mines = map(int, sys.stdin.readline().strip().split())\\n  \\n          print \"Case #{0}:\\n{1}\".format(i, solve_problem(rows, columns, mines))\\n", "substitutes": {"x": ["p", "e", "ctx", "at", "xes", "t", "m", "le", "rame", "max", "h", "code", "ware", "name", "item", "w", "d", "full", "line", "r", "xf", "el", "to", "min", "xd", "ord", "a", "ce", "c", "search", "lat", "step", "ux", "hex", "xs", "xxxx", "wx", "o", "xp", "ax", "ct", "ox", "key", "id", "s", "xa", "tx", "xt", "any", "xi", "u", "left", "width", "on", "yx", "est", "lex", "back", "ix", "yl", "v", "xx", "xml", "X", "cy", "dx", "time", "z", "n", "g", "f", "inx", "point", "l", "content", "ay", "xe", "ice", "file", "nex", "fx", "right", "zx", "act", "k", "rx", "xc", "ace", "int", "mx", "index", "ty", "al", "xy", "ex", "px", "text"], "y": ["p", "col", "e", "t", "m", "yy", "h", "an", "hot", "ny", "axy", "uy", "w", "d", "_", "ya", "by", "c", "cell", "poly", "yt", "south", "o", "key", "yu", "any", "on", "sy", "ery", "yx", "ly", "sky", "ch", "yl", "ry", "v", "ony", "hy", "story", "gy", "cy", "yr", "z", "n", "g", "f", "my", "year", "ay", "Y", "icy", "ye", "dy", "wy", "ied", "vy", "fill", "type", "iy", "ier", "ies", "ys", "ym", "ey", "oy", "yn", "b", "yes", "ty", "yer", "xy", "yi", "py"], "cells": ["args", "images", "sels", "ells", " Cells", "units", "ctors", "games", "results", "blocks", "keys", "ports", "cod", "flows", "cache", "gets", "plays", "Cell", "bits", "ices", "locks", "holes", "terms", "odes", "products", "ses", "cell", "details", "ions", "actions", "comments", "cers", "xs", "less", "facts", "rings", "iques", "s", "files", "headers", "devices", "names", "acts", "hips", "parts", "boxes", "fields", "reports", "bs", "items", "types", "points", "phones", "vals", "rooms", "charges", "ows", "js", "tests", "values", "ns", "___", "strings", "letters", "els", "they", "ods", "grid", "classes", "cats", "content", "ews", "seconds", "cases", "lines", "ones", "olds", "bes", "ies", "csv", "papers", "eds", "versions", "faces", "cs", "workers", "scroll", "codes", "sections", "buff", "obj", "sheets", "tones", "frames", "ries", "objects", "jobs", "states", "windows"], "columns": ["columnnames", "Columnways", "chronways", "lengthS", "Columngroups", "colS", "minimumS", "colments", "chronensions", "columnifiers", "ifs", " Columnensions", "Columniffs", "subjectes", "colgroups", "colways", "columnensions", "columnways", "colt", "Columnifiers", "columnS", "minimums", "columnities", "Columnensions", " Columns", "lengths", "colensions", "chronifiers", "columniffs", "minimumensions", "lengthes", "chronnames", "Columns", "lengtht", "platformS", "alignments", "ifations", " Columnities", "platforms", "ifensions", "platformgroups", "columngroups", "coliffs", "aligns", "Columnes", "ColumnS", "colifiers", "ififiers", "ifities", "colations", "coles", "columnds", "platformensions", "alignensions", "cols", "columnations", "Columnnames", "colities", "subjects", "chrons", "chrones", "colds", "Columnations", "Columnments", "Columnds", "alignes", "minimumds", "columnments", "subjectiffs", "columnes", "subjectensions", "colnames", "columnt", "Columnt"], "rows": ["heads", "values", "olds", "xs", "months", "images", "issues", "rs", "relations", "uds", "times", "obs", "years", "ids", "modules", "results", "ios", "files", "blocks", "keys", "headers", "rown", "errors", "ports", "users", "flows", "reads", "dates", "orders", "names", "runs", "cs", "workers", "classes", "docs", "ins", "mins", "boxes", "fields", "reports", "groups", "posts", "ris", "bs", "ros", "sections", "items", "types", "rooms", "many", "ows", "cases", "views", "pages", "frames", "lines", "jobs", "states", "builders", "tests"], "remaining": ["Remaining", "resain", "reshained", "resgoing", "Remained", "resains", "reshaining", "remgoing", "Remains", "remain", " remgoing", "remained", "Remgoing", "remains", "reshains", "promained", "resaining", " remains", "promgoing", " remained", "resained", "Remain", "promaining", "reshain", " remain", "promain"], "recent": ["dom", "finals", "region", "connected", "modified", "reg", "used", "command", "history", "common", "given", "complete", "rent", "record", "window", "held", "later", "final", "relative", "seen", "example", "remote", "closed", "released", "registered", "random", "safe", "current", "restricted", "same", "related", "reported", "sequent", "created", "recorded", "days", "latest", "similar", "expected", "fresh", "release", " Recent", "sofar", "desc", "new", "many", "Recent", "good", "confirmed", "past", "windows"], "opened": ["open", "powered", "linked", "connected", "initialized", "raised", "induced", "used", "tested", "opens", "played", "held", "made", "worked", "ed", "shown", "joined", "closed", "started", "exclusive", "released", "issued", "registered", "activated", "ordered", "loaded", "created", "ened", "focused", "stretched", "successfully", "occupied", "enabled", "charged", "established", "locked", "balanced", "earned", "represented", "approved", "stated", "turned", "opening", "confirmed", "checked", "pressed"], "n_x": ["N_e", "nThexc", "ln_y", "n_xi", "on_x", "nXx", "on_xx", "n_e", "n_w", "n_key", "nXxf", " n_sex", "nxw", "ln_fx", "noxx", "nThesex", "nxx", "nxy", "N_x", "N_y", "nxxx", "on_y", " n_xc", "n_fx", "n___ex", "n_xt", "n_xf", "noxxc", "n___y", "ln_x", "nThey", " n_xi", "n_ex", "noxxf", "nThex", "n___x", "n___e", "n_sex", "N_ex", "noxy", "nXxc", "n_xc", " n_xt", "n_xx", "nXy", " n_xf", "on_w", "ln_key"], "n_y": ["dn___Y", " n_yt", "n_ry", " n2Y", "n_ym", "n_yr", "dn_ys", "n2ies", "current_x", "n7x", "n7y", " n2y", "n7vy", "n2Y", "nThevy", " n2yer", "nTheym", " n_yy", "dn_y", "n7Y", "n_ys", "n_ies", "n_Y", "n7yr", "n2yy", "current_vy", "current_yr", "n___ys", "n_yt", "np_vy", "n_yy", "current_y", " n_yl", "n7yt", "dn___y", "n___ny", "n2y", " n_Y", "n_vy", "np_y", " n_ies", "n___y", "nThey", "n_yer", "dn_Y", "dn_ny", "n___vy", " n_vy", "n2x", "n2yl", "nThery", "n_ny", "np_ym", "n___Y", "dn___ny", "n___ry", "n_yl", "dn___ys", " n_yer", "np_ry", " n2ies", "n___ym", "n2yer"], "solution": ["resolving", "convolution", " solved", "jsresolution", "ssigration", "ssolving", "Solved", "gsolve", "Sresolution", " solver", " solving", "convolve", " solve", "Solving", "sresolution", "jsolved", "ssolved", "solutions", "ssolver", "Solutions", "resolve", "ssolution", "resresolution", "gsolved", "solve", "ssansion", "convolved", "jsolve", "gsigration", "resolutions", "jsolution", "sansion", "convolutions", "resolution", "gsolution", "solver", " sigration", " solutions", "solving", " sansion", "gsresolution", "gsansion", "ssolutions", "Solution", "solved", "Solve", "sigration", "resolved"], "mines": ["serveds", "minsES", "sineds", "minces", "minseds", " minues", "tenions", "tenES", " minES", "tences", "Minues", "minsces", "sinees", "minses", "minsees", "minions", "serves", "minES", "sinions", "servees", "tenes", "Minces", "minsues", "mineds", "Minions", "Mines", "sines", "minees", "minsions", " minions", "minues", "servions", " minces"], "i": ["gi", "hi", "ic", "li", "it", "iy", "ia", "io", "ik", "ri", "il", "ti", "ini", "si", "xi", "im", "mi", "ai", "ip", "pi", "ii", "ij", "ix", "di", "ice", "zi", "ie", "v", "ir", "yi", "ci"], "j": ["ji", "jj", "k", "jl", "ju", "e", "ia", "o", "z", " vi", " ii", "ja", "jac", "uj", " iii", "ai", "kj", " dj", "dj", "oj", "ij", "jc", "di", "jas", "ie", "je", "aj", "py"], "row": ["post", "rc", "word", "col", "rx", "ob", "error", "OW", "key", "ro", "run", "record", "node", "ri", "raw", "rown", "rowd", "item", "tr", "user", "line", "entry", "r", " r", "val", "Row", "rep", "ow", "instance", "runner", "ows", "roll", "arrow", "ry", "cell", "bug", "test", " Row", "mod", "case", "pair"], "num_of_cases": ["num_ofxcases", "num_of__case", "num_of__cells", "num_of_tests", "num_ofxclasses", "num_of__cases", "num_of_cells", "num_Of_classes", "num_of_classes", "num_ofxtests", "num_Of_case", "num_Of_tests", "num_of__tests", "num_of_case", "num_Of_cases", "num_ofxcase"]}}
{"code": "\"\"\"\\n  Google Code Jam 2014 Qualification Problem A\\n  Usage:\\n      python a.py < input.txt > output.txt\\n  \"\"\"\\n  \\n  \\n  def solve_problem(first, first_rows, second, second_rows):\\n      intersection = set(first_rows[first - 1]) & set(second_rows[second - 1])\\n  \\n      if not intersection:\\n          return \"Volunteer cheated!\"\\n      elif len(intersection) > 1:\\n          return \"Bad magician!\"\\n      else:\\n          return intersection.pop()\\n  \\n  \\n  \\n  if __name__ == \"__main__\":\\n      num_of_cases = int(sys.stdin.readline().strip())\\n  \\n      for i in xrange(1, num_of_cases + 1):\\n          first_answer = int(sys.stdin.readline().strip())\\n          first_arrangement = [map(int, sys.stdin.readline().strip().split()) for x in xrange(4)]\\n  \\n          second_answer = int(sys.stdin.readline().strip())\\n          second_arrangement = [map(int, sys.stdin.readline().strip().split()) for x in xrange(4)]\\n  \\n          print \"Case #{0}: {1}\".format(i, solve_problem(first_answer, first_arrangement, second_answer, second_arrangement))\\n", "substitutes": {"first": ["third", "next", "basic", "default", "fr", "frame", "initial", "start", "part", "master", "lower", "minute", "pre", "success", "self", "before", "f", "top", "inter", "last", "upper", "full", "main", "local", "left", "current", "table", "primary", "month", "back", "st", "min", "th", "title", "prev", "major", "front", "fourth"], "first_rows": ["first_results", "second_users", "last_users", "first_ows", "second_ows", "first_runs", "second_runs", "last_ows", "last_results", "last_rows", "first_users"], "second": ["se", "third", "next", "south", "other", "video", "common", "secondary", "lo", "middle", "last", "six", "then", "section", "test", "another", "left", "sometimes", "two", "sec", "follow", "double", "latest", "server", "st", "bottom", "seconds", "never", "bowl", "low", "minimum", "lower", "Second", "small", "fifth", "fourth"], "second_rows": ["external_los", "two_results", "second_los", "external_rows", "second_users", "two_rows", "two_cells", "second_row", "second_cells", "two_row", "external_results", "second_results", "external_users"], "intersection": ["Intersector", "tertable", "Intersection", "interclusion", "Interclusion", "intererence", " interaction", "Intersect", "insect", "insector", "Intertable", "INTERsector", "intersaction", "interaction", " intererence", "intersections", "tersection", "tersections", "interserence", "Intersections", "interssection", "interssect", "INTERsect", "intersector", " intersections", "INTERclusion", " intertable", "intertable", "interssections", "intersclusion", "intersect", "Interaction", " intersect", "tersect", "insections", "INTERsections", "Intererence", "insection", "INTERsection"], "num_of_cases": ["num_of_lines", "num_of2tests", "num_of_tests", "num_Of_lines", "num_of2sections", "num_of_sections", "num_Of_case", "num_of2cases", "num_Of_tests", "num_of_case", "num_Of_cases", "num_of2lines"], "i": ["j", "p", "ic", "k", "__", "li", "e", "it", "ite", "t", "m", "isin", "n", "s", "z", " ii", " each", "f", "g", "name", " j", "ti", "ini", "d", " I", " it", "xi", "im", "y", "u", "r", "b", "l", "pi", "ix", "I", "a", "ex", "c", "v", "ir", "yi", "ind", "ci"], "first_answer": [" first_result", "firstxanswer", "firstxresult", " first_Answer", "First_response", "firstxwer", "First_Answer", "first_result", "first_response", "First_answer", "first_wer", "First_result", "first_Answer", "firstxAnswer", " first_wer"], "first_arrangement": ["first_angrangment", "first_angangements", "first_arrankuration", "first_arrrangements", "first_anganguration", "first_arrangeement", "first_arrongements", "first_angranguration", "first_arrankement", "first_rrangment", "first_rangements", "first_arrangment", "first_arrongement", "first_angangement", "first_arrangements", "first_rranguration", "first_rrangements", "first_angangment", "first_arrranguration", "first_arronguration", "first_rrangement", "first_arrrangement", "first_arrangeuration", "first_angrangements", "first_rangement", "first_ranguration", "first_arrongment", "first_arrankements", "first_arrankment", "first_rangment", "first_arrangeements", "first_arranguration", "first_arrrangment", "first_angrangement"], "x": ["ux", "check", "e", "X", "rx", "xes", "rax", "wx", "dx", "iw", "ax", "ct", "ox", "ross", "xt", "tx", "xi", "im", "sw", "inx", "xf", "iii", "\u00e7", "yx", "co", "xe", "ix", "ex", "plex", "fx", "ci"], "second_answer": ["second_answered", "second____answer", "second____swers", "second_result", "second____result", " second_swers", "second_case", " second_answered", " second_result", "second_swers", " second_record", "second____case", " second_case", "second_Answer", " second_Answer", "second_record"], "second_arrangement": ["second_arrongment", "second_arrANGment", "second_rrangements", "second_arrongements", "second_arrrangments", "second_rrangment", "second_rangment", "second_arrangeement", "second_arrrangement", "second_arrongement", "second_arrangements", "second_arrangEMENT", "second_arrANGements", "second_arrrangEMENT", "second_rangements", "second_arrrangment", "second_arrANGement", "second_rangEMENT", "second_rangments", "second_arrANGEMENT", "second_arrangment", "second_arrangeements", "second_rrangEMENT", "second_rrangments", "second_rangement", "second_arrrangements", "second_arrongEMENT", "second_rrangement", "second_arrongments", "second_arrangments"]}}
{"code": " if len(sys.argv) == 1:\\n      sys.stdin = open(\"C.in\")\\n  else:\\n      sys.stdin = open(sys.argv[1])\\n  \\n  def to_ints(s):\\n      return map(int, s.split())\\n  \\n  def get_ints():\\n      return to_ints(raw_input())\\n  \\n  sys.setrecursionlimit(4000)\\n  \\n  def fill(rows, cols, mines):\\n      seen = set()\\n      visited = set()\\n  \\n      def search(numbered, zeros, min_numbered):\\n          left = (rows * cols - mines) - len(numbered)\\n          if left == 0:\\n              raise StopIteration((numbered, zeros))\\n          if left < 0:\\n              return\\n          for n in xrange(min_numbered, len(numbered)):\\n              number = numbered[n]\\n              if number in zeros:\\n                  continue\\n              row, col = number\\n              neigh = []\\n              if row > 0:\\n                  if col > 0: neigh.append((row - 1, col - 1))\\n                  neigh.append((row - 1, col))\\n                  if col < cols - 1: neigh.append((row - 1, col + 1))\\n              if col > 0: neigh.append((row, col - 1))\\n              if col < cols - 1: neigh.append((row, col + 1))\\n              if row < rows - 1:\\n                  if col > 0: neigh.append((row + 1, col - 1))\\n                  neigh.append((row + 1, col))\\n                  if col < cols - 1: neigh.append((row + 1, col + 1))\\n              neigh = list(set(neigh) - set(numbered))\\n              zeros.add(number)\\n              search(numbered + neigh, zeros, n + 1)\\n              zeros.remove(number)\\n  \\n      try:\\n          for row in xrange(rows):\\n              for col in xrange(cols):\\n                  search([(row, col)], set(), 0)\\n      except StopIteration, e:\\n          numbered, zeros = e.message\\n          board = {}\\n          for row, col in numbered + list(zeros):\\n              board[row, col] = '.'\\n          if zeros:\\n              board[zeros.pop()] = 'c'\\n          else: # case where first click is on a number\\n              board[0, 0] = 'c'\\n          out = ''\\n          for row in xrange(rows):\\n              for col in xrange(cols):\\n                  out += board.get((row, col), '*')\\n              out += '\\n'\\n          return out.strip()\\n      return 'Impossible'\\n  \\n  n_cases = input()\\n  for case in xrange(1, n_cases + 1):\\n      rows, cols, mines = get_ints()\\n  \\n      result = fill(rows, cols, mines)\\n  \\n      print \"Case #%d:\" % case\\n      print result\\n", "substitutes": {"sys": ["python", "se", "ns", "src", "program", "func", "os", "console", "__", "std", "go", "Python", "exit", "io", "linux", "System", "util", "machine", "site", "rus", "ys", "sync", "pse", "Sys", "system", "dev", "req", "kernel", "lib", "shell", "spec", "proc", "iso", "process", "xi", "y", "init", "psy", "so", "sec", "phys", "nuts", "mk", "np", "tp", "usr", "nt", "dar", "sky", "thread", "math", "boot", "hw", "fs", "ry", "rt", "bin", "py", "windows"], "stdin": ["shins", "standardOut", " stdino", "shdin", "stddin", "standardout", "standardin", "shin", "wideout", " stddin", "stdins", " stdins", "shout", "wideino", " stdout", "wideOut", "stin", " stdOut", "stdino", "stdOut", "stdout", "stout", "stins", "standardino", "widein"], "s": ["se", "p", "str", "ats", "single", "source", "rs", "ps", "t", "m", "sl", "h", "ss", "g", "f", "ls", "spec", "sing", "q", "r", "its", "b", "ins", "qs", "string", "sv", "js", "sq", "c", "v", "S", "sb", "gs"], "rows": ["res", "heads", "ns", "months", "olds", "xs", "rc", "yrs", "rs", "ms", "los", "uds", "es", "max", "results", "roots", "blocks", "keys", "rown", "uns", "rolled", "users", "ors", "flows", "outs", "orders", "names", "runs", "ords", "r", "gets", "classes", "ins", "mins", "boxes", "cells", "days", "fields", "maps", "bs", "ews", "ris", "ros", "checks", "projects", "boards", "rooms", "ows", "views", "ums", "pages", "urs", "frames", "eeks", "lines", "objects", "ears", "right", "hops", "tests"], "cols": ["COLls", "columns", "cels", "COLins", " colabs", "COLs", "columnn", "colds", "colls", "colS", "celn", "chabs", "columnins", "celgs", "Cols", "columngs", "munds", "locls", "locins", "Colms", " colss", "colms", "columnms", "columnabs", "columnls", "colabs", "celabs", "chs", " colS", " colms", " colds", "columnts", "munabs", "divs", "divss", "COLts", "Colabs", "muns", "Colgs", "colss", " colls", " coln", "coln", "munS", " colgs", "locs", "divls", "widths", "columnds", "chls", "colgs", "widthss", "locts", "colts", "colins", "widthls", "columnS"], "mines": ["menials", "manials", "manes", "smallials", "menes", "mned", "minxes", "manions", "minses", "minions", "mnions", "smalled", "menxes", "mined", "minsials", " mined", "mnes", "mnials", "menions", "smallions", "smalles", "minials", "minsxes", "manxes", " minials", " minions", "minsions"], "seen": ["selected", "killed", "written", "used", "common", "existing", "held", "kept", "generated", "shown", "en", "rown", "own", "ordered", "holder", "found", "there", "named", "recorded", "marked", "read", "served", "new", "represented", "printed", "known", "drawn"], "visited": ["tified", "exited", "visended", "exended", "tended", "exitted", "exified", "titted", "versified", "versitted", "versited", "visified", "versended", "tited", "visitted"], "numbered": ["long", "solid", "generated", "lined", "osen", "line", "ordered", "loaded", "blank", "successful", "named", "occupied", "sequence", "filled", "still", "ered", "liner", "ned", "normal", "original", "mon", "itten", "num", "selected", "done", "linked", "initialized", "rawn", "umen", "edited", "rown", "straight", "born", "created", "ranked", "enos", "ln", "marked", "printed", "dated", "drawn", "matched", "killed", "connected", "modified", "tested", "layout", "made", "zero", "umbers", "another", "holder", "mentioned", "found", "NUM", "ten", "runner", "umbered", "signed", "lines", "nine", "next", "written", "centered", "los", "won", "elected", "shown", "started", "rolled", "uno", "colored", "aned", "limited", "even", "lower", "said"], "zeros": ["zedoses", "eroso", "zeroeros", "zerens", "zeol", "zoes", "silos", "zedos", "zios", "zerlements", "zeroses", "ozoses", "zops", "zograms", "ziol", "zerol", "zenos", "zlements", "zesos", "zenoes", "erososs", "zons", "zenoS", "siloS", "zol", "zerso", "zeroos", "zeo", "zerus", "zersos", "silOS", "zoss", "ozops", "neos", "zus", "zeroo", "zioes", "zerslements", "zesoes", "enzOS", "neeros", "zerOS", "zeoes", "ozens", "ozograms", "neo", "zerool", "zens", "zerops", "zero", "zo", "zeos", "enzoes", "zerons", "zelements", "zoS", "ozoes", "zesus", "zions", "zos", "enzens", "zeroS", "zeons", "zesoses", "zedoes", "zeroes", "zenOS", "erosos", "ezos", "neoss", "zoses", "zOS", "zedops", "ozos", "zereros", "zersoss", "ezoses", "erosoes", "enzos", "neoes", "zeross", "ozo", "ezus", "zeoss", "zerograms", "zeroograms", "siloes", "ozOS", "zerooes", "ezoes"], "min_numbered": ["min_umbered", "min___mon", "min_shown", "minute67shown", "max_colored", "min67shown", "minute67numbered", "min___umbered", "minute67umbered", "min67numbered", "min___numbered", "minute67mon", "max_shown", "minute_umbered", "max_numbered", "min___shown", "minute_mon", "min67umbered", "min_mon", "min_colored", "min67mon", "minute_numbered", "minute_shown"], "left": ["level", "next", "missing", "li", "half", "ll", "start", "Left", "long", "L", "le", "wrong", "no", "m", "off", "none", "all", "lo", "down", " Left", "small", "only", "loop", "size", "local", "lt", "l", "nl", "rel", "padding", "x", "below", "net", "loc", "min", "len", "center", "offset", "length", "low", "lower", "right", "inner"], "n": ["ns", "j", "p", "k", "nw", "ll", "t", "o", "m", "ind", "nr", "z", "node", "ne", "name", "nan", "mn", "index", "sn", "na", "u", "i", "y", "r", "nor", "nb", "nu", "bn", "l", "nl", "un", "x", "ln", "N", "nt", "nm", "a", "ul", "c", "nn", "nd", "num"], "number": ["next", "total", "one", "password", "word", "initial", "note", "long", "no", "block", "nr", "language", "none", "zero", "node", "record", "final", "name", "rown", "result", "uno", "another", "random", "line", "multiple", "na", "counter", "neutral", "byte", "money", "nom", "value", "member", "phone", "comment", "integer", "umber", "collection", "document", "notation", "negative", "NUM", "national", "Number", "position", "version", "string", "never", "normal", "length", "even", "original", "non", "inal", "object", "message", "num"], "row": ["fr", "re", "cur", "week", "char", "user", "line", "r", "ow", "batch", "box", "iter", "length", "arrow", "low", "cell", "num", "day", "bo", "word", "coll", "block", "ox", "ro", "run", "record", "raw", "rown", "rank", "rot", "ran", "dd", "rel", "ocr", "oh", "th", "ver", "rod", "ows", "uu", "dr", "gr", "ry", "sel", "rc", "form", "str", "rec", "ser", "zero", "wn", "sw", "Row", "co", "server", "month", "runner", "bar", "round", "our", "dir", "pair", "res", "post", "range", "ra", "frame", "rs", "addr", "rid", "tr", "entry", "rect", "scroll", "tab", "order", "pg", "roll", "rt", "mod", "bug"], "col": ["label", "rem", "count", "fr", "cur", "yy", "term", "con", "name", "proc", "char", "cat", "item", "pr", "comp", "prop", "var", "el", "min", "prev", "fc", "c", "cell", "mon", "num", "color", "day", "COL", "cp", "fl", "coll", "block", "cmp", "ct", "ox", "key", "nc", "tx", "rot", "rol", "pol", "sec", "rel", "child", "ell", "th", "mot", "pt", "ht", "br", "pat", "bl", "form", "str", "ll", "column", "sp", "doc", "cond", "path", "ann", "il", "ctl", "disc", "coord", "ol", "ac", "cor", "co", "table", "len", "file", "round", "pos", "aj", "cal", "fn", "dir", "res", "act", "ref", "cmd", "client", "mat", "Col", "int", "div", "cont", "tab", "val", "cl", "cycle", "nt", "loc", "obj", "roll", "non"], "neigh": ["nieig", "nesesh", "naagle", "nail", "annene", " kneir", "seig", " neig", "naollo", "neir", "niagle", "noteir", "nig", "nirog", "nil", "noteld", "nNeigh", "nigh", " nerox", "nider", "niir", "naigh", "ereigh", " neil", "neig", "neNeigh", "seob", "neil", "nesome", "neway", " nenel", " nerog", "nair", "naesh", "verog", "anneigh", "veigh", "uneollo", "anneld", "neag", "neob", "nyig", " neld", "niigh", "niag", "uneig", " neag", "nieil", "ereder", " neNeigh", "noteig", "noteigh", " kneway", "seigh", "neder", "uneigh", "veir", "seil", "diir", "nerog", "nir", "deir", "naag", "dild", "neesh", "nesig", "niig", "nagle", " kneig", " kneder", "diig", "neagle", "neollo", "narog", "nieob", "nychel", "nechel", "nirox", "ereagle", "deNeigh", "sechel", " neir", "senel", "nieigh", "nene", "uneir", "naome", "nyway", "seway", " nene", "niil", "nald", "nerox", "ninel", " kneagle", "nyigh", " neesh", "serox", "deigh", "neome", "neld", "nenel", "naob", "nane", "nesigh", "ereir", " neome", " neagle", "deig", " kneigh", "nyir", "diigh", "naig", "veil", "nyollo", " knechel"], "board": ["menu", "bo", "butt", "deck", "oard", "block", "won", "ro", "layout", " boards", "control", "stroke", "book", "failed", " clipboard", "loop", "uno", "line", "holder", "byte", "poll", "bang", "player", "bank", "pad", "hold", "buffer", "plate", "pool", "flow", "colored", "back", "boards", "ack", "balanced", "box", "runner", "boarding", "ward", "Board", "black", "controller", "land", "button", "cell", "lock", "design", "bd"], "pop": ["pick", "delete", "clear", "shift", "op", "end", "push", "max", "pull", "reset", "dot", "top", "last", "hop", "ip", "strip", "ext", "read", "drop", "bottom", "new", "prev", "crop", "paste", "sum", "Pop", "flush"]}}
{"code": " if len(sys.argv) == 1:\\n      sys.stdin = open(\"A.in\")\\n  else:\\n      sys.stdin = open(sys.argv[1])\\n  \\n  def to_ints(s):\\n      return map(int, s.split())\\n  \\n  def get_ints():\\n      return to_ints(raw_input())\\n  \\n  n_cases = input()\\n  \\n  for case in xrange(1, n_cases + 1):\\n      a_row, = get_ints()\\n      a_layout = [get_ints() for _ in range(4)]\\n      b_row, = get_ints()\\n      b_layout = [get_ints() for _ in range(4)]\\n  \\n      poss = set(a_layout[a_row - 1])\\n      poss.intersection_update(b_layout[b_row - 1])\\n  \\n      result = 'Bad magician!'\\n  \\n      if len(poss) == 0:\\n          result = 'Volunteer cheated!'\\n      elif len(poss) == 1:\\n          result = poss.pop()\\n  \\n      print \"Case #%d: %s\" % (case, result)\\n", "substitutes": {"sys": ["python", "se", "ns", "os", "console", "__", "std", "System", "linux", "cgi", "ys", "us", "pse", "req", "Sys", "system", "dev", "kernel", "shell", "lib", "usa", "proc", "iso", "process", "xi", "y", "module", "init", "psy", "sec", "phys", "nuts", "yes", "mk", "np", "usr", "nt", "dar", "math", "boot", "etc", "hw", "fs", "rt", "bin", "py", "windows", "num"], "stdin": ["shins", "descgin", "descOut", "shin", "stdgin", "stdins", "readout", "shgin", " stdins", "shout", "descin", "descout", "readOut", " stdout", " stdOut", "stdOut", "stdout", "readins", " stdgin", "descins", "readin"], "s": ["se", "p", "gs", "str", "ats", "single", "rs", "ps", "t", "m", "sl", "h", "ss", "n", "g", "f", "ls", "spec", "sing", "ws", "sample", "i", "r", "its", "b", "l", "qs", "input", "string", "a", "c", "v", "S", "say", "sb", "sv"], "n_cases": [" n_docs", "n_tests", "n00case", "n_results", "n00classes", "num_tests", "num_case", " n_results", "n00tests", "num_classes", "num_cases", "n_classes", "n_case", "n00cases", "n_docs"], "case": ["trial", "custom", "day", " cases", "client", "block", "zero", "id", "ace", "example", "nce", " CASE", "rule", "chain", "CE", " day", "condition", " trial", "use", "i", "set", "catch", "mode", " test", "board", " face", " c", "Case", "cycle", "sequence", "instance", " Case", " when", "connection", "cases", " so", "ASE", "ice", "ase", "ce", "c", " line", "bug", "test"], "a_row": [" a_rows", "a_col", "a1server", "aj_row", " a_col", "a1roll", "a1row", "a_roll", "aj_roll", "a1block", "aj_block", " a_ro", "aj_server", "a_block", "a_rows", "a_ro", "a_server"], "a_layout": ["a2layout", "A_layout", "A_Layout", "A_pool", "a_paper", "atxpaper", "a2paper", "A_layer", "atxlayer", "oa_paper", "a2setup", "a_setup", "oa_layer", "a2layer", "a_Layout", "oa_layout", "a_pool", "oa_setup", "atxsetup", "a_layer", "atxlayout"], "_": ["Time", "D", "__", "___", "all", "Local", "let", "____", "\u00e7", "x", "ix"], "b_row": ["a_frame", "bJtime", "bJcol", "a_col", "b_rows", "b_frame", "bptrow", "b2time", "b2col", "b2block", "bJrow", "b2row", "a_time", "bptrows", "b_block", "bJblock", "bptcol", "b_time", "a_block", "a_rows", "bptframe", "b_col"], "b_layout": ["b_base", " b_base", "b_offset", "b_lay", "bmssetup", "a_setup", "a_offset", "a_position", "b_position", "bmslayout", "bmsoffset", " b_lay", "b_setup", "bmsposition"], "poss": ["pobs", "composs", " poses", "compobs", "probs", "pose", "psois", "paloss", "Ploss", "psose", " pose", "lposes", "compos", "psobs", "permobs", "prOSS", "Pulse", "pois", "lposs", " pobs", "plasses", "Poss", "psos", "lpass", " passes", "lpois", "ploss", "psossible", "Pobs", "ploses", "psass", "prloss", "psasses", "plOSS", " pOSS", "psOSS", "pross", " pois", "poses", "psoss", "permos", "passes", "prulse", "paoss", "permossible", "pOSS", "permoss", "lpasses", "paobs", "paulse", "pulse", "lpOSS", "pos", "possible", "prose", "compossible"], "result": ["res", "answer", "reason", "match", "default", "type", "the", "report", "prefix", "product", "ful", "error", "relation", "success", "complete", "grade", "results", "term", "final", "ret", "name", "goal", "summary", "user", "neutral", "r", "cert", "successful", "view", "successfully", "unknown", "Result", "value", "html", "RESULTS", "output", "format", "title", "mail", "out", "status", "mate", "short", "search", "response", "description", "test", "valid", "comment", "message"]}}
{"code": " \\n  NEIGHBOURS = [\\n      (-1, -1), (-1, 0), (-1, 1),\\n      ( 0, -1),          ( 0, 1),\\n      ( 1, -1), ( 1, 0), ( 1, 1),\\n  ]\\n  \\n  MOVES = [(-1, 0), (1, 0), (0, 1), (0, -1)]\\n  \\n  def valid(size, location, changes):\\n      y, x = location\\n      for y1, x1 in changes:\\n          y1 += y\\n          x1 += x\\n          if y1 < 0 or y1 >= size[0]:\\n              continue\\n          if x1 < 0 or x1 >= size[1]:\\n              continue\\n          yield (y1, x1)\\n  \\n  def click(size, grid, location):\\n      y, x = location\\n      if grid[y][x] is 0:\\n          return None\\n  \\n      grid = [row[:] for row in grid]\\n      grid[y][x] = 0\\n  \\n      for y, x in valid(size, location, NEIGHBOURS):\\n          if grid[y][x]:\\n              grid[y][x] = False\\n  \\n      return grid\\n  \\n  def sweep(R, C, M):\\n      grid = [[True] * C for _ in range(R)]\\n      size = (R, C)\\n  \\n      if M + 1 == R * C:\\n          grid[0][0] = False\\n          return grid, (0, 0)\\n  \\n      states = []\\n      for y in range(R):\\n          for x in range(C):\\n              location = (y, x)\\n              states.append((click(size, grid, location), location))\\n  \\n      while states:\\n          grid, location = states.pop(0)\\n  \\n          mines_count = sum([sum(row) for row in grid])\\n          if mines_count == M:\\n              return grid, location\\n  \\n          if mines_count < M:\\n              continue\\n  \\n          for new_location in valid(size, location, NEIGHBOURS):\\n              new_grid = click(size, grid, new_location)\\n              if new_grid:\\n                  states.insert(0, (new_grid, new_location))\\n  \\n      return None\\n  \\n  def validate(size, grid, location):\\n  \\n      result = [row[:] for row in grid]\\n  \\n      y, x = location\\n      result[y][x] = sum([\\n          grid[y1][x1]\\n          for y1, x1 in valid(size, (y, x), NEIGHBOURS)\\n      ])\\n      assert result[y][x] == 0\\n  \\n      seen = set([location])\\n      locations = set([location])\\n  \\n      while locations:\\n          location = locations.pop()\\n          for y, x in valid(size, location, NEIGHBOURS):\\n              assert grid[y][x] is not True\\n              result[y][x] = sum([\\n                  grid[y1][x1]\\n                  for y1, x1 in valid(size, (y, x), NEIGHBOURS)\\n              ])\\n              if result[y][x] == 0 and (y, x) not in seen:\\n                  locations.add((y, x))\\n                  seen.add((y, x))\\n  \\n      for row in result:\\n          for col in row:\\n              assert col is not False\\n  \\n      for y, row in enumerate(result):\\n          output = ''\\n          for x, col in enumerate(row):\\n              if col is True:\\n                  output += '*'\\n              else:\\n                  output += str(col)\\n          print output\\n  \\n  \\n  def process(case, R, C, M):\\n      result = sweep(R, C, M)\\n  \\n      print 'Case #%d:' % (case + 1)\\n      if not result:\\n          print 'Impossible'\\n          return\\n  \\n      grid, location = result\\n      for y, row in enumerate(grid):\\n          output = ''\\n          for x, col in enumerate(row):\\n              if (y, x) == location:\\n                  output += 'c'\\n              elif col:\\n                  output += '*'\\n              else:\\n                  output += '.'\\n          print output\\n  \\n  \\n  \\n  def main():\\n      cases = int(sys.stdin.readline())\\n  \\n      for case in range(cases):\\n          R, C, M = map(int, sys.stdin.readline().split())\\n          process(case, R, C, M)\\n  \\n      return\\n      for case in range(100):\\n          R = random.randrange(51) + 1\\n          C = random.randrange(51) + 1\\n          M = random.randrange(R * C - 1) + 1\\n          process(case * 100000 + M - 1, R, C, M)\\n  \\n  \\n  if __name__ == '__main__':\\n      main()\\n", "substitutes": {"NEIGHBOURS": ["NEIGHSBOUNRS", "NEIGHBOUNrs", "NEIGHSBOUNLS", "NEIGHBOWRs", "NEIGHBANKLS", "NEIGHBROUNRS", "NEIGHBOULS", "NEIGHBROWLS", "NEIGHBROWRS", "NEIGHBANPS", "NEIGHBOOrs", "NEIGHSBOULS", "NEIGHBouPS", "NEIGHBANRS", "NEIGHBANKRS", "NEIGHBOUrs", "NEIGHBROUPS", "NEIGHBROURs", "NEIGHBROURS", "NEIGHSBOURS", "NEIGHBROUNRES", "NEIGHBOWRS", "NEIGHBOURES", "NEIGHBouLS", "NEIGHBOWPS", "NEIGHBOUNLS", "NEIGHBOUNRs", "NEIGHBOUNRS", "NEIGHBOUPS", "NEIGHBANKPS", "NEIGHBROURES", "NEIGHBOUNRES", "NEIGHBours", "NEIGHBANLS", "NEIGHBROULS", "NEIGHBOURs", "NEIGHBOWRES", "NEIGHBOORS", "NEIGHSBOUNPS", "NEIGHSBOUPS", "NEIGHBROWRs", "NEIGHBANRs", "NEIGHBOOPS", "NEIGHBOWLS", "NEIGHSBOUrs", "NEIGHBANKRES", "NEIGHBOUNPS", "NEIGHBROUNLS", "NEIGHBROWPS", "NEIGHBouRS", "NEIGHSBOUNrs", "NEIGHBOOLS", "NEIGHBROUNPS"], "MOVES": ["DMOVALS", "MANGED", "MANGES", "MACHED", "MANGes", "MOVALS", "MOTALS", "DMOVED", "DMACHALS", "DMACHED", "MOVED", "DMOVES", "MACHES", "MOTes", "MACHes", "DMACHes", "DMACHES", "MOVes", "MACHALS", "MOTED", "MANGALS", "MOTES", "DMOVes"], "size": ["range", "function", "empty", "city", "speed", "color", "owner", "storage", "count", "type", "south", "space", "source", "settings", "start", "area", "time", "m", "zone", "zero", "window", "z", "n", "style", "group", "example", "general", "scale", "capacity", "name", "grow", "see", "radius", "small", "SIZE", "shape", "power", "sn", "ze", "index", "set", "width", "dim", "mode", "year", "ize", "unit", "number", "cycle", "resolution", "position", "height", "format", "dimension", "false", "device", "length", "news", "c", "Size", "now", "sum", "scope", "ger", "square"], "location": ["behavior", "function", "menu", "owner", "initial", "command", "direction", "peer", "node", "option", "name", "move", "local", "line", "instance", "communication", "Position", "position", "connection", "height", "box", "length", "original", "cell", "description", "vector", "color", "region", "go", "o", "usage", "slot", "action", "sample", "where", "number", "resolution", "directory", "creation", "center", "origin", "modified", "history", "time", "zone", "resource", "layout", "address", "zero", "selection", "coord", "copy", "Location", "uration", "point", "member", "density", "collection", "document", "ocation", "file", "ion", "translation", "localhost", "comment", "range", "storage", "type", "expression", "reference", "relation", "capacity", "present", "condition", "entry", "value", "loc", "place", "definition", "trace", "scope", "message"], "changes": ["values", "comments", "weights", "args", "xs", "settings", " modifications", "rs", "history", "times", "results", " change", "keys", "params", "errors", "grades", "change", "dates", "names", "Changes", "content", "codes", "options", "items", "changed", "changing", "views", "diff", "rows", "lines", "steps", " jumps", "details", "es", "ions", "places", "actions", " moves", " updates"], "y": ["p", "e", "at", "t", "io", "m", "aily", "yy", "h", "an", "node", "hot", "ny", "top", "axy", "uy", "page", "w", "user", "set", "cache", "r", "ot", "asy", "height", "ya", "by", "a", "c", "yt", "o", "no", "ox", "key", "chain", "on", "sy", "yx", "ly", "sky", "ch", "yo", "yl", "out", "v", "ry", "entity", "gy", "cy", "yr", "z", "n", "g", "address", "zero", "i", "my", "l", "ay", "Y", "ye", "wy", "sat", "vy", "j", "type", "iy", "ies", "client", "ys", "lon", "ym", "ey", "index", "oy", "yn", "b", "ip", "yes", "ty", "fy", "yer", "xy", "yd", "sys", "yi", "py"], "x": ["ux", "p", "color", "xs", "e", "xxx", "X", "rx", "xes", "t", "wx", "column", "dx", "m", "xp", "time", "cy", "ax", "h", "ox", "key", "success", "z", "n", "xc", "true", "xa", "f", "xt", "tx", "then", "exp", "exclusive", "name", "mx", "w", "index", "only", "any", "xi", "i", "left", "width", "axis", "inx", "xf", "r", "cox", "el", "point", "l", "yx", "content", "xe", "xd", "ix", "yl", "xy", "length", "a", "ex", "px", "c", "v", "xx", "right", "zx", "status", "pair"], "y1": [" yx", " yOne", "yy0", "oyOne", " y0", "y001", "x4", "eyone", "ey2", "x2", "x3", "nyOne", "ey4", "eyx", "yy2", "cyOne", "iy1", "oy0", "y4", "y0", "yyOne", "eyOne", "xOne", " y91", "ny0", "ey1", " y3", "iyOne", "cy1", "oy1", "y2", "yx", "Y0", "yy1", "iy0", "x0", "YOne", "yy91", "y91", "Y1", " y2", "x001", " y4", "oy001", "y3", "cyone", "ryOne", "ny1", "ny001", "Y2", "ry1", "yy3", "nyone", "xx", "ry91", "yOne", "iy2", "ry0", "yone"], "x1": ["x9", "xnum", "xx1", "rx01", "ix001", "xxone", "ix1", "ax1", "wx1", "xxOne", "x2", "axOne", "fx1", "rx1", "ixnum", "xOne", "xx2", "x001", "x01", "ax9", "z1", " x01", "zOne", "x91", "rxone", "ix91", "ix0", "ox1", "fx0", "xx01", "xone", " xOne", "ynum", "y9", " xone", " x001", "yOne", "wx001", "fx91", " xnum", "ox001", " x91", " x0", "x0", "z9", "fx001", " x2", "rx2", "rxOne"], "grid": ["empty", "raid", "func", "clear", "dom", "check", "domain", "week", "window", "node", "fine", "wrapper", "close", "jac", "line", "cache", "set", "module", "hold", "network", "filled", "age", "tree", "position", "connection", "box", "debug", "gc", "cell", "lat", "status", "rage", "region", "util", "block", "manager", "mg", "record", "held", "final", "tile", "github", "remote", "chain", "lay", "config", "ga", "setup", "back", "device", "out", "confirmed", "edge", "valid", "cfg", "square", "form", "load", " grids", "modified", "mask", "column", "graph", "array", "success", "layout", "address", "zero", "g", "group", "grow", "copy", "current", "work", "state", "content", "cells", "query", "table", "fresh", "draw", "flow", "net", "gate", "new", "fixed", "map", "file", "lag", "data", "header", "queue", "play", "dim", "test", "range", "res", "storage", "frame", "Grid", "login", "client", "addr", "rid", "active", "gm", "wire", "multi", "entry", "db", "view", "wrap", "buffer", "browser", "order", "figure", "holding", "locked", "trace", "get", "bag", "rows", "model", "game", "list"], "row": ["range", "post", "res", "day", "rc", "word", "frame", "cy", "column", "sel", "m", "lock", "block", "roy", "error", "ro", "key", "run", "record", "week", "node", "lo", "rown", "page", "item", "tr", "index", "w", "change", "user", "copy", "line", "sc", "entry", "r", "state", "view", "byte", "value", "Row", "board", "server", "ow", "co", "month", "loc", "batch", "box", "roll", "xy", "ward", "length", "bar", "may", "ready", "square", "arrow", "rows", "ry", "now", "cell", "mod", "step", "status", "pair"], "R": ["D", "G", "X", "RA", "H", "L", "U", "CR", "Q", "A", "E", "DR", "B", "RF", "SR", "Res", "AR", "Mr", "F", "r", "V", "RO", "RS", "Y", "N", "NR", "RE", "TR", "GR", "RR", "Rs", "K", "I", "RM", "P", "RT", "T", "BR", "S", "MR"], "C": ["Co", "D", "G", "O", "JC", "Ch", "COR", "X", "H", "L", "Cal", "U", "CR", "E", "Q", "CM", "A", "Count", "CS", "B", "CV", "SIZE", "CC", "F", "V", "Y", "Cor", "N", "CT", "K", "I", "P", "CB", "W", "c", "CL", "Size", "CU", "T", "S", "Cs"], "M": ["D", "G", "O", "X", "H", "L", "m", "U", "E", "Q", "CM", "NM", "MAN", "B", "MM", "SIZE", "F", "V", "Z", "Y", "N", "MI", "K", "I", "RM", "P", "W", "DM", "Size", "MC", "T", "MS", "S", "MR"], "_": ["t", "m", "ct", "ox", "all", "con", "on", "ac", "val", "ay", "ation", "ow", "ix", "mult", "ex", "ge", "c", "non", "mod"], "states": ["res", "values", "comments", "ages", "args", "utters", "finals", "guards", "storage", "settings", "history", "ands", "games", "obs", "agents", "ids", "stores", "stories", "results", "sites", "files", "roots", "blocks", "devices", "itions", "errors", "versions", "ports", "outs", "flows", "dates", "events", "lights", "workers", "state", "cells", "pins", "groups", "chains", "sections", "ations", "rates", "items", "resources", "points", "rooms", "seconds", "charges", "status", "ags", "services", "frames", "doms", "States", "lines", "ifications", "steps", "ts", "jobs", "rows", "ates", "actions", "stats", "gs"], "mines_count": ["mines____only", "minese_ctr", "minese_sum", "mines_sum", "minese____only", "mines____count", "mineters_sum", "mines____sum", "mines_number", "minese____count", "mineters_number", "minesses_info", "mines_info", "mines____ctr", "mineters_count", "mines_ount", "minessesrettyount", "minesrettyinfo", "minessesrettycount", "mines_only", "minese_count", "minese_only", "minessesrettyinfo", "minese____ctr", "minesrettycount", "mines_ctr", "minesrettyount", "minesses_ount", "minese____sum", "minesses_count"], "new_location": ["new_loc", " new_loc", "New_direction", " new_behavior", "new_node", "New_Location", "New_loc", "new_direction", " new_position", "new_Location", "new_behavior", "New_location", " new_node", "new_position"], "new_grid": ["new_cell", " new_row", "new___managed", "new___lag", "newnewmanaged", "next___lag", "new_status", "next___grid", "new_managed", "new_lag", " new_cell", "new___band", "new_age", "New_grid", "new___age", "New_cell", "next___managed", "next_status", "newnewlag", "new_row", " new_wrapper", "next_lag", "next_grid", "newnewgrid", "new___grid", "New_age", "new_wrapper", "new___status", "newnewstatus", "next___status", "new___cell", "new_band", "New_band", "next_managed"], "result": ["res", "answer", "match", "total", "done", "report", "correct", "product", "complete", "success", "results", "final", "ret", "goal", "section", "description", "extra", "summary", "same", "created", "db", "view", "found", "Result", "table", "number", "replace", "new", "profile", "contact", "data", "mate", "search", "response", "front", "test", "message", "pair"]}}
{"code": " \\n  \\n  def main():\\n      cases = int(sys.stdin.readline())\\n  \\n      for case in range(cases):\\n          row1 = int(sys.stdin.readline())\\n          arrangement1 = [\\n              map(int, sys.stdin.readline().split())\\n              for _ in range(4)\\n          ]\\n          chosen1 = set(arrangement1[row1 - 1])\\n  \\n          row2 = int(sys.stdin.readline())\\n          arrangement2 = [\\n              map(int, sys.stdin.readline().split())\\n              for _ in range(4)\\n          ]\\n          chosen2 = set(arrangement2[row2 - 1])\\n  \\n          chosen = chosen1 & chosen2\\n  \\n          if not chosen:\\n              print 'Case #%d: Volunteer cheated!' % (case + 1)\\n          elif len(chosen) != 1:\\n              print 'Case #%d: Bad magician!' % (case + 1)\\n          else:\\n              print 'Case #%d: %d' % (case + 1, chosen.pop())\\n  \\n  if __name__ == '__main__':\\n      main()\\n", "substitutes": {"cases": ["values", "cycles", "months", "powers", "ms", "units", "times", "ids", "suits", "blocks", "fixes", "ces", " Cases", "cs", "orders", "runs", "names", "its", "changes", "classes", "cells", "codes", "chains", "sections", "hands", "items", "types", "caps", "checks", "ends", "rooms", "charges", "ups", "terms", "ases", "rows", "lines", "steps", "pes", "limits", "models", "tests"], "case": ["trial", "switch", "ced", "ance", "day", "cho", "count", "race", "client", "seat", "code", "zero", "ace", "example", "nce", "name", "chain", "rule", "cation", "condition", "index", "line", "set", "i", "country", "core", "feature", "role", "catch", "row", "Case", "number", "x", "sequence", "cycle", "instance", "call", " Case", "chance", "connection", "step", "ice", "ASE", "ase", "rice", "ce", "cer", "zip", "bug", "context", "test", "choice", "cas", "size", "ci", "num"], "row1": ["ro1", "line0", "ro01", "ro10", "line001", "row01", "lineOne", "ow01", "roOne", "row10", "RowOne", "line1", " row001", "row001", "ow1", "rowOne", "Row1", "Row001", "row0", "rollOne", "Row0", "ow10", "roll1", "roll10", "roll01", "owOne", " row0", " rowOne"], "arrangement1": ["arrangements2", "arrangignmentOne", "arrangament1", "arrancementOne", "arrrangement0", "arrangEMENT0", "arrangEMENT1", "arrancement1", "arrancignmentOne", "arrancignment2", "arrancignment1", "arrrangement2", "arrrangment3", "arrangement0", "arrancignment11", "arrrangement1", "arrangment11", "arrangment1", "arrangement11", "arrrangment2", "arrangment3", "arrangementOne", "arrangament2", "arrangignment2", "arrangement3", "arrangamentOne", "arrangment2", "arrancement11", "arrangignment1", "arrancement2", "arrangEMENT3", "arrangignment11", "arrrangment0", "arrangmentOne", "arrangements1", "arrangements3", "arrrangment1", "arrangment0", "arrangEMENT2", "arrrangement3", "arrangament11", "arrangements0"], "_": ["__", " long", " cpu", "___", "ox", " __", " the", "____", "ix"], "chosen1": ["choserOne", "chooser1", "choosen2", "choser2", "choinOne", "chorge2", "chooser2", "chorge1", "chooserOne", "chorgeOne", "chosenOne", "choosenOne", "choin1", "choosen1", "choser1", "choin2"], "row2": [" row5", "ow02", "ow5", "ow2", " row6", "row8", "roll02", "roll2", "roll5", "roll8", "row5", "row6", "ow8", "row02", " row02", " row8", "ow6", "roll6"], "arrangement2": ["arrangament1", "arrancement1", "arrangement02", "arrangagement162", "arrancignment2", "arrancementtwo", "arrancignment1", "arrangment02", "arrangament4", "arrangement162", "arrrangement2", "arrrangement02", "arrangimation1", "arrangimation2", "arrrangement1", "arrangment1", "arrrangment02", "arrangamenttwo", "arrrangment2", "arrangimation02", "arrangagement02", "arrangment4", "arrangement4", "arrangament2", "arrangignment2", "arrangementtwo", "arrancement4", "arrangignmenttwo", "arrrangment162", "arrangignment4", "arrangagement1", "arrangment2", "arrangagement2", "arrangignment1", "arrancement2", "arrancignmenttwo", "arrangimation162", "arrangment162", "arrrangment1", "arrancignment4", "arrangmenttwo", "arrrangement162"], "chosen2": ["chooin5", "achosen1", "chosen5", "choosen02", "chinese3", "choosen2", "choser2", "chosen02", "chinese5", "choin3", "choser5", "choser02", "chinese1", "chooin1", "cholen5", "achinese5", "achinese1", "choser3", "achosen5", "choin1", "cholen02", "choin02", "cholen1", "chosen3", "chooin2", "chooin02", "choosen1", "choin5", "cholen2", "achosen3", "achosen2", "choser1", "achinese3", "choin2", "choosen5", "chinese2", "achinese2"], "chosen": ["chicked", "chedzn", "cheosen", "echosen", "choose", " chicked", "hoser", "Chosen", "chitched", "Chitched", "collzn", "choosen", "cheosed", "chuned", "chnitched", "chose", "choen", "Chosing", "chnown", "chooser", "chedose", "colloen", " chosed", "chown", "chlied", "choser", "Chicked", "cheicked", "chedosen", "Chown", "choown", "echzn", "hlied", "echoen", "choitched", "cheduned", "hosen", "cholied", "chedlied", "chedoen", "chedoser", "cheosing", " chosing", "chosed", "hose", "chosing", "Chosed", "collosen", "colluned", "echuned", "chnosen", "chzn", "Choser", "chnoser"]}}
{"code": " \\n  T = int(raw_input())\\n  \\n  def generate(R, C, a, sw):\\n      if sw:\\n          R, C = C, R\\n      res = [['*']*C for i in xrange(R)]\\n      for i in xrange(len(a)):\\n          for j in xrange(a[i]):\\n              if sw:\\n                  res[j][i] = '.'\\n              else:\\n                  res[i][j] = '.'\\n      res[0][0] = 'c'\\n      return str(res)[2:-2].replace(' ', '').replace(\"'\",'').replace('[', '').replace('],','\\n').replace(',', '')\\n  \\n  \\n  def solveEq(k, s, x1):\\n      if 2*(x1 + k - 2) > s or k*x1 < s:\\n          return None\\n      r = [0]*k\\n      r[0] = r[1] = x1\\n      s -= 2*x1\\n      for i in xrange(k-2, 0, -1):\\n          t = min(x1, s - 2*i + 2)\\n          r[k-i] = t\\n          s -= t\\n      return r\\n  \\n  def solve(R, C, M):\\n      S = R*C\\n      nm = S - M\\n      if R == 1 or C == 1:\\n          if R == 1:\\n              return '*'*M + '.'*(S-M-1) + 'c'\\n          else:\\n              return '*\\n'*M + '.\\n'*(S-M-1) + 'c'\\n      else:\\n          sw = False\\n          if R > C:\\n              R, C = C, R\\n              sw = True\\n          if nm == 2 or nm == 3 or nm == 5 or nm == 7 or (R == 2 and nm%2 == 1 and nm > 1):\\n              return \"Impossible\"\\n          if nm == 1:\\n              return generate(R, C, [1], sw)\\n          for k in xrange(2, R+1):\\n              for x1 in xrange(2, C+1):\\n                  r = solveEq(k, nm, x1)\\n                  if r != None:\\n                      return generate(R, C, r, sw)\\n          return \"Something wrong\"\\n  \\n  for z in xrange(T):\\n      c, f, x = map(int, raw_input().split())\\n      print \"Case #%d:\\n%s\" % (z+1, solve(c, f, x))\\n", "substitutes": {"T": ["D", "G", "O", "TT", "TN", "X", "H", "L", "TM", "E", "Q", "A", "TH", "B", "TC", "TS", "TA", "F", "J", "V", "Z", "Y", "N", "WT", "TR", "TB", "K", "I", "P", "W"], "R": ["D", "G", "O", "X", "RA", "H", "L", "U", "CR", "A", "Q", "E", "MR", "DR", "ro", "Br", "Remote", "n", "NM", "IR", "RG", "B", "RF", "Res", "Root", "RL", "AR", "Mr", "HR", "F", "J", "KR", "V", "RO", "RS", "Rot", "Repl", "Z", "Y", "N", "NR", "RE", "RR", "Rs", "K", "I", "RM", "P", "Rat", "RT", "W", "BR", "SR", "Role"], "C": ["Co", "D", "G", "O", "CD", "BC", "Ch", "JC", "X", "H", "Cal", "L", "U", "HC", "A", "CR", "E", "CM", "Cr", "Q", "CN", "Count", "Comp", "Chain", "CS", "B", "Col", "Cons", "CA", "CV", "CE", "Cl", "TC", "CC", "WC", "F", "CON", "J", "V", "Con", "Y", "Cor", "N", "Cu", "CT", "CG", "VC", "CP", "CF", "DC", "K", "I", "P", "CB", "W", "CL", "Size", "MC", "CU", "Cond", "CCC", "Cs", "CW", "Can"], "a": ["ap", "au", "sa", "p", "alpha", "er", "re", "e", "rs", "at", "o", "area", "m", "A", "an", "mat", "ja", "ar", "aa", "am", "aaa", "w", "na", "b", "ac", "l", "ata", "aux", "abs", "ma", "ca", "data", "ta", "v", "aj", "es", "ab", "da"], "sw": ["switch", "se", "sa", "sd", "nw", "ok", "warn", "store", "sp", "sl", "iw", "Sw", "wait", " SW", "ssh", "ust", "sync", "sex", " Sw", "ws", "wa", "w", "tr", "only", "sn", "sf", "sc", "wn", "send", "rew", "resh", "ww", "isc", "so", "SW", "wrap", "sy", "ew", "hr", "sh", "pool", "ow", "sr", "syn", "aw", "stream", "skip", "st", "sm", "wo", "th", "ost", "ssl", "wh", "hw", "swe", "now", "we", "wt", "enc", "rw", "tw", "fw", "sv"], "res": ["rem", "p", "os", "ref", "rc", "rev", "re", "err", "rs", "reg", "ps", "rx", "ms", "ress", "ro", "reset", "results", "us", "req", "ren", "rest", "ret", "sol", "tx", "Res", "pres", "rez", "result", "pr", "q", "RES", "resh", "expr", " Res", "content", "rep", "rel", "resolution", "obj", "new", "gr", "resp", "cons", "js", "mem", "out", "v", "rt", "free", "right", "arr"], "i": ["gi", "ki", "ji", "ic", "p", "li", "e", "it", "ia", "o", "jp", "m", "ik", "h", "id", "n", "g", "phi", "int", "ti", "index", "si", "d", "xi", "im", "y", "u", "q", "ai", "b", "ip", "l", "pi", "ii", "ij", "iu", "ix", "di", "I", "zi", "ie", "v", "ir", "ak", "ci"], "j": ["ji", "p", "jj", "jl", "li", "it", "jp", "ijk", "o", "ik", "ax", "n", " ii", "ja", "name", "index", "si", "uj", "q", "u", "y", "J", "kj", "b", "dj", "l", "oj", "ii", "ij", "job", "jc", "obj", "ix", "js", "jump", "ion", "v", "aj"], "k": ["ki", "kan", "ks", "p", "tk", "ok", "it", "ek", "ijk", "m", "ik", "h", "key", "n", "ikk", "ck", "sk", "g", "kid", "uk", "kw", " K", "kk", "w", "kh", "ke", "q", "y", "kr", "wk", "ka", "ko", "kj", "b", "mk", "l", "kn", "ku", "ch", "K", "km", "kar", "v", "kl", "ak", "unk", "num"], "s": ["ns", "p", "os", "gs", "sd", "south", "xs", "e", "rs", "ms", "o", "m", "sp", "h", "ss", "self", "ys", "n", "g", "ls", "w", "d", "si", "q", "u", "y", "cs", "its", "b", "ins", "l", "sh", "sym", "sm", "second", "js", "sq", "v", "ts", "es", "sb", "sv"], "x1": ["tx0", "xt2", "ks", "xt0", "xs", "ax3", "xxx", "x9", "xt9", "tx2", "Xs", "k2", "xp", "X9", "x3", "x2", "Xx", "xx1", " xp", "k0", " x9", "exp", "tx1", "Xp", "xt1", "Xone", "k1", "xxone", "xx2", "xone", "X2", " xs", "ex3", " x0", "ax0", "ix1", "x0", "k3", "X0", "X3", "ixx", " x2", "X1", "ex1", "ex0", "ixone", "ax1", "ax2", "xx", "ix2", " x3", "ex2"], "r": ["range", "answer", "br", "p", "rc", "er", "re", "e", "err", "rs", "o", "lr", "m", "h", "ro", "rb", "n", "g", "rl", "ar", "result", "w", "d", "pr", "q", "u", "y", "kr", "rect", "b", "row", "l", "rr", "hr", "rar", "sr", "rm", "mr", "vr", "rn", "v", "rd", "rt", "ir", "pair"], "t": ["tt", "p", "tm", "e", "it", "at", "o", "m", "n", "ti", "tr", "w", "d", "dt", "tf", "q", "y", "b", "lt", "l", "ty", "tp", "tz", "ot", "te", "out", "ta", "v", "ts", "tc", "wt", "rt", "pt", "tw"], "M": ["D", "G", "O", "X", "Memory", "H", "L", "m", "U", "TM", "E", "A", "Q", "CM", "MN", "NM", "MAN", "B", "F", "J", "V", "Man", "Y", "N", "MT", "MI", "K", "I", "RM", "P", "W", "MC", "MS", "AM"], "S": ["Si", "D", "G", "O", "SU", "TN", "SI", "X", "SM", "H", "L", "A", "Q", "E", "MN", "NS", "NM", "SH", "Ns", "SAM", "B", "CS", "SIZE", "SL", "J", "SN", "V", "RS", "SA", "Z", "Y", "N", "SS", "SP", "K", "ES", "I", "P", "W", "Size", "SE", "IS", "MS", "SR", "Sn"], "nm": ["ns", " sm", "em", "tm", "TN", "reg", "cm", "m", "no", "nr", "ct", "MN", "NS", "NW", "n", "asm", "NM", "nc", "ne", "ym", "Ns", "ny", "name", "um", "mn", "htm", "om", "dem", "sn", "im", "tem", "nor", "fm", "NJ", " N", "nu", "nom", " NM", "ctr", "np", "sam", "sym", "ni", "N", "NR", "sr", "num", "sm", "iam", "mom", "rm", "RM", "km", "mr", "rn", "mem", "nam", "NH", "fn", "nn", "Num", "orm"], "z": ["cz", "os", "fr", "o", "fl", "n", "zh", "d", "ze", "iz", "q", "nz", "y", "Z", "tz", "ij", "ot", "zi", "zer", "ez", "zip", "iaz", "zen", "ie", "aj", "az"], "c": ["p", "e", "cp", "cm", "o", "m", "lc", "n", "g", "w", "d", "u", "y", "b", "l", "co", "cc", "fc", "v"], "f": ["fd", "p", "fr", "e", "o", "fe", "m", "fl", "cf", "g", "rf", "d", "q", "u", "F", "ff", "l", "fp", "file", "fc", "fs", "v", "fi", "fn", "fa"], "x": ["p", "xs", "e", "X", "rx", "o", "m", "h", "n", "xc", "g", "w", "q", "xi", "y", "u", "b", "l", "ix", "ex", "v", "xx"]}}
{"code": "T = int(raw_input())\\n  \\n  def readSq(n):\\n      res = []\\n      for i in xrange(n):\\n          res.append(set(map(int, raw_input().split())))\\n      return res\\n  \\n  def solve():\\n      a1 = int(raw_input())\\n      s1 = readSq(4)\\n      a2 = int(raw_input())\\n      s2 = readSq(4)\\n      ans = s1[a1-1] & s2[a2-1]\\n      if len(ans) == 0:\\n          return \"Volunteer cheated!\"\\n      if len(ans) > 1:\\n          return \"Bad magician!\"\\n      return str(list(ans)[0])\\n  \\n  for z in xrange(T):\\n      print \"Case #%d: %s\" % (z+1, solve())\\n", "substitutes": {"T": ["D", "G", "TI", "TT", "TN", "X", "t", "TM", "L", "E", "Q", "A", "XT", "R", "B", "TS", "TA", "PT", "F", "V", "M", "Z", "Y", "N", "WT", "GT", "TR", "C", "K", "I", "P", "W", "S"], "n": ["ns", "p", "j", "k", "t", "o", "m", "no", "nr", "g", "s", "ne", "nc", "d", "sn", "na", "q", "r", "nb", "b", "nu", "l", "np", "N", "nt", "a", "c", "v", "nn", "num"], "res": ["rem", "j", "p", "rc", "ref", "re", "rs", "reg", "ms", "ress", "resource", "ro", "reset", "results", "rent", "mat", "s", "req", "rest", "eq", "ret", "tx", "Res", "exp", "pres", "rez", "result", "q", "RES", "set", "r", "grid", "pas", "rand", "val", "red", "rel", "x", "resources", "right", "list", "back", "reed", "obj", "gr", "out", "cons", "arr"], "i": ["ic", "li", "it", "ia", "io", "id", " ii", "ri", "il", "ti", "ini", "int", "si", "xi", "im", "y", "ip", "pi", "ii", "ix", "di", "I", "ie", "ind", "ci"], "a1": ["era1", "a11", "era00", "sa11", "a51", "an00", "area00", "an51", "sa01", "an11", " a01", "area11", "area1", "s11", "a01", "era51", "area51", "sa2", "a00", " a11", "an1", "era11", "sa1", "s01"], "s1": ["S3", "sa0", " s3", "s3", " sone", "a3", " s0", "s0", "S1", "S0", "Sone", "aone", "sa2", "sa3", "sa1", "S2", "sone"], "a2": ["sa8", "a10", "A2", "au02", "la8", "au2", "alpha1", "au10", "la02", "sa02", " atwo", "Atwo", "la10", "a02", "atwo", "alpha2", "A1", "au8", "sa2", "sa10", "la2", "a8", "alphatwo"], "s2": ["s256", "a256", "as1", " s3", "s3", "a3", "n2", "ntwo", "S1", "as02", "n3", " stwo", "stwo", "a02", "n256", "atwo", "s02", "as2", " s256", "S2", "S02"], "ans": ["ants", "ns", "ks", "os", "aps", "rs", "aus", "ms", "beans", "ands", "ents", "leans", "ids", "ANS", "lan", "us", "an", "ann", "s", "ls", "An", "anc", "eds", "can", "annels", "uns", "ars", "users", "names", "arms", "amps", "mails", "ran", "ai", "aos", "ins", "anes", "yes", "rans", "anas", "anks", "ros", "ens", "ean", "AN", "arts", "ians", "aned", "ons", "ats", "said"], "z": ["cz", "j", "p", "k", "count", "t", "wx", "o", "zone", "id", "code", "hz", "zo", "name", "zh", "w", "d", "iz", "ze", "oz", "q", "u", "nz", "y", "state", "zon", "Z", "tz", "x", "zi", "zer", "ez", "zip", "v", "zen", "az", "step", "num"]}}
{"code": " \\n  T = int(input())\\n  \\n  for n in range(1, T+1):\\n      print(\"Case #%d:\" % n)\\n      (R, C, M) = (int(x) for x in input().split())\\n      dots = R*C - M\\n      if M == 0:\\n          print(\"\\n\".join([\"c\"+(C-1)*\".\"] + (R-1)*[C*\".\"]))\\n      elif dots == 0:\\n          print(\"Impossible\")\\n      elif R == 1:\\n          assert C - M > 0\\n          print(\"c\"+(C-M-1)*\".\"+M*\"*\")\\n      elif C == 1:\\n          assert R - M > 0\\n          print(\"c\\n\"+(R-M-1)*\".\\n\"+M*\"*\\n\", end='')\\n      elif dots == 1:\\n          print(\"\\n\".join([\"c\"+ (C-1)*\"*\"] + (R-1)*[C*\"*\"]))\\n      elif dots > 3:\\n          if (dots == 5) or (dots == 7):\\n              print(\"Impossible\")\\n              continue\\n          if (R == 2) or (C == 2):\\n              if dots%2 != 0 :\\n                  print(\"Impossible\")\\n                  continue\\n              elif R == 2:\\n                  l = int(dots/2)\\n                  print(\"c\"+(l-1)*\".\"+(C-l)*\"*\")\\n                  print(l*\".\"+(C-l)*\"*\")\\n                  continue\\n              elif C == 2:\\n                  l = int(dots/2)\\n                  print(\"c.\")\\n                  print((l-1)*\"..\\n\", end='')\\n                  print(int(M/2)*\"**\\n\", end='')\\n                  continue\\n          (lines, extra) = divmod(dots, C)\\n          temp = []\\n          if (lines >= 2) and (extra != 1):\\n              temp.append(\"c\"+(C-1)*\".\")\\n              temp.extend((lines-1)*[C*\".\"])\\n              temp.append(extra*\".\"+(C-extra)*\"*\")\\n              temp.extend((R-lines-1)*[C*\"*\"])\\n              print(\"\\n\".join(temp))\\n              continue\\n          elif (lines > 2) and (extra == 1):\\n              temp.append(\"c\"+(C-1)*\".\")\\n              temp.extend((lines-2)*[C*\".\"])\\n              temp.append((C-1)*\".\"+\"*\")\\n              temp.append(\"..\"+ (C-2)*\"*\")\\n              temp.extend((R-lines-1)*[C*\"*\"])\\n              print(\"\\n\".join(temp))\\n              continue\\n          elif (lines == 2) and (extra == 1):\\n              temp.append(\"c\"+(C-2)*\".\"+\"*\")\\n              temp.append((C-1)*\".\"+\"*\")\\n              temp.append(3*\".\"+(C-3)*\"*\")\\n              temp.extend((R-3)*[C*\"*\"])\\n              print(\"\\n\".join(temp))\\n              continue\\n          elif lines < 2:\\n              (l, rem) = divmod(dots, 2)\\n              if rem == 1:\\n                  l -= 1\\n                  rem += 2\\n              temp.append(\"c\"+(l-1)*\".\"+(C-l)*\"*\")\\n              temp.append(l*\".\"+(C-l)*\"*\")\\n              temp.append(rem*\".\"+(C-rem)*\"*\")\\n              temp.extend( (R-3)*[ C*\"*\" ])\\n              print(\"\\n\".join(temp))\\n              continue\\n      else:\\n          print(\"Impossible\")\\n  \\n", "substitutes": {"T": ["Time", "D", "G", "O", "TI", "TT", "TN", "X", "t", "L", "TY", "TM", "E", "Q", "TV", "TH", "B", "TC", "TS", "TA", "F", "V", "Z", "Y", "NT", "N", "GT", "TR", "TB", "K", "I", "P", "W", "VT", "S"], "n": ["ns", "next", "p", "k", "nw", "note", "t", "o", "no", "nr", "h", "an", "z", "nc", "ne", "node", "nil", "name", "nan", "w", "ng", "sn", "na", "NL", "r", "nor", "nb", "yn", " N", "nu", "np", "nl", "un", "N", "ln", "nt", "nm", "nv", "a", "nn", "nd"], "R": ["Co", "Range", "D", "G", "O", "X", "RA", "H", "L", "U", "CR", "Q", "E", "A", "DR", "RC", "IR", "RG", "B", "SR", "Res", "RL", "AR", "HR", "Reader", "r", "J", "F", "V", "RO", "RS", "RB", "Y", "PR", "N", "NR", "RE", "TR", "GR", "RR", "Rs", "VR", "RM", "P", "RT", "OR", "W", "c", "BR", "S", "MR", "Re", "ER"], "C": ["D", "CD", "BC", "U", "A", "Count", "CAR", "Cl", "CC", "F", "Code", "CF", "K", "length", "c", "Size", "MC", "Co", "G", "Ch", "HC", "CM", "CN", "AC", "Chain", "CS", "B", "Cons", "CV", "CE", "CI", "WC", "CON", "Ca", "EC", "CO", "CT", "CG", "CP", "CU", "S", "JC", "COR", "X", "L", "MAX", "CA", "TC", "Y", "Cu", "DC", "P", "Cs", "O", "H", "CR", "Q", "E", "Cr", "CAP", "SC", "V", "Con", "N", "Length", "I", "CB", "CL"], "M": ["D", "G", "VM", "O", "AM", "X", "Memory", "MA", "MD", "L", "m", "TM", "H", "Q", "E", "CM", "U", "NM", "Mon", "MAN", "B", "PM", "MM", "JM", "F", "J", "Multi", "V", "Me", "Z", "Y", "LM", "N", "Ms", "MIT", "MT", "MI", "I", "RM", "P", "Mc", "DM", "W", "MAT", "MC", "MH", "ME", "MS", "S", "MR", "MP"], "x": ["ux", "p", "xs", "k", "e", "ctx", "X", "rx", "xes", "t", "wx", "dx", "m", "ax", "z", "xc", "f", "xa", "xt", "tx", "mx", "xi", "q", "y", "i", "r", "inx", "xf", "xe", "xd", "ix", "xy", "a", "ex", "px", "c", "nex", "v", "xx", "xb", "fx"], "dots": ["sdshots", "dshots", "dnits", "dosumps", " dumbers", "dhots", " daps", "dsots", "dsoms", "hot", "nots", "dotes", " dugs", "diumps", "totted", "didoots", " dits", "tumbers", "daugs", "Daps", "dosshots", "numbers", "daps", " dot", "Dumps", " doms", "totes", "mdots", "Dits", "daots", "dot", "sdots", "dths", "dnhots", "tots", "mdoms", "dits", "rot", "dbashes", "daot", "Drots", "hots", "rugs", "dugs", "dosots", " doots", " dashes", "doms", "hugs", "rotes", "dosets", "didOTS", "tot", " dths", "mdumps", " drots", "mdths", " dets", "diets", "dishots", "sdets", "doots", "tashes", "Dhots", "drots", "Dots", "dbrots", "dbOTS", "dsumps", "DOTS", "trots", " dhots", "hotes", "rots", "dumbers", "dnots", "didots", "dOTS", "dets", "dsths", "Dets", "dotted", "diOTS", " dOTS", "dbots", "notted", "nashes", "tugs", "sdumps", "diots", "Dashes", "dashes", "darots", "dnashes", "didaps", " dotted", " dumps", "dumps", " dotes", "Doots"], "l": ["j", "p", "jl", "la", "li", "ll", "t", "lin", "long", "L", "le", "fl", "m", "sl", "lr", "o", "lc", "h", "lv", " L", "z", "g", "s", "lo", "ls", "dl", "w", "d", "line", "i", "left", "r", "pl", "lp", "b", "lt", "el", "cl", "nl", "ld", "ln", "loc", "len", "tl", "c", "v", "ml", "kl"], "lines": ["verts", "ns", "lists", "cycles", "Line", "xs", "comments", "rs", "levels", "times", "LINE", "stores", "Numbers", "s", "files", "blocks", "ls", "ds", "errors", "line", "cs", "names", "runs", "r", "hours", "parts", "LIN", "RS", "cats", "boxes", "cells", "codes", "groups", "chains", "sections", "ln", "N", "items", "points", "vs", "vals", "ines", "Rs", "pages", "tests", "inline", "frames", "rows", "jobs", "steps", "objects", "links", "LS", "Cs", "posts"], "extra": ["empty", "total", "alpha", "equal", "er", "missing", "e", "adding", "err", "size", "t", "area", "absolute", "o", "m", "depth", "common", "error", "secondary", "max", "none", "fine", "relative", " extras", "important", "info", "exclusive", "item", "Extra", "tra", "line", "i", "optional", "repeat", "special", "r", "entry", "related", "incre", "external", "ras", "auto", "buffer", "border", "expected", "ext", "alias", "aux", "add", "normal", "offset", "diff", "more", "ex", "interrupted", "c", "added", "exc", "meta", "inner", "other", "prime"], "temp": ["empty", "level", "tmp", "plates", "p", "total", "em", "dat", "ps", "dest", "t", "warm", "orig", "m", "alt", "context", "relative", "pretty", "generated", "create", "perm", "tr", "EMP", "cache", "current", "multi", "tem", "tim", "created", "buffer", "fake", "Temp", "template", "thread", "emp", "iter", "mp", "mint", "stem", "porary", "mem", " temporary", "v", "ts", "tc", "now", "unt", "pt", "test", "prime"]}}
{"code": " ncases = int(input())\\n  \\n  for n in range(1, ncases+1):\\n      row = int(input())\\n      for m in range(1, 5):\\n          if m == row:\\n              r1list = [int(x) for x in input().split()]\\n              assert len(r1list) == 4\\n          else:\\n              tmp = input()\\n      row = int(input())\\n      for m in range(1,5):\\n          if m == row:\\n              r2list = [int(x) for x in input().split()]\\n              assert len(r1list) == 4\\n          else:\\n              tmp = input()\\n      nset = set(r1list) & set(r2list)\\n      if len(nset) == 1:\\n          print(\"Case #%d:\" % n, nset.pop())\\n      elif len(nset) > 1:\\n          print(\"Case #%d:\" % n, \"Bad magician!\")\\n      else:\\n          print(\"Case #%d:\" % n, \"Volunteer cheated!\")\\n", "substitutes": {"ncases": ["nnase", "ncants", "ncasing", "nases", "nnasing", "NCases", "nsases", "cnASE", "NCase", "nants", "cnases", "NCants", "nsasing", "cnants", "nsales", "ncales", "nase", "nsase", "cnasing", "cnase", "NCASE", "ncASE", "nASE", "nnales", "ncase", "nnases", "cnales"], "n": ["ns", "j", "p", "k", "gn", "missing", "nw", "note", "t", "o", "norm", "h", "none", "an", "z", "nc", "ne", "g", "s", "ny", "en", "name", "mn", "d", "cn", "sn", "na", "y", "i", "conn", "names", "r", "nor", "on", "nu", "l", "unc", "np", "un", "N", "nt", "nm", "min", "mut", "ma", "new", "out", "nam", "c", "v", "fn", "nn", "nd", "num"], "row": ["res", "range", "post", "mon", "rc", "col", "prefix", "mm", "no", "cur", "ser", "max", "ro", "week", "run", "key", "node", "con", "term", "lo", "raw", "rown", "field", "tr", "index", "w", "user", "line", "sc", "rot", "sw", "r", "tab", "rep", "co", "ow", "cycle", "month", "order", "to", "batch", "wo", "th", "box", "ver", "ows", "roll", "out", "round", "rows", "ry", "pos", "cell", "test", "step", "num"], "m": ["p", "j", "mid", "em", "e", "cm", "t", "o", "mm", "an", "mat", "g", "f", "ym", "am", "name", "um", "mn", "w", "om", "d", "gm", "mi", "man", "i", "y", "mo", "r", "on", "M", "mt", "l", "mc", "min", "nm", "mut", "ma", "md", "ter", "mult", "a", " mm", "c", "v", "ml", "arm"], "r1list": ["r5LIST", "r0lists", "R2dict", "r10list", "ar1list", "r6name", "r2st", "m8set", "ar001set", "r6list", "ar001list", "r11list", "r6dict", "r6LIST", "r6set", "r1dict", "n1List", "m1st", "rnbool", "r1st", "rnlist", "m8st", "r001name", "r0st", "R2list", "n1dict", "n1list", "r2set", "ar001LIST", "r8list", "n11dict", "r001LIST", "R1st", "r11lists", "ar001name", "r10st", "n11lists", "r5name", "r1LIST", "r5list", "r1lists", "r11List", "m1set", "m1list", "r0dict", "r0set", "r1set", "r5set", "r10bool", "r1List", "R1bool", "R1list", "R2st", "rnst", "r6lists", "r8set", "r001list", "r11dict", "r0list", "ar1name", "r10dict", "ar1LIST", "ar1set", "r2dict", "n1lists", "rndict", "n11List", "r6List", "m8list", "r2bool", "R1dict", "r001set", "R2bool", "n11list", "r1name", "r1bool", "r0List", "r8st"], "x": ["ux", "hex", "p", "xs", "e", "xxx", "xxxxxxxx", "rx", "xxxx", "t", "wx", "xes", "dx", "ctx", "ox", "z", "ross", "xc", "xa", " xx", "tx", "xt", "ey", "name", "w", "xi", "q", "y", "i", "inx", "xf", "\u00e7", "l", "yx", "xe", "xd", "ix", "xy", "px", "ex", "c", "xx", "v", "xml", "ml", "fx", "ci", "php"], "tmp": ["src", "tt", "seed", "dirty", "tm", "buf", "ctx", "img", "orig", "mm", "txt", "yy", "cmp", "ret", "perm", "proc", "aaa", "another", "copy", "cache", "nb", "tab", "mk", "auto", "np", "buff", "nt", "attr", "emp", "obj", "mut", "mp", "prev", "etc", "tc", "test", "temp"], "r2list": ["r5listed", "r2List", "r0list", "r3st", "r1listed", "R1List", "p2listed", "p2list", "R1set", "p2List", "r3list", "r5list", "R2set", "r1st", "r3List", "R2list", "r1set", "r3set", "r2set", "r0set", "p5listed", "p5list", "r7set", "p2set", "r5set", "r2st", "r5List", "r1List", "r7List", "p5List", "r2listed", "r7st", "R1st", "R1list", "R2st", "r0listed", "r7list", "p5set", "R2List", "r0List"], "nset": [" nstore", "dnSET", "radd", "rsync", "dnset", "numsize", "gnull", "Nstore", "nsync", "numset", "NSet", "ysync", " nadd", "yset", "nnstart", "nnsum", " nSet", "rstore", "dnnull", "Nsize", "nlist", "cnstore", " nstart", "cnsize", "cnset", "lnSET", "nstart", "cnstart", "lnnull", "cnSet", "numSet", "nnull", "glist", "yadd", " nsum", "nadd", "lnset", "ystore", "cnsum", "gset", "nnSet", " nsync", "dnlist", "Nset", "rset", "nSet", "lnlist", "nstore", "nSET", "gSET", "nnset", "nsize", "numstore", "nsum"]}}
{"code": " \\n  \\n  IMPOSSIBLE = []\\n  \\n  def transpose(grid):\\n      return map(list, zip(*grid))\\n  \\n  def find_grid(R, C, M):\\n      \"\"\"Return a grid of a solution, if one exists, otherwise []\\n  \\n      Observations:\\n      * WLOG, C <= R (otherwise, take the transpose of a solution)\\n      * Trivial cases are:\\n        - M = 0 or  M = RC - 1\\n        - C = 1\\n        - (R, C) = (2, 2)\\n        - (R, C, M) = (3, 3, 2)\\n        - (C, M) = (2, 1)\\n      * If M >= C >= 2 and R >= 3, we can add a row of C mines to the bottom and consider M'=M-C, R'=R-1\\n      * The remaining cases are M <= R-2, and M + 1 == R == C >= 4, which are both solvable\\n      \"\"\"\\n      if M == 0:\\n          grid = [['.' for c in xrange(C)] for r in xrange(R)]\\n          grid[0][0] = 'c'\\n          return grid\\n      elif M == R * C - 1:\\n          grid = [['*' for c in xrange(C)] for r in xrange(R)]\\n          grid[0][0] = 'c'\\n          return grid\\n      elif C > R:\\n          return transpose(find_grid(C, R, M))\\n      elif C == 1:\\n          return [['c']] + [['.'] for i in xrange(R-M-1)] + [['*'] for i in xrange(M)]\\n      elif (R, C) == (2, 2) or (R, C, M) == (3, 3, 2) or (C, M) == (2, 1):\\n          return IMPOSSIBLE\\n  \\n      assert 2 <= C <= R >= 3, \"R={} C={} M={}\".format(R, C, M)\\n  \\n      if M >= C:\\n          s = find_grid(R-1, C, M-C)\\n          return s and s + [['*' for c in xrange(C)]]\\n      elif M <= R-2 and C >= 3:\\n          grid = [['.' for c in xrange(C)] for r in xrange(R)]\\n          grid[0][0] = 'c'\\n          for i in xrange(M):\\n              grid[R-i-1][C-1] = '*'\\n          return grid\\n      elif M + 1 == R == C >= 4:\\n          grid = [['.' for c in xrange(C)] for r in xrange(R)]\\n          grid[0][0] = 'c'\\n          grid[R-1][C-2] = '*'\\n          for i in xrange(M-1):\\n              grid[R-i-1][C-1] = '*'\\n          return grid\\n  \\n      assert False, \"R={} C={} M={}\".format(R, C, M)\\n  \\n  def check_soln(grid, R, C, M):\\n      \"\"\"checking, because debugging...\"\"\"\\n      error = \"R={} C={} M={}\".format(R, C, M)\\n      assert sum(row.count('*') for row in grid) == M, error\\n      assert sum(row.count('c') for row in grid) == 1, error\\n      assert len(grid) == R, error\\n      assert all(len(row) == C for row in grid), error\\n      _ = [i for i, row in enumerate(grid) if 'c' in row][0]\\n      click = (_, [i for i, c in enumerate(grid[_]) if c == 'c'][0])\\n  \\n      def neighbours(r, c):\\n          ns = [(i, j) for i in range(max(r-1,0),min(r+2,R)) for j in range(max(c-1,0),min(c+2,C))]\\n          ns.remove((r, c))\\n          return ns\\n  \\n      cpy = map(list, grid)\\n      def fill(cpy, pos):\\n          cpy[pos[0]][pos[1]] = str(sum(1 for i, j in neighbours(*pos) if grid[i][j] == '*'))\\n          if cpy[pos[0]][pos[1]] == '0':\\n              for i, j in neighbours(*pos):\\n                  if cpy[i][j] == '.':\\n                      fill(cpy, (i, j))\\n      fill(cpy, click)\\n      assert sum(row.count('.') for row in cpy) == 0, error\\n  \\n  def solve(R, C, M):\\n      soln = find_grid(R, C, M)\\n      if soln == IMPOSSIBLE:\\n          return \"Impossible\"\\n      else:\\n          check_soln(soln, R, C, M)\\n          return '\\n'.join(''.join(row) for row in soln)\\n  \\n  if __name__ == '__main__':\\n      fin = open(sys.argv[1], 'rU') if sys.argv[1:] else sys.stdin\\n      fout = open(sys.argv[2], 'w') if sys.argv[2:] else sys.stdout\\n      with fin, fout:\\n          T = int(fin.readline())\\n          for case in xrange(1, T+1):\\n              r, c, m = map(int, fin.readline().split())\\n              soln = solve(r, c, m)\\n              print >> fout, \"Case #{0}:\\n{1}\".format(case, soln)\\n  \\n", "substitutes": {"IMPOSSIBLE": ["IMPOSED", "IMPLOSSED", "IMPOSTABLE", "IMPossIC", "IMPOSTIBLE", "IMPLESSIC", "IMPossED", "IMPESSible", "IMPESSED", "IMPOSSIC", "IMPLESSED", "IMSPOSSIBLE", "IMPESSibles", "IMPOSible", "IMPLESSible", "IMPossible", "IMPESSIBLE", "IMPLESSIBLE", "IMPOSSABLE", "IMPOSTibles", "IMPossibles", "IMPLOSSIC", "IMPossIBLE", "IMPLOSSIBLE", "IMPESSABLE", "IMPLOSSible", "IMSPOSSABLE", "IMSPOSSible", "IMPossABLE", "IMPOSIC", "IMSPOSSibles", "IMSPossABLE", "IMSPossibles", "IMPOSTible", "IMPOSSibles", "IMPESSIC", "IMPOSIBLE", "IMSPossible", "IMPOSSED", "IMPOSSible", "IMSPossIBLE"], "grid": ["raid", "func", "clear", "band", "console", "e", "t", "domain", "window", "node", "term", "wrapper", "jac", "ad", "q", "line", "set", "cache", "module", "hold", "network", "split", "sequence", "car", "filled", "age", "box", "dq", "debug", "gc", "plot", "cell", "status", "ixture", "stock", "default", "prefix", "product", "util", "block", "disk", "manager", "record", "cf", "final", "tile", "chain", "field", "lay", "xi", "sid", "gr", "out", "device", "series", "valid", "filter", "values", "form", "load", "modified", "mask", "column", "cart", "array", "layout", "stack", "g", "group", "work", "content", "table", "query", "server", "flow", "card", "gate", "format", "fixed", "map", "file", "lag", "bar", "data", "zip", "queue", "play", "test", "memory", "res", "range", "storage", "frame", "Grid", "filename", "cm", "url", "client", "rid", "mat", "csv", "section", "result", "index", "gm", "wire", "multi", "cli", "db", "unit", "buffer", "pack", "layer", "input", "bag", "rows", "model", "list"], "R": ["Range", "D", "G", "O", "Right", "JR", "X", "RA", "H", "L", "U", "CR", "A", "MR", "E", "Q", "DR", "RC", "Remote", "Reg", "IR", "B", "RF", "Res", "Root", "AR", "HR", "F", "J", "Reader", "V", "RO", "RS", "Rot", "Row", "Z", "Y", "Cor", "N", "NR", "RE", "TR", "GR", "RR", "Rs", "K", "I", "RM", "P", "RI", "RT", "W", "Rat", "BR", "S", "SR", "ER"], "C": ["D", "CD", "U", "Cal", "A", "Count", "CAR", "IC", "Cl", "CC", "AR", "F", "Z", "VC", "CF", "K", "MC", "Co", "G", "Ch", "HC", "CM", "CN", "Chain", "CS", "B", "Cons", "CV", "CE", "CI", "WC", "CON", "EC", "Config", "CO", "CT", "CG", "CP", "GC", "CU", "S", "Cache", "COR", "X", "L", "RC", "Comp", "Y", "RE", "DC", "P", "Cs", "O", "H", "CR", "E", "Q", "Cr", "Col", "SC", "V", "Con", "N", "I", "CB", "W", "CCC", "CL"], "M": ["Rem", "D", "G", "VM", "O", "X", "MA", "L", "H", "TM", "E", "A", "MR", "CM", "Q", "U", "MN", "REM", "NM", "OM", "MAN", "B", "PM", "MM", "JM", "AR", "F", "J", "IM", "V", "Man", "RS", "Me", "Manager", "Z", "Y", "LM", "EM", "N", "RE", "MIT", "MT", "MI", "I", "RM", "P", "DM", "W", "MC", "ME", "MS", "S", "AM", "MP"], "c": ["dc", "p", "ic", "rc", "count", "col", "cp", "cm", "rec", "t", "cur", "lc", "ct", "g", "con", "f", "ar", "can", "pc", "cu", "cod", "arc", "sc", "ec", "cin", "const", "ac", "cor", "cl", "unc", "l", "cr", "co", "cc", "ir", "icc", "ci"], "r": ["range", "res", "p", "rc", "er", "re", "it", "rec", "t", "h", "ro", "run", "g", "f", "ri", "ar", "w", "pr", "cr", "rar", "sr", "order", "dr", "gr", "rm", "mr", "rd", "ir", "rt", "ind"], "i": ["gi", "ic", "ico", "ib", "e", "it", "rec", "t", "ri", "il", "ti", "ini", "int", "im", "ai", "b", "ip", "co", "pi", "ii", "ij", "ati", "di", "I", "ion", "ir", "ind", "ci"], "s": ["res", "p", "os", "xs", "ges", "ats", "single", "e", "ools", "rs", "ps", "t", "sub", "ids", "h", "ss", "results", "n", "g", "f", "ls", "sol", "ds", "ws", "ims", "w", "d", "y", "its", "b", "hs", "ins", "l", "x", "js", "a", "rows", "ches", "ts", "v", "es", "S", "sb", "gs"], "row": ["level", "post", "day", "load", "col", "column", "block", "ro", "week", "run", "zero", "rown", "section", "line", "where", "Row", "ow", "flow", "box", "ver", "ows", "roll", "round", "rows", "low", "way", "cell", "component"]}}
{"code": " \\n  \\n  def read_row(fin, n):\\n      rows = [set(map(int, fin.readline().strip().split())) for i in xrange(4)]\\n      return rows[n-1]\\n  \\n  def solve(rowa, rowb):\\n      both = rowa & rowb\\n      if len(both) == 1:\\n          return list(both)[0]\\n      elif len(both) > 1:\\n          return \"Bad magician!\"\\n      elif not both:\\n          return \"Volunteer cheated!\"\\n  \\n  if __name__ == '__main__':\\n      fin = open(sys.argv[1], 'rU') if sys.argv[1:] else sys.stdin\\n      fout = open(sys.argv[2], 'w') if sys.argv[2:] else sys.stdout\\n      with fin, fout:\\n          T = int(fin.readline())\\n          for case in xrange(1, T+1):\\n              n = int(fin.readline())\\n              rowa = read_row(fin, n)\\n              n = int(fin.readline())\\n              rowb = read_row(fin, n)\\n              soln = solve(rowa, rowb)\\n              print >> fout, \"Case #{0}: {1}\".format(case, soln)\\n  \\n", "substitutes": {"fin": ["fd", "adv", "fr", "die", "sent", "irm", "fine", "en", "send", "writer", "stream", "skip", "raf", "fast", "fc", "front", "fw", "pdf", "trans", "fl", "din", "ro", "final", "inn", "ini", "ran", "ln", "read", "resp", "out", "mot", "fa", "fre", "os", "form", "reader", "rec", "f", "conn", "train", "sw", "fen", "pen", "len", "FIN", "fp", "file", "fn", "dir", "bin", "res", "next", "std", "oin", "lin", "fail", "compl", "den", "Fin", "lo", "dev", "do", "div", "tr", "init", "stat", "fil", "rand", "pid", "eric", "syn", "nt", "mont", "fs", "sys", "fi", "rt"], "n": ["ns", "j", "p", "k", "count", "gn", "t", "o", "m", "no", "nr", "an", "nc", "ne", "s", "f", "g", "en", "int", "mn", "w", "d", "cn", "sn", "na", "u", "y", "r", "nb", "b", "nu", "l", "np", "nl", "number", "un", "ni", "N", "ln", "nt", "net", "nm", "len", "a", "c", "v", "nn", "size", "num"], "rows": ["heads", "ns", "values", "rs", "ms", "los", "uds", "times", "rys", "results", "bys", "rown", "ds", "ws", "users", "dates", "orders", "runs", "workers", "each", "airs", "ins", "row", "downs", "fields", "reports", "bs", "groups", "sections", "posts", "ros", "items", "members", "vs", "vals", "ows", "cases", "pages", "lines", "tests"], "i": ["p", "ic", "j", "k", "li", "e", "it", "id", "int", "ti", "ini", "index", "im", "ine", "mi", "ip", "l", "x", "pi", "ix", "di", "ice", "I", "v", "ind", "ci"], "rowa": ["roa", " rowA", "rowan", "rownae", "rownba", "recordan", "rowsm", " rowca", "rownA", "rownan", "rowna", "rownea", "hubca", "rowca", "recordba", "rowm", "rowsa", "rollA", "rownca", "rowu", "rowea", "rowsA", "rown0", "recordae", "rowsae", "rowsba", "rollan", " rowsa", "row0", "roA", "rowba", " rowu", "huba", "rowae", "roea", "hub0", "rowA", "rollm", "roan", "rowssa", "rowsan", "hubu", "rolla", " rowm", "recorda", "rownu", " row0", "rollsa", "rollea"], "rowb": ["rwv", "owsb", "rowr", "pair1", "rowsb", "rowbs", "rowna", "rysb", "owv", "Rowbb", "rwsb", "Rowr", "rownb", "rollbs", "rowdb", " rowbs", "rowns", "rya", "paira", " rowbb", "Rowb", " rowr", "owbb", "pairbs", "rwa", "pairb", "ryb", "rollb", " rowdb", "row1", "rowv", "roll1", "rownr", "rwb", "owdb", "rolla", "rowbb", "ryv", "rownbb", "owb", "Rows", "rowndb", " row1", "owa"], "both": ["total", "equal", "cho", "bo", "either", "half", "Neither", "always", "forth", "m", "sl", "old", "none", "OTH", "all", "lo", " Both", "pal", "only", "they", "Both", "left", "same", "multi", "two", "blank", "each", "nor", "pl", "airs", "ALL", "parts", "where", "who", "l", "hand", "list", "vs", "comb", "balanced", "them", "hl", "void", "wh", "orth", "length", "broad", "also", "ither", "tw", "between", "pair"], "fout": ["wOut", "win", "pout", " fOut", "Fin", "fdOut", "fOut", "Fout", "foutput", "fOUT", " fOUT", "pOut", "Fot", " fot", "tOut", "fdout", "tout", "tin", "xfot", " foutput", "fdoutput", "wout", "pOUT", "poutput", "xfin", "fdOUT", "xfout", "fot"], "T": ["Time", "D", "G", "O", "TT", "TN", "X", "t", "H", "L", "TY", "E", "Q", "R", "B", "TC", "TS", "TA", "F", "Type", "V", "M", "TW", "Z", "Y", "Case", "N", "GT", "WT", "C", "K", "I", "P", "W", "S"], "case": ["trial", "switch", "se", "one", "race", "su", "count", "li", "lc", "pe", "id", "zero", "ace", "nce", "name", "chain", "cation", "TC", "section", "CE", "condition", "line", "Case", "number", "co", "instance", "order", "C", "cases", "ice", "ASE", "ase", "P", "ce", "ion", "zip", "c", "tc", "cell", "test", "ci", "num"], "soln": ["solf", "Sol", "Solve", " solution", " solf", " solve", "Solf", "ssolve", "sol", "ssolution", "solve", " sol", "ssol", "ssolf", "Soln", "ssoln", "Solution", "solution"]}}
{"code": " \\n  \\n  \\n  \\n  \\n  \\n  \\n  \\n  \\n  \\n  \\n  \\n  \\n   \\n  \\n  \\n  \\n  \\n  def debug(*args):\\n      print(*args, file=sys.stderr)\\n  \\n  fin = sys.stdin\\n  T = int(fin.readline())\\n  for case in range(1, T + 1):\\n      RR, CC, M = map(int, fin.readline().split())\\n      R, C = None, None\\n      blocks = RR*CC - M\\n      inverse = False\\n      if RR > CC:\\n          inverse = True\\n          R, C = CC, RR\\n      else:\\n          R, C = RR, CC\\n      result = None\\n      if R == 1:\\n          result = [('.' * blocks) + ('*' * M)]\\n      elif R == 2:\\n          if blocks == 1:\\n              result = ['.' + ('*' * (C-1)), '*' * C]\\n          elif blocks % 2 == 0 and blocks != 2:\\n              cc = blocks // 2\\n              result = [('.' * cc) + ('*' * (C - cc)), ('.' * cc) + ('*' * (C - cc))] \\n          else:\\n              result = None\\n      else:\\n          if blocks == 1:\\n              result = ['*' * C] * R\\n          elif blocks == 4:\\n              result = ['..' + (C-2)*'*']*2\\n              result += ['*'*C] * (R-2)\\n          elif blocks == 6:\\n              result = ['...' + (C-3)*'*']*2\\n              result += ['*'*C] * (R-2)\\n          for rows in range(3, R+1):\\n              for columns in range(rows, C+1):\\n                  size = rows * columns\\n                  if size - blocks >= 0:\\n                      if size - blocks <= columns - 2: \\n                          result = []\\n                          for r in range(rows):\\n                              if r < rows - 1:\\n                                  result.append(('.' * columns) + ('*' * (C - columns)))\\n                              else:\\n                                  cc = columns - (size - blocks)\\n                                  result.append(('.' * cc) + ('*' * (C - cc)))\\n                          for r in range(R - rows):\\n                              result.append('*' * C)\\n                      elif size - blocks == columns - 1 and rows >= 4:\\n                          result = []\\n                          for r in range(rows):\\n                              if r < rows - 2:\\n                                  result.append(('.' * columns) + ('*' * (C - columns)))\\n                              elif r == rows - 2:\\n                                  cc = columns - 1\\n                                  result.append(('.' * cc) + ('*' * (C - cc)))\\n                              else:\\n                                  cc = 2\\n                                  result.append(('.' * cc) + ('*' * (C - cc)))\\n                          for r in range(R - rows):\\n                              result.append('*' * C)\\n                      \\n  \\n  \\n  \\n      print(\"Case #%d: \" % (case))\\n      if result is None:\\n          debug('impossible', blocks, RR, CC)\\n          print(\"Impossible\")\\n      else:\\n          mines = 0\\n          for r in range(RR):\\n              row = ''\\n              for c in range(CC):\\n                  rr, cc = r, c\\n                  if inverse:\\n                      rr, cc = c, r\\n                  if rr == 0 and cc == 0:\\n                      row += 'c'\\n                  else:\\n                      row += result[rr][cc]\\n                      if result[rr][cc] == '*':\\n                          mines += 1\\n              print(row)\\n          if mines != M:\\n              raise Exception(\"%d != %d %d x %d\" % (mines, M, RR, CC))\\n              \\n  \\n  \\n", "substitutes": {"fin": ["res", "fd", "trans", "fr", "reader", "rec", "lin", "fl", "txt", "ind", "den", "din", "Fin", "irm", "n", "ren", "con", "f", "han", "en", "mn", "ini", "jen", "tan", "fun", "conn", "init", "fil", "fen", "ln", "syn", "ven", "pen", "skip", "raf", "FIN", "fp", "file", "fc", "fs", "fi", "rt", "fn", "fa", "dir", "bin", "fre"], "T": ["Time", "D", "G", "O", "TT", "TN", "X", "t", "L", "TM", "TY", "A", "Q", "Tab", "TH", "B", "TC", "TS", "TA", "F", "Type", "V", "Z", "Y", "N", "GT", "TR", "TB", "K", "UTC", "I", "TX", "P", "W", "S"], "case": [" tests", "cycles", " cycles", "race", "Times", " cases", "X", " rounds", " times", "TM", "times", " X", " iteration", "TC", "tr", " trial", "runs", "cor", "Row", "Z", "Y", " traces", "TR", " cores", "cases", "P", " tr", "tests"], "RR": ["RD", "JR", "rs", "RA", "RFC", "TM", "CR", "MR", "CM", "DR", "RC", "LR", "ROM", "RG", "RF", "RL", "AR", "Mr", "HR", "Rec", "RO", "RS", "RN", "RB", "NR", "RE", "TR", "VC", "Rs", "VR", "RM", "RT", "RI", "CCC", "RW", "BR", "IR", "SR", "ER", "RP"], "CC": ["BC", "JC", "CD", "FC", "Cow", "CR", "Q", "CM", "CN", "RC", "CBS", "LR", "PC", "LC", "CS", "TC", "IC", "CE", "CA", "ACK", "WC", "SC", "RS", "CH", "EC", "CBC", "ACC", "CNN", "FF", "CO", "CT", "MT", "VC", "CP", "CF", "LL", "Mc", "CB", "CCC", "CL", "MC", "McC", "RW", "NC", "Cs", "TD", "CW"], "M": ["D", "G", "MD", "TM", "m", "L", "A", "Q", "CR", "CM", "E", "MN", "MODE", "BM", "B", "PM", "MM", "F", "J", "V", "Y", "MB", "LM", "MF", "N", "Ms", "MT", "ML", "MI", "K", "I", "RM", "P", "Cs", "CL", "MC", "MS", "S", "MR", "MP"], "R": ["D", "G", "O", "Right", "X", "RA", "H", "L", "U", "CR", "A", "MR", "E", "Q", "DR", "RC", "LR", "IR", "RF", "RG", "B", "Res", "RP", "RL", "AR", "Mr", "HR", "F", "J", "Rec", "Reader", "V", "RO", "RS", "RB", "Result", "Row", "Y", "N", "NR", "RE", "TR", "GR", "Rs", "K", "VR", "I", "RM", "P", "RT", "RI", "RW", "BR", "S", "SR", "ER", "Blocks"], "C": ["Co", "D", "G", "O", "BC", "JC", "Ch", "CD", "COR", "L", "H", "Cow", "E", "A", "CR", "CM", "HC", "U", "RC", "Q", "AC", "Count", "LC", "CS", "B", "Cons", "CAR", "TC", "Cl", "CE", "CA", "CI", "F", "WC", "J", "CON", "SC", "V", "EC", "Y", "CNN", "N", "Cu", "CO", "CT", "CG", "VC", "CP", "CF", "DC", "I", "P", "GC", "Mc", "CB", "CCC", "CL", "MC", "CU", "Size", "W", "NC", "S", "Cs", "CW"], "blocks": ["works", "args", "images", "bytes", "units", "m", "times", "bars", "bc", "results", "bys", "users", "assets", "Mr", "ins", "mins", "ctr", "bits", "MB", "locks", "scripts", "plugins", "rules", "builders", "actions", "guards", "block", "stores", "modules", "s", "files", "rights", "headers", "params", "B", "mods", "names", "ers", "elines", "boxes", "maps", "bs", "groups", "mc", "members", "types", "points", "mr", "pieces", "S", "MR", "tests", "heads", "values", "cycles", "ms", "mm", "mb", "mn", "outs", "reads", "styles", "classes", "RS", "cells", "chains", "ros", "checks", "MT", "pages", "lines", "usters", "offs", "breaks", "rons", "BM", "PC", "bm", "errors", "events", "orders", "runs", "workers", "tags", "codes", "sections", "nos", "Rs", "frames", "jobs", "limits", "MS", "Blocks"], "inverse": ["inreverse", "Inject", "conversible", "insvert", "insversible", " invert", "convert", " inversible", "inversible", " inject", "Inreverse", "invert", "converse", "Inverse", "conreverse", "Invert", "inject", "insject", " inreverse", "Inversible", "insverse"], "result": ["function", "reverse", "count", "command", "error", "complete", "results", "ret", "name", "see", "page", "process", "full", "cache", "sequence", "mark", "output", "position", "date", "debug", "void", "length", "search", "front", "description", "power", "match", "default", "word", "report", "prefix", "product", "block", "run", "final", "create", "chain", "summary", "config", "render", "number", "back", "RESULTS", "out", "also", "response", "answer", "reason", "total", "root", "this", "mask", "transform", "display", "public", "success", "example", "be", "work", "join", "Result", "table", "make", "runner", "new", "data", "mate", "component", "test", "memory", "comment", "res", "next", "bridge", "relation", "all", "section", "view", "buffer", "replace", "trace", "message", "list"], "cc": ["cz", "dc", "ic", "BC", "rc", "circ", "inc", "cp", "ll", "cm", "cy", "cca", "lc", "ct", "bc", "bb", "cmp", "cf", "nc", "acc", "ck", "cci", "ucc", "code", "zz", "pc", "ctl", "kk", "erc", "cu", "cn", "sc", "cs", "ec", "vc", "uc", "cus", "ac", "sec", "ctr", "cl", "vv", "co", "mc", "card", "pp", "cd", "fc", "ce", "sq", "Mc", "gc", "xx", "tc", "CCC", "cell", "nn", "ci"], "rows": ["bytes", "times", "results", "keys", "users", "ors", "_", "height", "iter", "OWS", "views", "num", "s", "files", "headers", "rown", "names", "boxes", "fields", "groups", "bs", "items", "types", "ows", "S", "tests", "values", "heads", "n", "reads", "its", "RS", "cells", "chains", "x", "ros", "checks", "cases", "pages", "lines", "res", "range", "olds", "rs", "errors", "tr", "orders", "cs", "runs", "cont", "cr", "sections", "Rs", "frames", "ries", "states"], "columns": ["columntypes", "Columnensions", " columnS", "columnns", "holdS", "colns", " Columns", "Columnists", "Columnsets", "colsets", "colls", "colS", "characterensions", "holdsize", "columners", "colensions", "characterS", "cltypes", "Columnes", "paragraphS", "ColumnS", "rownS", "paragraphensions", "rowns", "Columners", "clt", "columnains", "columneds", "colists", "Columns", "columnls", " columnt", " Columntypes", "holds", "characters", "rownes", "widthts", "cleds", "rowners", "columnts", "cls", "Columnains", "colsize", " columnists", " columnensions", "widthes", "characterns", "columnsets", " columntypes", "paragraphns", "colers", " Columnt", "columnsize", "columnensions", "holdsets", "paragraphs", "columnists", "columnes", "widths", "coles", " columneds", "colts", "Columnts", " Columneds", "colains", "columnt", "cols", " columnains", "Columnls", "widthls", "Columnsize", "columnS"], "size": ["empty", "total", "count", "check", "storage", "type", "space", "settings", "fit", "bytes", "si", "column", "m", "time", "site", "address", "s", "g", "style", "grow", "scale", "name", "capacity", "chain", " sizes", "see", "radius", " Size", "shape", "SIZE", "send", "margin", "sc", "sample", "cs", "set", "width", "multiple", "scan", "extra", "align", "scroll", "ize", "number", "body", "score", "sized", "len", "height", "tie", "format", "second", "ice", "dimension", "length", "news", "data", "Size", "sum", "ci", "scope", "power", "small", "message", "num"], "r": ["res", "range", "j", "p", "er", "fr", "adr", "re", "err", "rs", "rec", "t", "o", "m", "yr", "nr", "ro", "run", "rb", "n", "ur", "f", "ar", "w", "d", "pr", "q", "i", "l", "Row", "hr", "cr", "rar", "x", "usr", "sr", "dr", "Rs", "mr", "vr", "rd", "rt"]}}
{"code": " \\n  \\n  \\n  \\n  \\n  \\n  \\n  \\n  \\n  \\n  \\n  \\n  \\n  \\n  \\n  \\n  \\n  \\n  def debug(*args):\\n      print(*args, file=sys.stderr)\\n  \\n  fin = sys.stdin\\n  T = int(fin.readline())\\n  for case in range(1, T + 1):\\n      answer1 = int(fin.readline())\\n      rows1 = []\\n      for i in range(4):\\n          rows1.append(set(map(int, fin.readline().split())))\\n      answer2 = int(fin.readline())\\n      rows2 = []\\n      for i in range(4):\\n          rows2.append(set(map(int, fin.readline().split())))\\n  \\n      possibilities1 = rows1[answer1-1]\\n      possibilities2 = rows2[answer2-1]\\n  \\n      numbers = possibilities1.intersection(possibilities2)\\n      result = None\\n      if len(numbers) == 1:\\n          result = list(numbers)[0]\\n      elif len(numbers) == 0:\\n          result = 'Volunteer cheated!'\\n      else:\\n          result = 'Bad magician!'\\n  \\n  \\n      print(\"Case #%d: %s\" % (case, result))\\n  \\n", "substitutes": {"fin": ["fd", "trans", "form", "fr", "reader", "dat", "foot", "sent", "rec", "forth", "fl", "van", "den", "Fin", "erd", "irm", "n", "fo", "det", "han", "f", "ren", "fine", "inn", "mn", "ini", "conn", "fun", "train", "ran", "dig", "fil", "pid", "fen", "ln", "front", "syn", "fol", "pen", "dis", "ven", "eric", "mont", "raf", "len", "dr", "FIN", "fp", "file", "fc", "conv", "fs", "sys", "fi", "fn", "fa", "dir", "bin", "fre"], "T": ["Time", "D", "G", "O", "TT", "TN", "t", "L", "A", "Q", "Test", "R", "TH", "B", "TC", "TS", "TA", "F", "V", "M", "TW", "Z", "Y", "N", "GT", "TB", "C", "K", "I", "P", "W", "VT", "S"], "case": ["trial", "se", " num", "one", " cases", "su", "count", " one", "issue", "U", "zero", "patch", "ace", " ace", "example", " CASE", " number", "CE", "condition", "line", " t", " time", " test", " c", "Case", "number", "sequence", " cas", " Case", "C", "ice", "cases", "ASE", "ase", "I", "P", "ce", "ca", "c", "tc", " line", "test", "cas"], "answer1": ["answerFirst", "orderone", "answered01", "answeredFirst", " answerOne", "answered1", "answer01", "orderBack", "iteratorone", "answeredOne", "answerone", " answer01", "orderOne", "iteratorBack", "responseone", "iteratorOne", " answerFirst", "answerBack", "answerOne", "response01", "order1", "response1", "responseFirst", "iterator1", "responseOne", "responseBack"], "rows1": ["ows2", "rows01", "rows0", " rows01", "rown11", "ows5", "ows11", "rown1", "rownOne", "orders1", "orders01", "row11", "rown5", "rown0", "rowOne", "row5", "row0", " rowsOne", "row1", "rown2", "ows1", "ordersOne", "rown01", "owsOne", "ows0", "row2", "rows11", "rows5", "rowsOne"], "i": ["gi", "ic", "li", "iy", "it", "ia", "ik", "iti", "ri", "ei", "il", "ti", "ini", "si", "xi", "im", "ai", "\u00ed", "ip", "oi", "ii", "pi", "ij", "ati", "di", "I", "zi", "ir", "ci"], "answer2": ["swersTwo", "answerTwo", "Answertwo", "root3", "swerstwo", "swerssecond", " answer3", "answeredtwo", "answersecond", "Answer3", "enitwo", " answertwo", "answeredTwo", "answeredsecond", "answertwo", "swers2", "Answer1", "roottwo", "answer3", "eniTwo", "eni2", "answered2", "root1", "root2", "enisecond", "Answer2"], "rows2": ["ows2", "flows256", "orders3", "rys102", "rowsTwo", "roomsB", "owsTwo", "owsB", "ordersTwo", "ews3", "flows2", " rowsB", "ewsTwo", "orders2", "flows1", "rows256", "rooms1", "rys2", "ows256", "rowsB", "ows3", "ows102", "ews82", "ows1", "orders82", "flows102", "roomsTwo", "rooms2", "rows82", "rows3", " rowsTwo", "rys1", "ews2", "rys256", "ows82", "rows102"], "possibilities1": ["possibles2", "positibilities1", "possibilitiesOne", "possilities1", "ponsibilities2", "possilitiesOne", "positibilities2", "possions2", "possionsOne", "ponsibles0", "ponsibles11", "ponsibles2", "possions11", "possilities2", "possibility11", "possions0", "positibility1", "possions1", "positibilityOne", "ponsibilities0", "possilities0", "possibility2", "positibility0", "possibility1", "ponsibles1", "ponsibilities11", "possibility0", "positibilities0", "positibility2", "possibles1", "possibilities11", "possibilityOne", "ponsibilities1", "possibles11", "possibilities0", "positibilitiesOne", "possibles0"], "possibilities2": ["passibilities3", "passibles0", "possibles2", "possions3", "possibilities02", "possibilities3", "pessibilities1", "pessibilities02", "possiesB", "possibilityB", "possilities3", "possies2", "passibilities2", "possies02", "possibles3", "pessibilitiesB", "possions2", "pessibility1", "pessibility2", "possies1", "passibles2", "possilities2", "possiencies02", "possibility02", "possions0", "possienciesB", "possilities0", "possiencies1", "passibles3", "passibilities0", "possibility2", "possibility1", "pessibilities2", "pessibility02", "possiencies2", "possibilitiesB", "possibilities0", "pessibilityB", "possibles0"], "numbers": ["pumbers", "dNumbers", " nomers", "poms", " noms", " nums", "Nodes", " numeric", "numumer", "numer", "norumbers", "Nums", "Numbers", "noromers", "numumber", "nums", "neNumbers", "dumeric", "sumeric", "Numer", "norums", "dumbers", "sodes", "sumbers", "Numeric", " number", "neumbers", "norumeric", "numumbers", "numeric", "dums", "neums", "pomers", "NNumbers", "nNumbers", "noms", "numodes", "number", "nomers", "neumeric", "Number", "sums", "podes", "noroms", "norodes", " numer", " nodes", "nodes"], "result": ["res", "function", "answer", "reason", "match", "type", "the", "report", "correct", "part", "prefix", "product", "command", "error", "relation", "success", "complete", "results", "grade", "term", "final", "group", "username", "ret", "name", "something", "process", "description", "summary", "r", "cert", "successful", "view", "successfully", "Result", "value", "table", "number", "RESULTS", "output", "currency", "string", "title", "profile", "contact", "date", "format", "msg", "status", "data", "mate", "method", "component", "response", "pair", "test", "comment", "message", "list"]}}
{"code": " \\n  def generate_matrix(r, c, char):\\n  \tmat = [[char for i in range(c)] for j in range(r)]\\n  \treturn mat\\n  \t\\n  def merge(mat1, mat2):\\n  \tfor i in range(len(mat1)):\\n  \t\tfor j in range(len(mat1[i])):\\n  \t\t\tmat2[i][j] = mat1[i][j]\\n  \treturn mat2\\n  \\n  def solve(r, c, m):\\n  \tif 0 == m:\\n  \t\tmat = generate_matrix(r, c, '.')\\n  \t\tmat[0][0] = 'c'\\n  \t\treturn mat\\n  \t\t\\n  \tf = r * c - m\\n  \t\\n  \tif 0 == f:\\n  \t\treturn False\\n  \t\t\\n  \tif 1 == f:\\n  \t\tmat = generate_matrix(r, c, '*')\\n  \t\tmat[0][0] = 'c'\\n  \t\treturn mat\\n  \t\t\\n  \tif 1 == min(r, c):\\n  \t\tmat = generate_matrix(r, c, '*')\\n  \t\tfor i in range(f):\\n  \t\t\tmat[0 if 1 == r else i][0 if 1 == c else i] = '.'\\n  \t\tmat[0][0] = 'c'\\n  \t\treturn mat\\n  \\n  \tif 2 == min(r, c):\\n  \t\tif (0 != f % 2) or (2 == f):\\n  \t\t\treturn False\\n  \t\tmat = generate_matrix(r, c, '*')\\n  \t\tfor i in range(f // 2):\\n  \t\t\tmat[0 if 2 == r else i][0 if 2 == c else i] = '.'\\n  \t\t\tmat[1 if 2 == r else i][1 if 2 == c else i] = '.'\\n  \t\tmat[0][0] = 'c'\\n  \t\treturn mat\\n  \t\t\\n  \tif (3 == r) and (3 == c):\\n  \t\tif (4 == f) or (6 == f):\\n  \t\t\tmat = generate_matrix(r, c, '*')\\n  \t\t\tfor i in range(f // 2):\\n  \t\t\t\tmat[0][i] = '.'\\n  \t\t\t\tmat[1][i] = '.'\\n  \t\t\tmat[0][0] = 'c'\\n  \t\t\treturn mat\\n  \t\tif 8 == f:\\n  \t\t\tmat = generate_matrix(r, c, '.')\\n  \t\t\tmat[2][2] = '*'\\n  \t\t\tmat[0][0] = 'c'\\n  \t\t\treturn mat\\n  \t\treturn False\\n  \t\t\\n  \trows_to_reduce = min(r - 3, m // c)\\n  \tif 0 < rows_to_reduce:\\n  \t\tres = solve(r - rows_to_reduce, c, m - rows_to_reduce * c)\\n  \t\tif False == res:\\n  \t\t\treturn False\\n  \t\tmat = merge(res, generate_matrix(r, c, '*'))\\n  \t\treturn mat\\n  \t\t\\n  \tcols_to_reduce = min(c - 3, m // r)\\n  \tif 0 < cols_to_reduce:\\n  \t\tres = solve(r, c - cols_to_reduce, m - cols_to_reduce * r)\\n  \t\tif False == res:\\n  \t\t\treturn False\\n  \t\tmat = merge(res, generate_matrix(r, c, '*'))\\n  \t\treturn mat\\n  \t\\n  \tmat = generate_matrix(r, c, '.')\\n  \tfor i in range(min(m, r - 2)):\\n  \t\tmat[r - i - 1][c - 1] = '*'\\n  \tif m == r - 1:\\n  \t\tmat[r - 1][c - 2] = '*'\\n  \tmat[0][0] = 'c'\\n  \treturn mat\\n  \t\t\t\\n  \\n  t = int(sys.stdin.readline().strip())\\n  \\n  for i in range(t):\\n  \tprint \"Case #\" + str(i + 1) + \":\"\\n  \\n  \tr, c, m = [int(i) for i in sys.stdin.readline().strip().split()]\\n  \t\\n  \tres = solve(r, c, m)\\n  \t\\n  \tif False == res:\\n  \t\tprint \"Impossible\"\\n  \telse:\\n  \t\tfor i in range(r):\\n  \t\t\tfor j in range(c):\\n  \t\t\t\tsys.stdout.write(res[i][j])\\n  \t\t\tprint\\n", "substitutes": {"r": ["range", "br", "p", "rem", "rc", "ra", "er", "root", "re", "e", "fr", "rs", "rx", "reg", "o", "lr", "rec", "h", "nr", "ro", "rg", "rb", "n", "ur", "ren", "R", "ri", "raw", "rate", "rf", "g", "ar", "ru", "rw", "w", "d", "pr", "tr", "u", "q", "y", "rect", "b", "me", "l", "rr", "hr", "cr", "rar", "x", "usr", "sr", "attr", "th", "dr", "gr", "rm", "mr", "vr", "rn", "v", "rd", "ir", "rt", "rh"], "c": ["p", "col", "e", "cur", "h", "bc", "con", "cos", "pc", "cat", "w", "d", "cb", "cache", "cd", "fc", "ca", "ce", "a", "gc", "enc", "ci", "cp", "o", "lc", "ct", "cf", "nc", "s", "chain", "cu", "u", "sc", "vc", "cin", "cc", "mc", "ch", "C", "etc", "v", "rc", "z", "n", "g", "anc", "arc", "y", "ec", "ac", "cor", "content", "l", "co", "x", "dc", "ic", "cm", "xc", "can", "erc", "cs", "b", "cont", "cl", "unc", "cr", "loc", "tc", "com"], "char": ["color", "k", "str", "fr", "col", "er", "err", "cp", "word", "cur", "letter", "term", "ar", "name", "int", "tr", "u", "q", "character", "cher", "ctr", "cr", "car", "ch", "Char", "string", "ter", "new", "CHAR", "ie", "v", "che", "cell", "text", "test", "com"], "mat": ["function", "tmp", "func", "col", "at", "mac", "mol", "term", "att", "spec", "jac", "cat", "full", "fm", "cert", "prop", "late", "mk", "port", "html", "rat", "mp", "apt", "mem", "plot", "et", "lat", "mon", "num", "match", "trans", "dat", "product", "txt", "ct", "vert", " matrix", "hist", "mand", "feat", "Matrix", "rot", "umat", "gem", "config", "struct", "wat", "pred", "mit", "qt", "wt", "mot", "pt", "ht", "cfg", "pat", "flat", "tag", "form", "tm", "it", "img", "transform", "mm", "doc", "cond", " Mat", "path", "det", "exp", "um", "sit", "man", "grid", "mode", "mt", "dict", "x", "sche", "vec", "net", "met", "gate", "format", "map", "hat", "mate", "MAT", "pos", "dim", "sat", "case", "tt", "act", "pose", "cmd", "buf", "Mat", "only", "dt", "atten", "pit", "multi", "init", "db", "stat", "unit", "red", "tar", "bool", "prot", "mut", "ma", "md", "msg", "mult", "mun", "xy", "method", "mod", "list"], "i": ["ki", "hi", "p", "li", "e", "io", "iti", "name", "item", "ai", "pi", "ii", "ati", "iter", "zi", "a", "ie", "ir", "ci", "gi", "ji", "uri", "o", "ik", "key", "id", "ini", "bi", "u", "xi", "\u00ed", "ij", "iu", "ix", "di", "v", "ib", "it", "n", "g", "ui", "info", "ti", "il", "y", "l", "x", "ion", "ee", "ic", "ami", "iy", "ia", "iri", "ri", "phi", "ei", "int", "index", "si", "im", "mi", "ip", "ma", "I", "yi"], "j": ["ji", "p", "jj", "k", "jl", "fr", "er", "li", "it", "jp", "o", "h", "z", "n", "g", "ja", "jac", "bi", "index", "si", "uj", "u", "q", "y", "J", "kj", "b", "dj", "l", "oj", "x", "ij", "jc", "ch", "ix", "js", "jump", "ie", "v", "je", "aj", "ir", "bj", "ind"], "mat1": [" mat3", "mat0", "mat01", "hat1", "hat3", " mat01", "mt2", "Mat8", "cat2", "Mat2", "pat1", "mt1", "mtOne", "Mat0", "Mat3", "cat3", "pat0", "matOne", "mat8", "matone", "Matone", "catOne", " matOne", "pat8", "Mat1", "patOne", "pat01", "MatOne", "hatone", "pat2", "hat2", "mat3", " matone", "Mat01", " mat0", "cat1", "mt8"], "mat2": [" mat3", "mat0", "cat0", "hat3", "mem8", "Mat8", "mt2", "cat2", "Mat2", "pat1", "Mat0", "pat3", "Mat3", "pat0", "mt5", "cat3", "mat8", "mt3", " mat0", "cat5", "mem1", "Mat1", "hat0", "mat5", "pat2", " mat8", "hat2", "mem3", "mat3", "hat5", "mem2", "mt0"], "m": ["p", "k", "tm", "e", "ms", "cm", "o", "mm", "h", "n", "g", "perm", "d", "gm", "u", "q", "mi", "y", "fm", "b", "M", "mt", "l", "mc", "mut", "ma", "mr", "a", "km", "v"], "f": ["fd", "p", "bf", "k", "fr", "df", "e", "it", "o", "fe", "fl", "h", "of", "cf", "n", "g", "z", "rf", "frac", "all", "fg", "fb", "w", "d", "full", "tf", "u", "q", "y", "sf", "F", "fm", "ff", "b", "l", "float", "x", "fac", "fp", "file", "fc", "a", "v", "fi", "fa"], "rows_to_reduce": ["rows_to_Reduction", "rows_to_reduction", "rows_to_resuce", "rows_to_dedure", "rows_to_redure", "rows_to_reducer", "rows_to_Reducer", "rows_to_deduce", "rows_to_deducer", "rows_to_Redure", "rows_to_resucer", "rows_to_deduction", "rows_to_Reduce", "rows_to_resuction", "rows_to_resure"]}}
{"code": " \\n  def read_row():\\n  \ta = int(sys.stdin.readline().strip())\\n  \tfor j in range(a - 1):\\n  \t\tsys.stdin.readline()\\n  \tread_set = set(sys.stdin.readline().strip().split(\" \"))\\n  \tfor j in range(5 - a - 1):\\n  \t\tsys.stdin.readline()\\n  \t\t\\n  \treturn read_set\\n  \\n  \\n  t = int(sys.stdin.readline().strip())\\n  \\n  for i in range(t):\\n  \tprint \"Case #\" + str(i + 1) + \":\",\\n  \\n  \tset1 = read_row()\\n  \tset2 = read_row()\\n  \t\\n  \tintersect = set1.intersection(set2)\\n  \t\\n  \tif 1 == len(intersect):\\n  \t\tprint intersect.pop()\\n  \telif 0 == len(intersect):\\n  \t\tprint \"Volunteer cheated!\"\\n  \telse:\\n  \t\tprint \"Bad magician!\"\\n", "substitutes": {"a": ["au", "sa", "p", "act", "la", "count", "at", "area", "o", "m", "A", "ax", "h", "an", "n", "s", "all", "g", "am", "aa", "va", "ao", "aaa", "index", "na", "u", "r", "ai", "b", "ac", "ga", "l", "ae", "x", "eas", "oa", "ea", "ma", "ca", "ta", "c", "aka"], "j": ["ji", "p", "jj", "ju", "k", "str", "li", "it", "jp", "ia", "jo", "ax", "h", "z", "n", "g", "f", "ja", "uj", "q", "y", "r", "ai", "kj", "b", "l", "x", "ij", "jc", "ch", "ix", "js", "v", "aj", "ind"], "read_set": ["readvalSET", "read2SET", "readvalset", "read_Set", " read2SET", "read2set", "read_SET", " read_Set", " read_SET", "readvalSet", "read2Set", " read2set", " read2Set"], "t": ["tt", "total", "p", "type", "tm", "e", "it", "ties", "o", "m", "time", "h", "z", "n", "g", " T", "all", "f", "name", "ti", "w", "d", "dt", "r", "b", "l", "number", "ot", "to", "te", "title", "tu", "c", "ta", "v", "tc", "ts", "T", "tw"], "i": ["gi", "ji", "hi", "p", "k", "iq", "li", "e", "o", "m", "ik", "key", "id", "n", "z", "f", "qi", "ti", "ini", "bi", "d", "si", "xi", "im", "y", "mi", "ai", "ip", "l", "x", "pi", "ii", "ij", "ix", "di", "I", "zi", "c", "v", "ind"], "set1": ["Set2", "pair1", "set0", " seta", " set0", "pair2", "Set1", "et3", "paira", "Set0", "Set3", "set3", "pair0", " set3", "et0", "Seta", "et1", "et2", "seta"], "set2": ["set0", "set4", "et02", " set0", "store02", "store4", " setb", "et3", " set4", "et4", "storeb", " set02", "etb", "store2", "set02", "set3", "store0", " set3", "et0", "store1", "setb", "et1", "store3", "et2"], "intersect": ["intersection", "pairput", "pairect", "terput", "interconnect", "Intersection", "Interect", "Intersect", "intect", " Interract", "intsect", "cosect", "pairsect", "coput", "intract", "terect", "pairsection", "tersection", "intsection", " Intersection", " Interect", "interract", "INTERsect", "interput", "Interconnect", "coect", "INTERect", "INTERract", " Intersect", "cosection", "terract", "interect", "tersect", "intconnect", "Interract", "terconnect", "INTERsection"]}}
{"code": "directory = 'C:/users/me/desktop/google code jam/2014/qualification/C/'\\n  \\n  \\n  \\n  def solve_one_case (R,C,M):\\n          l = []\\n          for i in range(R):\\n              for j in range(C):\\n                  l.append((i,j))\\n  \\n          empty_mat = []\\n          for i in range(R):\\n              empty_mat.append(['.']*C)\\n  \\n          found = False\\n  \\n          assert (0,0) in l\\n          l = l[1:]\\n          l = l[::-1]\\n          assert (0,0) not in l\\n          \\n          output = ''\\n          \\n          for mine_placement in itertools.combinations(l,M):\\n              mat = deepcopy(empty_mat)\\n              for cell in mine_placement:\\n                  mat[cell[0]][cell[1]] = '*'\\n              if isOneClick(mat, R, C, M):\\n                  mat[0][0] = 'c'\\n                  for line in mat:\\n                      output += ''.join(line) + '\\n'\\n                  found = True\\n                  return output\\n              \\n          if not found:\\n              return 'Impossible\\n'\\n          \\n          assert ValueError()\\n          \\n  def solve (f_in, f_out):\\n      T = int(f_in.readline())\\n      for testcase in range(1,T+1):\\n          line = f_in.readline()\\n          R,C,M = [int(q) for q in line.split()]\\n          print (testcase,R,C,M)\\n  \\n          output = solve_one_case (R,C,M)\\n          f_out.write('Case #' + str(testcase) + ':\\n')\\n          f_out.write(output)\\n  \\n          \\n  \\n  \\n  def isOneClick (mat, R, C, M):\\n  \\n      mat_cpy = deepcopy(mat)\\n      oneclickcells = [(0,0)]\\n      while oneclickcells:\\n          node = oneclickcells.pop()\\n          mat_cpy[node[0]][node[1]] = 'v'\\n          if noNearbyMines(mat_cpy,node):\\n              oneclickcells.extend(getNearbyUnvisited(mat_cpy, node))\\n  \\n      return sum([l.count('.') for l in mat_cpy]) == 0\\n      \\n  \\n  def getNearbyUnvisited(mat, node):\\n      R = len(mat)\\n      C = len(mat[0])\\n      deltas_r = [0]\\n      deltas_c = [0]\\n      if node[0] > 0:\\n          deltas_r.append(-1)\\n      if node[1] > 0:\\n          deltas_c.append(-1)\\n      if node[0] < R-1:\\n          deltas_r.append(1)\\n      if node[1] < C-1:\\n          deltas_c.append(1)\\n  \\n      ret_list = []\\n      for delta_r in deltas_r:\\n          for delta_c in deltas_c:\\n              next_node = (node[0]+delta_r, node[1] + delta_c)\\n              if mat[next_node[0]][next_node[1]] not in ['*','v']:\\n                  ret_list.append((next_node[0],next_node[1]))\\n  \\n      return ret_list\\n  \\n  def noNearbyMines(mat,node):\\n      R = len(mat)\\n      C = len(mat[0])\\n      deltas_r = [0]\\n      deltas_c = [0]\\n      if node[0] > 0:\\n          deltas_r.append(-1)\\n      if node[1] > 0:\\n          deltas_c.append(-1)\\n      if node[0] < R-1:\\n          deltas_r.append(1)\\n      if node[1] < C-1:\\n          deltas_c.append(1)\\n  \\n      for delta_r in deltas_r:\\n          for delta_c in deltas_c:\\n              if mat[node[0] + delta_r][node[1] + delta_c] == '*':\\n                  return False\\n      return True\\n      \\n  def main_run():\\n      filenames = [x for x in os.listdir (directory)]\\n      filenames = [x for x in filenames if x.endswith('.in')]\\n      l1 = [(os.stat(directory+x).st_mtime, x) for x in filenames]\\n      chosen_filename =  sorted(l1)[-1][1][:-3]\\n  \\n      print ('Directory : ', directory)\\n      print ('Chosen Filename : ',chosen_filename)\\n      print()\\n      print ('Start : ', time.ctime())\\n      print()\\n      \\n      f_in = open(directory+chosen_filename+'.in')\\n      f_out = open(directory+chosen_filename+'.out', 'w')\\n      solve(f_in,f_out)\\n      f_in.close()\\n      f_out.close()\\n  \\n      print ()\\n      print ('End : ', time.ctime())\\n  \\n  \\n  main_run()\\n  \\n", "substitutes": {"directory": ["D", "root", "volume", "uri", "prefix", "filename", "command", "Directory", "disk", "path", "n", "doi", "database", "location", "project", "d", "picture", "folder", "Dir", "application", "email", "entry", "home", "collection", "pattern", "file", "library", "dir", "wd"], "R": ["D", "col", "e", "U", "A", "of", "AR", "Mr", "_", "F", "r", "J", "Rot", "call", "RM", "RT", "RI", "Dr", "G", "block", "DR", "Remote", "B", "Res", "RL", "NR", "RW", "select", "S", "MR", "ER", "X", "RA", "L", "RC", "RG", "RO", "RS", "join", "Y", "RE", "new", "P", "lines", "IR", "SR", "O", "H", "CR", "Q", "E", "all", "V", "cont", "just", "N", "TR", "GR", "RR", "Ring", "Rs", "I", "BR", "com"], "C": ["COM", "Co", "D", "G", "O", "JC", "Ch", "X", "H", "L", "U", "HC", "CR", "Q", "E", "CM", "CN", "A", "CBS", "AC", "CS", "B", "Cons", "CA", "Cl", "CE", "IC", "CV", "CC", "F", "CON", "J", "Craig", "SC", "V", "EC", "Con", "Y", "CNN", "N", "ERC", "CT", "CG", "VC", "CF", "CP", "DC", "K", "I", "YC", "P", "Cache", "W", "c", "CL", "CCC", "MC", "CU", "S", "Cs", "CW"], "M": ["D", "VM", "O", "G", "Ch", "X", "H", "L", "m", "TM", "U", "E", "Q", "A", "CM", "MR", "MN", "REM", "NM", "OM", "Mon", "MAN", "B", "PM", "JM", "MM", "MX", "MO", "F", "J", "IM", "V", "Mode", "Manager", "Y", "LM", "EM", "N", "Ms", "MT", "MI", "K", "I", "RM", "P", "DM", "W", "MC", "MS", "S", "AM"], "l": ["label", "p", "jl", "li", "base", "at", "t", "lr", "long", "m", "le", "sl", "h", "ls", "dl", "lit", "d", "local", "r", "log", "el", "tl", "like", "a", "c", "o", "fl", "lc", "lay", "left", "lp", "pl", "lt", "nl", "ly", "ln", "ch", "yl", "v", "kl", "ll", "lab", "L", "lis", "z", "n", "g", "f", "il", "ol", "lb", "len", "lines", "range", "la", "lin", " L", "all", "lo", "rl", "b", "layer", "loc", "al", "hl", "ul", "ml", "list"], "i": ["gi", "ji", "ic", "p", "k", "li", "e", "it", "t", "m", "z", "n", "ri", "int", "ti", "ini", "il", "si", "xi", "im", "mi", "y", "u", "r", "ai", "b", "ip", "pi", "ii", "ij", "iu", "ix", "zi", "I", "a", "c", "ie", "v", "ir", "ci"], "j": ["ji", "p", "jj", "k", "jl", "li", "e", "jp", "t", "o", "m", "z", "n", "g", "f", "bi", "uj", "y", "r", "J", "kj", "b", "dj", "oj", "ij", "job", "jc", "js", "jump", "c", "v", "aj"], "empty_mat": ["empty_ct", "empty___mat", "empty_list", " empty_at", "empty2list", "empty___cat", "empty_cat", " empty_ct", "empty_mot", "empty67mot", " empty2list", "empty2at", "empty_col", "complete___dat", "empty67col", "complete_dat", "complete_mot", "empty___mot", "empty___ct", "empty_man", "empty2mat", "empty_at", " empty2mat", "complete_col", "empty___list", " empty2man", "empty___dat", " empty2at", "empty2man", "empty___col", "empty_dat", "complete___mat", " empty_cat", "empty67dat", " empty_man", "complete___col", "complete_mat", "empty67mat", "complete___mot", " empty_list"], "found": ["fd", "done", "matched", "count", "form", "connected", "initialized", "sent", "used", "built", "t", "ent", "compl", "error", "given", "success", "conf", "ed", "all", "f", "seen", "shown", "started", "failed", "result", "released", "index", "d", "loaded", "finder", "created", "identified", "hit", "filled", "find", "finding", "printed", "fixed", "diff", "Found", "first", "stable", "search", "pos", "confirmed", " Found", "valid"], "output": ["answer", "detail", "next", "update", "str", "type", "cut", "command", "o", "outer", "display", "error", "success", "path", "option", "example", "shell", "generated", "null", "pretty", "section", "result", "summary", "left", "module", "ut", "current", "html", "config", "write", "successful", "log", "buffer", "value", "hidden", "network", "table", "comment", "put", "tail", "figure", "document", "bool", "body", "net", "job", "position", "input", "come", "string", "format", "new", "debug", "print", "out", "file", "ion", "data", "header", "plot", "response", "text", "Output", "message"], "mine_placement": ["mine_pracement", "mine_Plination", "mine_participancy", "mine_Placement", "mine_replacements", "mine_lancy", "mine_splacing", "mine_placements", "mine_lination", "mine_splification", "mine_splacements", "mine_Placements", "mine_plancy", "mine_participacements", "mine_replacement", "mine_participacement", "mine_pracements", "mine_pracing", "mine_replacing", "mine_prification", "mine_lacement", "mine_splacement", "mine_lacements", "mine_placing", "mine_plification", "mine_Plancy", "mine_replification", "mine_participination", "mine_plination"], "mat": ["tmp", "p", "col", "li", "at", "mac", "m", "mol", "h", "att", "ret", "jac", "cat", "set", "cache", "r", "log", "mk", "batch", "tree", "kat", "mem", "c", "plot", "lat", "mon", "match", "dat", "ct", "json", "np", "mit", "out", "mr", "bat", "mot", "flat", "pat", "tm", "ll", "it", "lab", "mm", "doc", "path", "man", "grid", "mode", "mt", "dict", "co", "table", "net", "vec", "format", "hat", "mate", "MAT", "sum", "pos", "test", "tt", "act", "cm", "lin", "Mat", "result", "dt", "multi", "db", "stat", "cont", "unit", "tab", "nt", "ma", "md", "mun", "rm", "ml", "rt", "text", "list"], "cell": ["label", "check", "word", "col", "cp", "column", "butt", "client", " Cell", "ck", "tile", "shell", "page", "char", "field", "item", "tex", "lay", "cache", "entry", "cin", "row", "cells", "Cell", "tab", "cel", "el", "co", "call", "cc", "table", "job", "ell", "pixel", "slice", "ce", "square", "c", "cer", "tc", "ql", "edge", "sel", "case"], "line": ["range", "Line", "match", "ide", "word", "frame", "e", "source", "col", "li", "note", "lin", "column", "m", "eline", "LINE", "le", "block", " Line", "online", "code", "term", "lo", "lined", "name", "page", "quote", "item", "result", "field", "ze", "change", "sample", "ine", "define", "set", "left", "entry", "email", "write", "link", "row", "log", "unit", "lt", "nl", "query", "text", "ln", "list", "liner", "position", "input", "string", "format", "phrase", "out", "inline", "lines", "lock", "edge", "comment", "case", "pair"], "f_in": [" f_IN", " f_ins", "f_In", "f_ins", "file_ins", "file_in", "f_din", " f_In", "f_IN", " f_din", "file_din", "file_out"], "f_out": ["f_OUT", " f2in", "foutOUT", "f2err", " f2w", " f2OUT", " f_Out", " f2out", "foutin", "f_output", " f_t", "f2OUT", "f2out", "foutw", "f2in", " f_w", " f_output", "f_w", "f_t", "f_Out", "f2Out", " f_OUT", "f_err", "foutout", "f2w", " f_err"], "T": ["Time", "D", "O", "TT", "TN", "IT", "X", "t", "H", "L", "TM", "TY", "B", "TC", "TS", "TA", "F", "OT", "V", "Z", "Y", "NT", "N", "WT", "GT", "PO", "TR", "TB", "K", "I", "P", "W", "TO", "VT", "S"], "testcase": ["casease", "caseline", " testase", "vertest", "testCase", "TestCase", "vercase", "verline", "showline", "traincase", "showtest", " testline", "trainCase", " testCase", "testase", "verCase", "showCase", "Testcase", "testtest", "showcase", "traintest", " testtest", "Testtest", "Testase", "casecase", "testline", "Testline", "caseCase"], "q": ["p", "k", "qv", "iq", "quality", "col", "e", "li", "t", "qu", "Q", "ox", "qq", "qual", "n", "g", "term", "ck", "f", "eq", "name", "qi", "char", "field", "cat", "question", "quit", "ine", "r", "ue", "cl", "query", "qt", "ch", "dq", "sq", "c", "ql", "text", "test", "sel", "case"], "mat_cpy": ["mat_cple", "mat_pply", "mat_pumpy", "mat_rcumpy", "mat_lcumpy", "mat___cpy", "mat_cumpy", "mat_lcps", "mat_Cly", "mat_Caxy", "mat_mcpy", "mat_lcpy", "mat_ciopy", "mat_csple", "mat_cipy", "mat_lcply", "mat_lcaxy", "mat_ccbd", "mat_lcly", "mat_rcply", "mat___vcaxy", "mat_cspl", "mat_ppy", "mat_rcps", "mat_ccpy", "mat_Cpy", "mat_mcPy", "mat_cibd", "mat_mcpl", "mat_cpl", "mat___caxy", "mat_cachePy", "mat___cly", "mat_copy", "mat_cbd", "mat_rcPy", "mat_ccopy", "mat___vcpy", "mat_cps", "mat_cspy", "mat_ciny", "mat_cPy", "mat_mcple", "mat_vcly", "mat_cciny", "mat_coPy", "mat_rcbd", "mat___vcly", "mat_vcaxy", "mat_rcpy", "mat_csPy", "mat_rcopy", "mat_lcPy", "mat_cacheple", "mat_cply", "mat_cops", "mat_ciiny", "mat_cachepy", "mat_cly", "mat_vcpy", "mat_cachepl", "mat_rciny", "mat_caxy"], "oneclickcells": ["onecheckers", "oneclickrooms", " onecommentrooms", "onefocuscell", "oneclickcell", "onecommentcells", "onetrackbands", " oneclickers", "onewaitcells", "onecheckrooms", " oneclickdevices", "onefocuscells", " onewaitlets", " onecloudcells", " oneclickparts", " oneclickcell", " onecommenters", "onecloudcells", " onewaitvalues", "onecloudrows", " onecommentcells", " onecloudbands", "onecommentrooms", "onelinedevices", " oneclicklocks", "onetracklocks", "oneleafrows", "onecklets", "oneClickvalues", "onecommenters", "onecommentcell", "oneclickdevices", "onefocusrooms", "oneckvalues", " onecloudlocks", "oneclicklines", " onecloudrows", "onelinecells", " oneclickrooms", " onewaitcells", "oneloadlines", "onewaitlets", "oneClicklets", "oneclickparts", " oneclicklines", "oneleafcells", "onelineparts", "onecloudbands", "onecheckcells", " oneclicklets", "oneleaflocks", "oneleafbands", "onefocusers", " oneclickrows", "onecheckcell", "oneclickers", "oneckcells", " onecommentcell", "onelinelines", "oneloadcells", " oneclickvalues", "onewaitvalues", "oneClickcells", "oneclickbands", "oneclicklocks", "oneloaddevices", " oneclickbands", "oneclicklets", "onetrackcells", "oneclickrows", "onetrackrows", "onecloudlocks", "oneloadparts", "oneclickvalues"], "node": ["se", "tmp", "label", "seed", "t", "m", "sim", "window", "ne", "wrapper", "name", "proc", "item", "local", "cache", "link", "row", "instance", "job", "tree", "wife", "box", "normal", "c", "station", "ode", "num", "day", "bo", "source", "part", "no", "manager", "key", "id", "parent", "image", "slot", "field", "dd", "nb", "np", "child", "device", "edge", "sel", "nd", "nw", "worker", "ind", "n", "conn", "holder", "server", "student", "component", "test", "our", "post", "mid", "k", "note", "client", "slave", "self", "index", "entry", "Node", "obj", "msg", "object", "nn"]}}
{"code": "directory = 'C:/users/me/desktop/google code jam/2014/qualification/A/'\\n  \\n  \\n  \\n  def solve (f_in, f_out):\\n      T = int(f_in.readline())\\n      for testcase in range(1,T+1):\\n          \\n          c1 = int(f_in.readline())\\n          l1 = []\\n          for i in range(4):\\n              l1.append(f_in.readline())\\n          \\n          c2 = int(f_in.readline())\\n          l2 = []\\n          for i in range(4):\\n              l2.append(f_in.readline())\\n  \\n          d1 = l1[c1-1].split()\\n          d2 = l2[c2-1].split()\\n  \\n          foundFlag = False\\n          chosenCard = None\\n          badMagician = False\\n          for card in d1:\\n              if card in d2:\\n                  if not foundFlag:\\n                      foundFlag = True\\n                      chosenCard = card\\n                  else:\\n                      badMagician = True\\n  \\n          f_out.write('Case #' + str(testcase) + ': ')\\n          if badMagician:\\n              f_out.write('Bad magician!\\n')\\n          elif not foundFlag:\\n              f_out.write('Volunteer cheated!\\n')\\n          else:\\n              f_out.write(chosenCard + '\\n')\\n  \\n  \\n  \\n  \\n  def main_run():\\n      filenames = [x for x in os.listdir (directory)]\\n      filenames = [x for x in filenames if x.endswith('.in')]\\n      l1 = [(os.stat(directory+x).st_mtime, x) for x in filenames]\\n      chosen_filename =  sorted(l1)[-1][1][:-3]\\n  \\n      print ('Directory : ', directory)\\n      print ('Chosen Filename : ',chosen_filename)\\n      print()\\n      print ('Start : ', time.ctime())\\n      print()\\n      \\n      f_in = open(directory+chosen_filename+'.in')\\n      f_out = open(directory+chosen_filename+'.out', 'w')\\n      solve(f_in,f_out)\\n      f_in.close()\\n      f_out.close()\\n  \\n      print ()\\n      print ('End : ', time.ctime())\\n  \\n  \\n  main_run()\\n", "substitutes": {"directory": ["python", "third", "delete", "password", "root", "volume", "maximum", "word", "space", "binary", "prefix", "filename", "reference", "command", "source", "absolute", "direction", "Directory", "disk", "language", "variable", "relative", "system", "database", "location", "dry", "direct", "archive", "copy", "folder", "application", "buffer", "network", "home", "install", "collection", "number", "hello", "document", "tree", "template", "position", "output", "connection", "environment", "definition", "device", "length", "library", "voice", "description", "memory", "dir", "message"], "f_in": ["f___out", "f__in", "fm_din", "f64out", "f_ins", "fc_out", "f_input", " f_nin", "f_IN", "f__out", "f_err", "f64in", " f_conn", " f_IN", "fc_in", "f___gin", " f_ins", " f_on", "fm_in", "f_nin", "f_din", " f_din", "f_i", " f_input", "f64nin", " f_err", "f_conn", "f__cin", "f_gin", "f__din", " f_gin", "f___conn", "f_inner", " f_i", "fc_inner", "fm_out", "f___in", " f_cin", "f_cin", "f64cin", "fc_ins", "f___input", "f___err", "f_on"], "f_out": ["fockot", "f_end", "f___out", "f__in", "f__on", "f2out", " f_outs", "fockout", " f_end", " f_client", "f__out", "f_writer", "f2Out", "f_write", "f_err", " f_ot", " f_Out", " f_on", "f2in", " f_output", "f_outs", " f2outs", "f_2", " f_writer", " f_err", " f2in", "f___on", "f_n", "f_ot", "f2outs", " f2Out", " f2out", "f_output", "f__err", " f_write", " f_n", "f___in", "f_client", "fockin", "f_Out", "fockn", "f_on", "f___outs", " f_2"], "T": ["Time", "D", "G", "O", "TI", "TT", "TN", "t", "H", "TM", "L", "TY", "E", "A", "Q", "Test", "R", "B", "TC", "TS", "TA", "TIT", "F", "Type", "V", "M", "Y", "N", "GT", "TB", "C", "K", "I", "P", "VT", "S"], "testcase": [" testase", "testcases", "testCase", "TestCase", "matchcase", "validase", "validtest", "Testcondition", " testCase", "testase", "matchcondition", "Testcase", "Testcases", " testcondition", "testtest", "matchcases", " testtest", "Testtest", "testcondition", "validcase", "validCase", "matchCase", "Testase", " testcases"], "c1": ["l001", "c0", " c001", "col001", "col1", "l0", "c81", "lc001", "col81", "col0", "lc81", "c001", "lc1", "loc001", "loc0", " c0", "lc2", "loc1", "lc0", "loc81"], "l1": ["l51", "ls1", "flone", "nl3", "nlone", "loc51", "l001", " l01", "fl3", "locasso", "ql1", "Lone", "ls2", "ql101", "L0", "ll01", "ll1", "l01", "ll51", "l0", " l4", "lc001", " l51", " lasso", "rl51", "qlMap", "fl1", "lasso", "c001", "L3", "lc1", "nl1", "ql001", "loc0", "l4", "c51", "lcMap", "cMap", "ls4", "c01", "rl0", "nl2", "ls0", "lone", "rl1", "loc1", " l0", "lMap", "L1", "c101", "L2", "fl2", "L4", "l101", "l3", "rlasso", "lc101"], "i": ["gi", "j", "ic", "li", "iy", "it", "ia", "int", "ti", "ini", "il", "si", "xi", "im", "ai", "ip", "pi", "ii", "oi", "ij", "ati", "di", "zi", "I", "c", "fi", "ir", "ci"], "c2": ["lc02", "lc8", "c02", " c8", " c02", "c8", "lc1", "l4", "l8", " c4", "C1", "c4", "lc2", "C4", "C02", "C2", "l02"], "l2": ["i4", " l256", "f1", "L0", "ll1", "f2", "i1", "l0", "l5", " l4", "f256", "L5", "ll2", "d4", " l5", "l4", "c256", "i2", "ll0", " l0", "L1", "ll5", "L2", "l256"], "d1": [" d001", "t001", "fdOne", "t1", "d3", "d001", "l0", "d0", " d3", "dOne", "ndOne", " dOne", "fd1", "nd001", "lOne", " d0", "fd0", "fd3", "nd1", "l3", "tOne"], "d2": ["D02", "D3", "d02", "d3", " d4", "l0", "d0", "D2", "c3", " d3", "c02", "d4", " d22", "D4", "D22", "l4", "D1", " d0", "D0", "d22", "c22", " d02"], "foundFlag": ["foundFLAG", "FoundFlag", "foundCommand", "foundflag", "findFlags", "finderStatus", "successFlag", "findFlag", "finderFlag", "sentStatus", "findingStatus", " foundFLAG", "Foundflag", "finderFlags", "foundFlags", "foundState", "foundStatus", " foundFlags", " foundStatus", "finderState", "FoundStatus", "seenFlag", "seenflag", "successFLAG", "findingFlags", "sentFlag", " foundflag", "seenFlags", "findingFlag", "sentCard", " foundCommand", "findflag", "successFlags", "seenFLAG", "findingCommand", "sentflag", "findingState", "findingFLAG", " foundState", "findFLAG", "FoundCard", " foundCard", "foundCard", "successCommand"], "chosenCard": ["chaincard", "choserCard", "chickedCard", "Chosencard", "chosingNote", "chosingBrand", "chosenBrand", "choserController", "chosedBrand", "chickedcard", "ChickedController", "chickedARD", "chainARD", "Chosercard", "chosingCard", "ChoserCard", "ChosenController", "choserARD", "choserBrand", "chosedCard", "chosingcard", "chosedcard", "chosingController", "chosercard", "ChickedNote", "Chickedcard", "ChosenBrand", "chickedController", "ChosenCard", "choserNote", "chosenController", "chosenARD", "chickedNote", "ChickedCard", "chosencard", "chosenNote", "ChosenNote", "chainCard", "ChoserARD", "ChosenARD", "ChoserBrand"], "badMagician": ["badmagicist", "badTechnistical", "badmagick", "badMagicians", "badMagick", " badGalicians", "badTechnicator", "badGalician", "badGalicist", " badMagicist", "BadTechnician", "goodMagicist", "badTechnicist", "badGalicator", "BadMagicist", "badGalistical", "goodmagicians", " badMagick", "badMagicator", "goodmagician", "badmagicians", "goodMagician", "BadTechnicians", "badTechnick", " badMagicians", "BadTechnicist", "badTechnicians", "badmagician", " badGalicist", "goodmagistical", " badGalick", "badmagistical", "badMagistical", "BadMagicator", " badGalician", "goodmagicist", "BadMagician", "badTechnician", "badGalicians", "badMagicist", "badGalick", "BadMagicians", "BadTechnicator", "goodMagicians", "badmagicator", "goodMagistical"], "card": ["ard", "custom", "Any", "check", "One", "camp", "X", "crit", "cards", "deck", "A", "cart", "cmp", "Brand", "Null", "none", "cf", "incent", "node", "do", " Card", "null", "can", "condition", "field", "Card", "arc", "any", "cue", "man", "cert", "var", "cont", "Continue", "ANY", "board", "gu", "draw", "car", "hello", "hand", "ARD", "XXXX", "N", "C", "center", "void", "guard", "cd", "controller", "And", "gc", "comment", "php", "list"], "filenames": ["basernumbers", "filenomes", "fillenames", "basernames", "filENums", "FILENnames", "filernumbers", "filENAME", "filenAME", "fillenAMES", "filername", "filensames", "FILenames", "filtenames", "filernAME", "Filenums", "filENAMES", "FILENAMES", "filenosums", "filernAMES", "filtenums", " filENomes", "filensame", "filennames", "filENnames", "filatenails", "basenumbers", "basenAMES", "basenames", "filENames", "fillenAME", " filENAME", "filennails", "Filennails", "filensnames", " filenAMES", "FILenAMES", "filensums", "filatenames", "filenails", " filENames", " filenAME", "filenosnames", "filenums", "filtenAMES", "filensumbers", "filenAMES", " filenomes", "FILENames", "filatenumbers", "Filenails", "basename", "filatenums", "filenosames", "basername", "basernAMES", "filennums", "filenumbers", "filtenails", "filename", "FilennAMES", "FILENums", "filENomes", "filensAMES", "fillenomes", "Filennames", "filernames", "filatename", "Filenames", "filennAMES", "filenosAMES", "filernomes", " filENAMES", "filatenAMES", "FILenums", "Filennums", "FILennames", "FilenAMES"], "x": ["ux", "hex", "p", "xs", "k", "e", "xxx", "X", "rx", "xes", "xxxx", "wx", "rax", "dx", "xp", "ax", "h", "ox", "key", "z", "ross", "xc", "ck", "n", "xa", " xx", "f", "xt", "tx", "ey", "ph", "name", "mx", "w", "index", "xi", "y", "inx", "xf", "\u00e7", "el", "l", "yx", "co", "mix", "xe", "lex", "xd", "ont", "ix", "xy", "ex", "px", "xx", "xml", "plex", "v", "xb", "fx"], "chosen_filename": ["chlected_brush", "chicked_Filename", "chosen_til", "chosen_fp", "chicked_filename", "chosen__filename", "chosen_file", "choser_username", "chlected_Filename", "chosen_LCS", "chosen__username", "chicked_til", "chicked_path", "chicked_LCS", "chosen__file", "chosen_Filename", "chosen_username", "choser_filename", "choser_Filename", "chosen_path", "chlected_filename", "chosen__Filename", "chicked_fp", "choser_file", "chosen_brush"]}}
{"code": " \\n  \\n  FREE = '.'\\n  BOMB = '*'\\n  CLICK = 'c'\\n  \\n  \\n  class Board:\\n  \\n  \tdef __init__(self, R, C, M):\\n  \t\tself.initial_M = M\\n  \t\tself.R = R\\n  \t\tself.C = C\\n  \t\tself.M = M\\n  \t\tself.matrix = [[FREE for c in range(C)] for r in range(R)]\\n  \t\tself.endx = len(self.matrix[0])\\n  \t\tself.endy = len(self.matrix)  # 0 < R * C\\n  \t\tself.startx = 0\\n  \t\tself.starty = 0\\n  \\n  \tdef fill_row(self, row):\\n  \t\tfor c in self.range_active_cols:\\n  \t\t\tself.matrix[row][c] = BOMB\\n  \t\tself.starty += 1\\n  \t\tself.M -= self.active_cols\\n  \\n  \tdef fill_col(self, col):\\n  \t\tfor r in self.range_active_rows:\\n  \t\t\tself.matrix[r][col] = BOMB\\n  \t\tself.startx += 1\\n  \t\tself.M -= self.active_rows\\n  \\n  \tdef pprint(self):\\n  \t\tfor row in self.matrix:\\n  \t\t\tfor cell in row:\\n  \t\t\t\tprint(cell, end='')\\n  \t\t\tprint()\\n  \\n  \t@property\\n  \tdef active_rows(self):\\n  \t\treturn self.endy - self.starty\\n  \\n  \t@property\\n  \tdef active_cols(self):\\n  \t\treturn self.endx - self.startx\\n  \\n  \tdef optimize(self):\\n  \t\twhile 1:\\n  \t\t\tif (self.active_cols <= self.active_rows\\n  \t\t\t\t\tand self.active_cols <= self.M):\\n  \t\t\t\tself.fill_row(self.starty)\\n  \t\t\telif (self.active_rows < self.active_cols\\n  \t\t\t\t\tand self.active_rows <= self.M):\\n  \t\t\t\tself.fill_col(self.startx)\\n  \t\t\telse:\\n  \t\t\t\tbreak\\n  \\n  \t@property\\n  \tdef range_active_cols(self):\\n  \t\treturn range(self.startx, self.endx)\\n  \\n  \t@property\\n  \tdef range_active_rows(self):\\n  \t\treturn range(self.starty, self.endy)\\n  \\n  \tdef is_free(self, row, col):\\n  \t\treturn self.matrix[row][col] == FREE\\n  \\n  \tdef place_bomb(self):\\n  \t\tfor row in self.range_active_rows:\\n  \t\t\tfor col in self.range_active_cols:\\n  \t\t\t\tif (self.is_free(row, col) \\n  \t\t\t\t\t\tand row + 2 < self.R\\n  \t\t\t\t\t\tand col + 2 < self.C):\\n  \t\t\t\t\tself.matrix[row][col] = BOMB\\n  \t\t\t\t\tself.M -= 1 \\n  \t\t\t\t\treturn True\\n  \t\tfor col in self.range_active_cols:\\n  \t\t\tfor row in self.range_active_rows:\\n  \t\t\t\tif (self.is_free(row, col)\\n  \t\t\t\t\t\tand row + 2 < self.R\\n  \t\t\t\t\t\tand col + 2 < self.C):\\n  \t\t\t\t\tself.matrix[row][col] = BOMB\\n  \t\t\t\t\tself.M -= 1\\n  \t\t\t\t\treturn True\\n  \t\treturn False\\n  \\n  \tdef mark_click(self):\\n  \t\tself.matrix[-1][-1] = 'c'\\n  \\n  \tdef win_condition(self):\\n  \t\tclick_row = len(self.matrix) - 1\\n  \t\tclick_col = len(self.matrix[0]) - 1\\n  \t\tif (click_col - 1 >= 0\\n  \t\t\t\tand not self.is_free(click_row, click_col - 1)):\\n  \t\t\treturn False\\n  \\n  \t\tif (click_row - 1 >= 0\\n  \t\t\t\tand not self.is_free(click_row - 1, click_col)):\\n  \t\t\treturn False\\n  \\n  \t\tif (click_row -1 >= 0\\n  \t\t\t\tand click_col -1 >= 0\\n  \t\t\t\tand not self.is_free(click_row - 1, click_col - 1)):\\n  \t\t\treturn False\\n  \t\t\\n  \t\treturn True\\n  \\n  \tdef win_cond2(self):\\n  \t\tif self.initial_M + 1 == self.C * self.R:\\n  \t\t\treturn True\\n  \t\treturn False\\n  \\n  \tdef solve(self):\\n  \t\tself.optimize()\\n  \t\twhile self.M > 0 and self.place_bomb():\\n  \t\t\tpass\\n  \t\tif self.M == 0 and (self.win_condition() or self.win_cond2()):\\n  \t\t\tself.mark_click()\\n  \t\t\tself.pprint()\\n  \t\telse:\\n  \t\t\tprint('Impossible')\\n  \\n  \\n  def read_case(f):\\n  \treturn map(int, f.readline().split())\\n  \\n  \\n  def main():\\n  \tfn = sys.argv[1]\\n  \twith open(fn, encoding='utf-8') as f:\\n  \t\tncases = int(f.readline())\\n  \t\tfor case in range(1, ncases + 1):\\n  \t\t\tR, C, M = read_case(f)\\n  \t\t\tprint('Case #{}:'.format(case))\\n  \t\t\tb = Board(R, C, M)\\n  \t\t\tb.solve()\\n  \\n  \\n  def main1():\\n  \tb = Board(2, 1, 1)\\n  \tb.solve()\\n  \\n  \\n  if __name__ == '__main__':\\n  \tmain()\\n", "substitutes": {"FREE": ["NULL", "D", "LE", "ERROR", "E", "UN", "EW", "Q", "A", "FR", "REM", "CRE", "CLE", "B", "ERE", "LEASE", "CE", "WER", "RES", "F", "XY", "NAME", "KEY", "NEW", "Y", "WIN", "WT", "DE", "RE", "NO", "FE", "KER", "Free", "FW", "OK", "RET", "VALUE", "CHAR", "DEF", "W", "CB", "BO", "T", "free", "YOU", "BOX"], "BOMB": ["BOOMBC", "BOOMB", "BUMPB", "BOOBO", "BOOOBO", "BUMBC", "BOOE", "BUMPBC", "BUMPE", "BUMBO", "BOOOE", "BOOB", "BOME", "BOOMBO", "BUMB", "BUMPBO", "BOMBC", "BOOME", "BOOBC", "BOMBO", "BUME", "BOOOB", "BOOOBC"], "CLICK": ["CHICK", "CHINK", "BLACK", " CLAPE", " CLACK", "CLINK", "CHAPE", "CHACK", "BLAPE", " CLINK", "BLICK", "CLACK", "BLINK", "CLAPE"], "self": ["app", "se", "tmp", "python", "cho", "console", "error", "h", "complete", "results", "req", "wrapper", "ls", "close", "spec", "proc", "shape", "full", "user", "local", "comp", "cache", "help", "log", "network", "instance", "attr", "review", "clean", "output", "debug", "views", "diff", "Big", "short", "details", "partial", "rss", "cp", "agg", "txt", "sub", "cmp", "sql", "conf", "s", "final", "parent", "raw", "drive", "config", "Th", "sect", "rel", "ln", "pkg", "lex", "deep", "print", "resp", "also", "xml", "context", "serial", "sb", "form", "this", "load", "eval", "public", "responsible", "path", "asm", "n", "info", "conn", "my", "sw", "so", "expr", "dict", "sche", "add", "new", "first", "pair", "next", "api", "compl", "client", "Writer", "ren", "system", "all", "dev", "subject", "ws", "builder", "view", "me", "cl", "just", "replace", "nt", "you", "obj", "weak", "sys", "object", "Self"], "R": ["Range", "D", "G", "X", "RA", "H", "L", "U", "A", "Q", "DR", "B", "RF", "SR", "Res", "RL", "F", "J", "V", "RO", "RS", "Y", "N", "RE", "TR", "RR", "Rs", "K", "I", "RM", "P", "RT", "RI", "W", "T", "S", "MR", "RP"], "C": ["Co", "D", "G", "O", "BC", "JC", "Ch", "H", "L", "U", "CR", "A", "E", "CM", "Q", "B", "CS", "Cons", "CA", "CV", "CE", "CC", "WC", "F", "CON", "V", "CH", "EC", "Con", "Z", "Y", "CNN", "N", "CO", "ERC", "CT", "CP", "CF", "K", "I", "P", "CHAR", "W", "CL", "MC", "CU", "T", "S", "Cs"], "M": ["D", "G", "O", "MED", "X", "MA", "H", "L", "m", "TM", "Mass", "U", "Q", "A", "CM", "Mon", "MAN", "B", "JM", "MM", "MO", "F", "MAC", "J", "V", "MOD", "Z", "Y", "LM", "Med", "N", "Mem", "MT", "MI", "K", "I", "RM", "P", "W", "MC", "MH", "T", "MS", "S", "MU"], "initial_M": ["initial___M", "initial_m", "initial_T", "initial___T", "initial___m", "Initial_M", "initial___R", "Initial_T", "Initial_R", "initial_R", "Initial_m"], "matrix": ["matchrices", "matchrix", "matchMatrix", "mMatrix", "umatrices", "matMatrix", "mrix", "catMatrix", "MATrix", "mvector", "MATrices", "catrices", "mtrix", "MATction", "mtvector", "matction", "umatrix", "atrix", "catrix", "mrices", "mction", "atMatrix", "atvector", "mtMatrix", "atrices", "matvector", "matrices", "umatction", "mtrices"], "c": ["p", "rc", "k", "col", "cp", "cm", "cur", "lc", "cf", "n", "xc", "z", "con", "f", "nc", "cu", "cb", "q", "cs", "ec", "b", "cont", "cl", "mc", "cv", "ch", "cd"], "r": ["p", "j", "ra", "rc", "er", "re", "rx", "m", "ro", "rg", "rb", "ar", "ru", "w", "d", "q", "b", "rr", "cr", "sr", "dr", "rm", "mr", "rn", "rd", "rt", "ir"], "endx": ["endz", "endcol", "endedx", "endedz", "endedy", "startz", " endcol", "endedcol", "startcol", "starty", "startx", " endz"], "endy": ["endY", "endsx", "startny", "endedx", "endedy", "endedny", "endsY", "endny", "endsny", "startY", "endedY", "endsy", "starty", "startx"]}}
{"code": " \\n  \\n  \\n  def read_grid(f):\\n  \treturn [\\n  \t\t[int(x) for x in line.split()]\\n  \t\tfor line in [f.readline() for _ in range(4)]\\n  \t]\\n  \\n  def read_case(f):\\n  \tanswer1 = int(f.readline())\\n  \tgrid1 = read_grid(f)\\n  \tanswer2 = int(f.readline())\\n  \tgrid2 = read_grid(f)\\n  \treturn (grid1[answer1 - 1], grid2[answer2 - 1])\\n  \\n  \\n  def solve(r1, r2):\\n  \tres = set(r1) & set(r2)\\n  \tif len(res) == 0:\\n  \t\treturn 'Volunteer cheated!'\\n  \tif len(res) == 1:\\n  \t\treturn list(res)[0]\\n  \treturn 'Bad magician!'\\n  \\n  \\n  \\n  def main():\\n  \tfn = sys.argv[1]\\n  \twith open(fn, encoding='utf-8') as f:\\n  \t\tncases = int(f.readline())\\n  \t\tfor case in range(1, ncases + 1):\\n  \t\t\trow1, row2 = read_case(f)\\n  \t\t\tsolution = solve(row1, row2)\\n  \t\t\tprint('Case #{}: {}'.format(case, solution))\\n  \\n  \\n  if __name__ == '__main__':\\n  \tmain()\\n", "substitutes": {"f": ["ft", "fd", "p", "bf", "ic", "j", "form", "fr", "df", "e", "it", "t", "fa", "fl", "h", "ct", "of", "cf", "window", "fo", "g", "uf", "af", "z", "elf", "fps", "fg", "ret", "exp", "um", "fb", "w", "d", "lf", "tf", "sf", "alf", "q", "u", "F", "r", "xf", "fm", "ff", "b", "ac", "l", "ln", "fed", "feed", "fp", "fac", "file", "fc", "c", "fs", "v", "fi", "fin", "fx", "fw"], "x": ["ux", "p", "xs", "k", "e", "X", "rx", "t", " i", "wx", "m", "xp", "ox", "z", "n", "xc", " X", "xa", " xx", "xt", "tx", "name", "w", "xi", "i", "y", "r", "xf", "l", "xe", "ix", "xy", "a", "ex", "c", "xx", "v", "ci"], "line": ["range", "Line", "fill", "ide", "frame", "e", "ite", "lin", "block", "code", "n", "id", "do", "lined", "chain", "name", "page", "ner", "change", "q", "ine", "lay", "write", "link", "row", "oline", "l", "eno", "ln", "liner", "len", "box", "string", "format", "iter", "out", "file", "inline", "ge", "v", "lines", "lock", "ode", "list"], "_": ["range", "t", "time", "all", "int", "sw", "l", "val", "mult", "length", "ex", "non"], "answer1": ["turn1", "answerFirst", "line0", "answer001", "ver001", "lineFirst", "answer81", "response001", "line1", "answerone", "answer0", "lineone", " answerFirst", " answer0", "turn001", "bridgeone", "answerOne", "bridge1", "response81", "ver81", " answerone", "response1", "verOne", "turnOne", "bridge0", "bridgeFirst", "responseOne", "ver1", "turn81"], "grid1": ["map8", "map1", "layOne", "bridge8", "lay1", "tile1", "graphOne", "map001", "bridgeA", "tileOne", "mapOne", "lay0", "gridOne", "tile0", "bridge1", "graph001", "grid0", "layA", "grid001", "graph8", "gridA", "bridge001", "bridge0", "tileA", "grid8", "bridgeOne", "graph1"], "answer2": ["answer02", "quote12", "answerTwo", " answerb", "quote2", "say02", "quote02", "sayb", "answer4", "side02", "response4", "answerb", "answer12", "response12", "answered4", "side2", "response2", "answered12", "answered2", "sideTwo", " answerTwo", " answer02", "quote4", "response02", "answered02", "sayTwo", "sideb", "say2"], "grid2": ["tabletwo", "db22", "row22", "bridge2", "lay2", "answer22", "gridtwo", "bridgetwo", "table02", "tableTwo", "answertwo", "bridgeTwo", "lay02", "row3", "grid02", "dbtwo", "answer3", "grid22", "table2", "laytwo", "bridge02", "db3", "db2", "gridTwo", "grid3", "layTwo", "rowtwo"], "r1": ["ro1", "ro01", "row01", "R3", "r8", "rc11", "sr11", "sr1", "rowtx", "r01", "row3", "ro3", "rc1", "sr8", "rt11", "R01", "Rtx", "R1", "rt8", "rt1", "rc3", "rtx", "r11", "rotx", "rc8", "sr3", "r3", "rt3"], "r2": ["ro1", "R2", " r4", "rcte", "rotwo", "rc2", "ro2", "rtwo", "res2", "rc4", "r4", "res4", "R4", "Rtwo", "restwo", " rte", "rc1", "reste", "R1", "ro4", "rte", "res1"], "res": ["rem", "rev", "re", "rs", "ps", "ms", "reg", "rx", "ress", "ro", "reset", "results", "req", "s", "rest", "rek", "ret", "sol", "tx", "Res", "pres", "rez", "result", "RES", "cs", "r", "respons", "rand", "rel", "resolution", "vec", "gre", "vals", "gr", "rm", "cons", "resp", "ther", "mem", "js", "we", "details", "des"], "fn": ["fd", "bf", "fr", "filename", "fl", "txt", "FN", "path", "n", "nc", "ren", "cf", "mn", "full", "cn", "sn", "pn", "tf", "lf", "fun", "fm", "fil", "mt", "dn", "np", "ln", "nm", "format", "fp", "file", "fc", "rn", "fin", "kl", "fps"], "ncases": ["ncaces", "nased", "nases", "NCases", "cnidents", "NCase", "cnased", "bcase", "cased", "cnases", "NCcases", "ncased", "bcases", "caces", "NCidents", "nase", "cncases", "naces", "cnase", "nccases", "cases", "bcidents", "bccases", "ncase", "ncidents", "cnaces"], "case": ["switch", "se", "ance", "match", "race", " cases", "count", "ide", "su", "block", "code", "zero", "ace", "example", "nce", " CASE", "name", "cation", "chain", "rule", "condition", "use", "index", "change", "core", "catch", "board", "Case", "number", "co", "cycle", "instance", " Case", "hyp", "cases", "ice", "ASE", "ase", "ce", "mate", "c", "test"], "row1": ["ro1", "ro01", "ro10", "row01", "Row51", "ow11", "ro51", "row10", "ro0", "ro11", "row11", "ow1", " row51", "ro7", "Row1", "ow7", "row0", "row7", "Row0", "ow10", "roll1", "Row01", "roll10", "roll7", "row51", " row0", "roll11", " row01"], "row2": [" row5", "ow5", "owTwo", " rowtwo", "ow2", "owtwo", "recordtwo", "recordTwo", "Row7", "record1", "ow1", " row7", "rowTwo", "row5", "ow7", "row7", "Row2", "Row5", " rowTwo", "record2", "RowTwo", "rowtwo"], "solution": ["convolver", "convolution", " solved", "Solve", " solver", "Solved", "convolve", " solve", "ssolve", "ssolved", "ssolver", "resolve", "ssolution", "solve", "convolved", "solver", "resolution", "Solver", "resolver", "solved", "Solution", "resolved"]}}
{"code": " \\n  lines = [line.strip() for line in open(sys.argv[1])]\\n  count = int(lines[0])\\n  \\n  for i in xrange(count):\\n      R,C,M = map(int, lines[i+1].split())\\n      print \"Case #%s:\" % (i+1)\\n  \\n      w = max(R,C)\\n      h = min(R,C)\\n      X = R*C - M\\n      assert X > 0\\n  \\n      if X == 1:\\n          rows = ['c' + ('*' * (w-1))] + (h-1) * ['*' * w]\\n      elif h == 1:\\n          rows = ['c' + '.' * (X-1) + '*' * M]\\n      elif X == 4:\\n              rows = [\\n                  'c.' + '*' * (w-2),\\n                  '..' + '*' * (w-2),\\n              ] + ['*' * w] * (h-2)\\n      elif h == 2:\\n          if X%2 == 1 or X == 2:\\n              rows = None\\n          else:\\n              rows = [\\n                  'c' + '.' * (X/2-1) + '*' * (M/2),\\n                  '.' + '.' * (X/2-1) + '*' * (M/2)\\n              ]\\n      elif X <= 5 or X == 7:\\n          rows = None\\n  \\n      elif X%2 == 0 and X <= w*2:\\n          r = X/2\\n          rows = [\\n              'c' + '.' * (r - 1) + '*' * (w-r),\\n                    '.' * r       + '*' * (w-r),\\n          ] + ['*' * w] * (h-2)\\n  \\n      elif X <= w*3 and (X % 3) != 1:\\n          n = (X+1) / 3\\n          t = X - 2*n\\n          rows = [\\n              'c' + '.' * (n-1) + '*' * (w-n),\\n                    '.' * n     + '*' * (w-n),\\n                    '.' * t     + '*' * (w-t)\\n          ] + ['*' * w] * (h-3)\\n      else:\\n          n = X / w\\n          t = X % w\\n          if t == 1:\\n              rows = (\\n                      ['c' + (w-1) * '.']\\n                  +   ['.' * w] * (n-2)\\n                  +   ['.' * (w-1) + '*']\\n                  +   ['..' + '*' * (w-2)]\\n                  +   ['*' * w] * (h - n - 1)\\n              )\\n          else:\\n              k = 1 if t == 0 else 0\\n              rows = (\\n                      ['c' + (w-1) * '.']\\n                  +   ['.' * w] * (n-1)\\n                  +   ['.' * t + '*' * (w-t)] * (1 - k)\\n                  +   ['*' * w] * (h - n - 1 + k)\\n              )\\n  \\n      if rows:\\n          if R > C:\\n              rows = [\"\".join(row[i] for row in rows) for i in xrange(R)]\\n  \\n          for row in rows:\\n              print row\\n  \\n          assert len(rows) == R\\n          assert len(rows[0]) == C\\n          assert sum(1 for row in rows for col in row if col == '*') == M\\n  \\n      else:\\n          print \"Impossible\"\\n  \\n", "substitutes": {"lines": ["values", "ns", "args", "xs", "lins", "rs", "bytes", "prints", "years", "ids", "rings", "strings", "words", "files", "blocks", "ls", "ds", "reads", "dates", "mails", "parts", "ins", "elines", "cells", "pins", "codes", "bs", "groups", "sections", "qs", "rates", "ln", "points", "vs", "vals", "ines", "pages", "frames", "fs", "links", "limits", " Lines", "posts", "gs"], "line": ["Line", "next", "str", "word", "frame", "li", "command", "lin", "column", "L", "LINE", "eline", "block", "record", "code", "lo", "chain", "name", "page", "field", "ine", "dd", "entry", "ip", "limit", "l", "nl", "x", "ln", "liner", "string", "new", "iter", "out", "file", "inline", "cell", "comment", "message", "list"], "count": ["total", "start", "history", "m", "max", "ct", "z", "Count", "index", "q", "counter", "current", "nb", "cont", "ctr", "l", "x", "number", "cycle", "N", "read", "nt", "cum", "ch", "len", "length", "c", "v", "sum", "ind", "size", "num"], "i": ["gi", "hi", "j", "p", "li", "e", "it", "o", "m", "sim", "us", "id", "z", "s", "info", "ti", "ini", "bi", "index", "si", "xi", "im", "y", "mi", "multi", "ai", "on", "me", "ip", "l", "x", "pi", "oi", "ij", "ix", "di", "I", "zi", "c", "v", "ind", "ci"], "R": ["D", "G", "Right", "RA", "H", "L", "CR", "Q", "A", "RC", "RG", "B", "SR", "Res", "V", "RO", "RS", "Rot", "Y", "N", "RE", "TR", "GR", "RR", "Rs", "I", "RM", "P", "RT", "RI", "W", "T", "S", "IR", "MR"], "C": ["Co", "D", "G", "COR", "H", "L", "A", "CR", "Q", "CM", "CBS", "CS", "B", "CE", "CC", "CI", "Custom", "F", "CON", "Craig", "V", "EC", "Y", "CNN", "N", "CO", "CT", "CP", "DC", "K", "I", "YC", "P", "Mc", "W", "c", "CB", "MC", "CU", "T", "S", "Cs"], "M": ["D", "G", "O", "H", "L", "m", "TM", "U", "E", "Q", "CM", "NM", "MAN", "B", "PM", "Mi", "MM", "F", "J", "V", "Z", "Y", "LM", "N", "Ms", "MT", "MI", "K", "I", "RM", "P", "Mc", "W", "MC", "MH", "T", "MS", "S"], "w": ["p", "win", "m", "wait", "max", "window", "term", "d", "q", "wm", "TW", "ow", "wall", "mem", "c", "wr", "power", "fw", "word", "wx", "o", "s", "kw", "wl", "widget", "width", "write", "wat", "wo", "hw", "v", "wt", "we", "wb", "nw", "history", "L", "iw", "words", "z", "f", "exp", "wn", "y", "man", "sw", "l", "ew", "x", "new", " W", "weight", "wd", "temp", "space", "H", "ws", "wa", "rew", "wk", "b", "N", "wal", "wh", "W", "wp", "rw", "tw"], "h": ["hi", "p", "hp", "e", "ho", "hd", "H", "ih", "m", "history", "hm", "o", "ah", "z", "hz", "hh", "hang", "ph", "zh", "he", "kh", "q", "y", "head", " H", "b", "host", "hs", "l", "html", "hr", "sh", "dh", "x", "bh", "HH", "oh", "ch", "th", "height", "hl", "ha", "her", "hw", "c", "v", "high", "uh", "ht"], "X": ["Time", "WH", "D", "O", "H", "L", "U", "E", "Q", "A", "ax", "ox", "XT", "TH", "OX", "HTML", "Ex", "Event", "Width", "ZX", "MX", "F", "XY", "J", "IM", "V", "DX", "PH", "XP", "XXX", "IX", "Z", "Tx", "XL", "x", "XM", "XX", "N", "Y", "HTTP", "UX", "EX", "Length", " x", "ML", "PE", "K", "Xi", "I", "TX", "P", "W", "Ax", "MC", "T", "MS", "S"], "rows": ["res", "heads", "ns", "values", "issues", "rs", "los", "relations", "uds", "units", "models", "ways", "bys", "roots", "blocks", "papers", "headers", "keys", "rown", "ports", "users", "flows", "orders", "names", "runs", "workers", "ins", "cells", "fields", "groups", "bs", "owners", "rates", "ros", "hands", "items", "options", "points", "body", "projects", "vals", "rooms", "sheets", "ows", "views", "tests", "pages", "frames", "eeks", "jobs", "ues", "rules", "posts"], "r": ["res", "br", "p", "j", "rc", "er", "fr", "re", "e", "rs", "rx", "reg", "it", "m", "nr", "ro", "rg", "z", "g", "rb", "ur", "rate", "ar", "d", "tr", "pr", "u", "q", "y", "b", "l", "rr", "cr", "rar", "x", "usr", "sr", "dr", "mr", "vr", "c", "v", "rd", "rt", "radius"], "n": ["ns", "j", "p", "nw", "at", "o", "m", "long", "no", "tn", "nr", "an", "z", "g", "ne", "nc", "f", "node", "s", "en", "name", "mn", "d", "ng", "sn", "cn", "na", "pn", "y", "nb", "yn", "b", " N", "nu", "l", "np", "nl", "x", "number", "un", "N", "ln", "nt", "net", "ot", "nm", "nv", "new", "c", "v", "nn", "num"], "t": ["tt", "p", "j", "type", "e", "it", "at", "o", "m", "z", "g", "td", "ant", " T", "s", "f", "ti", "test", "tr", "dt", "d", "tf", "y", "b", "mt", "l", "ty", "tz", "x", "nt", "ot", "to", "te", "st", "th", "out", "pt", "tu", "ta", "c", "v", "wt", "tc", "ts", "T", "unt", "rt", "tw", "lat"]}}
{"code": " \\n  \\n  lines = [map(int, line.strip().split(\" \")) for line in open(sys.argv[1]).readlines()]\\n  [count] = lines[0]\\n  assert count * 10 + 1 == len(lines)\\n  \\n  for i in xrange(count):\\n      base = i*10\\n      [n1] = lines[base+1]\\n      [n2] = lines[base+6]\\n      row1 = set(lines[base+1+n1])\\n      row2 = set(lines[base+6+n2])\\n      common = row1.intersection(row2)\\n      print \"Case #%s:\" % (i+1),\\n      if len(common) == 1:\\n          print list(common)[0]\\n      elif not common:\\n          print \"Volunteer cheated!\"\\n      else:\\n          print \"Bad magician!\"\\n", "substitutes": {"lines": ["works", "values", "lists", "olds", "lins", "rs", "levels", "rings", "strings", "words", "sites", "files", "blocks", "ls", "papers", "eds", "ds", "ports", "sets", "outs", "reads", "dates", "orders", "amps", "parts", "docs", "ins", "elines", "boxes", "cells", "days", "reports", "pins", "codes", "groups", "sections", "bs", "rates", "qs", "items", "points", "vs", "vals", "nets", "ines", "locks", "cases", "lets", "pages", "frames", "rows", "objects", "steps", "links", "limits", "details", "models", "posts", "gs"], "line": ["Line", "str", "word", "frame", "command", "lin", "le", "LINE", "eline", "block", " Line", "code", "option", "lined", "name", "page", "char", "field", "lf", "ine", " l", "entry", "link", "row", "ste", "l", "ln", "liner", "pixel", "string", "new", "inline", "file", "data", "cell", "text", "comment"], "count": ["total", "type", "iq", "flag", "cm", "store", "area", "max", "ct", "id", "n", "code", "Count", "z", "conf", "char", "index", "counter", "cache", "nb", "found", "hold", "ctr", "cont", "cycle", "cum", "read", "nt", "consider", "find", "batch", "len", "length", "c", "sum", "ind", "size", "num"], "i": ["gi", "ji", "hi", "j", "ic", "p", "li", "e", "it", "m", "key", "id", "n", "iri", "f", " j", "ti", "int", "bi", "index", "d", "xi", "im", "y", "mi", "ai", "b", "l", "x", "pi", "ii", "ij", "ix", "di", "I", "zi", "c", "v", "ind", "ci"], "base": ["bas", "basic", "origin", "alpha", "root", "bo", "check", "reverse", "prefix", "store", "used", "area", "orig", "m", "domain", "client", "pre", "balance", "reset", "id", "relative", "parent", "scale", "chain", "bi", "index", "local", "y", "set", "init", "db", "b", "buffer", "l", "kit", "server", "pa", "back", "batch", "bottom", "Base", "child", "bal", "tree", "ma", "ase", "beta", "bat", "based", "bre", "real", "pos", "handle", "lower", "stable", "bare", "prime"], "n1": ["N3", "ne3", " n7", "p1", "p3", "p2", "N2", "n3", " n3", "N1", "n0", "N7", "p7", "N0", " n0", "ne0", "ne1", "n7"], "n2": ["ln1", "N3", "ln05", " n7", "c2", "p1", "c3", "c1", "N6", "p3", "ln7", "p2", "N2", "n6", "n3", "N05", "ln2", "N1", "N7", "c6", "n05", "p6", "n7", " n05"], "row1": ["owone", "Row3", "col2", "roll0", "rowone", "rollone", "col1", "ow1", "col0", "Row1", "roll3", "row0", "ow0", "row3", "Row0", "Row2", "col3", " row3", "roll1", "ow3", " rowone", " row0"], "row2": [" row5", "ow5", "rotwo", "roll0", " rowtwo", "ow2", "ro2", "row256", "ow4", "roll4", "ro0", "rolltwo", " row256", "roll256", "row4", "roll2", " row7", "roll5", "row5", "ow7", "row0", "row7", "ro256", " row4", " row0", "roll7", "rowtwo"], "common": ["dist", "shared", "basic", "custom", "default", "amiliar", "initial", "unique", "m", "public", "norm", "associated", "none", "necessary", "ordinary", "con", "seen", "general", "name", "specific", "some", "pleasant", "full", "main", "any", "set", "same", "multi", "core", "related", "generic", "found", "ared", "similar", "Common", "met", "qualified", "bare", "new", "normal", "recent", "broad", "non", "confirmed", "MON", "central", "valid", "known", "com", "other"]}}
{"code": " \\n  \\n  \\n  \\n  INPUT = \"tiny\"\\n  INPUT = \"C-small-attempt1.in\"\\n  \\n  def debug(*args):\\n      sys.stderr.write(str(args) + \"\\n\")\\n  \\n  class Memoize:\\n      def __init__(self,function):\\n          self._cache = {}\\n          self._callable = function\\n              \\n      def __call__(self, *args, **kwds):\\n          cache = self._cache\\n          key = self._getKey(*args,**kwds)\\n          try: return cache[key]\\n          except KeyError:\\n              cachedValue = cache[key] = self._callable(*args,**kwds)\\n              return cachedValue\\n      \\n      def _getKey(self,*args,**kwds):\\n          return kwds and (args, ImmutableDict(kwds)) or args    \\n  \\n  IMPOSSIBLE = set([(2,2,2), (2,2,1), (2,3,1), (2,4,1), (2,5,1)])\\n  \\n  for i in range(2,51):\\n      IMPOSSIBLE.add((2,i,1))\\n      IMPOSSIBLE.add((i,2,1))\\n  \\n  SOLN = {\\n      (1,2,1) : [\"c*\"],\\n      (2,1,1) : [\"c\", \"*\"],\\n      (2,2,3) : [\"c*\", \"**\"],\\n  }\\n  \\n  def solve(R, C, M):\\n      if M == 0:\\n          s = [\"c%s\" % ('.' * (C-1))]\\n          for i in range(R-1):\\n              s.append('.' * C)\\n          return s\\n      t = (R, C, M)\\n      if t in IMPOSSIBLE:\\n          debug(\"** %s %s %s\" % t)\\n          raise ValueError\\n      if t in SOLN:\\n          return SOLN[t]\\n  \\n      if C < M and R > 2:\\n          try:\\n              return solve(R-1, C, M-C) + [\"*\" * C]\\n          except ValueError:\\n              pass\\n  \\n      if C <= R:\\n          if M >= C and R > 2:\\n              return solve(R-1, C, M-C) + [\"*\" * C]\\n      else:\\n          if M >= R and C > 2:\\n              return [\"%s*\" % s for s in solve(R, C-1, M-R)]\\n      if R > 2:\\n          mines = min(C, M)\\n          if mines == C - 1:\\n              mines -= 1\\n          try:\\n              return solve(R-1, C, M-mines) + [(\".\" * (C - mines)) + (\"*\" * mines)]\\n          except ValueError:\\n              if C > 2:\\n                  mines = min(R, M)\\n              if mines == R - 1:\\n                  mines -= 1\\n              s = [\"%s%s\" % (s, '*' if k > C-mines else '.') for k, s in enumerate(solve(R, C-1, M-mines))]\\n              return s\\n      debug(R, C, M)\\n      return []\\n  \\n  def do_trial(R, C, M):\\n      try:\\n          r = solve(R,C,M)\\n          s = \"\\n\" + '\\n'.join(r)\\n          assert len(r) == R\\n          for r1 in r:\\n              assert len(r1) == C\\n          assert len(''.join(k for k in s if k == '*')) == M\\n          return s\\n      except ValueError:\\n          return \"\\nImpossible\"\\n  \\n  \\n  def all():\\n      for R in range(1,50):\\n          for C in range(1,50):\\n              for M in range(R*C):\\n                  print(R, C, M)\\n                  print(do_trial(R, C, M))\\n      sys.exit(0)\\n  \\n  \\n  f = file(INPUT)\\n  T = int(f.readline()[:-1])\\n  for i in range(T):\\n      R, C, M = [int(x) for x in f.readline().split()]\\n      v = do_trial(R, C, M)\\n      print \"Case #%d: %s\" % (i+1, v)\\n", "substitutes": {"INPUT": ["INST", "inST", " INHT", " OUTFIX", "InHT", "InST", "INFIX", "OUTPUT", "INHT", "OUTJECT", "inJECT", "inPUT", " OUTJECT", " OUTPUT", "InFIX", "INJECT", " OUTHT", " INJECT", "OUTP", "InPUT", "OUTST", "InJECT", "InP", "INP", " INFIX", "inP"], "self": ["python", "func", "app", "se", "p", "rem", "tmp", "args", "console", "h", "pre", "req", "ls", "close", "spec", "w", "full", "q", "local", "user", "eth", "instance", "review", "mp", "details", "handle", "default", "private", "prefix", "agg", "cmp", "final", "github", "remote", "params", "left", "config", "np", "rel", "pkg", "lex", "requ", "th", "print", "resp", "also", "this", "reader", "rec", "your", "public", "responsible", "n", "exp", "my", "sw", "add", "new", "ref", "rs", "client", "ren", "dev", "subject", "ws", "me", "cl", "replace", "nt", "you", "obj", "weak", "object", "py", "Self"], "function": ["partial", "func", "python", "functional", "word", "initial", "command", "what", "handler", "closure", "action", "fun", "module", "feature", "F", "role", "value", " Function", "call", "number", "connection", "FUN", "string", "never", "normal", "evaluate", "callback", "method", "library", "Function", "component", "fn", "object"], "_cache": ["__root", "_chain", "_Cache", "_ac", "__ache", "_key", "_ache", "__cache", "_root", "__Cache"], "_callable": ["_actionback", "_CallABLE", "_actionabe", "_cback", "_callback", "_drawable", "_Callable", "_Callation", "_varier", "_cabe", "_cables", "_Caller", "_cacheable", "_actionable", "_cable", "_cacheabe", "_drawation", "_variable", "_drawABLE", "_cacheables", "_cacheback", "_callabe", "_callation", "_caller", "_actionables", "_drawer", "_callABLE", "_variation", "_callables", "_variABLE"], "cache": ["tmp", "p", "match", "force", "go", "cp", "master", "cm", "store", "miss", "memory", "cmp", "metadata", "conf", "wrapper", "close", "cos", "can", "chain", "driver", "see", "use", "ache", "index", "local", "cs", "set", "ached", "config", "db", "ac", "HE", "auto", "aches", "dict", "co", "table", "mc", "cycle", "call", "remember", "map", "mem", "c", "gc", "parse", "hash", "Cache", "case"], "key": ["Key", "next", "match", "tag", "owner", "prefix", "it", "ek", "foo", "client", "id", "path", "keys", "kw", "name", "ey", "chain", "page", "item", "test", "index", "slot", "y", "set", "my", "entry", "KEY", "where", "row", "value", "val", "member", "oto", "primary", "te", "title", "new", "ter", "by", "hash", "case", "pair"], "cachedValue": ["tachedvalue", "Codedvalue", "CachedVALUE", "cavedvalue", "cachedValues", "cachableValue", "codedvalue", "tavedVALUE", "cavedVALUE", "cachedvalue", "cachablevalue", "tavedValue", "cashedValue", "cacherValue", "Cachedvalue", "cashedvalue", "tavedvalue", "cacherVALUE", "codedVALUE", "CodedCurrent", "tachedValue", "tavedValues", "cashedVALUE", "CachedValue", "codedCurrent", "codedValues", "cashedValues", "codedValue", "cavedValues", "cacherCurrent", "cavedValue", "tachedVALUE", "CodedValue", "cachableVALUE", "CachedCurrent", "CodedVALUE", "cachervalue", "tachedValues", "cachedVALUE", "cachedCurrent", "cachableCurrent"], "IMPOSSIBLE": ["IMPPESSABLE", "IMPOSSibility", "IMPOSTibility", "IMFPOSSible", "IMPPESSible", "IMPOSTABLE", "IMPOSTBILITY", "IMPPOSSibles", "IMTPossBILITY", "IMPPOSSIBLE", "IMPASSible", "IMPPOSSible", "IMPOSTIBLE", "IMTPossABLE", "IMFPOSSIBLE", "IMPESSible", "IMPossibility", "IMTPOSSIBLE", "IMSPOSSIBLE", "IMPESSibles", "IMSPESSible", "IMPOSible", "IMFPOSibility", "IMPPESSibles", "IMPOSSBILITY", "IMPASSABLE", "IMPOSABLE", "IMPossible", "IMSPESSABLE", "IMPESSIBLE", "IMFPOSIBLE", "IMPOSSABLE", "IMPossibles", "IMTPOSSBILITY", "IMFPOSSBILITY", "IMPOSibility", "IMTPOSSibility", "IMPossIBLE", "IMTPossIBLE", "IMPESSABLE", "IMSPOSSABLE", "IMPossBILITY", "IMPESSBILITY", "IMSPOSSible", "IMPossABLE", "IMTPOSSABLE", "IMTPossibility", "IMSPESSIBLE", "IMPPESSIBLE", "IMPASSIBLE", "IMPPOSSABLE", "IMSPOSSibles", "IMPASSibles", "IMFPOSible", "IMPOSIBLE", "IMPOSSibles", "IMFPOSSibility", "IMSPESSibles", "IMPESSibility", "IMPOSBILITY", "IMPOSSible", "IMFPOSBILITY"], "i": ["gi", "p", "ic", "j", "li", "e", "it", "io", "o", "m", "id", "z", "n", "phi", "int", "ti", "bi", "index", "si", "d", "xi", "im", "mi", "y", "ai", "b", "ip", "l", "pi", "ii", "ij", "di", "I", "c", "ind", "ci"], "SOLN": ["SOOLG", " SOLNT", "MolN", "SILNG", " SOTNG", " SOTM", "SOLMN", "SALNS", "SOLNT", "MOLG", "SSOLN", "SolNT", "SUNMN", " SOLNG", "SALNG", "SILN", "SALNT", "SOTNT", "SSILMN", "SolNG", "SULNT", "SOLM", "SolN", "SILMN", "MOLN", "SILM", "SILNT", "SALM", "SALMN", "SILNS", "MOLNG", "SULNG", "SOOLN", "SOLNG", "SOLNS", "SOTN", " SOTN", "SSILNS", "MolG", "SUNNS", "SOOLNT", " SOTNT", "SOOLNG", " SOLM", "SULG", "SULN", "MOLNT", "SSILN", "SALN", "MolNT", "SOTM", "SSOLMN", "SSOLNS", "MolNG", "SolG", "SOTNG", "SUNN", "SOLG"], "R": ["Range", "D", "G", "O", "Right", "X", "RA", "H", "L", "U", "CR", "E", "A", "Q", "DR", "RC", "IR", "RG", "B", "SR", "Res", "AR", "F", "J", "V", "RO", "RS", "Y", "N", "NR", "RE", "TR", "GR", "RR", "Rs", "I", "RM", "P", "RT", "Rat", "RI", "W", "BR", "S", "MR"], "C": ["Co", "D", "G", "O", "CD", "Ch", "COR", "X", "H", "L", "U", "CR", "E", "A", "CM", "Q", "AC", "Chain", "CS", "B", "CA", "CV", "Cl", "IC", "TC", "CC", "AR", "This", "You", "F", "V", "Y", "N", "RE", "CO", "Car", "CT", "CG", "VC", "CF", "CP", "K", "DC", "I", "P", "RM", "Mc", "W", "c", "CCC", "MC", "CU", "S"], "M": ["D", "G", "O", "X", "MA", "H", "L", "m", "U", "E", "Q", "MR", "CM", "TM", "A", "MAN", "B", "MM", "AR", "F", "J", "IM", "Multi", "V", "Y", "N", "RE", "MD", "MT", "MI", "K", "I", "RM", "P", "Mc", "W", "Size", "MAT", "MC", "MS", "S", "AM"], "s": ["ns", "p", "os", "str", "er", "type", "rs", "ps", "m", "sb", "h", "ss", "strings", "n", "g", "ed", "ls", "sol", "spec", "ds", "w", "sets", "set", "its", "b", "gets", "ins", "bs", "sign", "qs", "seconds", "string", "abs", "sv", "als", "tests", "js", "a", "ses", "c", "fs", "rows", "ts", "sys", "es", "S", "sts", "gs"], "t": ["fort", "p", "j", "tt", "TI", "type", "str", "TT", "e", "it", "Ts", "o", "m", "alt", "txt", "h", "ct", "n", "g", "td", "ret", "ti", "w", "d", "tr", "dt", "y", "set", "opt", "b", "tw", "lt", "TW", "mt", "l", "tg", "nt", "ot", "to", "te", "tif", "st", "title", "new", "out", "a", "c", "ta", "tc", "ts", "wt", "rt", "gt", "lat", "tes"]}}
{"code": " \\n  \\n  \\n  INPUT = \"tiny\"\\n  if 1:\\n      INPUT = \"A-large.in\"\\n      INPUT = \"A-small-attempt0.in\"\\n  \\n  def debug(*args):\\n      return\\n      sys.stderr.write(str(args) + \"\\n\")\\n  \\n  class Memoize:\\n      def __init__(self,function):\\n          self._cache = {}\\n          self._callable = function\\n              \\n      def __call__(self, *args, **kwds):\\n          cache = self._cache\\n          key = self._getKey(*args,**kwds)\\n          try: return cache[key]\\n          except KeyError:\\n              cachedValue = cache[key] = self._callable(*args,**kwds)\\n              return cachedValue\\n      \\n      def _getKey(self,*args,**kwds):\\n          return kwds and (args, ImmutableDict(kwds)) or args    \\n  \\n  def do_trial(a1, r1, a2, r2):\\n      p1 = set(r1[a1-1])\\n      p2 = set(r2[a2-1])\\n      u = p1.intersection(p2)\\n      if len(u) < 1:\\n          return \"Volunteer cheated!\"\\n      if len(u) > 1:\\n          return \"Bad magician!\"\\n      return list(u)[0]\\n  \\n  f = file(INPUT)\\n  T = int(f.readline()[:-1])\\n  for i in range(T):\\n      rows1 = []\\n      a1 = int(f.readline()[:-1])\\n      for r in range(4):\\n          rows1.append([int(x) for x in f.readline().split()])\\n      a2 = int(f.readline()[:-1])\\n      rows2 = []\\n      for r in range(4):\\n          rows2.append([int(x) for x in f.readline().split()])\\n      v = do_trial(a1, rows1, a2, rows2)\\n      print \"Case #%d: %s\" % (i+1, v)\\n", "substitutes": {"INPUT": ["INST", "inST", " OUTFIX", " INST", "InUT", "InST", "inFIX", "EXPORT", "INFIX", "INInput", "INPORT", "InPORT", "inLINE", "InInput", "EXUT", " INLINE", "ANInput", "inJECT", "inInput", "inPUT", " INFILE", "inUT", "inFILE", "INUT", " OUTLINE", " OUTPUT", "InFIX", "INJECT", " INJECT", "inPORT", "INLINE", "EXFILE", "EXPUT", "ANPUT", "InPUT", "InFILE", "INFILE", "ANFIX", " OUTFILE", "InJECT", "ANST", " INFIX"], "self": ["python", "func", "app", "tmp", "rem", "args", "h", "pre", "req", "close", "spec", "w", "full", "q", "local", "user", "ae", "instance", "c", "details", "handle", "default", "private", "prefix", "agg", "cmp", "s", "github", "parent", "remote", "params", "config", "parts", "rel", "pkg", "lex", "requ", "th", "resp", "also", "context", "sel", "this", "rec", "your", "public", "responsible", "n", "asm", "my", "sw", "make", "add", "new", "k", "ref", "client", "ren", "all", "dev", "subject", "ws", "init", "me", "cl", "replace", "nt", "obj", "look", "sys", "object", "py", "Self"], "function": ["partial", "func", "python", "type", "functional", "word", "service", "command", "what", "handler", "relation", "closure", "section", "action", "fun", "module", "feature", "F", "role", "when", "value", "call", "job", "connection", "string", "normal", "evaluate", "callback", "method", "library", "Function", "component", "fn", "object"], "_cache": ["_store", " _call", " _Cache", "_c", "_Cache", " _driver", "_call", "_driver"], "_callable": ["_codor", " _callor", "__caller", "_constructor", "__callpoint", "_cacheer", "_Callable", "_Callability", "_codable", " _codables", "__Callpoint", "_constructability", "_cacheability", " _codable", "_codability", " _codability", "_callor", "_constructable", "__Callable", "_Caller", "_cacheable", "_Callables", "__Caller", "__Callability", "_cachepoint", " _codor", " _callability", "_callability", "_Callor", "_constructables", "_caller", "_callpoint", "__callability", "_callables", "_Callpoint", "__callable", "_codables", " _callables"], "cache": ["tmp", "p", "apache", "api", "force", "cp", "master", "cm", "store", "memory", "cmp", "h", "metadata", "conf", "wrapper", "close", "cos", "can", "chain", "spec", "use", "ache", "local", "cs", "set", "ached", "module", "config", "db", "ac", "HE", "aches", "dict", "co", "table", "mc", "cycle", "map", "ca", "mem", "c", "gc", "parse", "hash", "Cache"], "key": ["Key", "next", "password", "k", "tag", "str", "col", "prefix", "source", "cy", "ek", "client", "id", "path", "s", "code", "keys", "kw", "name", "ey", "chain", "page", "item", "result", "slot", "index", "field", "y", "set", "my", "entry", "prop", "KEY", "where", "value", "member", "primary", "title", "ice", "by", "a", "ex", "sum", "hash", "case", "pair"], "cachedValue": ["cachableItem", "cachableKey", "cacheVALUE", " cachableVALUE", "cachableValue", "bcachedItem", " cachedVALUE", "codedFunction", "bcachedResult", "bcannedResult", "calledVALUE", "codedVALUE", "cachedResult", "bcannedVALUE", " cachableKey", " cachableValue", "cachableFunction", "cacheKey", "bcachedValue", "bcannedValue", "bcachedVALUE", "cachedItem", "cannedValue", " cachedFunction", "codedValue", "cannedResult", "bcannedItem", "calledItem", "cachedFunction", "codedKey", " cachableFunction", "cachedKey", "cannedItem", "cachableVALUE", "cacheValue", "cacheFunction", "cannedVALUE", "calledValue", " cachedKey", "calledResult", "cachedVALUE", "cachableResult"], "a1": ["p0", "ta001", "sa0", "A2", "r0", "pone", "a3", "go001", "aa1", "ta01", "ma01", " a5", "pa001", "aaa01", "pa01", "a001", "ma2", "aa2", "saone", "pa6", "aaa2", "go6", "a0", "rone", "aone", "a01", "ma1", "pa1", "A01", "aaa1", "A5", "a6", "A3", "ta1", "ma3", "ta6", "A1", "go01", "aa5", "sa2", "go1", "aaa3", "sa1", "a5"], "r1": ["p0", "rs0", "p8", "r0", "r8", " r0", "rFirst", "ar1", "rs1", "aFirst", "pFirst", "ar2", "rs2", "ar8", "arFirst", "a8"], "a2": ["oa5", "A2", " a02", " a5", "a21", "r02", "i1", "sta21", "oa21", "sta5", "ea6", " a6", "ea02", "ea2", "A32", "A02", "r5", "row6", " atwo", "itwo", "Atwo", "oa6", "a32", "oa2", "a02", "A5", "row02", "sta6", "atwo", "a6", "i2", "i32", "A1", "sta2", " a32", "row2", " a21", "a5"], "r2": ["rt02", "rs4", "rstwo", "p4", "rc2", "r20", "ptwo", "rtwo", "res20", "res2", "r02", "rc4", "r4", "rs1", "rt2", "rctwo", "rc1", "rs2", "rt20", "rt1", "res1", "res02", "p02", "p20"], "p1": ["pa3", " p51", "P2", "pkg7", " p7", "p3", "r51", "P3", "p7", "pa1", " p3", "pkg51", "pa2", "r7", "P1", "p51", "pkg1"], "p2": ["p42", "P42", "P2", "p22", "ptwo", "rtwo", "P102", "c2", "ctwo", " p102", "a102", "c1", "P22", "r42", "p102", "Ptwo", "c42", "a22", "P1", " p22"], "u": ["au", "lu", "pu", "p", "su", "bo", "uid", "t", "units", "U", "ou", "unique", "util", "us", "fu", "yu", "uf", "ui", "up", "ru", "upper", "cu", "user", "ut", "nu", "ue", "un", "eu", "mu", "iu", "cum", "you", "uu", "du", "tu", "ul", "uni", "c", "uv", "bu"], "f": ["ft", "fd", "p", "bf", "j", "form", "fr", "df", "e", "it", "t", "o", "fl", "h", "of", "cf", "conf", "fo", "g", "fg", "exp", "fb", "w", "d", "full", "lf", "tf", "sf", "alf", "y", "q", "F", "xf", "fm", "b", "l", "fed", "fast", "fp", "out", "file", "fc", "a", "fs", "c", "et", "fa", "fw"], "T": ["Time", "D", "O", "TI", "TT", "TN", "IT", "t", "TM", "TY", "L", "A", "Q", "R", "It", "B", "TC", "TS", "TA", "F", "OT", "J", "Type", "V", "M", "Z", "NT", "Y", "N", "WT", "GT", "TR", "TB", "C", "K", "Total", "I", "P", "W", "S"], "i": ["gi", "j", "ic", "p", "li", "e", "it", "ia", "m", "id", "n", "s", "g", "z", "ri", "ti", "ini", "w", "d", "si", "bi", "xi", "im", "y", "mi", "b", "ip", "l", "pi", "di", "I", "zi", "a", "c", "ir", "ci"], "rows1": ["ows2", "rows_", "rows0", "rowsFirst", " rows_", "owsFirst", "papers_", "ows_", "row0", "papersFirst", "row1", " rows0", "ows1", "ows0", "row2", "papers1", " rowsFirst"], "r": ["p", "j", "er", "fr", "adr", "re", "err", "e", "t", "m", "h", "run", "ar", "art", "w", "d", "pr", "rr", "cr", "hr", "rar", "attr", "dr", "mr", "vr", "c", "rd", "ir", "rt"], "x": ["ux", "hex", "xs", "e", "xxxx", "X", "rx", "xxx", "t", "wx", "rax", "dx", "xp", "ax", "ct", "ox", "z", "n", "xc", "ross", "xa", "xt", "tx", "int", "mx", "w", "xi", "q", "y", "xf", "inx", "\u00e7", "yx", "xe", "xd", "ix", "rox", "xy", "ex", "px", "c", "nex", "xx", "rex", "fx", "ci"], "rows2": ["ows2", " rows6", "rs4", "rows4", "views2", "relationstwo", "ows4", "ows5", "ows6", "relations1", "views1", "owstwo", " rows4", "rs1", "relations2", "viewstwo", "rs2", "ows1", "rs6", "rows6", " rows5", "rows5", "rowstwo", "rs5"], "v": ["vy", "vector", "p", "j", "qv", "t", "o", "m", "video", "lv", "z", "n", "g", "w", "d", "y", "b", "V", "ev", "value", "vv", "l", "vt", "tv", "cv", "vs", "nv", "vp", "a", "c", "uv", "vm", "av", "sv"]}}
{"code": " \\n  lines = iter('''\\n  13\\n  5 5 23\\n  3 1 1\\n  1 3 1\\n  2 2 1\\n  4 7 3\\n  10 10 82\\n  10 1 4\\n  1 10 5\\n  2 10 8\\n  10 2 8\\n  2 10 9\\n  10 2 7\\n  5 3 3\\n  '''.splitlines(False)[1:])\\n  out = sys.stdout\\n  \\n  sys.setrecursionlimit(1500)\\n  \\n  \\n  class MyException(Exception):\\n  \tpass\\n  lines = iter(open(r'C-small-attempt7.in').readlines(False))\\n  out = open('c-small.answer', 'w')\\n  \\n  def solve(C, R, M):\\n  \tboard = [['.']*C for _ in range(R)]\\n  \tboard[-1][-1] = 'c'\\n  \ttry:\\n  \t\tfor r in range(R-2):\\n  \t\t\tfor c in range(C-2):\\n  \t\t\t\tif r == R-3 and c == C-3:\\n  \t\t\t\t\traise StopIteration()\\n  \t\t\t\tboard[r][c] = '*'\\n  \t\t\t\tM -= 1\\n  \t\t\t\tif M == 0:\\n  \t\t\t\t\treturn board \\n  \texcept StopIteration:\\n  \t\tpass\\n  \t\t\\n  \tif M % 2 == 0:\\n  \t\tfor r in range(R-3):\\n  \t\t\tboard[r][C-1] = '*'\\n  \t\t\tboard[r][C-2] = '*'\\n  \t\t\tM -= 2\\n  \t\t\tif M == 0:\\n  \t\t\t\treturn board\\n  \t\tfor c in range(C-3):\\n  \t\t\tboard[R-1][c] = '*'\\n  \t\t\tboard[R-2][c] = '*'\\n  \t\t\tM -= 2\\n  \t\t\tif M == 0:\\n  \t\t\t\treturn board\\n  \t\t\\n  \t\t\\n  \t\traise MyException()\\n  \telse:\\n  \t\tboard[R-3][C-3] = '*'\\n  \t\tM -= 1\\n  \t\tif M == 0:\\n  \t\t\treturn board\\n  \t\tfor r in range(R-2):\\n  \t\t\tboard[r][C-1] = '*'\\n  \t\t\tboard[r][C-2] = '*'\\n  \t\t\tM -= 2\\n  \t\t\tif M == 0:\\n  \t\t\t\treturn board\\n  \t\tfor c in range(C-2):\\n  \t\t\tboard[R-1][c] = '*'\\n  \t\t\tboard[R-2][c] = '*'\\n  \t\t\tM -= 2\\n  \t\t\tif M == 0:\\n  \t\t\t\treturn board\\n  \t\t\\n  \t\traise MyException()\\n  \t\t\\n  \t\\n  caseCnt = int(next(lines))\\n  \\n  for case in range(1, caseCnt+1):\\n  \tR,C,M = map(int, next(lines).split())\\n  \t\\n  \tprint('Case #%d:'%case, file=out)\\n  \tif M == 0:\\n  \t\tprint('c' + '.'*(C-1), file=out)\\n  \t\tfor _ in range(R-1):\\n  \t\t\tprint('.'*C, file=out)\\n  \telif R*C==M+1:\\n  \t\tprint('c' + '*'*(C-1), file=out)\\n  \t\tfor _ in range(R-1):\\n  \t\t\tprint('*'*C, file=out)\\n  \telif C == 1 and R == 1:\\n  \t\tprint('Impossible', file=out)\\n  \telif C == 1:\\n  \t\tif M > R-1:\\n  \t\t\tprint('Impossible', file=out)\\n  \t\telse:\\n  \t\t\tprint('c', file=out)\\n  \t\t\tfor _ in range(R-M-1):\\n  \t\t\t\tprint('.', file=out)\\n  \t\t\tfor _ in range(M):\\n  \t\t\t\tprint('*', file=out)\\n  \telif R == 1:\\n  \t\tif M > C-1:\\n  \t\t\tprint('Impossible', file=out)\\n  \t\telse:\\n  \t\t\tprint('c' + '.'*(C-M-1) + '*'*M, file=out)\\n  \telif C == 2:\\n  \t\tif M %2 or M//2 > R-2:\\n  \t\t\tprint('Impossible', file=out)\\n  \t\telse:\\n  \t\t\tprint('c.', file=out)\\n  \t\t\tfor _ in range(R-M//2-1):\\n  \t\t\t\tprint('..', file=out)\\n  \t\t\tfor _ in range(M//2):\\n  \t\t\t\tprint('**', file=out)\\n  \telif R == 2:\\n  \t\tif M %2 or M//2 > C-2:\\n  \t\t\tprint('Impossible', file=out)\\n  \t\telse:\\n  \t\t\tprint('c' + '.'*(C-M//2-1) + '*'*(M//2), file=out)\\n  \t\t\tprint(      '.'*(C-M//2)   + '*'*(M//2), file=out)\\n  \telif M > R*C-4:\\n  \t\tprint('Impossible', file=out)\\n  \telse:\\n  \t\ttry:\\n  \t\t\tboard = solve(C, R, M)\\n  \t\t\tfor line in board:\\n  \t\t\t\tprint(''.join(line), file=out)\\n  \t\texcept MyException:\\n  \t\t\tprint('Impossible', file=out)\\n  \t\\n  \t\\n", "substitutes": {"lines": ["values", "comments", "lists", "cycles", "xs", "issues", "lins", "err", "rs", "los", "bytes", "ings", "rings", "es", "strings", "results", "words", "s", "files", "lo", "headers", "blocks", "ls", "eds", "errors", "ds", "ors", "cs", "runs", "ers", "parts", "its", "ins", "elines", "cells", "l", "bits", "codes", "groups", "sections", "posts", "qs", "ln", "bs", "items", "ens", "points", "vs", "boards", "vals", "nets", "ines", "iter", "cases", "inline", "tests", "frames", "rows", "objects", "steps", "details", "limits", "links", "breaks"], "out": ["res", "tmp", "p", "os", "Out", "col", "t", "o", "io", "txt", "client", "n", "conf", "name", "can", "result", "w", "outs", "cache", "co", "pool", "nt", "ot", "net", "output", "ch", "obj", "OUT", "file", "sys", "v", "pos", "gt", "bin", "status"], "C": ["Co", "D", "G", "O", "CD", "JC", "Ch", "BC", "COR", "X", "H", "L", "U", "HC", "CR", "E", "Q", "CM", "A", "Cr", "RC", "AC", "Count", "Chain", "Current", "LC", "CS", "B", "Col", "TC", "Cl", "CV", "CA", "IC", "CE", "CC", "CI", "F", "CON", "Craig", "SC", "V", "EC", "cr", "Change", "Y", "Cor", "N", "CO", "CT", "CG", "VC", "CP", "CF", "DC", "K", "I", "P", "Mc", "W", "CL", "CB", "MC", "CU", "T", "S", "Cs"], "R": ["Range", "Runner", "D", "JR", "Review", "U", "A", "Cl", "AR", "F", "Reader", "Rec", "RB", "Rot", "Repl", "Red", "RM", "RT", "G", "Ch", "Reg", "DR", "Remote", "Chain", "B", "Res", "RL", "RH", "NR", "OR", "RW", "S", "MR", "ER", "COR", "Right", "X", "RA", "L", "RC", "RG", "HR", "RO", "RS", "Result", "Row", "Y", "RE", "P", "IR", "SR", "Re", "RP", "O", "Ren", "H", "CR", "Q", "E", "RGB", "V", "PR", "N", "TR", "RR", "Rs", "VR", "I", "W", "T", "BR"], "M": ["D", "G", "O", "AM", "MA", "H", "L", "m", "TM", "E", "Q", "CM", "MN", "NM", "OM", "Mon", "MAN", "B", "MER", "PM", "MM", "JM", "FM", "MX", "F", "J", "IM", "V", "Me", "Y", "LM", "EM", "N", "MF", "MT", "MI", "Maker", "I", "RM", "P", "Mom", "Mc", "DM", "W", "MAT", "MC", "Mouse", "ME", "T", "MS", "S", "MR", "Message", "Mer", "MP"], "board": ["function", "base", "foot", "long", "deck", "old", "code", "fine", " boards", "cat", "cod", "local", "link", "row", "body", "template", "batch", "clean", "door", "box", "du", "fc", "Board", "library", "bd", "dam", "bo", "block", "ro", "control", "ault", "chain", "loop", " dashboard", "lay", "rank", "rot", "stone", "bank", "player", "back", "stri", "bro", "hall", "flo", "form", "reader", "oard", "layout", "zero", "style", "database", "lib", "vote", "boat", "copy", "ac", "bench", "dict", "co", "table", "runner", "ward", "bard", "bar", "land", "student", "design", "past", "comment", "pair", "bit", "client", "planet", "system", "lo", "book", "uno", "core", "cross", "builder", "pad", "buffer", "plate", "boards", "ack", "boarding", "black", "bird", "bug", "lock", "bot", "list"], "_": ["p", "m", "time", "ct", "ox", "code", "n", "all", "con", "name", "pc", "int", "ac", "val", "co", "x", "un", "ver", "mult", "a", "ml"], "r": ["range", "res", "br", "p", "j", "rc", "k", "er", "fr", "re", "adr", "e", "rs", "reg", "it", "t", "o", "rec", "m", "err", "yr", "nr", "h", "ro", "run", "rb", "g", "n", "ren", "f", "all", "ar", "w", "d", "pr", "q", "i", "kr", "b", "row", "l", "rr", "hr", "cr", "rar", "x", "rel", "usr", "sr", "ra", "RR", "dr", "rm", "mr", "vr", "rn", "a", "v", "rd", "rt", "rh", "ir", "right"], "c": ["dc", "p", "ic", "rc", "k", "col", "e", "cp", "cm", "cut", "t", "o", "m", "cur", "rec", "lc", "h", "ct", "bc", "n", "xc", "con", "g", "f", "category", "can", "chain", "pc", "cu", "d", "arc", "w", "cb", "sc", "i", "cs", "ec", "cache", "cin", "uc", "b", "ac", "cont", "cor", "cl", "unc", "l", "cr", "co", "x", "cc", "mc", "cycle", "ch", "ca", "fc", "a", "ce", "v", "tc", "ci"], "caseCnt": [" caseNount", " caseCct", "caseNct", "caseNnt", "casecount", "caseYCount", "CaseCnt", "caseCst", "caseCCount", "casecst", "casecNT", " caseCNT", "caseCNT", "caseNount", "caseYst", "CaseCst", "caseNNT", "CaseCNT", "casecnt", " caseNNT", " caseNct", "caseYnt", "caseCct", "CaseCCount", " caseCount", "caseYNT", "casecCount", "casecct", " caseNnt", "caseCount"], "case": ["match", "count", "client", "block", "sub", "key", "code", "ace", "close", "chain", "name", "section", "condition", "result", "change", "catch", "row", "Case", "cycle", "hyp", "cases", "ase", "ce", "first", "test", "cas", "pair"]}}
{"code": " \\n  input = open(r'C:\\MyDocument\\home\\gcj\\2014-04-12\\A-small-attempt0.in')\\n  caseCnt = int(input.readline())\\n  for caseNo in range(1, caseCnt+1):\\n  \tans1 = int(input.readline())\\n  \tfor i in range(1, 5):\\n  \t\tline = input.readline()\\n  \t\tif ans1 == i:\\n  \t\t\tcandidates = set(map(int, line.split()))\\n  \t\t\\n  \tans2 = int(input.readline())\\n  \tfor i in range(1, 5):\\n  \t\tline = input.readline()\\n  \t\tif ans2 == i:\\n  \t\t\tanswers = candidates.intersection(set(map(int, line.split())))\\n  \t\t\\n  \tif len(answers) == 0:\\n  \t\tprint('Case #%d: Volunteer cheated!'%caseNo)\\n  \telif len(answers) > 1:\\n  \t\tprint('Case #%d: Bad magician!'%caseNo)\\n  \telif len(answers) == 1:\\n  \t\tanswer = answers.pop()\\n  \t\tprint('Case #%d: %d'%(caseNo, answer))\\n", "substitutes": {"input": ["shift", "act", "open", "form", "reader", "re", "cmd", "console", "it", "img", "start", "command", "io", "history", "cur", "url", "txt", "client", "context", "inc", "submit", "csv", "ve", "raw", "up", "proc", "int", "exec", "dl", "wa", "process", "q", "local", "set", "conn", "PUT", "init", "config", "cont", "hidden", "mit", "stream", "http", "output", "ch", "add", "new", "format", "Input", "feed", "out", "file", "get", "quick", "ce", "sys", "xml", "sum", "lat", "text", "select", "filter", "inner"], "caseCnt": ["caseNnt", "casecnd", "casecount", "CaseCnd", "CaseCount", "CaseCnt", "caseCnd", "caseSount", "CaseCust", "casecNT", "casecust", "caseCNT", "caseNrc", "casecrc", "CaseCrc", "caseCrc", "caseNNT", "CaseCNT", "casecnt", "caseNnd", "caseSust", "caseCust", "caseSNT", "caseSnt", "caseCount"], "caseNo": [" caseNumber", "aseNo", "patchNO", "Caseno", "CaseNumber", "aseKo", "patchNo", "aseNumber", "caseKo", "patchNumber", "caseNO", " caseKo", "CaseNum", " caseNum", "caseNum", "caseno", "aseNO", "caseNumber", "CaseNo", " caseNO", "patchKo", "aseno", "aseNum", " caseno"], "ans1": ["antsOne", " ans0", "ants2", "ANS_", " ansOne", "ants5", "ens5", "an_", "ans5", "ANSOne", "an0", "ants1", "an2", "ans0", "ens2", "ANS0", "ans_", "an5", "ansOne", " ans_", "ensOne", "anOne", "an1", "ens1", "ANS1"], "i": ["gi", "ki", "hi", "p", "ic", "j", "li", "it", "ia", "o", "m", "ik", "phi", "ei", "int", "ti", "ini", "bi", "index", "si", "xi", "im", "y", "mi", "ai", "ip", "l", "pi", "ii", "oi", "iu", "ij", "ati", "di", "I", "zi", "ie", "c", "v", "fi", "yi", "ind", "ci"], "line": ["range", "se", "detail", "Line", "next", "frame", "li", "part", "piece", "lin", "long", "le", "eline", "LINE", "block", "lo", "shell", "chain", "pair", "page", "int", "lf", "ine", "set", "byte", "link", "row", "log", "l", "port", "nl", "text", "ln", "body", "pipe", "liner", "string", "iter", "ice", "phrase", "mail", "inline", "file", "out", "header", "lines", "cell", "handle", "comment", "list"], "candidates": ["validated", "madeidated", "valuations", "Canduations", "centsters", "canduations", "contsters", "Candidates", "candsters", "Candands", "candidated", "Candidated", "madeidates", "Candsters", "candands", "Candidate", "centidates", "madeidate", "contidate", "centidate", "contands", "validate", "contidates", "validates", "madeuations", "centands", "candidate"], "ans2": ["anas1", "atstwo", "ans3", "antwo", "ins5", "ans5", "an3", "anas2", "ats1", "eds3", "an02", "eds5", "an2", "ans02", "eds02", "eds2", "anstwo", "ats2", "ins3", "an5", "ins02", "an1", "ins2", "anastwo"], "answers": ["answors", "answoered", "ansdrawer", "ansswerers", "ansswers", "anwuers", "ansdrawers", "ansswors", "ansreaduers", "answoer", "anweds", "anwers", "ansdrawERS", "answERS", "answoors", "ansswuers", "anwERS", "ansreaders", "ansviewors", "ansswERS", "answuers", "answoeds", "anwors", "answriters", "answriterers", "answorder", "answeds", "answorders", "ansswered", "answerers", "ansreadeds", "answered", "ansviewers", "ansviewered", "ansswer", "anssweds", "answorderers", "anwerers", "answritERS", "anwered", "answoers", "ansviewERS", "answouers", "answordERS", "ansreader", "answriter", "ansviewer", "answoERS", "anwer", "ansdrawerers"], "answer": ["swers", "match", "duration", "next", "cho", "su", "word", "issue", "qual", "term", "ne", "option", "ve", "example", "ask", "eni", "ret", " answered", "see", "quote", "int", "result", "pet", "question", "vote", "ine", " unanswered", "man", "entry", "notice", "wer", "echo", "value", "answered", "rep", "query", "Answer", "after", "string", "bet", "accept", "response", "test", "say", "message"]}}
{"code": " \\n  def iterate_cases_1lpc(filepath):\t#1lpc = 1 line per case\\n  \twith file(filepath, 'rb') as f_in:\\n  \t\tfor line_index, line in enumerate(f_in):\\n  \t\t\tif line_index == 0: #T\\n  \t\t\t\tcontinue\\n  \t\t\tyield line_index, line.strip().split(' ')\\n  \\n  def iterate_cases_nlpc(filepath, n):\t#1lpc = n line per case\\n  \twith file(filepath, 'rb') as f_in:\\n  \t\tcase_counter = 1\\n  \t\tcase = []\\n  \t\tfor line_index, line in enumerate(f_in):\\n  \t\t\tif line_index == 0: #T\\n  \t\t\t\tcontinue\\n  \t\t\tcase.append(line.strip().split(' '))\\n  \t\t\tif not line_index % n:\\n  \t\t\t\tyield case_counter, case\\n  \t\t\t\tcase_counter += 1\\n  \t\t\t\tcase = []\\n  \\n  def iterate_cases_glpc(filepath):\t\t#glpc - given lines per case\\n  \twith file(filepath, 'rb') as f_in:\\n  \t\tcase_counter = 0\\n  \t\tnew_case = True\\n  \t\tfor line_index, line in enumerate(f_in):\\n  \t\t\tif line_index == 0: #T\\n  \t\t\t\tcontinue\\n  \t\t\tif new_case:\\n  \t\t\t\tnew_case = False\\n  \t\t\t\tcase_counter += 1\\n  \t\t\t\tcase = []\\n  \t\t\t\tassert len(line.strip().split(' ')) == 1\\n  \t\t\t\tlines_left = int(line.strip())\\n  \t\t\t\tif not lines_left:\\n  \t\t\t\t\tnew_case = True\\n  \t\t\t\t\tyield case_counter, case\\n  \t\t\t\tcontinue\\n  \t\t\tif lines_left:\\n  \t\t\t\tlines_left -= 1\\n  \t\t\t\tcase.append(line.strip().split(' '))\\n  \t\t\tif not lines_left:\\n  \t\t\t\tnew_case = True\\n  \t\t\t\tyield case_counter, case\\n  \t\t\t\\n  def part_of_list_to_int(array, flags):\\n  \tassert len(array) == len(flags)\\n  \toutput = []\\n  \tfor index, elem in enumerate(array):\\n  \t\tif flags[index]:\\n  \t\t\toutput.append(int(elem))\\n  \t\telse:\\n  \t\t\toutput.append(elem)\\n  \treturn output\\n  \\n  def list_to_int(array):\\n  \treturn part_of_list_to_int(array, [True] * len(array))\\n  \\n  def part_of_list_to_float(array, flags):\\n  \tassert len(array) == len(flags)\\n  \toutput = []\\n  \tfor index, elem in enumerate(array):\\n  \t\tif flags[index]:\\n  \t\t\toutput.append(float(elem))\\n  \t\telse:\\n  \t\t\toutput.append(elem)\\n  \treturn output\\n  \\n  def list_to_float(array):\\n  \treturn part_of_list_to_float(array, [True] * len(array))\\n  \\n  def get_max_array_on_index(array, index):\\n  \telem_len = len(array[0])\\n  \tassert index < elem_len\\n  \tfor elem in array:\\n  \t\tassert elem_len == len(elem)\\n  \tmax_sub = array[0][index]\\n  \tmax_elem = array[0]\\n  \tfor elem in array:\\n  \t\tif elem[index] > max_sub:\\n  \t\t\tmax_sub = elem[index]\\n  \t\t\tmax_elem = elem\\n  \treturn max_elem\\n  \\n  def list_index_in_sorted_with_position(a_list, value, pos):\\n  \tlist_len = len(a_list)\\n  \tif list_len == 1:\\n  \t\tif a_list[0] == value:\\n  \t\t\treturn pos\\n  \t\treturn -1\\n  \tif a_list[list_len/2] > value:\\n  \t\treturn list_index_in_sorted_with_position(a_list[:(list_len/2)], value, pos)\\n  \telse:\\n  \t\treturn list_index_in_sorted_with_position(a_list[(list_len/2):], value, pos + (list_len/2))\\n  \t\\n  def list_index_in_sorted_list(a_list, value):\\n  \treturn list_index_in_sorted_with_position(a_list, value, 0)\\n  \\n  def copy_list(list):\\n  \tres = []\\n  \tfor elem in list:\\n  \t\tres.append(elem)\\n  \treturn res\t\\n  \\n  \\n  def conj_mat(a):\\n  \tR = len(a)\\n  \tC = len(a[0])\\n  \tres = [['.' for _ in xrange(R)] for __ in xrange(C)]\\n  \tfor i in xrange(R):\\n  \t\tfor j in xrange(C):\\n  \t\t\tres[j][i] = a[i][j]\\n  \treturn res\\n  \\n  def one_line_builder(R, C, M):\\n  \tres = []\\n  \tres.extend(['*'] * M)\\n  \tres.extend(['.'] * (C - M))\\n  \tres[-1] = 'c'\\n  \treturn [res]\\n  \t\\n  def two_line_builder(R, C, M):\\n  \tline = []\\n  \tline.extend(['*'] * (M / 2))\\n  \tline.extend(['.'] * (C - M / 2))\\n  \tres = [line, copy_list(line)]\\n  \tres[1][-1] = 'c'\\n  \tif M%2 == 1:\\n  \t\tres[0][-1] = '*'\\n  \treturn res\\n  \t\\n  def three_line_builder(R, C, M):\\n  \tres = [['.' for _ in xrange(C)] for __ in xrange(R)]\\n  \tres[-1][-1] = 'c'\\n  \tm = min([M, R * C - 9])\\n  \tstop_flag = False\\n  \tfor j in xrange(C):\\n  \t\tif stop_flag:\\n  \t\t\tbreak\\n  \t\tfor i in xrange(R):\\n  \t\t\tif m == 0:\\n  \t\t\t\tstop_flag = True\\n  \t\t\t\tbreak\\n  \t\t\tres[i][j] = '*'\\n  \t\t\tm -= 1\\n  \tprint i,j\\n  \tif i == 2:\\n  \t\tres[1][j-1] = '.'\\n  \t\tif j == C - 3:\\n  \t\t\tres[0][j] = '*'\\n  \t\telse:\\n  \t\t\tres[0][-1] = '*'\\n  \t\\n  \tif M <= R * C - 9:\\n  \t\treturn res\\n  \telse:\\n  \t\tm = M - (R * C - 9)\\n  \t\tassert m not in [2, 4, 6, 7, 9]\\n  \t\tassert m > 0\\n  \t\tassert m < 10\\n  \t\t\\n  \t\tres[-3][-3] = '*'\\n  \t\tm -= 1\\n  \t\tif m == 0: return res\\n  \t\tres[-2][-3] = '*'\\n  \t\tres[-1][-3] = '*'\\n  \t\tm -= 2\\n  \t\tif m == 0: return res\\n  \t\tres[-3][-2] = '*'\\n  \t\tres[-3][-1] = '*'\\n  \t\tm -= 2\\n  \t\tif m == 0: return res\\n  \t\tres[-2][-2] = '*'\\n  \t\tres[-2][-1] = '*'\\n  \t\tres[-1][-2] = '*'\\n  \t\tm -= 3\\n  \t\tif m == 0: return res\\n  \t\tassert False\\n  \t\\n  \t\\n  \t\\n  def over_three_line_builder(R, C, M):\\n  \tif M <= (R - 3) * C:\\n  \t\tres = [['*' for _ in xrange(C)] for __ in xrange(M / C)]\\n  \t\tflag = False\\n  \t\tif (M % C) != (C - 1):\\n  \t\t\tline = ['*' for _ in xrange(M % C)]\\n  \t\t\tline.extend(['.' for _ in xrange(C - (M % C))])\\n  \t\telse:\\n  \t\t\tline = ['*' for _ in xrange((M % C) - 1)]\\n  \t\t\tline.extend(['.' for _ in xrange((C - (M % C)) + 1)])\\n  \t\t\tflag = True\\n  \t\tres.append(line)\\n  \t\tindex = len(res)\\n  \t\tres.extend([['.' for _ in xrange(C)] for __ in xrange(R - len(res))])\\n  \t\tif flag:\\n  \t\t\tres[index][0] = '*'\\n  \t\tres[-1][-1] = 'c'\\n  \t\tassert len(res) == R\\n  \t\tassert len(res[0]) == C\\n  \t\treturn res\\n  \telse:\\n  \t\tres = [['*' for _ in xrange(C)] for __ in xrange(R - 3)]\\n  \t\tM -= (R - 3) * C\\n  \t\ttmp = three_line_builder(3, C, M)\\n  \t\tif len(tmp) != 3: # error msg\\n  \t\t\treturn tmp\\n  \t\tres.extend(tmp)\\n  \t\treturn res\\n  \t\\n  def solve(R, C, M):\\n  \tres = None\\n  \t\\n  \tif M == R * C:\\n  \t\treturn 'Impossible'\\n  \tif R >= 3 and C >= 3:\\n  \t\tif R*C - M in [7, 5, 3, 2]:\\n  \t\t\treturn 'Impossible'\\n  \t\treturn over_three_line_builder(R, C, M)\\n  \t\t\\n  \telif R != 1 and C != 1:  #which means one of them is 2, and the other not 1\\n  \t\tif (R*C - M) % 2 == 1:\\n  \t\t\tif M < R*C - 1:\\n  \t\t\t\treturn 'Impossible'\\n  \t\tif M + 2 == R * C:\\n  \t\t\treturn 'Impossible'\\n  \t\telse:\\n  \t\t\tif R == 2:\\n  \t\t\t\treturn two_line_builder(R, C, M)\\n  \t\t\telse:\\n  \t\t\t\ttmp = two_line_builder(C, R, M)\\n  \t\t\t\treturn conj_mat(tmp)\\n  \t\\n  \telse:\t\t\t\t\t#which means one of them is 1\\n  \t\tif R == 1:\\n  \t\t\treturn one_line_builder(R, C, M)\\n  \t\telse:\\n  \t\t\ttmp = one_line_builder(C, R, M)\\n  \t\t\treturn conj_mat(tmp)\\n  \t\t\\n  \treturn res\\n  \\n  def mat_to_str(a):\\n  \tif a in ['Impossible', 'Not Implemented']:\\n  \t\treturn a\\n  \tstr_out = ''\\n  \tfor row in a:\\n  \t\tfor elem in row:\\n  \t\t\tstr_out += elem\\n  \t\tstr_out += '\\n'\\n  \treturn str_out[:-1]\\n  \t\\n  def calc_result(case):\\n  \tresult = None\\n  \t\\n  \tR = int(case[0])\\n  \tC = int(case[1])\\n  \tM = int(case[2])\\n  \tprint R, C, M\\n  \t\\n  \tresult = solve(R, C, M)\\n  \t\\n  \tstr_out = mat_to_str(result)\\n  \tm = str_out.count('*')\\n  \tassert (m==0 or m==M)\\n  \tprint str_out\\n  \t\\n  \treturn '\\n%s' % str_out\\n  \\n  def main(filepath):\\n  \tstart_time = time.time()\\n  \twith file('output.txt', 'wb') as f_out:\\n  \t\t\\n  \t\tfor case_index, case in iterate_cases_1lpc(filepath):\\n  \t\t\t\\n  \t\t\tprint \"case #%d: time:%.02f\" % (case_index, time.time() - start_time)\\n  \t\t\tresult = calc_result(case)\\n  \t\t\t\\n  \t\t\tf_out.write(\"Case #%d: %s\\n\" % (case_index, result))\\n  \t\t\t\t\\n  if __name__ == '__main__':\\n  \tmain(sys.argv[1])\\n", "substitutes": {"filepath": [" filefile", "fname", "reportfile", "ffile", "reportpath", "filename", "reportname", " filedir", "filefile", "reportdir", "fdir", " filename", "fpath", "filedir"]}}
{"code": " \\n  def iterate_cases_1lpc(filepath):\t#1lpc = 1 line per case\\n  \twith file(filepath, 'rb') as f_in:\\n  \t\tfor line_index, line in enumerate(f_in):\\n  \t\t\tif line_index == 0: #T\\n  \t\t\t\tcontinue\\n  \t\t\tyield line_index, line.strip().split(' ')\\n  \\n  def iterate_cases_nlpc(filepath, n):\t#1lpc = n line per case\\n  \twith file(filepath, 'rb') as f_in:\\n  \t\tcase_counter = 1\\n  \t\tcase = []\\n  \t\tfor line_index, line in enumerate(f_in):\\n  \t\t\tif line_index == 0: #T\\n  \t\t\t\tcontinue\\n  \t\t\tcase.append(line.strip().split(' '))\\n  \t\t\tif not line_index % n:\\n  \t\t\t\tyield case_counter, case\\n  \t\t\t\tcase_counter += 1\\n  \t\t\t\tcase = []\\n  \\n  def iterate_cases_glpc(filepath):\t\t#glpc - given lines per case\\n  \twith file(filepath, 'rb') as f_in:\\n  \t\tcase_counter = 0\\n  \t\tnew_case = True\\n  \t\tfor line_index, line in enumerate(f_in):\\n  \t\t\tif line_index == 0: #T\\n  \t\t\t\tcontinue\\n  \t\t\tif new_case:\\n  \t\t\t\tnew_case = False\\n  \t\t\t\tcase_counter += 1\\n  \t\t\t\tcase = []\\n  \t\t\t\tassert len(line.strip().split(' ')) == 1\\n  \t\t\t\tlines_left = int(line.strip())\\n  \t\t\t\tif not lines_left:\\n  \t\t\t\t\tnew_case = True\\n  \t\t\t\t\tyield case_counter, case\\n  \t\t\t\tcontinue\\n  \t\t\tif lines_left:\\n  \t\t\t\tlines_left -= 1\\n  \t\t\t\tcase.append(line.strip().split(' '))\\n  \t\t\tif not lines_left:\\n  \t\t\t\tnew_case = True\\n  \t\t\t\tyield case_counter, case\\n  \t\t\t\\n  def part_of_list_to_int(array, flags):\\n  \tassert len(array) == len(flags)\\n  \toutput = []\\n  \tfor index, elem in enumerate(array):\\n  \t\tif flags[index]:\\n  \t\t\toutput.append(int(elem))\\n  \t\telse:\\n  \t\t\toutput.append(elem)\\n  \treturn output\\n  \\n  def list_to_int(array):\\n  \treturn part_of_list_to_int(array, [True] * len(array))\\n  \\n  def part_of_list_to_float(array, flags):\\n  \tassert len(array) == len(flags)\\n  \toutput = []\\n  \tfor index, elem in enumerate(array):\\n  \t\tif flags[index]:\\n  \t\t\toutput.append(float(elem))\\n  \t\telse:\\n  \t\t\toutput.append(elem)\\n  \treturn output\\n  \\n  def list_to_float(array):\\n  \treturn part_of_list_to_float(array, [True] * len(array))\\n  \\n  def get_max_array_on_index(array, index):\\n  \telem_len = len(array[0])\\n  \tassert index < elem_len\\n  \tfor elem in array:\\n  \t\tassert elem_len == len(elem)\\n  \tmax_sub = array[0][index]\\n  \tmax_elem = array[0]\\n  \tfor elem in array:\\n  \t\tif elem[index] > max_sub:\\n  \t\t\tmax_sub = elem[index]\\n  \t\t\tmax_elem = elem\\n  \treturn max_elem\\n  \\n  def list_index_in_sorted_with_position(a_list, value, pos):\\n  \tlist_len = len(a_list)\\n  \tif list_len == 1:\\n  \t\tif a_list[0] == value:\\n  \t\t\treturn pos\\n  \t\treturn -1\\n  \tif a_list[list_len/2] > value:\\n  \t\treturn list_index_in_sorted_with_position(a_list[:(list_len/2)], value, pos)\\n  \telse:\\n  \t\treturn list_index_in_sorted_with_position(a_list[(list_len/2):], value, pos + (list_len/2))\\n  \t\\n  def list_index_in_sorted_list(a_list, value):\\n  \treturn list_index_in_sorted_with_position(a_list, value, 0)\\n  \\n  def copy_list(list):\\n  \tres = []\\n  \tfor elem in list:\\n  \t\tres.append(elem)\\n  \treturn res\t\\n  \\n  \\n  def intersect(arr_A, arr_B):\\n  \tprint '\\t\\t%s\\n\\t\\t%s' % (arr_A, arr_B)\\n  \tres = []\\n  \tfor a in arr_A:\\n  \t\tif arr_B.count(a):\\n  \t\t\tres.append(a)\\n  \tprint '\\t\\t%s' % res\\n  \treturn res\\n  \\n  def solve(row_A_selected, board_A,\\n  \t\t  row_B_selected, board_B):\\n  \tres = intersect(board_A[row_A_selected - 1], \\n  \t\t\t\t\tboard_B[row_B_selected - 1])\\n  \tif len(res) == 0:\\n  \t\treturn 'Volunteer cheated!'\\n  \tif len(res) == 1:\\n  \t\treturn res[0]\\n  \treturn 'Bad magician!'\\n  \t\\n  def calc_result(case):\\n  \tresult = None\\n  \t\\n  \trow_A_selected = int(case[0][0])\\n  \trow_B_selected = int(case[5][0])\\n  \tboard_A = case[1:5]\\n  \tboard_B = case[6:10]\\n  \t\\n  \tprint \"row_A_selected: %s\" % row_A_selected\\n  \tprint \"row_B_selected: %s\" % row_B_selected\\n  \tprint \\n  \tprint board_A\\n  \tprint \\n  \tprint board_B\\n  \tprint\\n  \t\\n  \tresult = solve(row_A_selected, board_A,\\n  \t\t\t\t   row_B_selected, board_B)\\n  \tprint result\\n  \t\\n  \t\\n  \treturn result\\n  \\n  def main(filepath):\\n  \tstart_time = time.time()\\n  \twith file('output.txt', 'wb') as f_out:\\n  \t\t\\n  \t\tfor case_index, case in iterate_cases_nlpc(filepath, 10):\\n  \t\t\t\\n  \t\t\tprint \"case #%d: time:%.02f\" % (case_index, time.time() - start_time)\\n  \t\t\tresult = calc_result(case)\\n  \t\t\t\\n  \t\t\tf_out.write(\"Case #%d: %s\\n\" % (case_index, result))\\n  \t\t\t\t\\n  if __name__ == '__main__':\\n  \tmain(sys.argv[1])\\n", "substitutes": {"filepath": [" filefile", "fname", "reportfile", "ffile", "reportpath", "filename", "reportname", " filedir", "filefile", "reportdir", "fdir", " filename", "fpath", "filedir"]}}
{"code": " \\n  def Fill(outmat,R,C,F):\\n      nF=F\\n      outmat[:2,:2]='.'\\n      nF-=4\\n      if nF==0: return\\n  \\n      outmat[2,:2]='.'\\n      nF-=2\\n      if nF==0: return    \\n  \\n      outmat[:2,2]='.'\\n      nF-=2\\n      if nF==0: return\\n  \\n      for iC in xrange(3,C):\\n          if nF==1:\\n              outmat[2,2]='.'\\n              return\\n          outmat[:2,iC]='.'\\n          nF-=2\\n          if nF==0: return\\n          \\n      for iR in xrange(3,R):\\n          if nF==1:\\n              outmat[2,2]='.'\\n              return\\n          outmat[iR,:2]='.'\\n          nF-=2\\n          if nF==0: return\\n  \\n      for iR,iC in ( (iR,iC) for iR in xrange(2,R)\\n                     for iC in xrange(2,C)):\\n          outmat[iR,iC]='.'\\n          nF-=1\\n          if nF==0: return\\n      \\n  \\n  \\n  \\n  def Solve(R,C,M):\\n      F=R*C-M\\n      if F==0: return '\\nImpossible'\\n      if (R>1 and C>1 and F in (2,3)):\\n          return '\\nImpossible'\\n  \\n      outmat=np.zeros( (R,C), dtype='S1')\\n      outmat[:,:]='*'\\n  \\n      if R==1:\\n          for i in xrange(F):\\n              outmat[0][i]='.'\\n      \\n      elif C==1:\\n          for i in xrange(F):\\n              outmat[i][0]='.'\\n  \\n      elif F>1:\\n          if F in (2,3,5,7): return \"\\nImpossible\"\\n          elif (R==2 or C==2) and F%2 != 0:\\n              return \"\\nImpossible\"\\n          elif R==2:\\n              outmat[:,:F/2]='.'\\n          elif C==2:\\n              outmat[:F/2,:]='.'\\n          else: Fill(outmat,R,C,F)\\n          \\n      outmat[0,0]='c'\\n      outmatlines=[ ''.join(x) for x in outmat ]\\n      answer='\\n'+'\\n'.join(outmatlines)\\n  \\n      Verify(answer,F)\\n  \\n      return answer\\n  \\n  disp=[ (dx,dy) for dx in (-1,0,1)\\n      for dy in (1,0,-1) if (dx !=0 or dy!=0) ]\\n  \\n  def Verify(answer,F):\\n      lines=[list(x) for x in answer.split('\\n')]\\n      if len(lines[0])==0: lines.pop(0)\\n      R,C=len(lines),len(lines[0])\\n      assert lines[0][0]=='c'\\n      assert answer.count('.')+1==F\\n      q=Queue.Queue()\\n      q.put( (0,0) )\\n  \\n      def adjToMine(x,y):\\n          for dx,dy in disp:\\n              if 0<=x+dx<R and 0<=y+dy<C:\\n                  if lines[x+dx][y+dy]=='*': return True\\n          return False\\n                  \\n  \\n      while not q.empty():\\n          x,y=q.get()\\n          for dx,dy in disp:\\n              if 0<=x+dx<R and 0<=y+dy<C:\\n                  if lines[x+dx][y+dy]=='c': continue\\n                  lines[x+dx][y+dy]='c'\\n                  if not adjToMine(x+dx,y+dy):\\n                      q.put( (x+dx,y+dy) )\\n  \\n      clicked='\\n'.join([ ''.join(x) for x in lines])\\n      if clicked.find('.')>=0:\\n          print '\\n','*'*20,\"\\nERROR, input:\"\\n          print answer\\n          print 'OUTPUT:'\\n          print clicked\\n      \\n  \\n  \\n  \\n  def parse(infile):\\n      R,C,M=map(int, infile.readline().split() )\\n      return R,C,M\\n  \\n  \\n  \\n  class GCJ_Parser( object ):\\n      def __init__(self,fname):\\n          self.infile=open(fname,'r')\\n          self.NumCases=int(self.infile.readline().strip() )\\n          self.caseNum=0\\n  \\n      def __iter__(self): return self\\n  \\n      def next(self):\\n          if self.caseNum==self.NumCases: raise StopIteration\\n          self.caseNum += 1\\n          args=parse(self.infile)\\n          return self.caseNum , args\\n  \\n  \\n  def runmain():\\n      myCases=GCJ_Parser(sys.argv[1])\\n  \\n      outname=sys.argv[1].rstrip('.in')+'.out'\\n      if os.path.isfile(outname):\\n          oldout=outname+'.old'\\n          ii=0\\n          while os.path.isfile(oldout):\\n              ii+=1\\n              oldout=outname+'.old'+str(ii)\\n          os.rename(outname,oldout)\\n          print 'Rename: %s -> %s'%(outname,oldout)   \\n   \\n      outfile=open(outname,'w')\\n  \\n      for iCase, args in myCases:\\n          answer=Solve(*args)\\n  \\n          print 'Case #'+str(iCase)+':',answer\\n          print >> outfile, 'Case #'+str(iCase)+':',answer\\n  \\n  \\n  \\n  \\n  if __name__=='__main__':\\n      runmain()\\n", "substitutes": {"outmat": ["outtag", " outdat", "newpat", "uppat", "outputmat", "Outhat", "overhat", "outhat", "newmat", "clientMat", "Outmon", "outputformat", "OUTmon", "outbuf", " outmem", "genhat", "bootkt", "exitpat", "scanformat", "scantag", "inmat", "npat", "inkt", "bootmt", "outputcat", "inmem", "outdat", "oukt", "bootmat", "inMat", "overformat", "overmat", "OUTmat", "scanhat", "scanmat", "outmt", "outputmem", "returnmat", "inpat", "oumat", "outputatt", "bootpat", " outdoc", "outcat", " outpat", "nmat", "Outkt", "ouformat", "incat", "clientdoc", "exithat", "newhat", "OUThat", "OUTformat", "outkt", "genmem", "newformat", "bootmem", " outbuf", "scandoc", "nmit", "allmem", "exitmat", "outformat", "returnbuf", "Outformat", "OUTmem", "outdoc", "clientmat", "ncat", "upMat", " outmon", " outformat", " outtag", "OUTdat", "returnmem", "outputmit", "allMat", "upmat", "exitmt", "Outmem", "OutMat", "clienttag", "outatt", "returndat", "newMat", "boothat", "outputpat", " outhat", " outMat", "outmon", "OUTatt", " outmt", "outpat", " outcat", "genpat", " outmit", "Outmat", "allpat", "OUTMat", "allmat", "Outcat", "allcat", "scanMat", "outmem", "upmem", "OUTbuf", "outMat", "newmem", "overpat", "scanpat", " outatt", "OUTpat", "oupat", " outkt", "genmat", "outmit", "newcat", "Outpat"], "R": ["Ram", "D", "G", "O", "Ren", "X", "Rob", "RA", "H", "L", "U", "CR", "A", "MR", "Q", "DR", "Br", "IR", "B", "RF", "RG", "Res", "AR", "Mr", "HR", "r", "J", "KR", " r", "V", "RO", "RS", "Rot", "Row", "Y", "N", "NR", "RE", "TR", "GR", "RR", "Rs", "K", "VR", "I", "RM", "P", "RT", "Rat", "OR", "W", "T", "BR", "S", "SR", "ER", "Dr"], "C": ["Co", "D", "G", "O", "CD", "JC", "Ch", "BC", "FC", "Cow", "L", "U", "CR", "A", "E", "CM", "H", "KC", "Chain", "CS", "B", "Col", "Cos", "Three", "TC", "Cl", "CE", "CV", "CC", "WC", "Craig", "GC", "V", "EC", "Con", "Y", "Config", "CNN", "Common", "N", "CT", "CF", "CP", "DC", "I", "P", "YC", "Mc", "CB", "c", "W", "MC", "Charlie", "CU", "T", "CL", "S", "Cs", "CW", "Can"], "F": ["D", "G", "O", "FG", "FC", "New", "X", "H", "L", "U", "E", "Q", "A", "FT", "Family", "Fin", "FN", "FR", "FER", "f", "B", "RF", "FP", "Fe", "FL", "DF", "Fixed", "EF", "FM", "Fif", "GF", "J", "Full", "FO", "V", "AF", "Z", "WF", "Y", "FF", "Fs", "N", "MF", "IF", "Length", "FE", "PF", "If", "CF", "Only", "K", "FIN", "I", "UF", "P", "SF", "W", " f", "T", "S", "FD", "Return"], "nF": ["cellGF", "namesFG", "nwFW", "noteF", "namesAF", "noteE", "connFO", "noteTF", "nFor", "cnFB", "pnF", "pnFW", "snThis", "namesFF", " nDF", "NE", "nWF", " nR", " nFe", "cnT", "nFW", "connFW", "ynF", "NFD", "nFO", "NT", "pnUF", "fnFrame", "dnUF", "anGF", "nFK", "dnF", "nR", "cnGF", "NF", "connF", "nwFamily", "nFB", " nH", "anFB", "cellFW", "anFK", "unT", " nFF", "pnThis", "noteN", "snDF", "nnE", "pnDF", " nE", "enWF", "noteAF", "connFG", "namesFK", "nFamily", "fnM", " nN", "unF", "snE", "anFO", "dnThis", "nD", "NR", "nanGF", "nanTF", "ynUF", "anFF", "nTF", "mnF", "mnFF", "anFW", "nnDF", "NN", " nWF", "snFF", "nFM", "nwF", "nFF", "pnFamily", "cnF", "cnH", "nFD", "NM", "nFe", "nN", "nThis", "connFK", "fnR", " nFrame", "unH", "noneF", "connFB", "connFor", " nFD", "connFilter", "ynGF", "nT", "dnDF", " nM", "nE", "noteFM", "nnWF", "snUF", "nGF", "snD", "anF", "anFG", "nanT", "nDF", "namesF", "nwFO", "nFrame", "fnE", "nanFrame", " nT", "nM", "cnUF", "nFG", "namesE", "snF", "cnFF", "connTF", "ynFW", "nanF", "noteFF", "nnF", "connGF", "anFM", "nUF", "mnFW", "fnT", "enE", "enDF", "noteFB", "nanFor", "noneFilter", " nAF", "mnFB", "nFilter", "namesFO", "nAF", "noteFor", "cnFW", "nH", "nwTF", "cnFe", "noneFO", "connFM", "ND", "connFamily", "fnF", "unFe", "cellUF", "noteFD", "nwFilter", "cellF", "noneFamily", "enF", " nD", "NFF", "pnTF", "noteGF", "nanE"], "iC": [" iCon", " iCS", "liR", "itA", "giA", "iuWC", "liWC", "iniR", " iA", "icCon", "liC", "hiC", "iCs", "iT", "icR", " iWC", "giC", "giR", "giCs", " iCh", " iCs", "aiR", "aiCon", "iuC", "hiT", "pCS", "iniCl", "iuR", "iniCS", "iniC", "iWC", "itCs", "iniCs", "uiCs", "aiC", "pC", "itC", "liCR", " iT", "hiCh", "itR", "iCS", "uiCh", " iCR", "iCh", "iCR", "aiCs", "iCl", "pR", "iA", "uiC", "uiT", "pCl", "iniI", "giCl", "iCon", "giI", "icC", "icCs", "iuCR", "iI", "hiCs", " iI", " iCl"], "iR": ["jiRow", "iM", "icR", "iniP", "iP", " iT", "irRs", " iCR", "jiRs", "piM", "piT", "siB", "iRs", "irRO", "riR", "icRow", "ciR", "riC", "liR", "phiRO", " iSR", "riM", "iRR", "phiR", "piP", "diR", "liP", "piD", "riP", "diC", "iiC", "iRow", "piC", "iniM", "irR", "iniR", "iT", "icRs", "iniC", "piR", "iiR", "iB", "iRO", "irM", "iD", "jiB", "siR", "jiR", "iSR", "siRow", "siRs", "iiD", "ciCR", "piRO", "iiT", "piRR", " iRR", " iD", "liSR", "phiRs", "iCR", "piSR", "icB", "ciC", " iP", "phiM", "diCR", "piRs", "liRR"], "M": ["D", "G", "O", "X", "H", "L", "m", "E", "Q", "A", "CM", "Mon", "B", "Mi", "MM", "FM", "J", "V", "Mo", "Y", "MF", "N", "MT", "MI", "K", "I", "RM", "P", "CB", "W", "MAT", "MC", "T", "S", "MR"], "i": ["p", "ic", "j", "k", "ib", "li", "e", "it", "t", "io", "o", "m", "ik", "id", "n", "z", "f", "phi", "Ni", "int", "ti", "ini", "il", "index", "si", "im", "mi", "r", "ai", "b", "ip", "l", "pi", "ij", "ix", "di", "I", "ig", "zi", "a", "c", "v", "ir", "ind", "ci"], "outmatlines": ["outMatline", "outxyline", "outmatvals", " outxyvals", "outmatls", "outpatline", " outmatline", " outmatls", " outxyls", "outMatlines", "outxylines", "outxyls", "outpatvals", "outMatls", "outMatvals", " outmatvals", "outxyvals", "outpatlines", "outpatls", " outxylines", " outxyline", "outmatline"]}}
{"code": " \\n  \\n  def Solve(F1,r1,F2,r2):\\n      s1=set(F1[r1-1])\\n      s2=set(F2[r2-1])\\n      sx=s1.intersection(s2)\\n      if len(sx)>1:\\n          return \"Bad magician!\"\\n      elif len(sx)==0:\\n          return \"Volunteer cheated!\"\\n      else:\\n          return sx.__iter__().next()\\n  \\n  \\n  \\n  def parse(infile):\\n      r1=int(infile.readline().strip())\\n      F1=[]\\n      for i in xrange(4):\\n          F1.append( map(int, infile.readline().split() ))\\n      r2=int(infile.readline().strip())\\n      F2=[]\\n      for i in xrange(4):\\n          F2.append( map(int, infile.readline().split() ))\\n      return F1,r1,F2,r2\\n  \\n  \\n  \\n  class GCJ_Parser( object ):\\n      def __init__(self,fname):\\n          self.infile=open(fname,'r')\\n          self.NumCases=int(self.infile.readline().strip() )\\n          self.caseNum=0\\n  \\n      def __iter__(self): return self\\n  \\n      def next(self):\\n          if self.caseNum==self.NumCases: raise StopIteration\\n          self.caseNum += 1\\n          args=parse(self.infile)\\n          return self.caseNum , args\\n  \\n  \\n  def runmain():\\n      myCases=GCJ_Parser(sys.argv[1])\\n  \\n      outname=sys.argv[1].rstrip('.in')+'.out'\\n      if os.path.isfile(outname):\\n          oldout=outname+'.old'\\n          ii=0\\n          while os.path.isfile(oldout):\\n              ii+=1\\n              oldout=outname+'.old'+str(ii)\\n          os.rename(outname,oldout)\\n          print 'Rename: %s -> %s'%(outname,oldout)   \\n   \\n      outfile=open(outname,'w')\\n  \\n      for iCase, args in myCases:\\n          answer=Solve(*args)\\n  \\n          print 'Case #'+str(iCase)+':',answer\\n          print >> outfile, 'Case #'+str(iCase)+':',answer\\n  \\n  \\n  \\n  \\n  if __name__=='__main__':\\n      runmain()\\n", "substitutes": {"F1": ["M1", "M41", "Fact001", "R2", " F001", "Fact0", "F0", "Formone", " F71", " F101", "Form71", "Fone", "Family001", " F21", "V1", "VOne", "F101", "Form1", " F4", "R0", "F4", "R4", "Familyone", "M101", "F41", "R001", "FOne", "F71", "Family71", "Form001", "Fact1", "V4", "MOne", " F0", "V2", " FOne", " Fone", "ROne", "R1", "M2", "Family1", "R101", "F001", "M0", "R21", "R41", "F21", "Fact21", " F41"], "r1": ["R2", "sr101", "c0", "r81", " r101", "r0", " rau", "Rau", "c2", "rau", "m1", "R81", "sr7", " r12", " r0", "c1", "row81", "sr1", "c12", "R0", "r001", "row001", "r12", " r7", "R12", "R001", "row1", "mau", "R7", "R1", "m2", "row2", "R101", " r001", "r101", "r7", "sr2", " r81"], "F2": ["R02", "VB", "R2", "L42", "S4", "V02", " F5", "R42", " FB", "FB", "f1", "F5", "f2", "S1", "V1", " F42", "V22", " F4", " F22", "F4", "R4", "RB", "f4", "F22", "V4", " F02", "R22", "F42", "V2", "R1", "L1", "F02", "L4", "f5", "L2", "S2", "R5", "S02"], "r2": ["tto", "R2", " r4", "cr2", " rtwo", "fl", "t1", "R3", "rtwo", "f1", "f2", "rl", "r6", "r4", "R6", "R4", "t3", "Rtwo", "f4", "f6", "r22", "stwo", "rto", "cr6", " r22", "s22", "crto", "Rto", "R22", "crl", " rto", " r3", " r6", "R1", "t2", " rl", "r3", "fto"], "s1": ["S3", " s3", "s3", " sone", "f1", " s0", "f2", "s0", "S1", "f0", "S0", "Sone", "f3", "Sx", "fone", "fx", "S2", "sone"], "s2": ["S3", " s3", "s3", "rb", " sto", "S1", " s6", "sts3", "Sb", "sto", " sb", "rto", "S6", "s6", "sts2", "Sto", "sts1", "sts6", "S2", "sb"], "sx": ["dsX", "dsxs", "sX", "nsxes", " sxes", " sxy", "rsxy", "Srx", "psx", "nsxs", "nsx", "Sxs", "rsx", "nsX", " sX", "sxs", "Sx", "SX", "sxy", "Sxes", "sxes", "psX", "dsx", "rsxs", "rs2", "srx", "dsrx", "psxes", "Sxy", " sxs", "S2", "psxs"], "infile": ["outFile", " inFile", " inname", "INname", "cinFile", "innfiles", " informat", "cinline", "outbuffer", "inport", "INfile", "outpath", "formline", "inputplay", " inport", "formfile", "inifile", "readFile", "iniFile", "INFile", "readformat", "formserver", " inile", "inbuffer", "cinformat", "cinport", "formbuffer", "inplay", "inFile", "inserver", " inplay", "inline", "inputfile", " inline", "cinfiles", "readbuffer", "INline", "outformat", "cinfile", "innfile", "readframe", "dinname", "inpath", "dinpath", "inname", " infiles", "readfile", "pinresource", "dinformat", "inresource", "inframe", "infiles", "outfiles", " inpath", "pinfile", "inile", "innport", "outserver", "outplay", "inputile", "readserver", "readline", "pinline", "outresource", "cinresource", "dinfile", "outline", "outile", "pinfiles", "iniframe", "iniline", "informat", " inframe"], "i": ["gi", "j", "ic", "p", "li", "e", "it", "iy", "o", "m", "f", "il", "ti", "ini", "xi", "im", "y", "ai", "ip", "l", "x", "pi", "ij", "ix", "di", "I", "zi", "c", "v", "ir", "ci"], "self": ["app", "se", "tmp", "p", "t", "h", "old", "about", "results", "req", "wrapper", "null", "ls", "close", "w", "full", "q", "local", "eth", "user", "help", "_", "r", "unknown", "html", "instance", "attr", "http", "body", "review", "mp", "debug", "diff", "mem", "details", "handle", "private", "ass", "sub", "cmp", "disk", "s", "final", "github", "raw", "parent", "dd", "np", "rel", "pkg", "lex", "th", "false", "resp", "hw", "also", "xml", "series", "response", "small", "nd", "__", "this", "err", "your", "public", "responsible", "n", "asm", "info", "my", "sw", "x", "pp", "add", "make", "new", "test", "res", "next", "ref", "compl", "all", "ren", "dev", "subject", "ws", "book", "result", "init", "view", "me", "cl", "val", "nt", "obj", "md", "object", "ind", "py", "Self"], "fname": ["ffilename", "filename", "filefilename", "outfilename", "filefile", "fpath", "fileword", "rword", "fword", "wfile", "rname", "rfile", "outpath", "outword", "wpath", "wname", "wfilename", "filepath", "ffile", "rpath"], "NumCases": ["NumEncats", "numClomes", "numCluses", "NumLuses", "NumChats", "numCases", "NumClase", "numClase", "numCase", "NumCluses", "NumCase", "NumClats", "NumLases", "NumChase", "NumClases", "NumComes", "numClases", "NumChases", "numClats", "numCats", "NumEncases", "numCuses", "NumClomes", "NumLase", "NumCats", "NumEncase", "NumLomes", "NumCuses", "numComes"], "caseNum": [" caseNumber", "testSup", "caseOff", "Casenum", "testNo", "aseNo", "caseSup", "cycleNo", "testNum", "CaseNumber", "caseNo", "asenum", "CaseName", " casenum", "casenum", "CaseSup", "CaseNum", "cycleNum", " caseNUM", "CaseOff", "cycleName", " caseOff", "caseNumber", "CaseNo", "CaseNUM", "aseOff", "testnum", "testName", "caseNUM", "cycleSup", "caseName", " caseNo", "testNumber", "aseNum", "aseNUM"], "args": ["res", "values", "ns", "ants", "ams", "xs", "Args", "aws", "cmd", "ais", "err", "settings", "rs", "atts", "ms", "obs", "ys", "results", "s", "files", "params", "ds", "arg", "ars", "arr", "w", "cs", "names", "axis", "config", "parts", "actions", "ras", "ins", "fields", "flags", "bits", "x", "qs", "options", "points", "aux", "vals", "obj", "uments", "many", "terms", "ags", "sys", "rows", "fs", "lines", "ts", "eps", "tests", "gs"], "myCases": [" myCats", " myCalls", "myCats", " myCsase", "myScalls", " myClases", "myScase", "myClases", "mySases", "myClalls", " myCsases", "mySams", "myCsases", " myCams", "myCaps", " myCaps", " myCase", "mySase", " myClalls", " myCsats", "myCalls", "myCsase", "myCsats", "myCsams", "myScases", "myCams", "myScaps", "myClams", " myCsams", "mySalls", "myCase", " myClase", "myClats", "myClaps", "myClase", "mySats", "mySaps", " myClaps"], "outname": ["outcap", "shortout", "Outfile", "outputmem", "offmem", "outName", "outtime", "inbase", " outbase", "inname", "Outname", " outmem", "inout", " outName", "newName", "Outcap", "outno", "offName", "writeName", "offno", "outputtime", "offtime", "inName", "writecap", "offfile", "newname", "OutName", "outputname", "outnames", "oldname", "outbase", "shortName", "offnames", "newbase", "oldmem", "writename", "inmem", "oldName", " outtime", "outmem", " outcap", "shortfile", "oldfile", "outout", "outputno", "newfile", "offname", " outout", " outnames", "shortname", "writefile", " outno", "Outnames"], "oldout": [" oldold", "backout", "OLDin", "backname", "OLDout", " oldOut", " oldfile", "outnet", "oldnew", "OLDfile", " oldoutput", "OLDresult", "OLDOut", " oldnet", "olderout", "oldernet", "oldnet", "oldoutput", "OLDname", "oldername", "olderresult", "oldresult", " oldresult", "olderfile", "oldname", " oldname", "olderOut", "backin", "outoutput", "oldfile", "oldold", "outout", "oldin", "backold", "OLDold", " oldnew", "OLDoutput", "OLDnew", " oldin", "oldernew", "oldOut", "OLDnet"], "ii": ["ami", "li", "initialized", "io", " ni", "aii", "iw", "eye", "irm", "qq", "iri", "isa", "ios", "ui", "sci", "ei", "qi", "ti", "ini", "si", "xi", "mi", "inx", "ai", "nb", "iii", "iona", "mini", "zie", "chi", "pi", "ni", "tif", "II", "ix", "ice", "di", "illi", "hai", "ie", "innie", "dim", "iom", "say", "ci", "iso"], "outfile": ["Outline", "OutFile", " outFile", "Outfile", "outputline", "Outname", "outFile", "outputname", "outline", "outputFile", " outline", "outputfile"], "iCase": ["siCase", "inCl", "incase", "siase", "inase", " iase", " icase", "sicase", "iCl", " iCl", "icase", "iase", "inCase", "siCl"], "answer": ["urn", "swers", "adder", "fill", "su", "err", "mask", "turn", "ox", "fix", "reply", "record", "rent", "rez", "result", "entry", "wer", "echo", "answered", "Answer", "equ", "ver", "mate", "ry", "accept", "response", "say", "interpret"]}}
{"code": "f = open('input.in')\\n  g = open('output', 'w')\\n  \\n  T = int(f.readline()[:-1])\\n  \\n  for case in xrange(T) :\\n      R, C, M = map(int, f.readline()[:-1].split())\\n      FREE = R*C - M\\n      if FREE == 0 : res = '\\nImpossible'\\n      elif FREE != 1 and M > 0 and (R == 2 or C == 2) and (FREE == 2 or FREE % 2 == 1) : res = '\\nImpossible'\\n      elif R > 2 and C > 2 and FREE in (2, 3, 5, 7) : res = '\\nImpossible'\\n      else :\\n          MAP = [['.' for c in range(C)] for r in range(R)]\\n          MAP[0][0] = 'c'\\n          if R == 1 :\\n              for i in range(C-1, C-M-1, -1) : MAP[0][i] = '*'\\n          elif C == 1 :\\n              for i in range(R-1, R-M-1, -1) : MAP[i][0] = '*'\\n          elif R == 2 :\\n              for i in range(C-1, C-M/2-1, -1) : MAP[0][i], MAP[1][i] = '*', '*'\\n              if FREE == 1 : MAP[1][0] = '*'\\n          elif C == 2 :\\n              for i in range(R-1, R-M/2-1, -1) : MAP[i][0], MAP[i][1] = '*', '*'\\n              if FREE == 1 : MAP[0][1] = '*'\\n          else :\\n              com = M / C\\n              for i in range(R-1, max(R-com-1, 2), -1) :\\n                  MAP[i] = ['*' for j in range(C)]\\n                  M -= C\\n              I = max([i for i, j in enumerate(MAP) if j[0] == '.'])\\n              if I == 2 :\\n                  com = M / 3\\n                  if com == 0 : i = C\\n                  for i in range(C-1, C-com-1, -1) :\\n                      MAP[0][i], MAP[1][i], MAP[2][i] = '*', '*', '*'\\n                      M -= 3\\n                  if M >= 1 : MAP[2][i-1] = '*'\\n                  if M >= 2 :\\n                      if i != 1 : MAP[2][i-2] = '*'\\n                      else : MAP[1][0] = '*'\\n              else :\\n                  for i in range(C-1, C-M-1, -1) : MAP[I][i] = '*'\\n                  if i == 1 :\\n                      MAP[I][i] = '.'\\n                      MAP[I-1][C-1] = '*'\\n          res = '\\n' + '\\n'.join([''.join(i) for i in MAP])\\n      output = 'Case #' + str(case + 1) + ': ' + str(res)\\n      g.write(output + '\\n')\\n      print output\\n  \\n  f.close()\\n  g.close()\\n", "substitutes": {"f": ["ft", "fd", "p", "bf", "fr", "df", "e", "t", "o", "m", "fl", "sp", "h", "n", "fo", "fg", "w", "lf", "sf", "q", "tf", "F", "fm", "b", "l", "x", "input", "fp", "file", "fc", "a", "fs", "v", "fa", "alf"], "g": ["G", "og", "k", "gl", "go", "e", "m", "h", "z", "n", "eg", "gg", "d", "gm", "gd", "gz", "ga", "gp", "gen", "gr", "gc", "v", " G", "ger", "gt", "gs"], "T": ["D", "G", "O", "TT", "TN", "X", "t", "L", "TM", "A", "Q", "TV", "TL", "TH", "B", "TC", "TS", "TA", "F", "J", "V", "Z", "Y", "N", "WT", "TR", "K", "P", "W", "VT", "S"], "case": ["trial", "race", "type", "li", "TM", "time", "U", "key", "chain", "name", "TC", "ti", " trial", " ti", " key", " time", "cor", "IX", " CI", "Case", "tri", " TM", "Ti", "ice", "tc", " IC", " Ti", "ci"], "R": ["Range", "D", "G", "O", "Right", "X", "RA", "H", "L", "U", "CR", "Q", "A", "E", "Reg", "CM", "RC", "Remote", "REM", "IR", "B", "RG", "RF", "Res", "SR", "RL", "AR", "RGB", "RES", "HR", "F", "J", "Resource", "V", "RO", "RS", "RB", "Y", "PR", "Cor", "N", "NR", "RE", "TR", "GR", "RR", "Rs", "VR", "RM", "P", "RT", "RI", "W", "CL", "BR", "S", "MR", "Re", "ER"], "C": ["D", "BC", "Cal", "U", "A", "CAR", "Cl", "IC", "CC", "F", "J", "VC", "CF", "K", "MC", "Cond", "Container", "Co", "G", "Ch", "CM", "AC", "Chain", "CS", "B", "Cons", "CE", "CI", "WC", "CON", "EC", "CO", "ERC", "CT", "CG", "CP", "GC", "CHAR", "CU", "S", "JC", "COR", "X", "RFC", "L", "CA", "Cod", "RO", "Y", "CNN", "RE", "Car", "DC", "P", "Cs", "COM", "O", "H", "CR", "E", "Q", "LC", "Craig", "SC", "V", "Con", "N", "CB", "W", "CCC", "CL"], "M": ["COM", "D", "G", "O", "VM", "AM", "MA", "H", "L", "m", "TM", "U", "E", "A", "CM", "REM", "MAN", "B", "AR", "MO", "F", "J", "IM", "V", "RO", "Man", "Men", "Manager", "Z", "Y", "N", "RE", "MT", "MI", "K", "RM", "P", "W", "DM", "MC", "MS", "S", "MR", "MP"], "FREE": ["RED", "WARN", "FR", "TIME", "VOL", "REE", "F", "MAC", "NEW", "WIN", "NO", "Free", "GRE", "MC", "NOTE", "VER", "DIS", "NULL", "NOR", "LE", "COMPLE", "TM", "EW", "REM", "MER", "SIZE", "KNOWN", "DER", "CON", "ARE", "OVER", "NR", "XXXX", "FE", " FRE", "VALUE", "OR", "CHAR", "free", "ER", "BOX", "READ", "MED", "WE", "CRE", "IRE", "RES", "FIR", "USE", "Y", "AME", "NUM", "RE", "WARNING", "NOT", "YOU", "COM", "HOW", "ICE", "VM", "MORE", "ERROR", "CR", "CBS", "ERE", "ZE", "ONE", "STAT", "VE", "V", "ANY", "N", "MI", "OUT", "MS"], "res": ["rem", "inv", "os", "rev", "report", "re", "rs", "ms", "reg", "ress", "reset", "results", "conf", "req", "rest", "ret", "sol", "chain", "Res", "pres", "rez", "result", "RES", "respons", "yes", "resolution", "RE", "resp", "gr", "cons", "out", "terms", "response", "details"], "MAP": ["AMP", "UP", "WARN", "MA", "SET", "MN", "MODE", "HTML", "FORM", "LOAD", "PUT", "SPEC", "MAC", "APP", "NEW", "LOCK", "VIEW", "MIT", "SP", "Maps", "JP", "TO", "MC", "SO", "NOTE", "NA", "TM", "CN", "IP", "MAN", "SIZE", "WHAT", "BY", "CON", "KEY", "HE", "DIR", "RESULTS", "Map", "VALUE", "PRES", "AP", "FIL", "WE", "DATA", "MG", "TON", "MAX", "TH", "TABLE", "TC", "MEN", "MX", "RES", "LOC", "NUM", "RE", "BP", "DC", "map", "MAT", "MP", "COM", "IT", "MAS", "WA", "ALE", "BM", "OU", "VE", "RAM", "CAP", "MI", "CLAIM"], "c": ["ic", "cp", "cm", "cut", "t", "cy", "cur", "lc", "cf", "xc", "con", "cat", "cu", "ec", "cin", "b", "unc", "l", "cr", "co", "cc", "tc"], "r": ["range", "p", "rc", "er", "re", "rec", "m", "ro", "run", "n", "ri", "ar", "pr", "rr", "cr", "co", "rar", "car", "dr", "rm", "mr", "rn", "rd", "rt", "ir"], "i": ["ki", "p", "li", "e", "t", "io", "m", "iti", "item", "q", "comp", "ai", "itime", "pi", "ii", "ati", "iter", "zi", "a", "ie", "ql", "ir", "ci", "status", "gi", "ico", "uri", "o", "key", "id", "ini", "bi", "xi", "\u0438", "on", "\u00ed", "adi", "ij", "iu", "ix", "di", "v", "ib", "it", "z", "n", "ui", "info", "il", "ti", "y", "l", "x", "oi", "ig", "ic", "ia", "iri", "phi", "ei", "int", "ili", "index", "si", "im", "mi", "init", "cli", "b", "ip"], "com": ["COM", "dom", "rem", "one", "race", "em", "obi", "tm", "COR", "re", "cp", "this", "reg", "cm", "m", "time", "cond", "common", "sim", "max", "complete", "lim", "conf", "term", "con", "Comp", "OM", "inter", "pro", "comm", "char", "om", "cu", "im", "comp", "ai", "IM", "bin", "me", "cor", "cl", "co", "cum", "min", "ch", "comb", "cre", "mp", "mom", "Com", "cons", "ex", "rom", "tc", "sum", "mod", "cal", "computer", "ci", "num"], "j": ["ji", "br", "p", "jj", "k", "jl", "li", "it", "jp", "o", "m", "z", "n", "ja", "jac", "char", "bi", " J", "uj", "q", "J", "kj", "b", "dj", "l", "jit", "oj", "x", "ni", "ij", "job", "jc", "ch", "obj", "js", "jas", "v", "je", "aj"], "I": ["Si", "Is", "D", "G", "O", "TI", "SI", "IT", "HI", "III", "AI", "L", "U", "IO", "E", "PI", "It", "B", "IC", "You", "CI", "VI", "F", "J", "IM", "Y", "N", "DI", "Ti", "II", "MI", "Xi", "Im", "P", "RI", "IJ", "NI"]}}
{"code": "f = open('input.in')\\n  g = open('output', 'w')\\n  \\n  T = int(f.readline()[:-1])\\n  \\n  for case in xrange(T) :\\n      a1 = int(f.readline()[:-1])\\n      M1 = [map(int, f.readline()[:-1].split()) for i in range(4)]\\n      a2 = int(f.readline()[:-1])\\n      M2 = [map(int, f.readline()[:-1].split()) for i in range(4)]\\n      r1 = M1[a1-1]\\n      r2 = M2[a2-1]\\n      res = set(r1).intersection(set(r2))\\n      if len(res) == 1 : res = res.pop()\\n      elif len(res) == 0 : res = 'Volunteer cheated!'\\n      else : res = 'Bad magician!'\\n      output = 'Case #' + str(case + 1) + ': ' + str(res)\\n      g.write(output + '\\n')\\n      print output\\n  \\n  f.close()\\n  g.close()\\n", "substitutes": {"f": ["ft", "fd", "p", "bf", "ic", "fx", "form", "fr", "df", "e", "t", "o", "io", "fl", "h", "ct", "cf", "conf", "fo", "uf", "af", "fg", "info", "fb", "w", "lf", "tf", "u", "be", "sf", "q", "F", "r", "fm", "b", "l", "inf", "pi", "fed", "input", "fast", "hl", "ma", "fp", "file", "fc", "a", "fs", "c", "v", "fi", "fa", "alf"], "g": ["gi", "G", "og", "j", "p", "gy", "go", "e", "gb", "reg", "t", "o", "m", "mg", "z", "gio", "group", "eg", "gg", "w", "d", "gm", "u", "gd", "y", "r", "b", "ga", "gz", "l", "gu", "tg", "gp", "pg", "gate", "vg", "gen", "msg", "gr", "out", "ig", "ge", "c", "gc", "v", "gs"], "T": ["D", "G", "TT", "TN", "X", "t", "H", "L", "TM", "A", "Q", "E", "Tab", "R", "B", "TC", "TS", "TA", "F", "J", "V", "M", "Z", "Y", "NT", "N", "TR", "C", "K", "I", "P", "W", "S"], "case": ["trial", "switch", "race", "li", "ite", "t", "time", "client", "seat", "pe", "ace", "option", "example", "chain", "cation", "condition", "line", "set", "catch", "mode", "cor", "rial", "bite", "Case", "sequence", "to", "C", "connection", "cases", "ice", "ASE", "ase", "I", "ce", "ion", "tc", "context", "test", "choice", "cas", "ci", "num"], "a1": ["era1", "A0", "a7", "aed", "A001", " a001", "la001", "a51", "a91", "r91", "a001", "area1", "A7", "r51", " a7", "red", "a0", "era91", "eraed", "era51", "la7", "area51", "la0", "A1", "area91", "areaed", " a0", "la1"], "M1": [" MOne", "MR2", " MA", "R2", " M30", "MA", "RA", "M30", "m1", "MR1", "m30", "mOne", "MOne", "R30", "MRA", "R1", "ROne", "m2"], "i": ["gi", "ki", "ji", "j", "ic", "li", "it", "io", "m", "iti", "iri", "ri", "phi", "ei", "ti", "ini", "si", "xi", "im", "cli", "ai", "ip", "x", "pi", "ii", "ij", "di", "zi", "I", "fi", "ir", "ci"], "a2": ["A0", "a7", "a256", "ma0", "A2", "ma7", " a3", "a3", " a02", "ma02", "oa02", "ma2", "oa256", " a7", "a0", "ma1", "oa2", "a02", "ma256", "oa7", "A3", "ma3", "A1", " a0", " a256"], "M2": ["MR2", "R2", "T4", "MR5", "T1", "MR1", "V1", "T5", "T2", "Rl", "M4", " Ml", "R4", "MRl", "V4", "V5", " M5", "V2", "R1", "Ml", "M5", "R5"], "r1": ["rsOne", "R2", "m7", "m1", "ar1", "r001", "rs1", "rOne", " r7", "rs001", "R001", " rOne", "mOne", "ar2", "rs2", "R7", "ROne", "R1", "m2", "arOne", "r7", "ar001"], "r2": ["R02", "R2", "malt", "m1", "r02", "m02", " r02", "Ralt", "a02", "ralt", "R1", "m2", " ralt"], "res": ["reason", "rem", "inv", "str", "rev", "re", "err", "rs", "reg", "part", "rend", "cond", "ress", "resource", "ro", "reset", "results", "success", "key", "req", "ne", "none", "rest", "zero", "rek", "ret", "sol", "pro", "Res", "tx", "pres", "rez", "result", "full", "RES", "conn", "r", "resh", "respons", "expr", "val", "red", "rep", "rel", "fresh", "resolution", "RE", "resources", "net", "gre", "ber", "ch", "hash", "new", "msg", "gr", "out", "cons", "resp", "mem", "rm", "conv", "response", "des"], "output": ["next", "detail", "console", "str", "report", "sole", "o", "column", "command", "display", "resource", "ne", "style", "name", "section", "result", "activation", "pot", "line", "PUT", "ut", "module", "monitor", "write", "unit", "log", "auto", "network", "hidden", "put", "net", "job", "four", "input", "quiet", "string", "format", "new", "pattern", "position", "print", "debug", "out", "file", "data", "plot", "response", "text", "Output", "virtual"]}}
{"code": " \\n  \\n  '''\\n  ...\\n  ...\\n  ...\\n  ...\\n  ...\\n  '''\\n  \\n  for i in range(int(input())):\\n  \\n      r, c, m = tuple(map(int, str.split(input())))\\n      count = r * c - m\\n      field = dict(map(lambda c: (c, \"*\"), itertools.product(range(c), range(r))))\\n      answer = \"Impossible\"\\n  \\n      if m == 0:\\n  \\n          answer = field\\n  \\n      elif 1 in (r, c):\\n  \\n          for p in itertools.islice(itertools.product(range(c), range(r)), count):\\n  \\n              field[p] = \".\"\\n  \\n          answer = field\\n  \\n      elif count in (0, 2, 3, 5, 7):\\n  \\n          pass\\n  \\n      elif count == 1:\\n  \\n          answer = field\\n  \\n      elif count // 2 < c or count == c * 2 + 1:\\n  \\n          if count % 2 != 0:\\n  \\n              tail = 3\\n              ncount = count - 3\\n  \\n          else:\\n  \\n              tail = 0\\n              ncount = count\\n  \\n          for x in range(ncount // 2):\\n  \\n              field[(x, 0)] = field[(x, 1)] = \".\"\\n  \\n          for x in range(tail):\\n  \\n              field[(x, 2)] = \".\"\\n  \\n          answer = field\\n  \\n      elif not (c == 2 and count % c == 1):\\n  \\n          for x in range(c):\\n  \\n              field[(x, 0)] = field[(x, 1)] = \".\"\\n  \\n          count -= 2 * c\\n          tail = 0\\n          if count % c == 1:\\n  \\n              tail = 2\\n              count -= 1\\n  \\n          y = 2\\n          while count > 0:\\n  \\n              rx = min(count, c)\\n              for x in range(rx):\\n  \\n                  field[(x, y)] = \".\"\\n  \\n              count -= rx\\n              y += 1\\n  \\n          for x in range(tail):\\n  \\n              field[(x, y)] = \".\"\\n  \\n          answer = field\\n  \\n      field[(0, 0)] = \"c\"\\n      print(str.format(\"Case #{}:\", i + 1))\\n      if isinstance(answer, dict):\\n  \\n          for y in range(r):\\n  \\n              print(str.join(\"\", map(lambda x: field[(x, y)], range(c))))\\n  \\n      else:\\n  \\n          print(answer)\\n", "substitutes": {"i": ["gi", "ki", "j", "ic", "li", "e", "it", "t", "n", "f", "ri", "phi", "ei", "ti", "ini", "d", "si", "xi", "im", "mi", "multi", "b", "ip", "l", "pi", "ii", "ij", "di", "I", "zi", "a", "v", "ind", "ci"], "r": ["range", "res", "br", "j", "rc", "ra", "er", "re", "e", "err", "rs", "t", "nr", "ro", "run", "rb", "n", "g", "R", "f", "rl", "ar", "d", "q", "u", "b", "l", "rr", "cr", "rar", "co", "sr", "mr", "a", "v", "rd", "rt", "ir"], "c": ["col", "e", "t", "cur", "h", "bc", "code", "con", "cos", "pc", "w", "d", "cb", "q", "_", "cache", "cd", "fc", "ce", "a", "gc", "ci", "cp", "o", "oc", "lc", "ct", "cf", "nc", "s", "chain", "cu", "u", "sc", "vc", "cin", "cc", "mc", "ch", "C", "v", "rc", "z", "n", "g", "f", "anc", "ec", "ac", "l", "co", "dc", "j", "ic", "k", "cm", "xc", "can", "cs", "b", "\u00e7", "cl", "unc", "cr", "tc", "com"], "m": ["j", "k", "dm", "tm", "e", "ms", "cm", "t", "mm", "h", "z", "n", "g", "s", "pm", "f", "perm", "um", "d", "gm", "q", "mi", "man", "b", "M", "l", "mc", "min", "mut", "rm", "mr", "a", "mate", "v", "mod", "num"], "count": ["check", "col", "force", "e", "t", "long", "max", "code", "term", "Count", "name", "d", "q", "cache", "const", "hold", "ctr", "amount", "call", "cd", "length", "a", "gc", "cell", "status", "num", "match", "report", "cp", "cmp", "ct", "key", "cf", "conf", "id", "any", "nb", "ount", "number", "cc", "cum", "read", "child", "ch", "C", "v", "reason", "total", "err", "time", "cond", "z", "n", "g", "f", "um", "current", "found", "l", "co", "find", "len", "add", "more", "lag", "now", "sum", "test", "comment", "size", "case", "act", "type", "cmd", "flag", "cm", "all", "result", "only", "index", "counter", "cs", "country", "core", "b", "scroll", "cont", "cr", "cycle", "nt", "bool", "ind", "message", "list"], "field": ["function", "tmp", "label", "detail", "force", "command", "domain", "error", "fix", "window", "term", "node", "option", "here", "null", "rule", "spec", "name", "user", "line", "cache", "local", "row", "simple", "position", "date", "description", "inner", "match", "word", "service", "operator", "prefix", "part", "util", "Field", "manager", "lc", "key", "record", "control", "general", "config", "player", "ment", "fields", "number", "target", "child", "attribute", "filter", "FIELD", "tag", "form", "update", "load", "master", "time", "display", "group", "f", "lib", "question", "join", "point", "dict", "table", "query", "ld", "document", "format", "phrase", "map", "file", "data", "queue", "play", "test", "comment", "range", "post", "bit", "storage", "flag", "relation", "section", "condition", "result", "index", "wire", "entry", "db", "view", "pad", "buffer", "value", "order", "input", "string", "lock", "message", "list"], "answer": ["urn", "bridge", "rage", "form", "report", "exit", "err", "expression", "e", "issue", "energy", "request", "enge", "error", "aq", "reply", "about", "address", "term", "ace", "record", "option", "ve", "eni", "image", "name", "see", "result", "question", "vote", "uno", "archive", "cache", " Answer", "onse", "entry", "write", "wer", "row", "value", "interpret", "answered", "ae", "install", "query", "remember", "order", "Answer", "consider", "after", "equ", "output", "version", "come", "review", "offer", "format", "environment", "out", "response", "description", "test", "comment", "say", "message", "status", "ee"], "p": ["ap", "post", "pat", "j", "k", "op", "cp", "part", "ps", "jp", "t", "o", "sp", "pan", "key", "pe", "n", "f", "pc", "page", "d", "pr", "q", "pn", "pl", "ip", "point", "np", "pid", "pi", "pa", "pp", "pkg", "pg", "fp", "P", "par", "v", "pos", "pt", "pair"], "tail": ["detail", "col", "foot", "t", "term", "ret", "nil", "then", "port", "vt", "body", "tree", "thread", "iter", "length", "tailed", "addy", "source", "lead", "ail", "run", "chain", "loop", "left", "rot", "write", "slice", "level", "root", "end", "it", "zero", "rest", "grow", "vote", "state", "limit", "l", "timeout", "table", "gate", "len", "termin", "gt", "test", "size", "temp", "next", "tt", "type", "exit", "stop", "lo", "tails", "rl", "last", "condition", "margin", "index", "mi", "wire", "scroll", "unit", "wind", "buffer", "cycle", "bis", "tie", "mint", "offset", "ta", "tc", "lock", "list"], "ncount": ["ncond", "nnc", "rc", "nconst", "nmatch", "Nmatch", " nCount", "nnCount", "lcount", "nc", "Ncount", "rcond", "Ncond", "nCount", "llength", "rcount", "nnconst", "rmatch", "ncurrent", " ncond", "rlength", " nmatch", " nc", " nlength", "NCount", " ncurrent", "lmatch", "rcurrent", " nconst", "lcurrent", "nlength", "nncount", "Nc", "Nconst"], "x": ["ux", "j", "xs", "edit", "bit", "check", "e", "ctx", "X", "xes", "xxxx", "wx", "dx", "xp", "time", "t", "ax", "h", "ox", "key", "z", "n", "xc", "id", "xa", " xx", "tx", "xt", "name", "exp", "mx", "w", "index", "item", "xi", "q", "_", "sw", "inx", "xf", "on", "el", "l", "yx", "read", "xe", "lex", "batch", "step", "ix", "xy", "ex", "px", "nex", "xx", "v", "xml", "lat", "es", "test", "fx", "ach", "zx"], "y": ["vy", "yt", "j", "ic", "gy", "col", "e", "iy", "cy", "t", "o", "iny", "no", "ies", "yy", "h", "yr", "key", "ys", "z", "n", "yu", "hot", "ym", "ny", "ey", "uy", "w", "oy", "size", "q", "my", "yn", "b", "row", "sy", "l", "ay", "fy", "ty", "Y", "ly", "ot", "ye", "ch", "yer", "yl", "xy", "out", "ya", "by", "yd", "dy", "wy", "ry", "v", "ach", "yi", "py"], "rx": ["res", "ux", "xs", "rc", "fx", "rue", "re", "err", "rax", "wx", "lr", "dx", "xp", "nr", "ax", "ox", "rid", "max", "eq", "rl", "tx", "rez", "mx", "cross", "row", "rr", "yx", "cr", "lex", "box", "ix", "new", "dr", "xy", "cd", "vr", "mr", "ex", "wy", "ry", "xx", "rd", "rt", "rw", "rex"]}}
{"code": "def read_case():\\n  \\n      answer = int(input())\\n      lines = tuple(map(lambda _: set(str.split(input())), range(4)))\\n      return lines[answer - 1]\\n  \\n  \\n  for i in range(int(input())):\\n  \\n      intersection = read_case() & read_case()\\n      count = len(intersection)\\n      if count == 1:\\n  \\n          answer = intersection.pop()\\n  \\n      elif count > 1:\\n  \\n          answer = \"Bad magician!\"\\n  \\n      elif count < 1:\\n  \\n          answer = \"Volunteer cheated!\"\\n  \\n      print(str.format(\"Case #{}: {}\", i + 1, answer))\\n", "substitutes": {"answer": ["cho", "e", "area", "energy", "about", "option", "name", "see", "q", "line", "euro", "imony", "blank", "answered", "review", "position", "ira", "length", "average", "description", "status", "open", "record", "vert", "ask", "ine", " unanswered", "number", "consider", "ell", "come", "offer", "ver", "v", "accept", "response", "form", "issue", "time", "n", "ve", "example", "question", "vote", "be", "echo", "don", "query", "remember", "format", "know", "comment", "size", "interpret", "case", "ee", "bridge", "next", "fill", "type", "turn", "aq", "eni", "do", "section", "result", "again", "entry", "wer", "value", "order", "replace", "Answer", "version", "string", "place", "said", "say", "message"], "lines": ["values", "args", "lists", "years", "rings", "strings", "results", "words", "files", "blocks", "headers", "keys", "ls", "ds", "letters", "els", "sets", "line", "names", "parts", "elines", "cells", "l", "fields", "nl", "codes", "sections", "qs", "items", "members", "points", "phones", "vs", "vals", "nets", "ines", "inline", "links", " Lines", "posts"], "i": ["gi", "j", "ic", "p", "li", "e", "it", "t", "m", "key", "n", "s", "f", "ei", "ti", "ini", "bi", "index", "d", "xi", "im", "q", "mi", "multi", "y", "b", "l", "x", "pi", "ii", "oi", "di", "zi", "I", "a", "c", "v", "yi", "ind", "ci"], "intersection": ["overlap", "Intersection", "Intersect", "teraction", "INTERj", "interaction", "Interlap", "consections", "oversections", "interj", "intersections", "tersection", "tersections", "Intersections", "oversection", "INTERsect", "INTERlap", "consection", "INTERaction", "oversect", "conj", "intersect", "Interaction", "consect", "interlap", "tersect", "Interj", "INTERsections", "INTERsection"], "count": ["duration", "race", "act", "check", "force", "report", "command", "area", "cond", "depth", "ct", "cf", "conf", "nc", "Count", "frequency", "close", "counter", "cs", "country", "multi", "repeat", "nb", "const", "ount", "found", "cont", "ctr", "hold", "corruption", "l", "double", "amount", "call", "cc", "cycle", "nt", "find", "len", "cloud", "second", "cd", "length", "lag", "c", "sum", "cell", "ind", "size", "every"]}}
{"code": " \\n  class Solver(object):\\n      def __init__(self):\\n          pass\\n      \\n      def solve(self, inputs):\\n          R, C, M = [int(x) for x in inputs[0].split()]\\n          mp = []\\n          for r in range(R):\\n              mp.append(['.']*C)\\n          mp[0][0] = 'c'\\n          outputs = []\\n          if M == 0:\\n              for row in mp:\\n                  outputs.append(''.join(row))\\n              return outputs\\n          rr, cc, rm = R, C, M\\n          while rm >= min(rr, cc):\\n              if rr <= cc:\\n                  for r in range(rr):\\n                      mp[r][cc-1] = '*'\\n                  cc -= 1\\n                  rm -= rr\\n              else:\\n                  for c in range(cc):\\n                      mp[rr-1][c] = '*'\\n                  rr -= 1\\n                  rm -= cc\\n          \\n          if rm == 0:\\n              if (min(rr, cc), max(rr, cc)) == (1, 2) and min(R, C) != 1:\\n                  return ['Impossible']\\n          else:\\n              if min(rr, cc) - rm >= 2:\\n                  if rr <= cc:\\n                      for r in range(rr-rm, rr):\\n                          mp[r][cc-1] = '*'\\n                  else:\\n                      for c in range(cc-rm, cc):\\n                          mp[rr-1][c] = '*'\\n              else:\\n                  if min(rr, cc) >= 4:\\n                      if rr <= cc:\\n                          for r in range(2, rr):\\n                              mp[r][cc-1] = '*'\\n                          mp[rr-1][cc-2] = '*'\\n                      else:\\n                          for c in range(2, cc):\\n                              mp[rr-1][c] = '*'\\n                          mp[rr-2][cc-1]='*'\\n                  elif min(rr,cc) == 3:\\n                      if max(rr, cc) == 3:\\n                          return ['Impossible']\\n                      else:\\n                          if rr <= cc:\\n                              mp[2][cc-1] = '*'\\n                              mp[2][cc-2] = '*'\\n                          else:\\n                              mp[rr-1][2] = '*'\\n                              mp[rr-2][2] = '*'\\n                  else:\\n                      return ['Impossible']\\n                      \\n          for row in mp:\\n              outputs.append(''.join(row))\\n          return outputs\\n          pass\\n      \\n      def feed(self, inputs):\\n          lines = [x.strip() for x in inputs]\\n          outputs = []\\n          test_case_n = int(lines[0])\\n          cur = 1\\n          for i in range(test_case_n):\\n              i = i\\n              case_line_cnt = 1\\n              case_inputs = lines[cur:cur+case_line_cnt]\\n              cur += case_line_cnt\\n              R, C, M = [int(x) for x in case_inputs[0].split()]\\n              rslt = self.solve(case_inputs)\\n              if self.verify(rslt, R, C, M):\\n                  outputs.append(rslt)\\n              else:\\n                  raise 'Failed'\\n          return outputs\\n      \\n      def verify(self, outputs, RR, CC, MCNT):\\n          if 'Impossible' == outputs[0]:\\n              return True\\n          rr = len(outputs)\\n          cc = len(outputs[0])\\n          if RR != rr or CC != cc:\\n              return False\\n          bd = []\\n          mask = []\\n          for i in range(rr):\\n              mask.append([1]*cc)\\n              bd.append([0]*cc)\\n              for j in range(cc):\\n                  if outputs[i][j] == '*':\\n                      bd[i][j] = 9\\n                  elif outputs[i][j] == 'c':\\n                      start = (i, j)\\n          for r in range(rr):\\n              for c in range(cc):\\n                  if bd[r][c] == 9:\\n                      for i in [r-1,r,r+1]:\\n                          for j in [c-1,c,c+1]:\\n                              if 0 <= i < rr and 0 <= j < cc:\\n                                  if bd[i][j] != 9:\\n                                      bd[i][j] += 1\\n  \\n          nlist = [start]\\n          while len(nlist):\\n              i, j = nlist.pop(0)\\n              if mask[i][j] != 0:\\n                  mask[i][j] = 0\\n                  if bd[i][j] == 9:\\n                      raise '!!! BOMB'\\n                  elif bd[i][j] == 0:\\n                      for ii in [i-1,i,i+1]:\\n                          for jj in [j-1,j,j+1]:\\n                              if 0<=ii<rr and 0<=jj<cc:\\n                                  if ii != i or jj != j:\\n                                      nlist.append((ii,jj))\\n          mcnt = 0\\n          for r in range(rr):\\n              for c in range(cc):\\n                  if mask[r][c] == 1:\\n                      mcnt += 1\\n                  if mask[r][c] == 1 and bd[r][c] != 9:\\n                      return False\\n                  if mask[r][c] != 1 and bd[r][c] == 9:\\n                      return False\\n          return (mcnt == MCNT)\\n                  \\n  \\n  if __name__ == '__main__':\\n      iname = 'C-small-attempt0.in'\\n      sample_in = '''\\n  7\\n  5 5 23\\n  3 1 1\\n  2 2 1\\n  4 7 3\\n  10 10 82\\n  3 4 0\\n  2 2 3\\n      '''\\n      sample_out = '''\\n  Case #1: 1.0000000\\n  Case #2: 39.1666667\\n  Case #3: 63.9680013\\n  Case #4: 526.1904762\\n      '''\\n      if os.path.exists(iname):\\n          with open(iname) as f:\\n              inputs = f.readlines()\\n      else:\\n          inputs = [x.strip() for x in sample_in.split('\\n') if x.strip()]\\n      solver = Solver()\\n      outputs = solver.feed(inputs)\\n      fail_flag = False\\n      if os.path.exists(iname):\\n          with open(iname+'.out', 'w') as f:\\n              for i, v in enumerate(outputs):\\n                  print >> f, 'Case #%d:'%(i+1)\\n                  print >> f, '\\n'.join(v)\\n      print '===================================================='\\n      for i, v in enumerate(outputs):\\n          print 'Case #%d:'%(i+1)\\n          print '\\n'.join(v)\\n      print '===================================================='\\n      print 'done' if not fail_flag else 'fail'\\n      pass\\n", "substitutes": {"self": ["python", "se", "p", "ref", "this", "cp", "rs", "private", "crit", "cmp", "s", "ren", "ls", "subject", "ws", "w", "pr", "q", "local", "my", "me", "cl", "network", "np", "you", "obj", "new", "print", "test", "object", "py", "Self"], "inputs": ["outputds", "InputS", " inputes", "inputts", "Inputs", "accepts", "Inputts", "Inputds", "inputS", "acceptS", " inputds", " inputS", "outputS", "inputds", "inputes", "acceptts", " inputts", "outputes", "Inputes"], "R": ["D", "G", "X", "RA", "H", "CR", "A", "RC", "RG", "B", "SR", "Res", "RP", "Mr", "F", "V", "RO", "RS", "Rot", "N", "NR", "RE", "TR", "GR", "Rs", "K", "I", "RM", "P", "RT", "W", "T", "S", "BR", "IR", "MR", "Dr"], "C": ["Co", "D", "G", "JC", "Ch", "COR", "X", "H", "L", "KC", "U", "CR", "A", "E", "CM", "CN", "PC", "B", "CS", "TC", "CV", "CI", "WC", "F", "V", "EC", "CNN", "N", "CO", "CT", "VC", "CP", "K", "DC", "I", "YC", "P", "CB", "RM", "CL", "CCC", "MC", "W", "T", "S", "Cs", "CW"], "M": ["D", "G", "O", "AM", "X", "H", "L", "m", "TM", "E", "Q", "CM", "NM", "B", "PM", "Mi", "MM", "F", "V", "LM", "N", "MT", "MI", "K", "I", "RM", "P", "W", "MC", "T", "MS", "S", "MR", "MP"], "x": ["ux", "hex", "xs", "xxxx", "X", "rx", "xxxxxxxx", "xes", "wx", "ctx", "dx", "xp", "ax", "ox", "key", "xc", "xa", "tx", "xt", "name", "mx", "xi", "y", "xf", "yx", "xe", "xd", "ix", "xy", "ex", "px", "xx", "fx", "case"], "mp": ["app", "tmp", "p", "rem", "jp", "mac", "m", "top", "proc", "pr", "comp", "prep", "mk", "mpeg", "omp", "vp", "mem", "rpm", "mon", "em", "cp", "cmp", "mg", "sql", "perm", "ph", "amps", "pl", "ep", "rep", "np", "mc", "pkg", "arp", "pps", "mr", "meg", "ap", "tm", "ms", "cap", "sp", "mm", "rup", "mb", "pb", "mop", "mt", "sym", "pp", "met", "map", "dp", "mph", "temp", "sv", "res", "MP", "aps", "rs", "ps", "mat", "pm", "ym", "prim", "multi", "ip", "phys", "tp", "pg", "emp", "ma", "trap", "msg", "px", "rows", "method", "mod", "meta", "py"], "r": ["res", "br", "p", "rc", "k", "er", "fr", "re", "adr", "err", "rs", "reg", "rec", "lr", "m", "h", "ro", "run", "rg", "rb", "rad", "all", "ur", "g", "f", "n", "ar", "tr", "w", "pr", "cu", "d", "kr", "b", "l", "cr", "hr", "rar", "co", "rel", "usr", "sr", "attr", "dr", "mr", "vr", "rn", "rd", "ir", "rt", "right"], "outputs": ["columns", " outputgs", "outputsb", "Outputsb", "returns", " outputsb", "putes", " output_", "putts", "puts", " outputts", "Outputgs", "Outputs", "outputts", "columnts", "putgs", "return_", "outputes", "returnsb", " outputes", "Outputts", "Output_", "columnes", "outputgs", "output_", "Outputes"], "row": ["res", "post", "rc", "word", "col", "mor", "rs", "rx", "rec", "ob", "OW", "ox", "ro", "record", "mat", "lo", "raw", "rown", "tr", "user", "line", "entry", "sw", "Row", "sur", "ow", "usr", "wo", "cro", "ows", "roll", "out", "mem", "may", "round", "rows", "ry", "cell", "rw", "mod", "our", "pair"], "rr": ["fr", "re", "JR", "rin", "lr", "rg", "req", "gg", "ar", "aa", "pc", "pr", "Mr", "mk", "rar", "sr", "attr", "iter", "vr", "rn", "rpm", "wr", "ir", "cell", "rage", "adr", "reg", "orig", "cmp", "bb", "ro", "repl", "ail", "rb", "ck", "nc", "ptr", "vc", "dd", "rol", "irt", "vv", "hr", "rel", "ell", "uu", "dr", "gr", "vd", "mr", "rh", "arr", "br", "rc", "err", "ll", "rec", "eor", "rog", "kk", "rint", "co", "pp", "rd", "res", "ra", "rer", "cmd", "rs", "rx", "nder", "nr", "addr", "rid", "ror", "rl", "cs", "kr", "cr", "ario", "elt", "ndra", "rt"], "cc": ["BC", "col", "bc", "ship", "con", "pc", "ctr", "ca", "fc", "cd", "ce", "sq", "gc", "cell", "icc", "ci", "circ", "cp", "coll", "cmp", "ct", "lc", "bb", "cf", "nc", "ck", "acc", "cci", "zz", "cu", "sc", "vc", "dd", "isc", "sec", "vv", "mc", "xx", "rc", "ib", "err", "ll", "cy", "rec", "cca", "ctl", "kk", "cn", "ec", "ac", "co", "pp", "cv", "dc", "ic", "cmd", "rs", "cm", "xc", "ucc", "erc", "cs", "uc", "ff", "cl", "unc", "cel", "cr", "cycle", "tc", "rt"], "rm": ["tmp", "rem", "fr", "col", "lr", "ort", "m", "remove", "norm", "irm", "pc", "Mr", "fm", "mk", "rar", "attr", "min", "RM", "mem", "like", "rn", "rpm", "wr", "handle", "rom", "orm", "rage", "dm", "cp", "reg", "cmp", "ct", "rb", "perm", "change", "rol", "mc", "nm", "mr", "lamm", "MR", "rc", "err", "time", "mm", "cond", "n", "cn", "co", "tri", "cv", "sm", "drm", "beta", "rd", "vm", "fn", "dim", "arm", "range", "dist", "act", "ref", "mir", "rs", "rx", "cm", "adjust", "off", "pm", "bm", "ri", "rl", "mi", "cr", "imm", "md", "km", "rt", "mod"], "c": ["dc", "cul", "p", "ic", "rc", "col", "e", "cp", "err", "cut", "rec", "cm", "t", "m", "lc", "ct", "bc", "h", "cf", "nc", "xc", "con", "g", "f", "n", "ar", "can", "pc", "cu", "arc", "sc", "u", "cs", "cache", "ec", "vc", "cin", "b", "ac", "cl", "unc", "l", "cr", "co", "mc", "ca", "fc", "ce", "gc", "tc", "ach", "ci"]}}
{"code": " \\n  class Solver(object):\\n      def __init__(self):\\n          pass\\n      \\n      def solve(self, inputs):\\n          r1 = int(inputs[0])\\n          cs1 = set([int(x) for x in inputs[r1].split()])\\n          r2 = int(inputs[5])\\n          cs2 = set([int(x) for x in inputs[5+r2].split()])\\n          r = cs1.intersection(cs2)\\n          cnt = len(r)\\n          if 1 == cnt:\\n              return max(r)\\n          elif 0 == cnt:\\n              return 'Volunteer cheated!'\\n          else:\\n              return 'Bad magician!'\\n          pass\\n      \\n      def feed(self, inputs):\\n          lines = [x.strip() for x in inputs]\\n          outputs = []\\n          test_case_n = int(lines[0])\\n          cur = 1\\n          for i in range(test_case_n):\\n              i = i\\n              case_line_cnt = 10\\n              case_inputs = lines[cur:cur+case_line_cnt]\\n              cur += case_line_cnt\\n              outputs.append(self.solve(case_inputs))\\n          return outputs\\n  \\n  if __name__ == '__main__':\\n      iname = 'A-small-attempt0.in'\\n      sample_in = '''\\n      3\\n  2\\n  1 2 3 4\\n  5 6 7 8\\n  9 10 11 12\\n  13 14 15 16\\n  3\\n  1 2 5 4\\n  3 11 6 15\\n  9 10 7 12\\n  13 14 8 16\\n  2\\n  1 2 3 4\\n  5 6 7 8\\n  9 10 11 12\\n  13 14 15 16\\n  2\\n  1 2 3 4\\n  5 6 7 8\\n  9 10 11 12\\n  13 14 15 16\\n  2\\n  1 2 3 4\\n  5 6 7 8\\n  9 10 11 12\\n  13 14 15 16\\n  3\\n  1 2 3 4\\n  5 6 7 8\\n  9 10 11 12\\n  13 14 15 16\\n      '''\\n      sample_out = '''\\n   Case #1: 7\\n  Case #2: Bad magician!\\n  Case #3: Volunteer cheated!\\n      '''\\n      if os.path.exists(iname):\\n          with open(iname) as f:\\n              inputs = f.readlines()\\n      else:\\n          inputs = [x.strip() for x in sample_in.split('\\n') if x.strip()]\\n      solver = Solver()\\n      outputs = solver.feed(inputs)\\n      fail_flag = False\\n      if os.path.exists(iname):\\n          with open(iname+'.out', 'w') as f:\\n              for i, v in enumerate(outputs):\\n                  print >> f, 'Case #%d: %s'%(i+1, str(v))\\n      else:\\n          ans = set([x.strip() for x in sample_out.split('\\n') if x.strip()])\\n          for i, v in enumerate(outputs):\\n              t = 'Case #%d: %s'%(i+1, str(v))\\n              if t not in ans:\\n                  print '!!! Wrong:', t\\n                  fail_flag = True\\n      print '===================================================='\\n      for i, v in enumerate(outputs):\\n          print 'Case #%d: %s'%(i+1, str(v))\\n      print '===================================================='\\n      print 'done' if not fail_flag else 'fail'\\n      pass\\n", "substitutes": {"self": ["python", "app", "p", "os", "ref", "console", "this", "client", "sub", "cmp", "h", "s", "ren", "github", "parent", "dev", "subject", "book", "w", "q", "local", "my", "sw", "writer", "unknown", "me", "cl", "np", "network", "rel", "instance", "pkg", "you", "obj", "th", "new", "mp", "print", "App", "conv", "also", "handle", "context", "test", "py", "Self"], "inputs": ["subjectz", "outputb", "texts", "outputses", "structes", "raws", "putes", "connectses", "inputments", "inputuments", "puteds", "inputls", "pulls", "intensions", "textls", "initials", " inputS", "inputples", "subjectes", "connectS", "outputes", "ints", " Inputples", "contextms", "initiales", "connects", "textensions", "outputples", "inputS", "contexts", "Inputments", "inputses", "outputS", "putz", "inputeds", "rawb", "interestls", "structses", "inputb", "initialls", "outputz", " Inputs", "putms", "inputps", "subjecteds", "structples", "puts", "feedes", "rawls", "Inputensions", "inputz", "intments", "inputes", "pulluments", "configls", "contextts", "interests", "configs", "intls", "putuments", "rawes", "feeds", " inputses", "Inputls", " Inputses", "inputts", "subjects", "contextes", "contextuments", "Inputs", "pullms", "rawts", "inputensions", "interestb", " Inputes", "outputls", "feedts", "outputts", "Inputz", "subjectps", "subjectls", "feedls", "structs", "Inputeds", "configes", "outputps", "textments", "inputms", "initialts", "putps"], "r1": ["p0", "ro1", "ro01", "R2", "rx", "rc2", "r0", "R51", "p1", "c1", "c03", "R0", "r03", "p2", " r01", "ro03", "r51", "cx", "r01", "c01", "rc1", "rc0", "rc51", "rox", "R1", " r03", " rx", "p51"], "cs1": ["ces1", "rs0", "ces0", "rsA", "cs3", "cs0", "csA", "cesn", "ks2", "rsn", "rs1", " csA", "cesone", " cs0", "ks1", "rsone", "rs3", "csn", "rs2", "ksA", "ks3", " csn", "csone", " cs3", " csone"], "x": ["ux", "hex", "p", "xs", "check", "str", "e", "xxxx", "xxx", "rx", "xxxxxxxx", "wx", "xes", "dx", "xp", "X", "at", "ax", "ox", "key", "z", "ross", "xc", "n", "s", "xa", "f", "tx", "xt", "ey", "name", "exp", "mx", "w", "xi", "q", "inx", "xf", "l", "yx", "ctx", "ext", "xe", "lex", "xd", "string", "ix", "xy", "px", "ex", "c", "xx", "xml", "xb", "fx", "zx"], "r2": ["mr42", "R2", "c0", "l42", "rc2", "r0", "R42", "c2", "rb", " r0", "l5", "cb", "mr5", "rcto", "r5", " rb", "l2", "r42", "rto", "rcb", "rc0", " rto", "cto", "R1", "mr2", "l1", "mr1", "R5"], "cs2": ["wcs2", "rstwo", "ckstwo", "vsn", "vs1", "s4", "rsn", "cstwo", "rs1", "vstwo", "sort", "wcsort", "stwo", " csort", "csort", "csn", " cs4", "rs2", "cks2", "s2", "wcstwo", "cks1", " cstwo", "cksn", "cs4", "vs2", "wcs4"], "r": ["res", "range", "br", "p", "rc", "er", "re", "rs", "rec", "lr", "m", "h", "nr", "ro", "n", "s", "rb", "g", "R", "ar", "ru", "d", "q", "rect", "b", "l", "rr", "cr", "rar", "sr", "mr", "c", "rd", "rt", "right", "arr"], "cnt": ["Cnt", "count", "cNT", "CNT", "Cct", "lcrt", "lcount", "cpt", "rcNT", "Ccount", " cnc", "ccount", "Cpt", "tcnc", " crt", "lcnt", "tcnt", "crt", "rcpt", " cNT", " cpt", "tcount", "lcnc", " count", "rcct", "rccount", " ccount", "rcnt", "cct", "tcrt", "cnc", " cct"], "lines": ["works", "ns", "lists", "olds", "cycles", "xs", "values", "args", "rs", "levels", "rings", "strings", "words", "files", "blocks", "ls", "eds", "reads", "line", "runs", "its", "parts", "plays", "ins", "elines", "boxes", "cells", "days", "l", "pins", "bs", "posts", "sections", "codes", "points", "vals", "ines", "cases", "frames", "ses", "rows", "steps", "links", "limits", "states", "tests", "gs"], "outputs": ["outputless", "inputts", "Outputits", "inputabs", "outputses", "putits", " outputless", "outputabs", "returns", "configses", "resultset", "results", "resultless", "putes", "inputS", "Outputabs", "outputits", "putts", "puts", " outputts", "Outputs", "outputS", "outputts", "returnS", "configset", "inputes", "outputes", "configless", " outputes", "returnts", " outputset", "Outputts", "resultses", "returnes", "configs", " outputses", "outputset", "Outputes", " outputabs", "OutputS", "returnits"], "test_case_n": ["test_line_n", "test_case_num", "test_line_name", "test_case_N", "test_line_N", "test_line_num", "test_case_name"], "cur": ["src", "tmp", "rc", "col", "cp", "cm", "lr", "orig", "ser", "lc", "ct", "nc", "g", "ur", "con", "ptr", "ph", "char", "div", "tr", "cu", "cat", "coord", "sc", "current", "multi", " Cur", "ug", "pri", "Cur", "incre", "cont", "ctr", "cor", "cr", "sur", "ld", "car", "pkg", "pg", "loc", "ch", "mut", "th", "dr", "gr", "c", "tc", "ctrl", "ci", "num"], "i": ["p", "ic", "j", "k", "count", "li", "e", "it", "at", "start", "m", "h", "z", "n", "g", "id", "f", "phi", "int", "index", "xi", "q", "y", "u", "ai", "b", "ip", "l", "pi", "ch", "I", "a", "c", "pos", "ind", "ci"], "case_line_cnt": ["case_line_lcnt", "case_line_ppt", "case_line_lcct", "case_line2cpt", "case_line_ncount", "case_line_pNT", "case_line2CNT", "case_line2Cnt", "case_line_ccount", "case_line_cpt", "case_line_Ccount", "case_line_pount", "case_line_cNT", "case_line_lcpt", "case_line_count", "case_line_Cct", "case_line_npt", "case_line_nnt", "case_line_Cnt", "case_line2cNT", "case_line_nct", "case_line2Count", "case_line_Count", "case_line2count", "case_line_cct", "case_line_pct", "case_line_pnt", "case_line_CNT", "case_line_lcNT", "case_line2cnt", "case_line_Cpt", "case_line2Cpt"], "case_inputs": ["case_outputes", "case_execests", "case_subS", "case_execls", "case_inputests", "case_inputts", "case_Inputts", "case_Inputes", "case_Inputs", "case_outputls", "case_outputs", "case_individualests", "case_inputls", "case_individualls", "case_inputports", "case_outputests", "case_subs", "case_inputS", "case_outputts", "case_individuals", "case_execports", "case_subes", "case_individualports", "case_execs", "case_inputes", "case_InputS", "case_subts", "case_outputS", "case_outputports"], "iname": ["oinename", "nename", " inname", "anename", "aname", "inname", " inAME", "INname", "INam", " inamed", "ginam", "name", "oiname", " inamer", " inam", "anamel", "anamer", "oinamed", "ginname", "inam", " inename", "ginename", "inamed", "INename", "namel", "IName", "inAME", "namer", "INamed", "giname", "inamel", " inamel", "inename", "inamer", "oinAME", "INAME"], "sample_in": [" sample_nin", "sample_file", "sample___in", " sample_IN", "sample_it", " sample_file", "sample_IN", "sample___it", " sample_it", "sample___out", "sample_nin", "sample___file"], "sample_out": ["sample_err", "Sample_in", "sample1in", "sample1err", "sample_output", "sample1out", "sample1output", "Sample_out", "Sample_err", "Sample_output"], "solver": ["psoln", "Solve", "insolar", "soln", " solution", "insolver", "psolar", " solve", "ssolve", "ssolver", "psolution", "ssolution", "solve", "insoln", " solar", "Soln", "insolution", "ssoln", "Solver", "solar", "psolver", "Solution", "solution", " soln"], "fail_flag": ["loss1", "lossx", "failedx", "raise1", "raisex", "fail1", "failx", "failed1"]}}
{"code": "'''\\n  Created on Apr 12, 2014\\n  \\n  @author: mostasem\\n  '''\\n  \\n  def getFloorRoots(m):\\n      r1 = -1 + math.sqrt(1 + (8 * m))/2\\n      r2 = -1 - math.sqrt(1 + (8 * m))/2\\n      return int(math.floor(r1))\\n      \\n  def boardHasZero(R,C,M):\\n      if(R > 1 and C > 1):\\n          S = M/C\\n          Sr = M % C\\n          print S,Sr\\n          return R >= S+3 or (R == S+2 and ((Sr % 2) == 0 or (((C + Sr) % 3 == 0) and (2*C >= (C + Sr + 4))))) or (R == S+1  and (C + Sr) % 2 == 0 and (2*C >= (C + Sr + 4)))  #M <= ((R*C) - 4)\\n      else :\\n          return M <= ((R*C) - 2)\\n  \\n  \\n  def generateMineSweeperCase(R,C,M):\\n  \\n      board = \"\"\\n  \\n      if( R > 1 and C > 1 ): # generate special\\n          S = M/C\\n          Sr = M % C\\n          print S,Sr\\n          if(S): # all rows of *\\n              board +=\"\\n\"\\n              if(R >= S+3 or (R == S+2 and Sr % 2 == 0)):\\n                  board += (S - 1) * ((C*\"*\") + \"\\n\")\\n              else:\\n                  board += (S - 2) * ((C*\"*\") + \"\\n\")\\n              board +=  ((C*\"*\"))\\n              \\n          if(R >= S+3):\\n              if(Sr):\\n                  board +=\"\\n\"\\n                  board += ((Sr *\"*\") + ((C - Sr) *\".\"))\\n              Rm = R - (S + 1)\\n              if(Rm):\\n                  board +=\"\\n\"\\n                  board += (Rm - 1) * ((C*\".\") + \"\\n\")\\n                  board +=  ((C*\".\"))\\n                  \\n          elif(R == S + 2):\\n              Sm = 0\\n              if(Sr % 2 == 0):\\n                  board +=\"\\n\"\\n                  board += (((Sr / 2) *\"*\") + ((C - (Sr / 2)) *\".\") +\"\\n\")\\n                  board += ((Sr / 2) *\"*\") + ((C - (Sr / 2)) *\".\")\\n              else:\\n                  board +=\"\\n\"\\n                  board += (((Sr / 3) *\"*\") + ((C - (Sr / 3)) *\".\") +\"\\n\")\\n                  board += ((Sr / 3) *\"*\") + ((C - (Sr / 3)) *\".\")\\n          else :\\n              Sm = Sr + C\\n              board +=\"\\n\"\\n              board += (((Sm / 2) *\"*\") + ((C - (Sm / 2)) *\".\") +\"\\n\")\\n              board += ((Sm / 2) *\"*\") + ((C - (Sm / 2)) *\".\")\\n                  \\n          list_board = list(board)\\n          list_board[len(list_board) - 1] = 'c'\\n          board = \"\".join(list_board)\\n      else:\\n          board +=\"\\n\"\\n          if(C == 1):\\n              board += M * \"*\\n\"\\n              board += (R-M-1) * \".\\n\"\\n              board +=  \"c\"\\n          else:\\n              board += M * \"*\"\\n              board += (C-M-1) * \".\"\\n              board += \"c\"\\n              \\n      return board\\n         \\n         \\n         \\n  \\n  f_r = open('C.in',\"r\")\\n  n_test=int(f_r.readline().strip()) \\n  f_w = open(\"C.out\", \"w\")\\n  result = \"\"\\n  for i in range(n_test):\\n      R,C,M = map(int,f_r.readline().split())\\n      print R,C,M\\n      if(boardHasZero(R,C,M)):\\n          result = generateMineSweeperCase(R,C,M)\\n      else :\\n          result =\"\\nImpossible\"\\n      print result\\n      output_str='Case #{itr}:{res}'.format(itr=(i+1),res=result)\\n      f_w.write(output_str+'\\n')\\n      \\n  f_r.close()\\n", "substitutes": {"m": ["p", "k", "dm", "tm", "ms", "cm", "t", "mac", "mm", "h", "mat", "n", "g", "s", "bm", "f", "om", "d", "gm", "q", "mi", "y", "i", "wm", "r", "b", "mt", "l", "x", "mc", "nm", "mut", "rm", "c", "v"], "r1": ["pair1", "pair8", "R2", "pair2", "t1", "R3", "r8", "m1", "m5", "rOne", "r5", "t3", "t5", "pairOne", "R8", " rOne", "ROne", "R1", " r8", "m2", "t2", "m3", "r3", "R5"], "r2": ["r3", " r3", "ar3", "R1", "R4", "ar2", "R2", " r4", "ar1", "r4", "ar4", "R3"], "R": ["Range", "D", "G", "O", "Role", "Right", "JR", "X", "RA", "H", "L", "U", "CR", "Q", "A", "E", "DR", "RC", "Remote", "REM", "B", "RF", "Res", "AR", "RAM", " r", "r", "F", "ALL", "V", "RO", "RS", "Result", "Z", "N", "RE", "TR", "RR", "I", "RM", "P", "RT", "W", "Return", "T", "BR", "IR", "MR", "ER"], "C": ["Co", "D", "G", "O", "CD", "BC", "Ch", "JC", "COR", "H", "Cal", "U", "L", "HC", "CR", "A", "Q", "CM", "E", "CN", "AC", "Cow", "CS", "B", "Cos", "CA", "CV", "CE", "Cl", "TC", "CC", "You", "CI", "F", "WC", "CON", "GC", "SC", "V", "CH", "Ca", "EC", "Y", "CNN", "N", "CO", "Car", "CT", "CG", "CP", "CF", "DC", "K", "I", "P", "Cache", "CB", "W", "c", "CCC", "Mc", "MC", "CU", "CL", "T", "Cs", "CW"], "M": ["D", "G", "O", "AM", "X", "H", "L", "U", "TM", "E", "A", "Q", "CM", "B", "MM", "F", "V", "RO", "Z", "Y", "N", "RE", "MT", "MI", "I", "RM", "P", "W", "MC", "T", "MS", "MR"], "S": ["Si", "G", "O", "SI", "X", "SM", "H", "L", "E", "Q", "A", "OS", "NS", "SB", "SAN", " s", "s", "Set", "SH", "CS", "B", "TS", "Sl", "SL", "F", "BS", "SC", "V", "RS", "SA", "Source", "Z", "VS", "Y", "N", "SS", "AS", "ES", "GS", "I", "P", "DS", "W", "JS", "WS", "PS", "SE", "T", "IS", "SU", "SR"], "Sr": ["src", "PsR", "Ssr", "Srs", "Lsr", "Sysr", "Jssr", " Sn", "Thenr", "Sc", "Esrc", "Jsrt", "Jsr", "SScr", "Esn", "SSnr", "SSsr", "sr", " Scr", "Pssr", "Newsri", "SSz", "Sn", "Sri", "NewR", "Newr", "Newattr", "Sysrt", "Serrs", " Srs", "GSsr", "GSr", " Sz", "Srt", "Sattr", "Ther", "Thez", "NewsR", " SR", "Newri", "SSr", "Serr", "Sdr", " Sdr", " Ssr", "Esr", "Lnr", "GSdr", "Jsrin", "Essr", "Src", "Serc", "sn", "Newsr", "Psdr", "Psrs", "Psr", "Psrt", "Newsattr", "SR", "JsR", "ssr", "Psc", "Sysrin", " Sc", "Lcr", "Sz", "Thesr", "Snr", "GSR", "Lr", "Srin", "Syssr", "Jsri", " Snr", "Jsattr", "Psrin", "Sersr", " Src", "Scr"]}}
{"code": "'''\\n  Created on Apr 11, 2014\\n  \\n  @author: mostasem\\n  '''\\n  \\n  \\n  \\n  def getIntersection(A,B):\\n      intersect_list = []\\n      dict = {};\\n      for i in range(4):\\n          if(dict.get(A[i]) <> None):\\n              dict[A[i]] += 1\\n              if(intersect_list.count(A[i]) == 0):\\n                  intersect_list.append(A[i])\\n          else:\\n              dict[A[i]] = 1\\n          if(dict.get(B[i]) <> None):\\n              dict[B[i]] += 1\\n              if(intersect_list.count(B[i]) == 0):\\n                  intersect_list.append(B[i])\\n          else:\\n              dict[B[i]] = 1\\n  \\n      return intersect_list\\n  \\n  f_r = open('A.in',\"r\")\\n  n_test=int(f_r.readline().strip()) \\n  f_w = open(\"A.out\", \"w\")\\n  result = \"\"\\n  for i in range(n_test):\\n      cards1 = []\\n      row_index_1 = int(f_r.readline()) - 1\\n      for j in range(4):\\n          cards1.append(map(int,f_r.readline().split()))\\n      cards2 = []\\n      row_index_2 = int(f_r.readline()) - 1\\n      for j in range(4):\\n          cards2.append(map(int,f_r.readline().split())) \\n      int_list =  getIntersection(cards1[row_index_1], cards2[row_index_2])\\n      result = \"\"\\n      if(len(int_list) == 0):\\n          result = \"Volunteer cheated!\"\\n      elif(len(int_list)  == 1):\\n          result = str(int_list[0])\\n      else:\\n          result = \"Bad magician!\"\\n      output_str='Case #{itr}: {res}'.format(itr=(i+1),res=result)\\n      print output_str\\n      f_w.write(output_str+'\\n')\\n  f_r.close()\\n  f_w.close()\\n", "substitutes": {"A": ["D", "What", "Ast", "Al", "MA", "Ah", "AA", "H", "L", "System", "RA", "Added", "As", "AUT", "AC", "All", "AST", "R", "API", "An", "Ar", "AU", "CAR", "CA", "AT", "AR", "Both", "This", "Alice", "You", "Art", "ALL", "V", "SA", "AB", "AF", "GA", "ACC", "At", "AD", "Array", "LA", "C", "ACT", "AS", "Auth", "App", "Att", "JA", "Ass", "AV", "Pat", "AE", "Ax", "ANG", "AL", "AZ", "HA", "T", "The", "ART", "S", "IA", "Ant", "AP"], "B": ["D", "G", "O", "BC", "BF", "VB", "BI", "BA", "Two", "IB", "L", "U", "USB", "SB", "WB", "Bs", "BM", "Bar", "OB", "Ber", "LB", "But", "Bo", "BU", "Both", "GB", "BB", "Blue", "BER", "BY", "J", "BS", "b", "V", "Builder", "RB", "Library", "AB", "Bill", "Z", "Y", "BG", "NB", "Box", "TB", "C", "BL", "EB", "LIB", "BT", "BD", "BE", "BO", "NOTE", "T", "DB", "BR", "Other", "Bern"], "intersect_list": ["intersect___str", "intersection_l", "interchange_List", "intersect_note", "intersectedList", "interract_dict", "intervert_list", "intersect___l", "interect___dict", "interconfig_list", "intersect_info", "intersectationlist", "interract_note", "intersect_file", "interract_info", "intersectedstr", "intersectationlists", "interchange_list", "intersectistlisted", "intersect___list", "intersectednote", "intersection_list", "intersectedlisted", "intervert_map", "interchange_lists", "intersectistmap", "intersectfulnote", "intersectfulinfo", "intersect_left", "intersectistlist", "intersect_pair", "intersect_map", "intersect_l", "interect___pair", "intersectationfile", "interconfigedset", "intersecteddict", "intersectedinfo", "intersect___List", "intersectfullist", "intervert_pool", "intersect_pool", "intersect_dict", "intersect_str", "interconfigedlisted", "intersect_List", "intersectedleft", "intersectedlist", "intersectfuldict", "interconfig_left", "interect___lists", "intersectedpair", "interect_list", "interect___list", "intersect_listed", "intersectedmap", "interconfigedleft", "intersectedset", "interect_pair", "intersectistpool", "intersect___lists", "interchange_file", "interect_dict", "intersectationList", "intersect___dict", "intersectedpool", "interconfig_listed", "intersect_set", "intervert_listed", "intersect_lists", "intersectedl", "interconfigedlist", "intersection_List", "interconfig_set", "interect_lists", "intersect___pair", "intersection_str", "intersectedlists", "interract_list"], "dict": ["level", "D", "pd", "dat", "df", "hd", "compl", "doc", "coll", "cond", "client", "dec", "ct", "key", "conf", "dot", "td", "keys", "subject", "ds", "bind", "info", "upper", "d", "dt", "cache", "conn", "init", "dd", "db", "da", "pred", "red", "inf", "dh", "ld", "pkg", "nt", "list", "desc", "back", "obj", "dep", "di", "ict", "dr", "map", "conv", "high", "details", "hash", "dir", "nd", "arr"], "i": ["gi", "ji", "hi", "ic", "p", "uri", "this", "li", "e", "source", "it", "ia", "t", "io", "o", "m", "sim", "id", "iri", "n", "g", "s", "f", "ri", "ui", "phi", "parent", "ei", "name", "chain", "info", "int", "ti", "ini", "item", "index", "si", "bi", "d", "xi", "im", "y", "mi", "multi", "user", "ai", "q", "cli", "b", "ip", "u", "l", "x", "pi", "ii", "ij", "iu", "ix", "iter", "di", "zi", "I", "ie", "c", "v", "yi", "ind", "ci", "status", "list"], "f_r": ["fd_reader", "f64h", " f_rs", "f_right", " f_rar", "fd_r", "fftstr", "f_rar", "fftn", "rf___rl", "fockw", "rf_vr", "rf___vr", "fd_rar", "fogr", "rf_rl", "f_rs", "pdfftstr", "fmyrar", "rf_right", "rf_r", "pdf_str", "fmyh", "f64n", " f_wr", "rf___right", "fockwr", "fockr", "f_fr", "f_str", "fd_h", "pdfftr", "f_n", "f_cur", "fmyr", "rf___r", "f___rl", "f8n", "fockfr", "f_reader", "f_wr", "f_vr", "pdfftn", "pdf_r", " f_fr", "f8r", "fmyreader", "pdf_n", " f_n", "fogwr", "fogfr", "f64fr", " f_cur", "fftr", "f64r", "f_rl", "f8str", "f_h", " f_h", "f___r", "f___vr", "f___right", "fogw"], "n_test": ["n_tests", "n1test", "N_Test", "n_master", "N_test", "nNmaster", "N_tests", "n_Test", "num_tests", "n1tests", "nNtest", "nNtests", "n2master", "num_Test", "n1Test", "N_testing", "n2Test", "n_testing", "n2tests", "num_test", "num_master", "n2test", "n1testing", "nNTest"], "f_w": ["fmlwr", "fldwt", "fmlr", " f_out", "fldwr", "fpyr", "sf_w", "fpyw", "fmlw", "fpyb", "sf_r", "fpywrite", "fldw", "sf_write", "fmlwt", "f_b", "f_wt", " f_wr", "f_write", "f_out", "f_2", "fldr", "f_wr", "sf_b", " f_2", " f_wt"], "result": ["res", "function", "answer", "reason", "match", "total", "cup", "next", "str", "type", "report", "region", "correct", "prefix", "command", "product", "ful", "what", "compl", "url", "error", "relation", "complete", "success", "results", "grade", "final", "group", "ret", "name", "chain", "goal", "info", "section", "full", "summary", "feature", "folder", "r", "cert", "successful", "successfully", "row", "join", "Result", "buffer", "value", "table", "RESULTS", "output", "make", "string", "format", "new", "profile", "false", "date", "out", "status", "data", "method", "response", "description", "test", "comment", "message", "case", "list"], "cards1": ["hands0", "players1", "cards001", "ards1", "cards101", "hands2", " cards0", "ards001", "guards101", "photosOne", " cards001", "card0", "card01", "ardsOne", "cards81", "photos001", " cardsOne", "players81", " cards81", "cards0", "phones1", "hands01", "phonesOne", "ards101", "cardsOne", "card1", "players001", " cards01", "hands1", "phones81", "phones001", "playersOne", "cards01", "guards001", "guards1", "photos1", "guardsOne", "photos101", "card2"], "row_index_1": ["row_indexx2", "row_index_7", "row_index_0", "row_indexx0", "row_key_one", "row_Index_1", "row_indexx1", "row_key_0", "row_Index_2", "row_index_one", "row_key_7", "row_Index_9", "row_indexx9", "row_index_9", "row_Index_0", "row_key_1"], "j": ["ji", "p", "jj", "k", "ju", "str", "it", "jp", "t", "jam", "h", "ct", "ah", "z", "n", "g", "f", "ja", "jac", "ang", "w", "d", "uj", "q", "y", "r", "kj", "b", "oj", "gu", "x", "ij", "jc", "ix", "js", "c", "iaz", "v", "je", "ind"], "cards2": ["players2", "players1", "nutsB", "ards1", "nuts2", " cards4", "cardsB", "photosB", "ardsB", "games1", "photos4", "ards6", "cards82", "photos2", "players82", "ardstwo", "cards6", " cardsTwo", "gamestwo", "photos82", "nuts4", "playersTwo", "ards2", "ards4", "photos6", "games4", "cardsTwo", "cards4", "games2", "photos1", "photosTwo", " cardstwo", "cardstwo", "nuts6", " cards82"], "row_index_2": ["row_indexx2", "row_indexx22", "row_num_two", "row_Index_1", "row_Index_two", "row_num_2", "row_indexx1", "row_Index_2", "row_index_two", "row_Index_22", "row_num_p", "row_index_22", "row_indexxtwo", "row_index_p"], "int_list": ["ind2pair", "ind2List", "int2List", "int2lists", "int_List", "int10collection", "integer_map", "iter_list", "int8listed", "ind_List", "int2map", "int___1", "iter_1", "int8list", "int2listed", "int___left", "intitylist", "int_lists", "ind2list", "iter_listed", "int___list", "int10list", "int2pair", "imm___List", "integer_listed", "integer_list", "int81", "int8collection", "imm___list", "int2list", "imm_left", "int___List", "int10listed", "intity1", "int_1", "imm_List", "int_pair", "int_collection", "ind_list", "imm___left", "intityList", "ind_pair", "imm_list", "int101", "iter_collection", "int_map", "integer_lists", "int_left", "imm_1", "imm___1", "intityleft", "int_listed"], "output_str": ["outputlystr", "outputlyctr", "output2str", "commandlyctr", " output_string", " output_sp", "output2string", "outputstrstr", "commandlystr", "commandlyStr", "output2STR", "command_str", "output___str", "command_usr", "output2arr", "Output_str", "Output_arr", "command_Str", " output_dr", "output_usr", "output___Str", "outputlyStr", "outputstrstring", "output_dr", "commandlyusr", "output_sp", "output_string", "output___usr", "outputstrsp", "Output_string", "outputlyusr", "output___ctr", "output_Str", "outputstrdr", "command_ctr", "output_ctr", "Output_STR", "output_arr", "output_STR"]}}
{"code": " \\n  FILE_NAME_BASE = 'C-small-attempt0'\\n  NUM_PROCESSES = 0\\n  MEM_LIMIT_GB = 1.5 # per worker process\\n  RECURSION_LIMIT = 1000\\n  \\n  def parse(inp):\\n  \trows, cols, mines = (int(x) for x in inp.readline().split())\\n  \treturn rows, cols, mines\\n  \\n  def search(rows, cols, mines):\\n  \\n  \tassert 0 <= mines < rows * cols\\n  \tif mines == 0:\\n  \t\treturn ['c' + '.' * (cols - 1)] + ['.' * cols] * (rows - 1)\\n  \tif mines == rows * cols - 1:\\n  \t\treturn ['c' + '*' * (cols - 1)] + ['*' * cols] * (rows - 1)\\n  \\n  \tif rows == 1:\\n  \t\treturn ['c' + '.' * (cols - 1 - mines) + '*' * mines]\\n  \tif cols == 1:\\n  \t\treturn ['c'] + ['.'] * (rows - 1 - mines) + ['*'] * mines\\n  \\n  \tif mines > rows * cols - 4:\\n  \t\treturn None\\n  \\n  \\n  \treturn None\\n  \\n  class SearchBoard(object):\\n  \\n  \tdef __init__(self, rows, cols):\\n  \t\tself.counts = [[0] * (cols + 2) for _ in xrange(rows + 2)]\\n  \t\tself.mineCount = 0\\n  \\n  \tdef addMine(self, row, col):\\n  \t\tcounts = self.counts\\n  \t\tassert counts[row + 1][col + 1] < 10\\n  \t\ttop = counts[row + 0]\\n  \t\ttop[col + 0] += 1\\n  \t\ttop[col + 1] += 1\\n  \t\ttop[col + 2] += 1\\n  \t\tmid = counts[row + 1]\\n  \t\tmid[col + 0] += 1\\n  \t\tmid[col + 1] += 10\\n  \t\tmid[col + 2] += 1\\n  \t\tbot = counts[row + 2]\\n  \t\tbot[col + 0] += 1\\n  \t\tbot[col + 1] += 1\\n  \t\tbot[col + 2] += 1\\n  \t\tself.mineCount += 1\\n  \\n  \tdef removeMine(self, row, col):\\n  \t\tcounts = self.counts\\n  \t\tassert counts[row + 1][col + 1] >= 10\\n  \t\ttop = counts[row + 0]\\n  \t\ttop[col + 0] -= 1\\n  \t\ttop[col + 1] -= 1\\n  \t\ttop[col + 2] -= 1\\n  \t\tmid = counts[row + 1]\\n  \t\tmid[col + 0] -= 1\\n  \t\tmid[col + 1] -= 10\\n  \t\tmid[col + 2] -= 1\\n  \t\tbot = counts[row + 2]\\n  \t\tbot[col + 0] -= 1\\n  \t\tbot[col + 1] -= 1\\n  \t\tbot[col + 2] -= 1\\n  \t\tself.mineCount -= 1\\n  \\n  \tdef checkConnected(self):\\n  \t\tcounts = self.counts\\n  \t\tcols = len(counts[0]) - 2\\n  \t\trows = len(counts) - 2\\n  \\n  \t\tfor rowIdx, row in enumerate(counts):\\n  \t\t\tif rowIdx == 0 or rowIdx > rows:\\n  \t\t\t\tcontinue\\n  \t\t\ttry:\\n  \t\t\t\tcolIdx = row.index(0, 1, -1)\\n  \t\t\texcept ValueError:\\n  \t\t\t\tpass\\n  \t\t\telse:\\n  \t\t\t\tclick = (rowIdx, colIdx)\\n  \t\t\t\tbreak\\n  \t\telse:\\n  \t\t\treturn None\\n  \\n  \t\trevealed = set()\\n  \t\tdef reveal(row, col):\\n  \t\t\tif 1 <= row <= rows and 1 <= col <= cols:\\n  \t\t\t\tpos = (row, col)\\n  \t\t\t\tif pos not in revealed:\\n  \t\t\t\t\trevealed.add(pos)\\n  \t\t\t\t\tcount = counts[row][col]\\n  \t\t\t\t\tif count == 0:\\n  \t\t\t\t\t\tfor dr in (-1, 0, 1):\\n  \t\t\t\t\t\t\tfor dc in (-1, 0, 1):\\n  \t\t\t\t\t\t\t\tif dr != 0 or dc != 0:\\n  \t\t\t\t\t\t\t\t\treveal(row + dr, col + dc)\\n  \t\t\t\t\telse:\\n  \t\t\t\t\t\tassert count < 10\\n  \t\treveal(*click)\\n  \t\tnumNonMines = rows * cols - self.mineCount\\n  \t\tif len(revealed) != numNonMines:\\n  \t\t\tassert len(revealed) < numNonMines\\n  \t\t\treturn None\\n  \\n  \t\tboard = [\\n  \t\t\t\t['.' if cell < 10 else '*' for cell in row[1 : -1]]\\n  \t\t\t\tfor row in counts[1 : -1]\\n  \t\t\t\t]\\n  \t\tboard[click[0] - 1][click[1] - 1] = 'c'\\n  \t\treturn [''.join(row) for row in board]\\n  \\n  def searchBruteForce(rows, cols, mines):\\n  \tif mines == rows * cols - 1:\\n  \t\treturn ['c' + '*' * (cols - 1)] + ['*' * cols] * (rows - 1)\\n  \\n  \tsearchBoard = SearchBoard(rows, cols)\\n  \\n  \tdef searchRec(idx, remaining):\\n  \t\tif remaining == 0:\\n  \t\t\treturn searchBoard.checkConnected()\\n  \t\telif idx < remaining:\\n  \t\t\treturn None\\n  \t\telse:\\n  \t\t\tpos = divmod(idx, cols)\\n  \t\t\tsearchBoard.addMine(*pos)\\n  \t\t\tfound = searchRec(idx - 1, remaining - 1)\\n  \t\t\tsearchBoard.removeMine(*pos)\\n  \t\t\tif found is not None:\\n  \t\t\t\treturn found\\n  \t\t\treturn searchRec(idx - 1, remaining)\\n  \\n  \treturn searchRec(rows * cols - 1, mines)\\n  \\n  def solve(rows, cols, mines):\\n  \tboard = search(rows, cols, mines)\\n  \\n  \tif board is None:\\n  \t\tboard = searchBruteForce(rows, cols, mines)\\n  \t\tif board is None:\\n  \t\t\treturn '\\n' + 'Impossible'\\n  \t\tprint 'ERROR: fast search missed solution for %dx%d board, %d mines:' \\\\n  \t\t\t\t% (rows, cols, mines)\\n  \t\tfor row in board:\\n  \t\t\tprint row\\n  \t\tprint\\n  \\n  \tassert len(board) == rows\\n  \tassert all(len(row) == cols for row in board)\\n  \tcounts = { 'c': 0, '.': 0, '*': 0 }\\n  \tfor row in board:\\n  \t\tfor cell in row:\\n  \t\t\tcounts[cell] += 1\\n  \tassert counts['c'] == 1\\n  \tassert counts['*'] == mines\\n  \\n  \tflowBoard = [\\n  \t\t\t['.' if cell == 'c' else cell for cell in row]\\n  \t\t\tfor row in board\\n  \t\t\t]\\n  \tdef countMinesOn(row, col):\\n  \t\tif 0 <= row < rows and 0 <= col < cols:\\n  \t\t\treturn 1 if flowBoard[row][col] == '*' else 0\\n  \t\telse:\\n  \t\t\treturn 0\\n  \tdef countMinesNear(row, col):\\n  \t\treturn sum(\\n  \t\t\tcountMinesOn(row + dr, col + dc)\\n  \t\t\tfor dr in (-1, 0, 1)\\n  \t\t\tfor dc in (-1, 0, 1)\\n  \t\t\t)\\n  \tdef reveal(row, col):\\n  \t\tif 0 <= row < rows and 0 <= col < cols:\\n  \t\t\tassert flowBoard[row][col] != '*'\\n  \t\t\tif flowBoard[row][col] == '.':\\n  \t\t\t\tcount = countMinesNear(row, col)\\n  \t\t\t\tflowBoard[row][col] = str(count)\\n  \t\t\t\tif count == 0:\\n  \t\t\t\t\tfor dr in (-1, 0, 1):\\n  \t\t\t\t\t\tfor dc in (-1, 0, 1):\\n  \t\t\t\t\t\t\treveal(row + dr, col + dc)\\n  \tclickRow, = [i for i, row in enumerate(board) if 'c' in row]\\n  \tclickCol = board[clickRow].index('c')\\n  \treveal(clickRow, clickCol)\\n  \tassert all('.' not in row for row in flowBoard), flowBoard\\n  \\n  \tassert all(type(row) == str for row in board)\\n  \treturn '\\n' + ''.join('\\n' + ''.join(row) for row in board)\\n  \\n  def main():\\n  \tsys.setrecursionlimit(RECURSION_LIMIT)\\n  \\n  \tsoft, hard = resource.getrlimit(resource.RLIMIT_AS)\\n  \tresource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))\\n  \\n  \tinp = open(FILE_NAME_BASE + '.in', 'r')\\n  \tnumCases = int(inp.readline())\\n  \tif NUM_PROCESSES == 0:\\n  \t\tresults = [\\n  \t\t\tsolve(*parse(inp))\\n  \t\t\tfor _ in range(numCases)\\n  \t\t\t]\\n  \telse:\\n  \t\tpool = Pool(NUM_PROCESSES)\\n  \t\tresults = [\\n  \t\t\tpool.apply_async(solve, parse(inp))\\n  \t\t\tfor _ in range(numCases)\\n  \t\t\t]\\n  \tinp.close()\\n  \tout = open(FILE_NAME_BASE + '.out', 'w')\\n  \tfor case, result in enumerate(results):\\n  \t\tvalue = result if NUM_PROCESSES == 0 else result.get()\\n  \t\tout.write('Case #%d: %s\\n' % (case + 1, value))\\n  \t\tout.flush()\\n  \tout.close()\\n  \\n  if __name__ == '__main__':\\n  \tmain()\\n", "substitutes": {"FILE_NAME_BASE": ["FILE_NAME_NBRA", "FILE_NAME_BAT", "FILE_NAME_NBASE", "FILE_NAME_BCAT", "FILE_NAME_BOAT", "FILE_NAME_BOOWER", "FILE_NAME_BCRA", "FILE_NAME_BCOWER", "FILE_NAME_BOWER", "FILE_NAME_BORA", "FILE_NAME_NBOWER", "FILE_NAME_NBAT", "FILE_NAME_BRA", "FILE_NAME_BCASE", "FILE_NAME_BOASE"], "NUM_PROCESSES": ["NUM_PROCNECTURES", "NUM_PROCESSURES", "NUM_PROGRNECTes", "NUM_PROCNECTES", "NUM_PROCUTURES", "NUM_PROCUSED", "NUM_PROCUSes", "NUM_PROCUTED", "NUM_PROGRNECTURES", "NUM_PROGRESSES", "NUM_PROCNECTED", "NUM_PROGRNECTED", "NUM_PROCUTES", "NUM_PROGRNECTES", "NUM_PROGRESSED", "NUM_PROCNECTes", "NUM_PROCUSURES", "NUM_PROCUTes", "NUM_PROCUSES", "NUM_PROCESSes", "NUM_PROCESSED", "NUM_PROGRESSes", "NUM_PROGRESSURES"], "MEM_LIMIT_GB": ["MEM_LIMITSINMB", "MEM_LIMIT_MB", "MEM_LIMITUSGB", "MEM_LIMITSINGB", "MEM_LIMIT2GB", "MEM_LIMITS_GB", "MEM_LIMIT_AGE", "MEM_LIMITINMB", "MEM_LIMITINAGE", "MEM_LIMITSINAGE", "MEM_LIMITUSMB", "MEM_LIMITINGB", "MEM_LIMIT2AGE", "MEM_LIMITS_MB", "MEM_LIMITUSAGE", "MEM_LIMITS_AGE", "MEM_LIMIT2MB"]}}
{"code": " \\n  FILE_NAME_BASE = 'A-small-attempt0'\\n  NUM_PROCESSES = 0\\n  MEM_LIMIT_GB = 1.5 # per worker process\\n  RECURSION_LIMIT = 1000\\n  \\n  def parseBoard(inp):\\n  \trowSel, = (int(x) for x in inp.readline().split())\\n  \tboard = tuple(\\n  \t\ttuple(int(x) for x in inp.readline().split())\\n  \t\tfor _ in xrange(4)\\n  \t\t)\\n  \treturn board, rowSel - 1\\n  \\n  def parse(inp):\\n  \tbefore, beforeSel = parseBoard(inp)\\n  \tafter, afterSel = parseBoard(inp)\\n  \treturn before, beforeSel, after, afterSel\\n  \\n  def solve(before, beforeSel, after, afterSel):\\n  \tcandidates = set(before[beforeSel]) & set(after[afterSel])\\n  \\n  \tif len(candidates) == 0:\\n  \t\treturn \"Volunteer cheated!\"\\n  \telif len(candidates) == 1:\\n  \t\treturn candidates.pop()\\n  \telse:\\n  \t\treturn \"Bad magician!\"\\n  \\n  def main():\\n  \tsys.setrecursionlimit(RECURSION_LIMIT)\\n  \\n  \tsoft, hard = resource.getrlimit(resource.RLIMIT_AS)\\n  \tresource.setrlimit(resource.RLIMIT_AS, (MEM_LIMIT_GB * 1024 ** 3, hard))\\n  \\n  \tinp = open(FILE_NAME_BASE + '.in', 'r')\\n  \tnumCases = int(inp.readline())\\n  \tif NUM_PROCESSES == 0:\\n  \t\tresults = [\\n  \t\t\tsolve(*parse(inp))\\n  \t\t\tfor _ in range(numCases)\\n  \t\t\t]\\n  \telse:\\n  \t\tpool = Pool(NUM_PROCESSES)\\n  \t\tresults = [\\n  \t\t\tpool.apply_async(solve, parse(inp))\\n  \t\t\tfor _ in range(numCases)\\n  \t\t\t]\\n  \tinp.close()\\n  \tout = open(FILE_NAME_BASE + '.out', 'w')\\n  \tfor case, result in enumerate(results):\\n  \t\tvalue = result if NUM_PROCESSES == 0 else result.get()\\n  \t\tout.write('Case #%d: %s\\n' % (case + 1, value))\\n  \t\tout.flush()\\n  \tout.close()\\n  \\n  if __name__ == '__main__':\\n  \tmain()\\n", "substitutes": {"FILE_NAME_BASE": ["FILE_NAME___BEGIN", "FILE_NAME___SBAS", "FILE_NAME___BASE", "FILE_NAME___BBS", "FILE_NAME_PBS", "FILE_NAME_PBBS", "FILE_NAME_SBBS", "FILE_NAME_SBASE", "FILE_NAME___SBEGIN", "FILE_NAME_PAS", "FILE_NAME_SBEGIN", "FILE_NAME_BEGIN", "FILE_NAME_PASE", "FILE_NAME___BAS", "FILE_NAME_SBAS", "FILE_NAME_BAS", "FILE_NAME_BBS", "FILE_NAME_PBAS", "FILE_NAME_PEGIN", "FILE_NAME___SBASE", "FILE_NAME_PBEGIN", "FILE_NAME___SBBS", "FILE_NAME_PBASE"], "NUM_PROCESSES": ["NUM_PROGRESSIONS", "NUM_PROGRNECTes", "NUM_PROCNECTES", "NUM_PROCOCIONS", "NUM_PROCNECTIONS", "NUM_PROCOCes", "NUM_PROCUSED", "NUM_PROCOCES", "NUM_PROGRNECTIONS", "NUM_PROCUSes", "NUM_PROGRESSES", "NUM_PROCNECTED", "NUM_PROGRNECTED", "NUM_PROGRNECTES", "NUM_PROGRESSED", "NUM_PROCNECTes", "NUM_PROCOCED", "NUM_PROCUSES", "NUM_PROCESSes", "NUM_PROCESSED", "NUM_PROGRESSes", "NUM_PROCESSIONS", "NUM_PROCUSIONS"], "MEM_LIMIT_GB": ["MEM_LIMITSINMB", "MEM_LIMIT_MB", "MEM_LIMITUSGB", "MEM_LIMITSINGB", "MEM_LIMITTIMEGB", "MEM_LIMITS_GB", "MEM_LIMIT_AGE", "MEM_LIMITINMB", "MEM_LIMITINAGE", "MEM_LIMITSINAGE", "MEM_LIMITUSMB", "MEM_LIMITINGB", "MEM_LIMITTIMEAGE", "MEM_LIMITTIMEMB", "MEM_LIMITS_MB", "MEM_LIMITUSAGE", "MEM_LIMITS_AGE"]}}
{"code": "T = int(raw_input().strip())\\n  misses = set()\\n  \\n  for i in xrange(T):\\n  \tR, C, M = map(int, raw_input().strip().split(' '))\\n  \tF = R * C - M\\n  \timpossible = False\\n  \tif F == 1:\\n  \t\tmatrix = [\"c\" + \"*\" * (C - 1)]\\n  \t\tfor _ in xrange(R - 1):\\n  \t\t\tmatrix.append(\"*\" * C)\\n  \telif R == 1:\\n  \t\tmatrix = [\"c\" + \".\" * (F - 1) + \"*\" * (C - F)]\\n  \telif C == 1:\\n  \t\tmatrix = [\"c\"]\\n  \t\tfor _ in xrange(F - 1):\\n  \t\t\tmatrix.append(\".\")\\n  \t\tfor _ in xrange(R - F):\\n  \t\t\tmatrix.append(\"*\")\\n  \telif R == 2:\\n  \t\tif F % 2 == 0 and (C > 1 and F != 2 or C == 1 and F <= 2):\\n  \t\t\tmatrix = [\\n  \t\t\t\t\"c\" + \".\" * (F / 2 - 1) + \"*\" * (C - F / 2),\t\\n  \t\t\t\t\".\" * (F / 2) + \"*\" * (C - F / 2)\\n  \t\t\t]\\n  \t\telse:\\n  \t\t\tmatrix = []\\n  \t\t\timpossible = True\\n  \telse:\\n  \t\tstack = []\\n  \t\tmatrix = []\\n  \t\tfor j in xrange(C, 1, -1):\\n  \t\t\tif F - 2 * j >= 0 and (R - 2) * j >= F - 2 * j:\\n  \t\t\t\tstack.append([j, j])\\n  \\n  \t\twhile stack:\\n  \t\t\telems = stack.pop()\\n  \t\t\tse = sum(elems)\\n  \t\t\tif se == F:\\n  \t\t\t\tfor count in elems:\\n  \t\t\t\t\tmatrix.append(\".\" * count + \"*\" * (C - count))\\n  \t\t\t\tfor _ in xrange(R - len(elems)):\\n  \t\t\t\t\tmatrix.append(\"*\" * C)\\n  \t\t\t\tmatrix[0] = \"c\" + matrix[0][1:]\\n  \t\t\t\tbreak\\n  \t\t\telif len(elems) < R:\\n  \t\t\t\tfor j in xrange(elems[-1], 1, -1):\\n  \t\t\t\t\tif F - se - j >= 0 and (R - len(elems)) * j >= F - se:\\n  \t\t\t\t\t\tstack.append(elems[::] + [j])\\n  \\n  \t\tif matrix == []:\\n  \t\t\timpossible =True\\n  \\n  \tprint \"Case #%s:\" % (i + 1)\\n  \tif impossible:\\n  \t\tprint \"Impossible\"\\n  \telse:\\n  \t\tfor row in matrix:\\n  \t\t\tprint row\\n", "substitutes": {"T": ["D", "G", "TI", "TT", "TN", "X", "t", "H", "L", "TM", "E", "Q", "TH", "B", "TC", "TS", "TA", "J", "V", "Z", "Y", "NT", "N", "GT", "TR", "TB", "K", "I", "P", "W", "S"], "misses": ["writES", " MissES", "lossenses", "losses", "writes", "missees", "writenses", " Missenses", " Misses", "lossES", "missES", " Missees", "missenses", "writees", "lossees"], "i": ["ji", "p", "li", "e", "it", "t", "m", "id", "n", " ii", "f", "ti", "index", " I", "im", "y", "r", "b", "l", "x", "ix", "iter", "I", "ie", "ind", "ci"], "R": ["Range", "D", "G", "O", "X", "Run", "RA", "H", "L", "U", "CR", "Q", "A", "E", "DR", "RC", "FR", "IR", "RF", "B", "SR", "Res", "RG", "AR", "r", "J", "V", "RO", "RS", "Y", "N", "NR", "RE", "TR", "GR", "RR", "Rs", "I", "RM", "P", "RT", "W", "BR", "S", "MR", "ER"], "C": ["Co", "D", "G", "O", "Ch", "FC", "X", "H", "L", "U", "CR", "E", "A", "CM", "Q", "Count", "CS", "B", "CAR", "TC", "CC", "CI", "WC", "J", "CON", "V", "Y", "N", "Car", "CT", "VC", "CP", "CF", "K", "I", "P", "W", "c", "MC", "CU", "S", "Cs"], "M": ["D", "G", "O", "X", "H", "L", "m", "TM", "E", "Q", "A", "CM", "B", "MM", "FM", "J", "V", "Y", "N", "MT", "K", "I", "RM", "P", "W", "MC", "S", "MR"], "F": ["D", "G", "O", "FG", "FA", "FC", "X", "H", "L", "U", "E", "FT", "Q", "A", "Family", "Fin", "FB", "FN", "FR", "FER", "f", "RF", "Fe", "B", "FP", "FL", "DF", "FU", "Fixed", "FM", "EF", "MF", "GF", "J", "FO", "Type", "V", "TF", "AF", "Z", "WF", "Y", "Format", "Fs", "FF", "N", "FI", "RE", "IF", "FE", "FK", "PF", "Length", "FS", "CF", "SF", "K", "I", "UF", "P", "W", "Function", " f", "Ret", "S", "FD"], "impossible": ["excured", " impacted", "impatible", "impossibility", " impossibility", "impulse", "excossible", "Impallowed", "ispulse", " impulse", "explossible", "Impacted", "explatible", "explured", "Impatible", "impacted", "ispossible", "Impossible", "excallowed", "impallowed", "explallowed", "Impured", "ispacted", "impured", "Impulse", "ispossibility", "excatible", "Impossibility"], "matrix": ["matchrices", "matcher", "dimrice", "scherice", "matMatrix", "matroll", "plotric", "mroll", "metrix", "matrics", "atrics", "atprint", "patrics", "modulerix", " matprint", "atrice", "modulezero", "moduleric", "patrix", "metrices", "atpack", "formatrier", "matric", "atment", " matroll", "scherier", "atrices", " matric", "matrices", " matzero", "mride", "Matcher", "matment", "mtrices", "dimrix", "matchMatrix", "mMatrix", "patric", " matpack", "Matrice", " matinate", "matzero", "manrix", "mitric", "mtrice", "matride", "mtrix", "Matrix", "magric", "formatrics", "tarrix", "matchric", "matrier", "matrice", "magrench", "mmrics", "atric", "mpack", "formatrices", "tarride", "mtment", "matrench", "mitinate", "manrice", "mric", "dimric", "tarbook", "umatric", "dimbook", " matrices", "mprint", "atrench", "plotrices", "minate", "mrix", "formatrix", "formatric", "mzero", "mbook", "plotrics", "mrics", "metrier", "mitrix", "matbook", "mitrices", "mrices", "umatbook", "atMatrix", "scherix", "plotrix", "patcher", "matchrix", "manric", "mmrix", "moduleroll", "matprint", "matinate", "Matrices", "magrix", "Matment", "Matric", "Matbook", "scherices", "tarric", "umatride", "formatrice", "umatrix", "formatcher", "Matrics", "atrix", "magrics", "mmrench", "manbook", "metrice", "matpack", " matrics", "mmric"], "_": ["__", "___", "t", "all", "Not", "int", " the", "____", "x", "get", "pt", "ml"], "stack": ["empty", "switch", "level", "args", "reverse", "check", "storage", "load", "frame", "space", "store", "history", "push", "wait", "complete", "window", "chain", "track", "Stack", "upper", "loop", "counter", "cache", "set", "each", "via", "view", "found", "hold", "forest", "buffer", "fake", "pack", "table", "call", "cycle", "batch", "st", "ack", "make", "slice", "iter", "stage", "trace", "frames", "acks", "first", "zip", "parse", "queue", "scope", "test", "valid", "pop", "status", "list"], "j": ["ji", "p", "jj", "k", "jl", "fr", "it", "jp", "t", "o", "m", "h", "z", "n", "s", "g", "f", "ja", "d", "uj", "q", "y", "json", "r", "J", "kj", "b", "dj", "el", "l", "jit", "oj", "x", "ij", "job", "jc", "ch", "obj", "js", "jump", "c", "v", "aj", "bj"], "elems": [" elets", " elels", " elemes", "plems", "temes", "lemtes", "elecs", " elecs", "plets", "elemn", "gerems", "Elels", "tenmn", " elemn", " eletes", "Elets", "elels", " elers", "germes", "vemes", "plers", "Elems", " elemers", "lemn", "Elemes", "eleems", "veems", "plemes", "elemers", "lemems", "Elemn", "plemn", "vemn", "temn", "elets", "lemls", "germn", "Eleems", "Elemb", "tilecs", "tilems", "lemes", "elemes", "lemms", "lecs", "tencs", "tems", "lemmes", "leems", "tilemes", "tenmes", "tenms", "lemmn", "germs", "lets", "lers", "eletes", "pleems", "temers", "tilemb", "vems", "Elecs", "letes", "lemers", " elemb", "elers", "lems", "lemts", "elemb"], "se": ["sa", "su", "fr", "sd", "re", "e", "SI", "sp", "Se", "sle", "ser", "ct", "ss", "pe", "pse", "ne", "ve", "sex", "see", "use", "si", "ze", "ke", "ese", "sc", "ine", "ree", "me", "so", "sec", "sy", "sed", "est", "sh", "sign", "sr", "te", "al", "th", "sem", "second", "sv", "ase", "sq", "ses", "ie", "ge", "parse", "SE", "we", " Se", "square", "prime"], "count": ["total", "p", "fr", "e", "ctx", "err", "t", "sp", "cur", "ind", "cond", "code", "z", "cf", "Count", "acc", "f", "node", "s", "n", "sex", "name", "index", "ze", "q", "counter", "set", "current", "const", "me", "ount", "ctr", "val", "value", " c", "cr", "number", "cc", "cycle", "nt", "st", "ch", "th", "second", "length", "c", "ie", "sum", "cre", "size", "case", "num"]}}
{"code": "T = int(raw_input().strip())\\n  \\n  for j in xrange(T):\\n  \trow_num1 = int(raw_input().strip())\\n  \tfor i in xrange(4):\\n  \t\tif i + 1 == row_num1:\\n  \t\t\trow1 = set(map(int, raw_input().strip().split(' ')))\\n  \t\telse:\\n  \t\t\traw_input()\\n  \trow_num2 = int(raw_input().strip())\\n  \tfor i in xrange(4):\\n  \t\tif i + 1 == row_num2:\\n  \t\t\trow2 = set(map(int, raw_input().strip().split(' ')))\\n  \t\telse:\\n  \t\t\traw_input()\\n  \tcommon = row1 & row2\\n  \tlc = len(common)\\n  \tif lc == 1:\\n  \t\tstuff = list(common)[0]\\n  \telif lc > 1:\\n  \t\tstuff = \"Bad magician!\"\\n  \telse:\\n  \t\tstuff = \"Volunteer cheated!\"\\n  \\n  \tprint \"Case #%s: %s\" % (j + 1, stuff)\\n", "substitutes": {"T": ["Time", "D", "G", "O", "TT", "TN", "X", "t", "H", "L", "TM", "E", "Q", "R", "B", "TC", "TS", "TA", "F", "J", "V", "M", "Z", "Y", "N", "WT", "GT", "TR", "TB", "C", "K", "Total", "I", "P", "S"], "j": ["ji", "jj", "ju", "k", "jl", "jp", "t", "m", "z", "id", "g", "n", " ii", "f", "ja", "name", "item", "d", " J", "uj", "q", "y", "json", "J", "state", "kj", "b", "dj", "typ", "jit", "ij", "job", "jc", "jump", "c", "v", "aj", "bj", "ind"], "row_num1": ["row_no2", "row7num91", "row_um01", "row_ver1", "row7num01", "row_num91", "row_NUM1", "row_number01", "row_no5", "row_ver5", "row_um1", "row7um91", "row_mon1", "row7um2", "row_no01", "row_mon2", "row_ver2", "row_no1", "row_number1", "row_mon91", "row7num2", "row_NUM5", "row_um2", "row_mon01", "row_number91", "row_NUM2", "row7um1", "row7um01", "row_num01", "row_um91", "row_number2", "row_NUM01", "row7num1", "row_num5", "row_ver01"], "i": ["asi", "ki", "hi", "ic", "p", "ji", "li", "it", "io", "o", "m", "iti", "phi", "ei", "il", "ti", "ini", "bi", "si", "xi", "im", "mi", "ai", "uli", "ip", "l", "x", "pi", "ii", "oi", "ij", "ni", "ati", "di", "zi", "I", "c", "yi", "ci"], "row1": ["rows2", " rowA", "col2", "row01", "rows1", "cell1", "col1", "RowOne", "colA", "rowsA", "rowOne", "Row1", "row0", "Row0", "col3", "row3", "cell01", "Row01", "rowA", " row3", "rows3", " row0", "cell0", "cellOne", " rowOne", " row01"], "row_num2": ["row_nam3", "row_no2", "row2mon2", "row2no12", "row2mon1", "row_no12", "row_nam1", "row_nam12", "row2num4", "row_mon3", "row_mon1", "row_num12", "row_mon12", "row_mon2", "row_num4", "row_no1", "row2num3", "row2num12", "row_number1", "row2no2", "row2mon5", "row2num1", "row_nam2", "row_mon5", "row2no3", "row_num3", "row_no3", "row_number5", "row2no1", "row2mon4", "row_number2", "row_mon4", "row2num2", "row_number4", "row2num5", "row_num5"], "row2": ["cell3", " row10", "rows2", "ow02", "col2", "ow2", "cell2", " row_", "cell_", "row10", "row_", "col_", "rows02", "row3", "col3", "ow10", "row02", " row3", "ow3", "rows10", " row02", "rows3"], "common": ["partial", "shared", "basic", "custom", "dom", "total", "cm", "used", "long", "unique", "public", "old", "con", "human", "seen", "general", "comm", "some", "specific", "full", "main", "local", "same", "core", "unknown", "generic", "similar", "Common", "qualified", "natural", "obj", "san", "new", "normal", "onet", "recent", "tc", "low", "non", "central", "known", "com", "other"], "lc": ["lu", "dc", " lac", "li", "uci", "cm", "lv", "bc", "lan", "nc", "loe", "cci", "nic", "LC", "ls", "LV", "rl", "pc", "ctl", "dl", "lf", "vc", "WC", "lp", "cow", "lb", "lt", "cl", "l", "mc", "ln", "len", " clen", " LCS", "LCS", "tl", "fc", "lvl", "c", "gc", "tc", "kl", "ci", "icc", "scl", "las"], "stuff": ["mostly", "tmp", "str", "yeah", "prefix", "uart", "what", "cca", "stab", "kind", "hack", "fuck", "txt", "za", "success", "company", "tech", "shake", "pretty", "name", "info", "something", "things", "town", "luck", "nothing", "food", "unknown", "magic", "strip", "just", "setup", "oooo", "bill", "pkg", "stick", "consider", "st", "fortune", "tie", "think", "contact", "know", "msg", "string", "uff", "look", "wow", "bag", "ie", "safety", "now", "bug", "front", "thing", "fx", "comment", "case"]}}
{"code": " \\n  \\n  f = open(sys.argv[1],'r')\\n  \\n  num = int(f.readline())\\n  \\n  def count(z, r, c):\\n      return len(z_and_nei(z,r,c))\\n  \\n  def nei(z, r, c):\\n      s = z_and_nei(z, r, c)\\n      s -= set(z)\\n      return s\\n  \\n  def z_and_nei(z, r, c):\\n      s = set()\\n      for x in z:\\n          s.add(x)\\n          s.add((x[0]-1,x[1]-1))\\n          s.add((x[0]-1,x[1]))\\n          s.add((x[0]-1,x[1]+1))\\n          s.add((x[0],x[1]-1))\\n          s.add((x[0],x[1]+1))\\n          s.add((x[0]+1,x[1]-1))\\n          s.add((x[0]+1,x[1]))\\n          s.add((x[0]+1,x[1]+1))\\n      o = set()\\n      for x in s:\\n          if x[0] < 0 or x[0] > r-1 or x[1] < 0 or x[1] > c-1:\\n              o.add(x)\\n      s-=o\\n      return s\\n  \\n  def find_config(z, r, c, t):\\n      if count(z,r,c) == t:\\n          return z\\n      if count(z,r,c) > t:\\n          return []\\n      n = nei(z,r,c)\\n      for x in n:\\n          z.append(x)\\n          if find_config(z,r,c,t) != []:\\n              return z\\n          z.pop()\\n      return []\\n  \\n  for i in range(num):\\n      print 'Case #{}:'.format(i+1)\\n      r, c, m = [int(x) for x in f.readline().split()]\\n      if r*c-m == 1:\\n          print 'c' + '*'*(c-1)\\n          for i in range(r-1):\\n              print '*'*c\\n      else:\\n          z = find_config([(0,0)], c, r, c*r-m)\\n          if z == []:\\n              print \"Impossible\"\\n          else:\\n              s = z_and_nei(z, c, r)\\n              for j in range(r):\\n                  for k in range(c):\\n                      if j == 0 and k == 0:\\n                          print 'c',\\n                      elif (k,j) in s:\\n                          print '.',\\n                      else:\\n                          print '*',\\n                  print\\n  \\n  \\n", "substitutes": {"f": ["ft", "fd", "p", "bf", "form", "fr", "df", "e", "fe", "fl", "h", "fo", "uf", "rf", "g", "fg", "fb", "w", "d", "ze", "lf", "tf", "y", "F", "fm", "b", "l", "fed", "feed", "fp", "file", "fc", "a", "fs", "v", "fi", "alf"], "num": ["mon", "total", "p", "no", "sim", "nr", "max", "conf", "con", "final", "zero", "en", "um", "om", "tr", "na", "multi", "init", "nb", "nu", "nom", "np", "number", "un", "NUM", "nm", "Number", "th", "mult", "sum", "cal", "Num"], "z": ["cz", "p", "os", "ic", "one", "e", "ll", "it", "zone", "h", "g", "zo", "hz", "all", "zero", "ed", "xt", "zh", "zes", "rez", "d", "ze", "iz", "w", "q", "nz", "y", "u", "oz", "sw", "pl", "config", "b", "cl", "l", "Z", "tz", "uz", "ld", "ot", "nt", "ix", "new", "zi", "zer", "ez", "a", "zip", "zen", "ry", "v", "data", "pt", "yz", "az"], "r": ["res", "br", "p", "rc", "ra", "er", "rer", "re", "e", "err", "rs", "it", "fr", "lr", "rec", "nr", "h", "ro", "rg", "rb", "ur", "g", "R", "ri", "ar", "ru", "tr", "d", "w", "q", "u", "y", "rect", "b", "l", "rr", "cr", "hr", "rar", "rel", "usr", "sr", "dr", "mr", "a", "rn", "vr", "v", "ry", "rd", "rt"], "c": ["dc", "p", "rc", "count", "e", "cp", "cm", "cur", "lc", "ct", "h", "cf", "con", "conf", "g", "nc", "anc", "cos", "chain", "ar", "cat", "cu", "d", "arc", "cn", "cb", "sc", "u", "cs", "cache", "ec", "cin", "y", "b", "ac", "cont", "cor", "l", "cr", "co", "mc", "cc", "w", "ch", "C", "ca", "cd", "fc", "ce", "mr", "a", "gc", "v", "tc", "com", "ci"], "s": ["se", "sa", "p", "ges", "er", "e", "settings", "h", "results", "ed", "ls", "w", "set", "ords", "gets", "ins", "simple", "qs", "terms", "a", "sq", "ses", "ions", "xs", "less", "ings", "ands", "mods", "sets", "ers", "ing", "bs", "types", "ows", "als", "js", "v", "es", "S", "sb", "tests", "ns", "os", "ms", "sp", "ss", "g", "ds", "els", "y", "its", "so", "l", "ans", "lines", "ats", "sts", "sv", "gs", "ments", "ools", "rs", "ps", "ies", "ys", "eds", "ws", "cs", "tags", "b", "st", "ends", "abs", "sys", "fs", "ries", "ts"], "x": ["p", "check", "e", "ctx", "at", "xes", "h", "item", "w", "dl", "q", "xf", "el", "xd", "a", "lat", "ux", "hex", "xs", "xxx", "xxxx", "wx", "xp", "ax", "ct", "ox", "key", "xa", " xx", "tx", "xt", "oxy", "any", "xi", "u", "on", "yx", "lex", "ix", "xx", "v", "xml", "X", "dx", "g", "exp", "y", "sw", "inx", "work", "ac", "content", "l", "co", "mix", "ext", "xe", "nex", "xb", "test", "fx", "zx", "ic", "rx", "xc", "ey", "mx", "iz", "\u00e7", "ty", "st", "xy", "ex", "px", "ml"], "o": ["p", "O", "os", "bo", "e", "oin", "no", "ob", "h", "ox", "g", "oS", "ed", "w", "d", "u", "y", "aos", "b", "so", "l", "co", "ot", "oa", "to", "out", "onet", "a", "v", "iso"], "t": ["tt", "total", "p", "type", "tm", "e", "it", "at", "time", "h", "ct", "g", "td", " T", "ti", "tr", "dt", "w", "d", "q", "tw", "l", "ty", "vt", "tp", "tz", "ot", "nt", "to", "te", "tif", "tu", "a", "ta", "v", "ts", "tc", "wt", "T", "pt", "test", "size"], "n": ["ns", "p", "e", "ll", "nr", "an", "nc", "g", "ne", "name", "d", "sn", "cn", "na", "nz", "y", "names", "nb", "nor", "nu", "l", "np", "nl", "N", "ln", "nt", "ot", "v", "nn"], "i": ["gi", "ki", "hi", "ic", "li", "e", "it", "sim", "ri", "phi", "ei", "ti", "ini", "bi", "index", "si", "xi", "im", "mi", "multi", "y", "q", "ai", "cli", "me", "ip", "l", "gu", "pi", "di", "zi", "I", "a", "v", "yi", "ci"], "m": ["p", "count", "dm", "e", "ms", "cm", "mm", "h", "g", "w", "d", "mi", "y", "b", "M", "l", "mc", "mu", "mr", "v"]}}
{"code": " \\n  \\n  f = open(sys.argv[1],'r')\\n  \\n  num = int(f.readline())\\n  \\n  for i in range(num):\\n      q1 = int(f.readline())\\n      for j in range(4):\\n          if j+1 == q1:\\n              line1 = f.readline()\\n          else:\\n              f.readline()\\n      q2 = int(f.readline())\\n      for j in range(4):\\n          if j+1 == q2:\\n              line2 = f.readline()\\n          else:\\n              f.readline()\\n      line1 = [int(x) for x in line1.split()]\\n      line2 = [int(x) for x in line2.split()]\\n      count = 0\\n      for x in line1:\\n          if x in line2:\\n              count += 1\\n              y = x\\n      if count == 0:\\n          print 'Case #{}: Volunteer cheated!'.format(i+1)\\n      elif count == 1:\\n          print 'Case #{}: {}'.format(i+1, y)\\n      else:\\n          print 'Case #{}: Bad magician!'.format(i+1)\\n", "substitutes": {"f": ["ft", "fd", "p", "bf", "fx", "form", "fr", "df", "e", "t", "o", "ent", "fa", "fl", "h", "of", "cf", "window", "uf", "fo", "af", "rf", "fg", "ret", "exp", "fb", "w", "full", "lf", "tf", "sf", "u", "q", "wire", "F", "r", "xf", "fm", "ff", "b", "l", "buffer", "inf", "fed", "fast", "feed", "fp", "fac", "file", "fc", "fs", "c", "v", "fin", "fi", "fw", "good"], "num": ["total", "rem", "su", "col", "m", "no", "nine", "sim", "max", "nr", "n", "zero", "um", "mn", "om", "index", "na", "im", "multi", "nb", "nu", "nom", "np", "number", "NUM", "net", "nt", "nm", "th", "mult", "Num", "sum", "cal", "dim", "mod", "mon"], "i": ["gi", "hi", "ic", "p", "li", "it", "ia", "m", "ik", "sim", "id", "z", "g", "s", "phi", "ui", "ei", "chain", "info", "int", "ti", "ini", "bi", "index", "si", "xi", "im", "mi", "multi", "cli", "ai", "init", "b", "ip", "ori", "pi", "ii", "ij", "ix", "di", "I", "zi", "ind", "ci"], "q1": ["q5", " qOne", "querOne", "Q5", "qq2", "qu2", "qqOne", " q0", "quer0", "q101", "qq5", " q101", "qq1", "qq0", "quOne", "qq101", "Q2", "q0", "qu1", "Q1", "qOne", "quer1", "quer101", "QOne", "qu5"], "j": ["ji", "br", "p", "jj", "ju", "jl", "er", "it", "jp", "t", "o", "jo", "ah", "z", "n", "g", "ja", "org", "ng", "uj", "q", "json", "r", "J", "kj", "b", "dj", " Dj", "oj", "ij", "you", "job", "jc", "ver", "js", "jump", "ion", "jas", "iaz", "je", "v", "aj", "bj"], "line1": ["laneA", "blockOne", "line0", " line01", "lineFirst", "lock1", "LineFirst", "page1", "block2", "lineOne", "lineA", "blockFirst", "block1", "line11", "laneone", "lock11", "loopSingle", "Line2", "tie0", "band1", "lineone", "band11", "loop1", "loopFirst", "lineSingle", " lineA", "ineSingle", "loop2", "ineFirst", "pageone", "line01", "ine2", "lockOne", "tieFirst", "lane01", " line0", "page01", "Line1", "tie2", "tie1", " lineone", "ine1", "blockSingle", "bandOne", " lineFirst", "Line0", "lane1", "pageA", "block11"], "q2": ["dq1", "q5", "qq02", " qtwo", "dq2", "qq2", " q5", "query5", "quest6", " q02", "quest5", "questtwo", "quest2", "dq02", "qq1", "qtwo", " q6", "dqtwo", "q02", "qqtwo", "querytwo", "query2", "q6", "query6"], "line2": ["load4", "lock2", "line0", " line3", "LINE2", "load2", "block2", "LINE1", "LINEtwo", "loadall", "block0", "line256", "Line4", "ine3", "linkTwo", "lineall", "Line2", "lock0", "lockTwo", "eline22", "blockTwo", "elineall", "linetwo", "lock8", "link0", "Linetwo", "link8", "liner2", "block8", "eline4", " line4", "Line3", "ine2", "LINE4", "link2", "line8", "linerall", "ine256", "Line1", "ine1", "line4", " line256", "Line256", "liner4", "line22", "load22", " linetwo", "line3", "eline2", "liner22", "lineTwo"], "x": ["hex", "ux", "ft", "p", "xs", " cx", "check", "k", "e", "ctx", "X", "rx", "xes", "t", "wx", "dx", "xxx", "qu", "ax", "h", "ox", "key", "max", "z", "n", "xc", "g", "ross", "xa", " xx", "sex", "xt", "tx", "name", "mx", "w", "index", "xi", "q", "inx", "xf", "\u00e7", "cox", "l", "co", "xe", "lex", "ix", "yl", "xy", "ex", "px", "c", "nex", "xx", "v", "xml", "lat", "fx", "ci", "list"], "count": ["cz", "total", "match", "check", "type", "flag", "t", "cond", "depth", "ct", "key", "code", "n", "z", "Count", "conf", "frequency", "result", "index", "counter", "cache", "nb", "const", "ount", "hold", "cont", "ctr", "found", "l", "amount", "number", "cc", "cycle", "call", "nt", "list", "find", "ch", "add", "th", "cd", "length", "c", "gc", "weight", "sum", "test", "ind", "size", "status"], "y": ["vy", "gy", "col", "iy", "cy", "yy", "h", "ys", "key", "z", "ym", "ny", "ey", "uy", "oy", "my", "b", "sy", "ay", "ty", "fy", "Y", "sky", "ye", "yer", "yl", "xy", "ya", "dy", "c", "wy", "ry", "yi", "py"]}}
{"code": " \\n  def check_bounds(state, coord):\\n      if coord[0] < 0 or coord[1] < 0:\\n          return False\\n      elif coord[0] > (len(state) - 1):\\n          return False\\n      elif coord[1] > (len(state[coord[0]]) - 1):\\n          return False\\n      else:\\n          return True\\n  \\n  def clear(state, coord):\\n      for r in range(-1,2):\\n          for c in range(-1,2):\\n              row = coord[0] + r\\n              col = coord[1] + c\\n              if check_bounds(state, (row, col)):\\n                  state[row][col] = 0\\n  \\n  def count(state):\\n      return sum([sum(x) for x in state])\\n  \\n  def state_print(state):\\n      print(\"c\" + \"\".join([\"*\"  if x else \".\" for x in state[0][1:]]))\\n      for line in state[1:]:\\n          print(\"\".join([\"*\"  if x else \".\" for x in line]))\\n  \\n  def solve(state, mines):\\n      prev_state = deepcopy(state)\\n      for row in range(len(state)):\\n          for col in range(len(state[row])):\\n              new_state = deepcopy(state)\\n              clear(new_state, (row, col))\\n              c = count(new_state)\\n              if(c < mines):\\n                  state = prev_state\\n              elif( c == mines):\\n                  state_print(new_state)\\n                  return True\\n              else:\\n                  if col == len(state[row]) -2:\\n                      prev_state = deepcopy(state)\\n                  state = new_state\\n      print(\"Impossible\")\\n      return False\\n  \\n  \\n  \\n  \\n  def main():\\n      filename = \"C-small-attempt0.in\"\\n  \\n  \\n      inp = open(filename, \"rU\")\\n  \\n      n = int(inp.readline().strip())\\n  \\n      for case in range(1, n + 1):\\n          R, C, M = map(int, inp.readline().strip().split(\" \"))\\n          state = [[1 for x in range(C)] for y in range(R)]\\n          print(\"Case #{}:\".format(case))\\n          solve(state, M)\\n  \\n  main()\\n", "substitutes": {"state": ["clear", "p", "seed", "count", "er", "re", "base", "force", "store", "t", "area", "m", "code", "node", "null", "close", "name", "State", "rule", "see", "spec", "item", "trust", "progress", "local", "cache", "set", "there", "log", "port", "call", "sequence", "instance", "body", "output", "position", "iter", "debug", "length", "mem", "plot", "cell", "power", "hash", "policy", "step", "status", "color", "trans", "open", "go", "reg", "block", "that", "run", "remote", "loop", "action", "change", "sample", "commit", "config", "back", "target", "print", "out", "tag", "form", "story", "this", "update", "it", "history", "public", "zone", "resource", "event", "topic", "info", "conn", "STATE", "point", "dict", "table", "co", "draw", "runner", "map", "data", "now", "component", "pos", "queue", "cal", "test", "memory", "size", "stats", "range", "post", "next", "type", "frame", "space", "start", "note", "self", "all", "ace", "result", "index", "init", "core", "rect", "db", "stat", "unit", "value", "buffer", "un", "cycle", "order", "loc", "al", "st", "version", "trace", "scope", "states", "list"], "coord": ["Co", "func", "dc", "p", "tmp", "tag", "form", "dat", "word", "cmd", "cp", "store", "orig", "cur", "url", "block", "cart", "addr", "request", "resource", "ordinate", "mat", "address", "nc", "con", "tile", "req", "location", "inter", "cation", "pair", "cat", "result", "index", "local", "cache", "dim", "rect", "work", "prop", "grid", "aff", "align", "cor", "point", "deg", "co", "call", "cum", "ctrl", "loc", "position", "ord", "comb", "obj", "ver", "date", "ch", "pixel", "iter", "xy", "trace", "mate", "pos", "cal", "cell", "lat", "com", "mon", "num"], "r": ["res", "range", "br", "p", "j", "rc", "ref", "fr", "re", "e", "rs", "rx", "reg", "t", "m", "nr", "h", "ro", "run", "s", "g", "f", "ar", "w", "d", "q", "i", "l", "rr", "cr", "co", "rm", "v", "rd", "rt", "right", "pair"], "c": ["dc", "p", "j", "rc", "count", "e", "cp", "cut", "cm", "cy", "t", "m", "cur", "h", "ct", "lc", "z", "xc", "con", "s", "f", "cf", "nc", "conf", "g", "cos", "can", "capacity", "cat", "cu", "w", "d", "cn", "u", "q", "i", "cs", "cache", "cin", "const", "b", "ac", "cont", "unc", "l", "cr", "co", "cc", "cum", "cv", "ch", "cd", "ca", "ce", "gc", "v", "tc", "abc", "com", "ci"], "row": ["range", "post", "res", "br", "j", "race", "rc", "form", "bo", "ra", "frame", "re", "rs", "e", "column", "cur", "coll", "ob", "ser", "block", "ox", "rid", "ro", "key", "record", "run", "con", "week", "rown", "name", "tr", "index", "w", "user", "rank", "rot", "set", "sw", "rect", "var", "Row", "board", "co", "ow", "month", "order", "loc", "th", "box", "iter", "ows", "roll", "dr", "bar", "round", "rows", "ry", "arrow", "pos", "cell", "rt", "mod", "our", "num"], "col": ["br", "p", "cul", "act", "count", "COL", "cp", "cmd", "cy", "cut", "column", "cur", "coll", "client", "cond", "ct", "ox", "key", "cf", "nc", "con", "chron", "icol", "top", "Col", " Col", "cos", "pc", "char", "cat", "pr", "left", "rot", "ol", "var", "cor", "point", "cl", "port", "tab", "sect", "ctr", "co", "cycle", "nt", "loc", "min", "child", "ch", "ell", "th", "roll", "yl", "xy", "offset", "fc", "pos", "cell", "pt", "cal", "mon", "num"], "x": ["ux", "p", "ic", "xs", "act", "check", "e", "ctx", "X", "rx", "xes", "t", "wx", "rax", "dx", "xp", "qu", "ax", "ct", "ox", "h", "z", "xc", "s", "f", "xa", "xt", "tx", "mx", "w", "d", "cat", "xi", "q", "i", "_", "inx", "xf", "rit", "on", "l", "yx", "co", "xe", "xd", "ix", "rox", "xy", "yl", "ex", "px", "xx", "v", "xml", "lat", "xb", "fx", "ci"], "line": ["range", "Line", "j", "next", "fill", "e", "cy", "lin", "block", "ox", "run", "code", "nc", "ne", "con", "lo", "chain", "cat", "w", "ner", "change", "q", "ine", "cross", "write", "point", "l", "el", "val", "nl", "co", "cycle", "draw", "ln", "liner", "iter", "ce", "ex", "v", "lines", "pos", "cell", "text"], "mines": ["minsES", "minies", "MinES", "gences", "minces", "minseds", "MINES", "mindes", "genees", "versions", "minses", "minions", "Minies", "minES", "Minees", "Minces", "MINes", "minsies", "minists", "mineds", "genions", "mindeds", "Minions", "mindES", "genes", "versES", "Mines", " minees", "mindists", "MINeds", "minees", "verses", "minsists", "minsions", " minions", " minces", "versies", "MINists"], "prev_state": ["prev_State", "prev_config", "req_State", "prevxstate", "new_val", "new_stat", "prevxuser", "pre_State", "prevxState", "pre_state", "req_state", "req_states", "prev_states", "prevedstat", "prev_user", "req_config", "pre_user", "new_State", "prevedval", "prevxval", "prevedState", "prev_stat", "pre_val", "prevedstate", "prev_val"], "new_state": ["old2state", "new_start", "new____row", "new_instance", "old2start", "new_memory", " new_statement", "old_state", "newlymemory", "newptstate", "newptsample", "new_zone", "new_stat", "single_stat", "var_state", "single_zone", "new____State", "newlystate", "old2sample", "new____zone", "var_row", "new____state", "old_sample", "new2sample", "new____stat", " new_val", "new____mem", "var_mem", "newlyState", "newlyval", "new2instance", "new_mem", "new_statement", "new2start", " new_State", "single____State", "single____state", "old_instance", " new_memory", "single____zone", "newlyinstance", "new_sample", "old_start", "new_val", "newptinstance", "new_row", "newptstart", "newlystart", "single_state", "newlysample", "new____test", "single____stat", "single_State", "var_test", "new_State", "new_test", "new2state", "old2instance"], "filename": ["knife", "txt", "mson", "FN", "path", "wav", "udder", "lua", "files", "f", "til", "username", "name", "pak", "phy", "Filename", "description", "journal", "fle", "WHAT", "whatever", "fil", "network", "bite", "png", "mpeg", "pai", "directory", "upload", "nm", "sbm", "title", "SourceFile", "fp", "file", "FILE", "wine", "kl", "fn", "ename"], "inp": ["inm", "outsp", "interp", " inlike", "interctx", "Inp", "Insp", "erp", "inpr", "INq", "inctx", "Inctx", " insp", " inpr", "outf", "insp", "Inq", "interf", " inm", "winm", "INsp", "intersp", "outp", "Inf", "inf", "INp", "erpr", "erm", " inf", " inctx", "winlike", "winpr", "outq", "inq", "erlike", "INf", "inlike", "winp"], "n": ["ns", "p", "count", "t", "o", "m", "no", "nr", "z", "nc", "ne", "en", "name", "mn", "w", "sn", "na", "i", "nb", "nor", " N", "nu", "l", "network", "np", "nl", "number", "N", "net", "nt", "nn", "num"], "case": ["trial", "switch", "se", "p", "race", "count", "li", "cp", "key", "code", "pe", "ace", "example", "nce", "name", "chain", "cation", "condition", "use", "i", "set", "core", "catch", "mode", "me", "cor", "rand", "Case", "number", "co", "cycle", "instance", "cases", "ASE", "ase", "cd", "ce", "test", "size", "cas"], "R": ["Co", "D", "G", "X", "RA", "H", "U", "L", "E", "Q", "A", "CR", "B", "Res", "J", "V", "RO", "RS", "Row", "Y", "N", "NR", "RR", "K", "I", "RM", "P", "T", "S", "MR"], "C": ["Co", "D", "G", "O", "Ch", "X", "H", "L", "U", "A", "E", "CR", "CM", "B", "CS", "Cl", "F", "V", "Y", "N", "CO", "CP", "K", "I", "P", "W", "CU", "T", "S", "Cs"], "M": ["D", "G", "O", "H", "L", "m", "U", "E", "Q", "A", "CM", "MN", "B", "MM", "JM", "F", "J", "V", "Y", "N", "Ms", "MT", "MI", "I", "RM", "P", "Mc", "W", "MC", "T", "S", "MR"], "y": ["j", "cy", "o", "m", "yy", "h", "yr", "z", "yu", "ym", "ey", "w", "d", "oy", "my", "yn", "b", "ay", "Y", "cycle", "ch", "yl", "xy", "yd", "ry", "yi"]}}
{"code": " \\n  filename = \"A-small-attempt0.in\"\\n  \\n  inp = open(filename, \"rU\")\\n  \\n  n = int(inp.readline().strip())\\n  \\n  for case in range(1, n+1):\\n      gr = lambda x: [list(map(int, inp.readline().strip().split(\" \"))) for p in range(4)][x-1]\\n      ans1 = int(inp.readline().strip())\\n      row1 = set(gr(ans1))\\n      ans2 = int(inp.readline().strip())\\n      row2 = set(gr(ans2))\\n      sect = row1 & row2\\n      if len(sect) <= 0:\\n          print(\"Case #{}: Volunteer cheated!\".format(case))\\n      elif len(sect) == 1:\\n          print(\"Case #{}: {}\".format(case, sect.pop()))\\n      elif len(sect) > 1:\\n          print(\"Case #{}: Bad magician!\".format(case))\\n      else:\\n          print(\"ERROR\")\\n", "substitutes": {"filename": ["bf", "endix", "PDATE", "prefix", "txt", "mson", "FN", "path", "wav", "udder", "unction", "f", "username", "nil", "name", "nants", "phy", "Filename", "sf", "fle", "println", "fil", "nu", "bite", "AME", "itled", "directory", "wide", "upload", "nm", "alse", "sbm", "dra", "title", "SourceFile", "sword", "fp", "file", "FILE", "kl", "fn", "bestos", "ename"], "inp": [" Inm", "enp", "inm", "outsp", "inpp", "ainpi", "innq", "ainl", "intp", "insl", " inpm", "insf", "INm", "innpp", "ainpkg", " insp", "intpd", "kinpi", "outf", "insp", "kinl", " inpd", "innpd", "infp", " Inpart", " infp", "inspkg", "inpkg", "edInf", " Inf", "inspi", "ainp", "outp", "edInp", " inq", "inpart", "inpd", "insm", "inl", "edInps", "inf", "INp", " inps", "innp", "inpm", "innfp", "inspart", "inps", "INpart", "enq", "intq", "outps", "intpm", " inf", "kinp", "kinpkg", "enpp", "edInsp", "enfp", "inq", " Inp", "inpi", "innpm", "INf", " inpp"], "n": ["ns", "gn", "count", "nw", "t", "m", "no", "nr", "nc", "ne", "en", "name", "nan", "mn", "d", "sn", "cn", "na", "i", "r", "nb", "nu", "l", "network", "np", "nl", "x", "N", "nt", "net", "nia", "c", "nn", "num"], "case": ["switch", "campus", "se", "match", "race", "su", "count", "word", "li", "lic", "force", "prefix", "cp", "space", "time", "client", "block", "context", "pe", "patch", "ace", "example", "nce", "name", "chain", "rule", "section", "condition", "use", "sample", "line", "ine", "core", "me", "row", "cor", "point", "Case", "number", "cycle", "sequence", "instance", "age", "ch", "hyp", "profile", "cases", "ice", "ASE", "ase", "ce", "mate", "c", "ate", "pair", "test", "cas", "size", "num"], "gr": ["res", "range", "der", "br", "gn", "fr", "er", "gb", "reg", "lr", "mg", "g", "group", "gor", "Gr", "ptr", "forge", "mn", "arr", "tr", "pr", "gm", "set", "r", "pl", "rand", "cl", "mt", "mk", "rr", "hr", "usr", "sr", "gre", "ch", "GR", "gener", "dr", "map", "mr", "vr", "her", "ge", "alg", "gc", "gt", "ger", "gs"], "p": ["pat", "j", "k", "e", "cp", "t", "xp", "h", "pan", "ox", "pe", "g", "f", "pc", "w", "d", "pn", "ip", "point", "pid", "pa", "pp", "pen", "P", "par", "c", "pair"], "ans1": ["ransfirst", "ansfirst", "ions0", " ans0", "ions8", "ANS_", "antsfirst", "rans0", "an_", "rans8", "an0", "ants1", "ants0", "ionsfirst", "an2", "ans8", "ans0", "ANS0", "ans_", "ions1", "ANS2", " ans_", "ants8", "an1", "ANS1", "rans1"], "row1": [" row10", "ro1", "Row3", "rows01", "ro10", " row01", "row01", "rows1", "roOne", "ow4", "row10", "RowOne", "ow1", "row4", "rowOne", "Row1", "row3", "ow10", " row3", "ro4", " row4", "owOne", "rowsOne", "rows3", " rowOne", "Row01"], "ans2": ["anall", "ants32", "ans32", "annb", "ann32", "ants2", "ansall", "ann2", "anb", "ann1", "ANSall", "ansb", "an0", "ants1", "ants0", "an2", "ans0", "ANS2", "an32", "an1", "ANS1", "ann0", "annall", "ANSb"], "row2": ["rows2", "Row3", "row22", "ow22", "ow2", " row6", "rows4", "ow4", "roll4", "row4", "roll2", "rows02", "row6", "roll22", "Row4", "row3", "Row2", "row02", " row3", "Row02", " row4", " row02", "rows3", "ow6", "roll6", " row22"], "sect": ["se", "pat", "act", "sequ", "dat", "col", "part", "supp", "crit", "sector", "compl", "sel", "cur", "cond", "secure", "sub", "ct", "seq", "sql", "rent", "patch", "con", "eq", "cong", "subject", "section", "dl", "div", "rupt", "config", "pl", "pol", "sec", "cont", "tab", "sed", "ect", "dict", "sections", "mix", "qus", "adj", "ld", "st", "mut", "connect", "mult", "diff", "sq", "round", "said", "mod", "lat", "test", "dit", "sb", "sv"]}}
{"code": " \\n  def transpose(result, R, C):\\n  \tresultSplitted = result.split(\"\\n\")\\n  \taux = R*[\"\"]\\n  \tfor i in xrange(R):\\n  \t\tfor j in xrange(C):\\n  \t\t    aux[i] += resultSplitted[j][i]\\n  \t\taux[i] += \"\\n\"\\n  \tresult = \"\"\\n  \tfor item in aux:\\n  \t\tresult += item + \"\\n\"\\n  \treturn result.strip()\\n  \\n  \\n  inputFileName = sys.argv[1]\\n  \\n  f = file(inputFileName)\\n  fout = file(\"output.txt\", \"w\")\\n  \\n  T = int(f.readline())\\n  \\n  for case in xrange(T):\\n  \tdata = f.readline().strip().split(\" \")\\n  \tR = int(data[0])\\n  \tC = int(data[1])\\n  \tM = int(data[2])\\n  \\n  \tresult = \"\"\\n  \\n  \tx = min(R,C)\\n  \ty = max(R,C)\\n  \\n  \tif M > (y - 2)*x and M != y*x - 1:\\n  \t\tN = M - (y-2)*x\\n  \t\tif N%2 == 1 or y*x - M == 2:\\n  \t\t\tresult = \"Impossible\"\\n  \tif result != \"Impossible\":\\n  \t\ti = 0\\n  \t\twhile M > 0: # 2\\n  \t\t\tif i < y - 2:\\n  \t\t\t\tif M >= x:\\n  \t\t\t\t\tresult += x*\"*\" + \"\\n\"\\n  \t\t\t\t\tM -= x\\n  \t\t\t\t\ti += 1\\n  \t\t\t\telif M <= x - 2:\\n  \t\t\t\t\tresult += M*\"*\" + (x - M) * \".\" + \"\\n\"\\n  \t\t\t\t\tM = 0\\n  \t\t\t\t\ti += 1\\n  \t\t\t\telif i + 2 < y - 1:\\n  \t\t\t\t\tresult += (M-1)*\"*\" + (x - M + 1) * \".\" + \"\\n\" + \"*\" + (x-1)*\".\" + \"\\n\"\\n  \t\t\t\t\tM = 0\\n  \t\t\t\t\ti += 2\\n  \t\t\t\telse:\\n  \t\t\t\t\tresult = \"Impossible\"\\n  \t\t\t\t\tbreak\\n  \t\t\telse:\\n  \t\t\t\tif M%2 != 0:\\n  \t\t\t\t\tresult += x*\"*\" + \"\\n\"\\n  \t\t\t\t\tresult += (x-1)*\"*\" + \"c\"\\n  \t\t\t\telse:\\n  \t\t\t\t\tn = M/2\\n  \t\t\t\t\tresult += n*\"*\" + (x-n)*\".\" + \"\\n\"\\n  \t\t\t\t\tresult += n*\"*\" + (x-n-1)*\".\" + \"c\"\\n  \t\t\t\tM = 0\\n  \t\t\t\ti += 2\\n  \t\t\t\t\t\\n  \t\twhile i <= y - 1 and result != \"Impossible\":\\n  \t\t\tif i == y - 1:\\n  \t\t\t\tresult += (x-1)*\".\" + \"c\"\\n  \t\t\telse:\\n  \t\t\t\tresult += x*\".\" + \"\\n\"\\n  \t\t\ti += 1\\n  \t\\n  \tif R < C and result != \"Impossible\":\\n  \t\tresult = transpose(result, R, C)\\n  \\n  \tfout.write(\"Case #%d:\\n%s\\n\" %(case + 1, result))\\n", "substitutes": {"result": ["function", "p", "reverse", "the", "e", "command", "m", "error", "complete", "results", "grade", "term", "ret", "name", "full", "cache", "r", "successful", "row", "sequence", "output", "search", "description", "status", "match", "report", "prefix", "product", "sql", "final", "true", "summary", "number", "back", "RESULTS", "false", "out", "evaluate", "ME", "response", "answer", "reason", "total", "rc", "su", "root", "this", "package", "success", "asm", "example", "successfully", "Result", "table", "ULT", "make", "format", "new", "test", "comment", "res", "type", "expression", "ERROR", "relation", "buffer", "value", "order", "obj", "string", "OUT", "text", "message"], "R": ["Range", "D", "G", "X", "RA", "H", "U", "L", "CR", "A", "Q", "DR", "ro", "RC", "IR", "RF", "RG", "B", "Res", "SR", "RL", "AR", "Mr", "RGB", "RAM", "F", "r", "J", "V", "RO", "RS", "Rot", "Result", "Y", "NR", "RE", "TR", "GR", "RR", "Rs", "I", "RM", "P", "RT", "RI", "BR", "S", "MR", "Re"], "C": ["Co", "D", "G", "BC", "JC", "Ch", "X", "L", "CR", "E", "Q", "CM", "CN", "LC", "CS", "B", "CA", "CV", "CE", "Cl", "CC", "WC", "F", "J", "CON", "SC", "V", "EC", "Y", "CNN", "Cu", "CO", "CT", "VC", "CP", "CF", "DC", "I", "YC", "P", "CB", "c", "CL", "MC", "CU", "S", "Cs", "CW"], "resultSplitted": ["resultsplit", "ResultSplatted", "Resultsplited", "resultsplatted", "resultSplatted", "Resultsplatted", "resultPlited", " resultSplited", " resultSplit", "Resultsplotted", "resultSplotted", "resultSPotted", "Resultsplitted", "resultsplotted", "ResultSplotted", "resultSPited", "resultSPatted", "resultsplited", "resultPlatted", "resultPlitted", "resultSplited", "resultPlit", " resultSplatted", "ResultSplitted", "resultPlotted", "resultsplitted", "resultSplit", "resultSPitted", "ResultSplited"], "aux": ["au", "ux", "res", "args", "tmp", "finals", "rc", "iq", "buf", "aus", "rs", "xxx", "sup", "area", "foo", "array", "ox", "us", "conf", "final", "af", "tx", "axe", "ru", "extra", "names", "utils", "amps", "ai", "aos", "aff", "ras", " Aux", "external", "bs", "alias", "buff", "items", " auxiliary", "obj", "abs", "Items", "etc", "a", "ex", "jobs", "abc", "offs", "actions"], "i": ["ic", "p", "k", "li", "e", "it", "t", "o", "m", "ik", "h", "z", "n", "s", "id", "ti", "ini", "index", "si", "int", "bi", "xi", "im", "q", "mi", "r", "ai", "u", "multi", "ip", "l", "pi", "ii", "ij", "iu", "I", "a", "c", "v", "ir", "ind", "ci"], "j": ["ji", "p", "jj", "k", "jl", "li", "it", "jp", "t", "o", "z", "n", "g", " ii", "ja", "name", "jac", "bi", "si", "uj", "q", "left", "J", "kj", "b", "dj", "l", "oj", "ij", "job", "jc", "obj", "ix", "di", "jump", "c", "v", "aj", "bj", "ind"], "item": ["iq", "Item", "it", "ite", "area", "element", "what", "sim", "ox", "key", "aq", "option", "name", "index", "q", "im", "gem", "ai", "ue", " Item", "row", "unit", "ip", "value", "val", "oj", "instance", "items", "job", "obj", "ix", "iter", "mem", "anything", "mod", "inner", "other"], "inputFileName": ["InputFileName", "InputfilePath", "inputfilePath", "inputfileNames", "inputfileName", "inputFilenameLine", "inputStringFull", "outputFilenameNames", "inputFileNames", "InputFileNames", "inputFileLine", "inputFILEName", "inputStringLine", "inputFILEFull", "inputStringNames", "inputFileSystem", "inputStringName", "outputFileFull", "InputfileNames", "outputFileNames", "inputfileSystem", "InputFilePath", "inputFilePath", "inputFILEPath", "inputFilenameName", "InputfileSystem", "InputfileName", "outputFilenameName", "inputFilenameSystem", "outputFileLine", "inputFILESystem", "InputFileSystem", "inputFILELine", "inputFilenamePath", "inputFileFull", "outputFilenameLine", "outputFilenameFull", "inputFILENames", "inputFilenameNames", "outputFileName", "inputFilenameFull"], "f": ["ft", "fd", "p", "bf", "fr", "df", "e", "t", "o", "sp", "h", "of", "cf", "fo", "uf", "af", "fb", "w", "lf", "tf", "sf", "alf", "F", "r", "xf", "fm", "b", "l", "inf", "feed", "fp", "out", "file", "fc", "fs", "c", "v", "fn", "fa", "fw"], "fout": ["fOut", "dfin", "Fout", " fOut", "FOut", "fname", "Fname", "dfname", " fin", "fin", "dfout", " fname", "dfOut", "Fin"], "T": ["D", "O", "TI", "TT", "TN", "X", "t", "TM", "L", "TY", "E", "Q", "TL", "TH", "B", "TC", "TS", "TA", "F", "OT", "J", "V", "Y", "NT", "TB", "K", "I", "P", "W", "S"], "case": ["trial", "D", "li", "Item", "X", "time", "ox", "key", "z", "Test", " ii", "name", "ti", " trial", " J", " I", " ti", "J", "JD", "Z", " c", "Case", "job", "Ti", "P", "ta", "test", "S"], "data": ["values", "ns", "next", "ops", "done", "dat", "DATA", "bytes", "area", "times", "no", "block", "key", "zero", "window", "group", "raw", "keys", "chain", "ds", "info", "d", "sample", "dates", "apps", "cache", "json", "rew", "row", "val", "bits", "ata", "table", "rel", "mu", "items", "aw", "list", "vals", "new", "date", "feed", "pieces", "first", "series", "steps", "details", "Data", "filter", "step", "stats", "da"], "M": ["D", "G", "X", "H", "L", "m", "TM", "U", "E", "A", "Q", "CM", "MN", "NM", "B", "MM", "MX", "F", "J", "V", "Z", "Y", "MT", "MI", "K", "I", "P", "W", "DM", "MC", "MS", "S"], "x": ["p", "xs", "X", "rx", "t", "dx", "m", "L", "time", "ax", "h", "ox", "ct", "key", "z", "n", "tx", "xt", "int", "mx", "w", "d", "MX", "xi", "q", "width", "r", "l", "Y", "min", "ix", "xy", "length", "a", "ex", "c", "xx", "v", "text", "size"], "y": ["yt", "p", "gy", "type", " Y", "cy", "t", "o", "m", "ies", "yy", "h", "yr", "z", "n", "g", "hot", "ym", "ny", "ey", "uy", "w", "size", "my", "two", "r", "b", "year", "sy", "l", "ay", "ty", "Y", "sky", "ch", "height", "xy", "ya", "by", "a", "dy", "c", "v", "py"], "N": ["D", "O", "TN", "NA", "X", "H", "L", "E", "Q", "NS", "n", "NM", "Ns", "Ni", "F", "J", "V", "NT", "Y", "NR", "I", "P", "W", "Size", "NC", " n", "S", "NI"]}}
{"code": " \\n  inputFileName = sys.argv[1]\\n  \\n  f = file(inputFileName)\\n  fout = file(\"output.txt\", \"w\")\\n  \\n  T = eval(f.readline())\\n  \\n  for case in xrange(T):\\n  \\n  \tA1 = int(f.readline().strip())\\n  \\n  \tfor i in xrange(4):\\n  \t\tif i == A1 - 1:\\n  \t\t\tpossibles1 = f.readline().strip().split(\" \")\\n  \t\telse:\\n  \t\t\tf.readline().strip().split(\" \")\\n  \\n  \tA2 = int(f.readline().strip())\\n  \\n  \tfor i in xrange(4):\\n  \t\tif i == A2 - 1:\\n  \t\t\tpossibles2 = f.readline().strip().split(\" \")\\n  \t\telse:\\n  \t\t\tf.readline().strip().split(\" \")\\n  \\n  \tfinal = []\\n  \tfor item in possibles2:\\n  \t\tif item in possibles1:\\n  \t\t\tfinal.append(item)\\n  \\n  \tif len(final) == 0:\t\\n  \t\tfout.write(\"Case #%d: Volunteer cheated!\\n\" %(case + 1))\\n  \telif len(final) == 1:\\n  \t\tfout.write(\"Case #%d: %s\\n\" %(case + 1, final[0]))\\n  \telse:\\n  \t\tfout.write(\"Case #%d: Bad magician!\\n\" %(case + 1))\\n", "substitutes": {"inputFileName": ["InputFileName", "inputFileFile", "inputfileNames", "inputfilePath", "inputfileName", "InputFilenameFile", "setFILENow", "inputFileNames", "inputBaseName", "InputFileNames", "inputFILEName", "InputFilenameName", "setFileNow", "inputFilenameSet", "inputFILENow", "inputfileFile", "inputBaseSet", "inputFileSet", "inputFilenameFile", "setFileSet", "inputFILESet", "InputFileFile", "inputFilePath", "inputfileSet", "inputFILEPath", "inputFilenameName", "setFilePath", "InputFileSet", "inputFileNow", "setFILEName", "setFILESet", "inputfileNow", "setFILEPath", "setFileName", "InputFilenameNames", "inputFilenameNow", "inputBaseNames", "inputBaseFile", "inputFilenamePath", "inputFilenameNames", "InputFilenameSet"], "f": ["ft", "fd", "p", "bf", "fx", "ic", "form", "fr", "df", "e", "t", "o", "fe", "fl", "h", "of", "cf", "conf", "fo", "uf", "af", "rf", "fg", "fuel", "exp", "info", "fb", "w", "full", "lf", "tf", "sf", "F", "r", "xf", "fm", "ff", "b", "l", "inf", "fed", "input", "obj", "fast", "feed", "fp", "file", "fc", "fs", "c", "v", "fi", "fn", "fa", "alf"], "fout": ["wOut", "fenformat", "ffio", "ffinal", "ffoutput", "xfoutput", " fOut", "fdOut", "dwrite", "fclient", "fOut", "fio", "foutput", "dout", "f2", "wfinal", "fxfinal", "ifclient", "fxOut", "wwrite", "ffOut", " f2", "fd2", "fenout", "ifout", "ifOut", "dOut", "fdout", "fwrite", "xfOut", "fdclient", "fformat", "ifformat", "fxout", "fxwrite", "fenOut", "fx2", " fclient", "dfinal", " foutput", "wout", "fenclient", " fformat", "xfout", " fio", "ffout", "xfio", "fxclient"], "T": ["Time", "D", "G", "TT", "TN", "X", "t", "TM", "L", "A", "E", "Q", "Tab", "R", "B", "AT", "TC", "TS", "TA", "TIT", "F", "Tree", "V", "M", "Y", "Case", "NT", "N", "NB", "C", "Total", "I", "P", "Size", "S"], "case": ["trial", "p", "race", "pose", "li", "time", "ind", "client", "success", "code", "pe", "ace", "example", " CASE", "name", "chain", "cation", "pair", "section", "condition", "CE", "index", "int", "line", "core", "catch", "point", "Case", "x", "cycle", "sequence", "come", "position", "cases", "ice", "ASE", "trace", "ase", "ce", "ie", "c", "context", "test", "choice", "cas", "ci", "num"], "A1": [" A0", "A0", "S3", "B7", " A7", "Aone", "A4", " A3", "S1", " Aone", "S0", "AU4", "AUone", "S7", "B1", "A7", "B0", "Alpha1", "B3", "AU1", " A4", "A3", "Alpha4", "Alphaone"], "i": ["gi", "Si", "ki", "asi", "p", "ic", "li", "it", " di", "t", "ici", "iti", " ii", "phi", "il", "ti", "ini", "iat", "si", " Ai", "xi", "im", "mi", "ai", "ip", "ori", "pi", "oi", "aci", "ii", "ij", "ati", "Ti", "ice", "di", "Xi", "zi", "I", "c", "v", "ci"], "possibles1": ["pOSSibles2", "possibilities1", "possesses3", "pOSSible2", "possibleOne", "possessionenses2", "possessesOne", "possessioniblesAP", "possibles3", "possiblesOne", "possenses1", "possenses2", "possiblesAP", "possessionensesAP", "possesses1", "posseesOne", "possensesAP", "possessionibles1", "possible1", "possees3", "pOSSibleOne", "possees1", "pOSSiblesOne", "possibilitiesAP", "possees2", "possesses2", "pOSSibles3", "possibleAP", "possibilities2", "pOSSible3", "possible3", "possessionenses1", "pOSSible1", "possessionibles2", "possible2", "pOSSibles1"], "A2": ["AA6", "AA5", "T4", "TTwo", "Area4", "Area5", "A4", "T22", "AreaTwo", " A22", "T2", "Area6", "Area22", " ATwo", "AA22", " A5", "ATwo", " A4", "Area2", "A5", "AA2", "A22", " A6", "A6"], "possibles2": ["passibles0", "possibilities1", "possibles4", "possiors2", "passible1", "pensible1", "possibilities3", "passible2", "passible3", "possiors1", "possibles3", "possibilities4", "pensible3", "possees0", "passibles2", "passible0", "possible4", "possiors3", "passibles1", "possees3", "possible1", "possiors4", "possible0", "pensible4", "possees1", "pensibles3", "pensibles4", "passibles3", "possees2", "pensible2", "pensibles2", "possibilities2", "pensibles1", "possible3", "possibilities0", "possible2", "possibles0"], "final": ["empty", "res", "next", "total", "finals", "su", "finished", "end", "initial", "Final", "unique", "public", "standard", "secondary", "complete", "success", "results", "zero", "fine", "all", "general", "ret", "nil", "last", "important", "div", "result", "upper", "specific", "full", "holy", "local", "neutral", "des", "special", "successful", " finals", "val", "latest", "sofar", "after", "aux", "alse", "actual", "new", "fixed", "out", "data", "specified", "stable", "real", "quant", "we", "sold", "inal", "test", "valid", "serial", "temp", "good", "num"], "item": ["match", "p", "word", "li", "Item", "prefix", "it", "this", "issue", "other", "element", "what", "m", "key", "true", "option", "It", "name", "rule", "condition", "some", "index", "arg", "ti", "im", "set", "gem", "typ", "ip", "unit", "value", "val", "x", "instance", "items", "complex", "string", "title", "iter", "new", "mem", "ex", "ie", "cell", "test", "temp", "pair"]}}
{"code": " \\n  \\n  EOL = \"\\n\"\\n  \\n  \\n  def is_equal_approx(x, y, epsilon=1e-6):\\n      \"\"\"Returns True iff y is within relative or absolute 'epsilon' of x.\\n      \\n      By default, 'epsilon' is 1e-6.\\n      \"\"\"\\n      if -epsilon <= x - y <= epsilon:\\n          return True\\n  \\n      if -epsilon <= x <= epsilon or -epsilon <= y <= epsilon:\\n          return False\\n  \\n      return (-epsilon <= (x - y) / x <= epsilon\\n          or -epsilon <= (x - y) / y <= epsilon)\\n    \\n  def read_syms(fd):\\n      \"\"\"Read a line of whitespace separated symbols.\"\"\"\\n      return fd.readline().strip().split()\\n  \\n  def read_ints(fd):\\n      \"\"\"Read a line of whitespace separated integers.\"\"\"\\n      return [int(p) for p in read_syms(fd)]\\n  \\n  def read_floats(fd):\\n      \"\"\"Read a line of whitespace separated floats.\"\"\"\\n      return [float(p) for p in read_syms(fd)]\\n  \\n  \\n  class Mtrx(object):\\n      \"\"\"A matrix object.\"\"\"\\n      \\n      def __init__(self, rows, cols, data):\\n          assert len(data) == rows * cols\\n          self.rows = rows\\n          self.cols = cols\\n          self.data = data\\n          \\n      def cell(self, r, c):\\n          return self.data[r * self.cols + c]\\n      \\n      def getrow(self, i):\\n          return [self.cell(i, c) for c in xrange(self.cols)]\\n  \\n      def getcol(self, i):\\n          return [self.cell(c, i) for c in xrange(self.rows)]\\n      \\n      @classmethod\\n      def readfromfile(cls, fd, readfunc, rows=None, cols=None):\\n          \"\"\"Read matrix from file, assuming first line at location is `R C`.\\n          \\n          Return a new Mtrx object. Reading values is performed by the `readfunc`.\\n          Pre-determined size can be passed using `rows` and `cols`.\\n          \"\"\"\\n          data = []\\n          if rows is None:\\n              assert cols is None\\n              rows, cols = read_ints(fd)\\n          else:\\n              assert cols is not None\\n          for _ in range(rows):\\n              line = readfunc(fd)\\n              assert len(line) == cols\\n              data.extend(line)\\n          return Mtrx(rows, cols, data)\\n              \\n      @classmethod\\n      def read_int_matrix(cls, fd, rows=None, cols=None):\\n          return cls.readfromfile(fd, read_ints, rows, cols)\\n              \\n      @classmethod\\n      def read_sym_matrix(cls, fd, rows=None, cols=None):\\n          return cls.readfromfile(fd, read_syms, rows, cols)\\n              \\n      def __str__(self):\\n          res = \"\"\\n          for i in xrange(self.rows):\\n              res += str(self.getrow(i)) + EOL\\n          return res\\n      \\n      def __repr__(self):\\n          return \"{}({}, {}, {})\".format(self.__class__.__name__, self.rows,\\n                                         self.cols, self.data)\\n  \\n  \\n  cachetotals = 0\\n  cachemisses = 0\\n  \\n  def statreset():\\n      global cachemisses, cachetotals\\n      cachemisses = 0\\n      cachetotals = 0\\n  \\n  class memoizeit(object):\\n      \"\"\"Decorator. Caches a function's return value each time it is called.\\n      \\n      If called later with the same arguments, the cached value is returned \\n      (not reevaluated).\\n      \"\"\"\\n      \\n      def __init__(self, func):\\n          self.func = func\\n          self.cache = {}\\n          \\n      def __call__(self, *args):\\n          \\n          global cachetotals, cachemisses\\n          cachetotals += 1\\n          \\n          try:\\n              return self.cache[args]\\n          except KeyError:\\n              \\n              cachemisses += 1\\n              \\n              value = self.func(*args)\\n              self.cache[args] = value\\n              return value\\n          except TypeError:\\n  \\n              cachemisses += 1\\n  \\n              return self.func(*args)\\n      \\n      @property\\n      def __name__(self):\\n          return self.func.__name__\\n      \\n      def __get__(self, obj, objtype):\\n          \"\"\"Support instance methods.\"\"\"\\n          return functools.partial(self.__call__, obj)\\n  \\n  \\n  class timeit(object):\\n      \"\"\"Decorator that times a function.\\n      \\n      When function ends, print name, runtime, return value and cache stats.\\n      \"\"\"\\n      \\n      def __init__(self, func):\\n          self.func = func\\n          \\n      def __call__(self, *args):\\n          start = time.time()\\n          value = self.func(*args)\\n          delta = time.time() - start\\n          cachedata = (1 - cachemisses/(cachetotals * 1.0)) if \\\\n              cachetotals else 0\\n          print self.func.__name__, \"{:7.3f}s, (res: {}, cache: {:.2%})\".format(\\n              delta, value, cachedata)\\n          return value\\n      \\n      def __get__(self, obj, objtype):\\n          return functools.partial(self.__call__, obj)\\n  \\n  \\n  def read_input(filename):\\n      data = []\\n      with open(filename, \"r\") as f:\\n          cases = read_ints(f)[0]\\n          for _ in xrange(cases):\\n              case = {}\\n              case[\"R\"], case[\"C\"], case[\"M\"] = read_ints(f)\\n              data.append(case)\\n      return data\\n  \\n  def make_output(fname, output):\\n      CASE_PRFX = \"Case #%s: \"\\n      fname = fname + time.strftime(\"%H%M%S\") + \".out\"\\n      with open(fname, \"w\") as f:\\n          restext = []\\n          print \"Output content ===============\"\\n          for i, outdata in enumerate(output):\\n              line = CASE_PRFX % (i + 1,) + EOL + str(outdata) + EOL\\n              print line,\\n              restext.append(line)\\n          print \"=\" * 30\\n          f.writelines(restext)\\n  \\n  \\n  MINE = \"*\"\\n  CLICK = \"c\"\\n  UNK = \".\"\\n  \\n  class Board(object):\\n      \\n      def __init__(self, r, c):\\n          self.rows = r\\n          self.cols = c\\n          self.edge_row_idx = self.rows - 1\\n          self.edge_col_idx = self.cols - 1\\n          self.board = [[UNK for _ in xrange(c)] for _ in xrange(r)]\\n          self.board[0][0] = CLICK\\n  \\n      def fill_edge_row(self, m):\\n          i = self.edge_col_idx\\n          while m > 0 and i >= 0:\\n              self.board[self.edge_row_idx][i] = MINE\\n              i -= 1\\n              m -= 1\\n          self.edge_row_idx -= 1\\n  \\n      def fill_edge_col(self, m):\\n          i = self.edge_row_idx\\n          while m > 0 and i >= 0:\\n              self.board[i][self.edge_col_idx] = MINE\\n              i -= 1\\n              m -= 1\\n          self.edge_col_idx -= 1\\n  \\n      def __str__(self):\\n          return EOL.join([\"\".join(r) for r in self.board])\\n  \\n  @memoizeit\\n  def is_stage_solvable(rows, cols, mines):\\n      \"\"\"Return True iff stage is solvable. \\n      Also return fill instruction:\\n      0 if impossible/dontcare, 1 to fill row, 2 to fill column, \\n      3 for row special (most in the row), 4 for col special (most in the col)\\n      \"\"\"\\n      rc = rows * cols\\n      \\n      if mines == rc:\\n          return False, 0\\n  \\n      if rows == 1:\\n          return mines <= rc - 1, 2\\n      if cols == 1:\\n          return mines <= rc - 1, 1\\n      \\n      if mines == rc - 1:\\n          return True, 1  # doesn't matter what to fill\\n      \\n      if mines > rc - 4:\\n          return False, 0\\n      \\n      if rows == 2:\\n          return (False, 0) if mines == 1 else (True, 2)\\n      if cols == 2:\\n          return (False, 0) if mines == 1 else (True, 1)\\n          \\n      if rows <= cols:\\n          if mines >= rows:\\n              return True, 2\\n          if mines == rows - 1:\\n              if mines == cols - 1:\\n                  if rows == 3:\\n                      return False, 0\\n                  return True, 4 # L shape fill, most in the column\\n              else:\\n                  return True, 1 # fill row\\n          return True, 2 \\n      else:\\n          if mines >= cols:\\n              return True, 1\\n          if mines == cols - 1:\\n              if mines == rows - 1:\\n                  if cols == 3:\\n                      return False, 0\\n                  return True, 3 # L shape fill, most in the row\\n              else:\\n                  return True, 2 # fill column\\n          return True, 1 \\n  \\n  @timeit\\n  def solveit(case):\\n      rows = case[\"R\"]\\n      cols = case[\"C\"]\\n      mines = case[\"M\"]\\n      \\n      b = Board(rows, cols)\\n      r, c, m = rows, cols, mines\\n      \\n      while m >= 0:\\n          okgo, howtofill = is_stage_solvable(r, c, m)\\n          if not okgo:\\n              return \"Impossible\"\\n          if howtofill == 1: # fill row\\n              b.fill_edge_row(m)\\n              if m <= c:\\n                  break # fill and done\\n              m -= c\\n              r -= 1\\n          elif howtofill == 2: # fill column\\n              b.fill_edge_col(m)\\n              if m <= r:\\n                  break # fill and done\\n              m -= r\\n              c -= 1\\n          elif howtofill == 3: # L shape fill, most in the row\\n              b.fill_edge_row(m - 1)\\n              b.fill_edge_col(1)\\n              break # fill and done\\n          elif howtofill == 4: # L shape fill, most in the column\\n              b.fill_edge_col(m - 1)\\n              b.fill_edge_row(1)\\n              break # fill and done\\n          else:\\n              assert False\\n  \\n      return str(b) \\n  \\n  \\n  \\n  @timeit\\n  def main(fname):\\n      data = read_input(fname)\\n      output = []\\n      for case in data:\\n          statreset() # reset cache stats\\n          res = solveit(case)\\n          output.append(res)\\n      make_output(fname, output)\\n  \\n  \\n  if __name__ == '__main__':\\n      main(\"C-small-attempt0.in\")\\n", "substitutes": {"EOL": ["NOT", "EOT", "LOL", "BAL", "NOF", "BOT", "LAL", "LOF", "LOT", "NAL", "NOL", "EAL", "BOL", "EOF", "BOF"], "x": ["ux", "hex", "j", "xs", "e", "xxxx", "xxxxxxxx", "rx", "X", "xxx", "wx", "o", "dx", "xp", "your", "time", "ax", "ct", "ox", "h", "z", "n", "xc", "window", "xa", "tx", "xt", "mx", "w", "xi", "on", "l", "yx", "xe", "xd", "step", "ix", "xy", "px", "ex", "xx", "xml", "v", "lat", "text", "fx", "zx"], "y": ["vy", "yt", "j", "gy", "e", "iy", "cy", "t", "o", "ies", "yy", "yr", "ox", "ys", "h", "z", "n", "s", "hot", "ym", "ny", "axy", "ey", "uy", "oy", "my", "b", "yz", "sy", "l", "ay", "fy", "Y", "ly", "sky", "ye", "yer", "yl", "xy", "yd", "ya", "v", "yi", "py"], "epsilon": ["epssilons", "epssilor", "epssiloni", "epchlorons", "psin", " epsiloner", "epdelayond", "ependixon", "epsilone", "epsilons", "epphaloning", "epsiloni", "epSiloton", " epphaloff", "epSilon", "epiphanyone", "epslon", "epfoloner", "psiy", "epspelloff", "epsiond", " epiphanyoner", " epphalon", "epspellor", "epilony", "epsil\u00f3n", "epiloton", "epsellons", "psilone", "epSiloni", "epchlorON", "epchlorone", "epssiln", "epsilond", "epsiON", "epSilons", "epschloroni", "epsior", "epdelayy", "psilon", "epchlorony", "psion", " epsiloning", "epticon", "epsalon", "epphalor", " epphalor", "epsaloner", "psilON", " epsilON", " epfoloner", "psiond", "epSilor", " epsilons", "epssilON", "epfolont", "psien", "epiphanyons", "epmilon", "epsellon", "psily", "epphalon", "epsin", "epspellon", "epsiloton", "epiphanyoner", "epilont", "epsiloff", "epsellony", "epSil\u00f3n", "epliton", "epssilon", " epiphanyons", "eplitor", "epsiloning", "epSiln", " epsiloff", "epmilone", " epfolON", "epiphanyon", "epssiloner", "epchlor\u00f3n", "epticON", "eptyy", "epsilony", "epphaloton", "epilon", "epschlorons", "epschlorn", "epslON", "epsilON", "epsiy", "epsiln", " epsilont", "epphaloner", " epsilor", "epphalons", "epmilON", "epssil\u00f3n", "epSilony", "epilor", "epslont", "eplitoning", " epiphanyone", "epsione", "eplitoff", " epfolont", "epsloner", "epticons", "epsilont", "epchloron", "epsell\u00f3n", "epschlorony", "epsien", "epschlor\u00f3n", "epschloron", "psilen", "epsily", "epslons", "ependixoni", "epSiloner", "epsilor", "psione", " epsilone", "eptyond", "epsions", " epiphanyon", "epmiln", "ependixn", "epsalony", "epsiloner", "epsion", "eptyen", "epticoner", "psiON", "epilON", "epphalony", "epphaloff", " epphaloning", " epfolon", "psilond", "epdelayen", "epsilen", "epchloroner", "epdelayon", "epfolon", "epilons", "epspelloning", "epfolON", "epSilone", "epssilony", "epiloner", "eptyon", "epsiony", "epchlorn", "epssiloton", "epchloroni", "psiln"], "fd": ["ft", "ped", "bf", "pd", "fr", "form", "df", "wd", "sd", "dial", "dat", "buf", "hd", "uds", "ud", "fl", "handler", "disk", "dump", "cf", "uf", "td", "f", "kt", "fred", "fb", "dl", "ctl", "d", "ad", "lf", "tf", "dt", "gd", "ini", "dd", "fm", "ff", "db", "FH", "fil", "gz", "wind", "fax", "pid", "buff", "ld", "ln", "stream", "fed", " fid", "tif", "dra", "format", "fp", "cd", "fc", "vd", "file", "fs", "fin", "rd", "handle", "fn", "fx", "dir", "FD", "bd", "nd", "pdf"], "p": ["ap", "post", "op", "type", "e", "cp", "part", "ps", "jp", "t", "sp", "h", "pre", "z", "n", "s", "g", "f", "yp", "osp", "pc", "ph", "w", "d", "pr", "q", "pn", "u", "lp", "pol", "b", "ep", "ip", "l", "rep", "np", "tp", "pid", "pi", "pa", "gp", "pp", "mp", "fp", "P", "a", "tap", "v", "dp", "pos", "wp", "pt", "php"], "self": ["app", "empty", "tmp", "se", "python", "console", "error", "h", "results", "close", "spec", "w", "full", "ng", "q", "local", "user", "eth", "help", "log", "ae", "instance", "attr", "body", "review", "mp", "debug", "quick", "diff", "views", "details", "handle", "partial", "private", "agg", "cmp", "rb", "final", "s", "raw", "parent", "left", "json", "dd", "config", "parts", "rel", "pkg", "deep", "th", "print", "resp", "also", "xml", "response", "context", "small", "nd", "form", "this", "history", "public", "info", "wn", "conn", "my", "sw", "work", "expr", "pp", "add", "new", "round", "test", "right", "next", "ref", "api", "space", "rs", "client", "request", "all", "ren", "dev", "subject", "init", "me", "cl", "sh", "chart", "nt", "md", "ml", "object", "py", "Self"], "rows": ["images", "issues", "col", "times", "obs", "packages", "of", "results", "bys", "ips", "blocks", "ls", "keys", "ports", "users", "ors", "ords", "docs", "ins", "row", "mins", "ow", "to", "views", "OWS", "length", "void", "tracks", "uploads", "rules", "months", "xs", "dat", "relations", "ids", "modules", "s", "ios", "files", "headers", "rown", "grades", "names", "each", "boxes", "fields", "reports", "np", "groups", "bs", "owners", "items", "members", "points", "types", "projects", "ows", "tests", "heads", "ns", "values", "ks", "form", "ores", "levels", "uds", "words", "grow", "ds", "reads", "dates", "sw", "ods", "classes", "cells", "ros", "resources", "checks", "format", "pages", "lines", "olds", "type", "rs", "roots", "errors", "ws", "uns", "tr", "faces", "index", "forms", "orders", "cs", "runs", "workers", "cont", "days", "sections", "text", "xy", "get", "frames", "jobs", " row", "rw", "posts"], "cols": [" colains", "columns", " coles", "COLps", "colsys", "colsets", "colS", "cles", "ilS", " colats", "rounds", "columnains", "locsys", " colensions", "columnabs", " colps", "roundabs", "buts", "ilsys", "columnsets", "columnensions", "cryptains", "butashes", " colgs", "columnms", "colashes", "columnS", "ctabs", " colsets", "columnats", "pooli", "COLs", "columni", "clS", "ils", "colensions", "clals", "columngs", "poolts", "roundS", " colts", "coli", "pools", "clgs", " colots", "coln", "colles", "columnps", " Colps", "colots", " colashes", "rowssets", "locs", "ctS", "colts", "columnsys", "cts", "crypts", "colats", "collS", "col2", "locms", " coli", "colps", "roundts", "Cols", " col2", "poolps", "clots", "rowsts", "cryptps", "il2", " Colensions", "columnts", "collps", " coln", "loces", "coles", "colains", "collats", " colals", "columnashes", "rowsS", "COLes", "iln", "Colts", "colls", "ctts", "butes", "ilms", "ColS", "butS", "ct2", "colms", "ctn", " Coles", "colabs", " colS", "colals", "iles", "COLts", "Colgs", "rowss", "cryptS", "columnes", " Cols", "columnots", "colgs", "columnals", "COLS"], "data": ["empty", "images", "initial", "bytes", "what", "times", "results", "blocks", " DATA", "name", "users", "d", "row", "to", "list", "batch", "length", "actions", "partial", "comments", "done", "dat", "missing", "reg", "block", "raw", "params", "apps", "names", "json", "reports", "rel", "groups", "items", "points", "feed", "out", "series", "Data", "values", "this", "DATA", "history", "public", "array", "zero", "n", "info", "na", "content", "cells", "dict", "table", "draw", "format", "new", "map", "lines", "size", "next", "all", "csv", "errors", "result", "index", "buffer", "ata", "mu", "options", "xy", "trace", "steps", "text", "da"], "r": ["br", "j", "er", "fr", "re", "e", "rs", "h", "nr", "ro", "rid", "rb", "n", "R", "f", "ri", "ar", "ru", "q", "row", "hr", "cr", "rel", "sr", "dr", "mr", "rd", "rt", "ir", "right"], "c": ["dc", "ic", "k", "col", "e", "cp", "li", "cm", "cut", "t", "o", "cur", "lc", "ct", "h", "cf", "n", "s", "con", "nc", "f", "xc", "g", "cos", "pc", "cat", "cu", "d", "arc", "u", "sc", "cs", "ec", "uc", "cin", "b", "ac", "cont", "cl", "l", "unc", "cr", "co", "cc", "ch", "C", "ca", "fc", "ce", "a", "v", "tc", "ir", "ci"], "i": ["gi", "ic", "j", "li", "e", "it", "o", "ik", "h", "id", "iri", "s", "f", "ri", "chain", "pc", "info", "int", "ti", "ini", "index", "si", "d", "xi", "u", "mi", "cin", "ai", "cli", "b", "ip", "cor", "l", "pi", "ii", "ij", "iu", "oi", "ch", "ix", "di", "dr", "I", "ie", "ir", "ci"], "cls": ["CLis", "lassns", "lassts", "lasss", "decls", "CLs", "classt", " clt", " clp", "clis", " clls", "CLps", "declps", "classic", "clls", "declns", " clns", "classs", "clt", " clic", "Clps", " clps", " clis", "clp", "clps", "CLts", "clic", "lassps", "lassp", "Clis", "CLls", "classts", " clts", "lassic", "clns", "Cls", "Clp", "Clls", "clts", "Clts", "lasst"], "readfunc": [" readval", "findval", "readval", "writefac", "writefunction", " readfun", "readunc", "getfun", "getfunction", "findfunc", "writefun", " readfac", "findunc", "writefunc", " readfunction", "findfunction", "getfac", "readfac", "writeunc", "getfunc", "readfunction", "readfun", " readunc", "writeval"], "_": ["ct", "mat", "all", "int", "set", "val", "ix", "ex", "non", "valid"], "line": ["se", "Line", "detail", "next", "word", "frame", "cmd", "part", "command", "lin", "column", "LINE", "block", "record", "code", "lo", "raw", "chain", "page", "char", "lf", "sample", "ine", "dd", "entry", "byte", "link", "row", "log", "l", "nl", "ln", "pipe", "string", "inline", "file", "lines", "handle", "text", "cell", "pair"]}}
{"code": " \\n  \\n  EOL = \"\\n\"\\n  \\n  \\n  def is_equal_approx(x, y, epsilon=1e-6):\\n      \"\"\"Returns True iff y is within relative or absolute 'epsilon' of x.\\n      \\n      By default, 'epsilon' is 1e-6.\\n      \"\"\"\\n      if -epsilon <= x - y <= epsilon:\\n          return True\\n  \\n      if -epsilon <= x <= epsilon or -epsilon <= y <= epsilon:\\n          return False\\n  \\n      return (-epsilon <= (x - y) / x <= epsilon\\n          or -epsilon <= (x - y) / y <= epsilon)\\n    \\n  def read_syms(fd):\\n      \"\"\"Read a line of whitespace separated symbols.\"\"\"\\n      return fd.readline().strip().split()\\n  \\n  def read_ints(fd):\\n      \"\"\"Read a line of whitespace separated integers.\"\"\"\\n      return [int(p) for p in read_syms(fd)]\\n  \\n  def read_floats(fd):\\n      \"\"\"Read a line of whitespace separated floats.\"\"\"\\n      return [float(p) for p in read_syms(fd)]\\n  \\n  class Mtrx(object):\\n      \"\"\"A matrix object.\"\"\"\\n      \\n      def __init__(self, rows, cols, data):\\n          assert len(data) == rows * cols\\n          self.rows = rows\\n          self.cols = cols\\n          self.data = data\\n          \\n      def cell(self, r, c):\\n          return self.data[r * self.cols + c]\\n      \\n      def getrow(self, i):\\n          return [self.cell(i, c) for c in xrange(self.cols)]\\n  \\n      def getcol(self, i):\\n          return [self.cell(c, i) for c in xrange(self.rows)]\\n      \\n      @classmethod\\n      def readfromfile(cls, fd, readfunc, rows=None, cols=None):\\n          \"\"\"Read matrix from file, assuming first line at location is `R C`.\\n          \\n          Return a new Mtrx object. Reading values is performed by the `readfunc`.\\n          Pre-determined size can be passed using `rows` and `cols`.\\n          \"\"\"\\n          data = []\\n          if rows is None:\\n              assert cols is None\\n              rows, cols = read_ints(fd)\\n          else:\\n              assert cols is not None\\n          for _ in range(rows):\\n              line = readfunc(fd)\\n              assert len(line) == cols\\n              data.extend(line)\\n          return Mtrx(rows, cols, data)\\n              \\n      @classmethod\\n      def read_int_matrix(cls, fd, rows=None, cols=None):\\n          return cls.readfromfile(fd, read_ints, rows, cols)\\n              \\n      @classmethod\\n      def read_sym_matrix(cls, fd, rows=None, cols=None):\\n          return cls.readfromfile(fd, read_syms, rows, cols)\\n              \\n      def __str__(self):\\n          res = \"\"\\n          for i in xrange(self.rows):\\n              res += str(self.getrow(i)) + EOL\\n          return res\\n      \\n      def __repr__(self):\\n          return \"{}({}, {}, {})\".format(self.__class__.__name__, self.rows,\\n                                         self.cols, self.data)\\n  \\n               \\n  cachetotals = 0\\n  cachemisses = 0\\n  \\n  def statreset():\\n      global cachemisses, cachetotals\\n      cachemisses = 0\\n      cachetotals = 0\\n  \\n  class memoizeit(object):\\n      \"\"\"Decorator. Caches a function's return value each time it is called.\\n      \\n      If called later with the same arguments, the cached value is returned \\n      (not reevaluated).\\n      \"\"\"\\n      \\n      def __init__(self, func):\\n          self.func = func\\n          self.cache = {}\\n          \\n      def __call__(self, *args):\\n          \\n          global cachetotals, cachemisses\\n          cachetotals += 1\\n          \\n          try:\\n              return self.cache[args]\\n          except KeyError:\\n              \\n              cachemisses += 1\\n              \\n              value = self.func(*args)\\n              self.cache[args] = value\\n              return value\\n          except TypeError:\\n  \\n              cachemisses += 1\\n  \\n              return self.func(*args)\\n      \\n      @property\\n      def __name__(self):\\n          return self.func.__name__\\n      \\n      def __get__(self, obj, objtype):\\n          \"\"\"Support instance methods.\"\"\"\\n          return functools.partial(self.__call__, obj)\\n  \\n  class timeit(object):\\n      \"\"\"Decorator that times a function.\\n      \\n      When function ends, print name, runtime, return value and cache stats.\\n      \"\"\"\\n      \\n      def __init__(self, func):\\n          self.func = func\\n          \\n      def __call__(self, *args):\\n          start = time.time()\\n          value = self.func(*args)\\n          delta = time.time() - start\\n          cachedata = (1 - cachemisses/(cachetotals * 1.0)) if \\\\n              cachetotals else 0\\n          print self.func.__name__, \"{:7.3f}s, (res: {}, cache: {:.2%})\".format(\\n              delta, value, cachedata)\\n          return value\\n      \\n      def __get__(self, obj, objtype):\\n          return functools.partial(self.__call__, obj)\\n  \\n", "substitutes": {"EOL": ["NOT", "EOT", "LOL", "BAL", "NOF", "BOT", "LAL", "LOF", "LOT", "NAL", "NOL", "EAL", "BOL", "EOF", "BOF"], "x": ["ux", "hex", "j", "xs", "e", "xxxx", "xxxxxxxx", "rx", "X", "xxx", "wx", "o", "dx", "xp", "your", "time", "m", "ax", "ct", "ox", "h", "z", "n", "xc", "window", "xa", "tx", "xt", "mx", "w", "xi", "on", "l", "yx", "xe", "xd", "step", "ix", "xy", "px", "ex", "xx", "xml", "v", "lat", "text", "fx", "zx"], "y": ["vy", "yt", "j", "gy", "e", "iy", "cy", "t", "o", "ies", "yy", "yr", "ox", "ys", "h", "z", "n", "s", "hot", "ym", "ny", "axy", "ey", "uy", "oy", "my", "b", "yz", "sy", "l", "ay", "fy", "Y", "ly", "sky", "ye", "yer", "yl", "xy", "yd", "ya", "v", "yi", "py"], "epsilon": ["epssilons", "epssilor", "epssiloni", "epchlorons", "psin", " epsiloner", "epdelayond", "ependixon", "epsilone", "epsilons", "epphaloning", "epsiloni", "epSiloton", " epphaloff", "epSilon", "epiphanyone", "epslon", "epfoloner", "psiy", "epspelloff", "epsiond", " epiphanyoner", " epphalon", "epspellor", "epilony", "epsil\u00f3n", "epiloton", "epsellons", "psilone", "epSiloni", "epchlorON", "epchlorone", "epssiln", "epsilond", "epsiON", "epSilons", "epschloroni", "epsior", "epdelayy", "psilon", "epchlorony", "psion", " epsiloning", "epticon", "epsalon", "epphalor", " epphalor", "epsaloner", "psilON", " epsilON", " epfoloner", "psiond", "epSilor", " epsilons", "epssilON", "epfolont", "psien", "epiphanyons", "epmilon", "epsellon", "psily", "epphalon", "epsin", "epspellon", "epsiloton", "epiphanyoner", "epilont", "epsiloff", "epsellony", "epSil\u00f3n", "epliton", "epssilon", " epiphanyons", "eplitor", "epsiloning", "epSiln", " epsiloff", "epmilone", " epfolON", "epiphanyon", "epssiloner", "epchlor\u00f3n", "epticON", "eptyy", "epsilony", "epphaloton", "epilon", "epschlorons", "epschlorn", "epslON", "epsilON", "epsiy", "epsiln", " epsilont", "epphaloner", " epsilor", "epphalons", "epmilON", "epssil\u00f3n", "epSilony", "epilor", "epslont", "eplitoning", " epiphanyone", "epsione", "eplitoff", " epfolont", "epsloner", "epticons", "epsilont", "epchloron", "epsell\u00f3n", "epschlorony", "epsien", "epschlor\u00f3n", "epschloron", "psilen", "epsily", "epslons", "ependixoni", "epSiloner", "epsilor", "psione", " epsilone", "eptyond", "epsions", " epiphanyon", "epmiln", "ependixn", "epsalony", "epsiloner", "epsion", "eptyen", "epticoner", "psiON", "epilON", "epphalony", "epphaloff", " epphaloning", " epfolon", "psilond", "epdelayen", "epsilen", "epchloroner", "epdelayon", "epfolon", "epilons", "epspelloning", "epfolON", "epSilone", "epssilony", "epiloner", "eptyon", "epsiony", "epchlorn", "epssiloton", "epchloroni", "psiln"], "fd": ["ft", "ped", "bf", "pd", "fr", "form", "df", "wd", "sd", "dial", "dat", "buf", "hd", "uds", "ud", "fl", "handler", "disk", "dump", "cf", "uf", "td", "f", "kt", "fred", "fb", "dl", "ctl", "d", "ad", "lf", "tf", "dt", "gd", "ini", "dd", "fm", "ff", "db", "FH", "fil", "gz", "wind", "fax", "pid", "buff", "ld", "ln", "stream", "fed", " fid", "tif", "dra", "format", "fp", "cd", "fc", "vd", "file", "fs", "fin", "rd", "handle", "fn", "fx", "dir", "FD", "bd", "nd", "pdf"], "p": ["ap", "post", "op", "type", "e", "cp", "part", "ps", "jp", "t", "m", "sp", "h", "pre", "z", "n", "s", "g", "f", "yp", "osp", "pc", "ph", "w", "d", "pr", "q", "pn", "u", "lp", "pol", "b", "ep", "ip", "l", "rep", "np", "tp", "pid", "pi", "pa", "gp", "pp", "mp", "fp", "P", "a", "tap", "v", "dp", "pos", "wp", "pt", "php"], "self": ["app", "empty", "tmp", "se", "python", "console", "error", "h", "results", "close", "spec", "w", "full", "ng", "q", "local", "user", "eth", "help", "log", "ae", "instance", "attr", "body", "review", "output", "mp", "debug", "quick", "diff", "views", "details", "handle", "partial", "private", "agg", "cmp", "rb", "final", "s", "raw", "parent", "left", "json", "dd", "config", "parts", "rel", "pkg", "deep", "th", "print", "resp", "also", "xml", "response", "context", "small", "nd", "form", "this", "history", "public", "info", "wn", "conn", "my", "sw", "work", "expr", "pp", "add", "new", "round", "test", "right", "next", "ref", "api", "space", "rs", "client", "request", "all", "ren", "dev", "subject", "init", "me", "cl", "sh", "chart", "nt", "md", "ml", "object", "py", "Self"], "rows": ["images", "issues", "col", "times", "obs", "packages", "of", "results", "bys", "ips", "blocks", "ls", "keys", "ports", "users", "ors", "ords", "docs", "ins", "row", "mins", "ow", "to", "views", "OWS", "length", "void", "tracks", "uploads", "rules", "months", "xs", "dat", "relations", "ids", "modules", "s", "ios", "files", "headers", "rown", "grades", "names", "each", "boxes", "fields", "reports", "np", "groups", "bs", "owners", "items", "members", "points", "types", "projects", "ows", "tests", "heads", "ns", "values", "ks", "form", "ores", "levels", "uds", "words", "grow", "ds", "reads", "dates", "sw", "ods", "classes", "cells", "ros", "resources", "checks", "format", "pages", "lines", "olds", "type", "rs", "roots", "errors", "ws", "uns", "tr", "faces", "index", "forms", "orders", "cs", "runs", "workers", "cont", "days", "sections", "text", "xy", "get", "frames", "jobs", " row", "rw", "posts"], "cols": [" colains", "columns", " coles", "COLps", "colsys", "colsets", "colS", "cles", "ilS", " colats", "rounds", "columnains", "locsys", " colensions", "columnabs", " colps", "roundabs", "buts", "ilsys", "columnsets", "columnensions", "cryptains", "butashes", " colgs", "columnms", "colashes", "columnS", "ctabs", " colsets", "columnats", "pooli", "COLs", "columni", "clS", "ils", "colensions", "clals", "columngs", "poolts", "roundS", " colts", "coli", "pools", "clgs", " colots", "coln", "colles", "columnps", " Colps", "colots", " colashes", "rowssets", "locs", "ctS", "colts", "columnsys", "cts", "crypts", "colats", "collS", "col2", "locms", " coli", "colps", "roundts", "Cols", " col2", "poolps", "clots", "rowsts", "cryptps", "il2", " Colensions", "columnts", "collps", " coln", "loces", "coles", "colains", "collats", " colals", "columnashes", "rowsS", "COLes", "iln", "Colts", "colls", "ctts", "butes", "ilms", "ColS", "butS", "ct2", "colms", "ctn", " Coles", "colabs", " colS", "colals", "iles", "COLts", "Colgs", "rowss", "cryptS", "columnes", " Cols", "columnots", "colgs", "columnals", "COLS"], "data": ["empty", "images", "initial", "bytes", "what", "times", "results", "blocks", " DATA", "name", "users", "d", "row", "to", "list", "batch", "output", "length", "actions", "partial", "comments", "done", "dat", "missing", "reg", "block", "raw", "params", "apps", "names", "json", "reports", "rel", "groups", "items", "points", "feed", "out", "series", "Data", "values", "this", "DATA", "history", "public", "array", "zero", "n", "info", "na", "content", "cells", "dict", "table", "draw", "format", "new", "map", "lines", "size", "next", "all", "csv", "errors", "result", "index", "buffer", "ata", "mu", "options", "xy", "trace", "steps", "text", "da"], "r": ["br", "j", "rc", "er", "fr", "re", "e", "rs", "m", "h", "nr", "ro", "rid", "rb", "n", "R", "f", "ri", "ar", "ru", "q", "row", "hr", "cr", "rel", "sr", "dr", "mr", "rd", "rt", "ir", "right"], "c": ["dc", "ic", "rc", "k", "col", "e", "cp", "li", "cm", "cut", "t", "o", "m", "cur", "lc", "ct", "h", "cf", "n", "s", "con", "nc", "f", "xc", "g", "cos", "pc", "cat", "cu", "d", "arc", "u", "sc", "cs", "ec", "uc", "cin", "b", "ac", "cont", "cl", "l", "unc", "cr", "co", "cc", "ch", "C", "ca", "fc", "ce", "a", "v", "tc", "ir", "ci"], "i": ["gi", "ic", "j", "li", "e", "it", "o", "ik", "h", "id", "iri", "s", "f", "ri", "chain", "pc", "info", "int", "ti", "ini", "index", "si", "d", "xi", "u", "mi", "cin", "ai", "cli", "b", "ip", "cor", "l", "pi", "ii", "ij", "iu", "oi", "ch", "ix", "di", "dr", "I", "ie", "ir", "ci"], "cls": ["CLis", "lassns", "lassts", "lasss", "decls", "CLs", "classt", " clt", " clp", "clis", " clls", "CLps", "declps", "classic", "clls", "declns", " clns", "classs", "clt", " clic", "Clps", " clps", " clis", "clp", "clps", "CLts", "clic", "lassps", "lassp", "Clis", "CLls", "classts", " clts", "lassic", "clns", "Cls", "Clp", "Clls", "clts", "Clts", "lasst"], "readfunc": [" readval", "findval", "readval", "writefac", "writefunction", " readfun", "readunc", "getfun", "getfunction", "findfunc", "writefun", " readfac", "findunc", "writefunc", " readfunction", "findfunction", "getfac", "readfac", "writeunc", "getfunc", "readfunction", "readfun", " readunc", "writeval"], "_": ["ct", "mat", "all", "int", "set", "val", "ix", "ex", "non", "valid"], "line": ["se", "Line", "detail", "next", "word", "frame", "cmd", "part", "command", "lin", "column", "LINE", "block", "record", "code", "lo", "raw", "chain", "page", "char", "lf", "sample", "ine", "dd", "entry", "byte", "link", "row", "log", "l", "nl", "ln", "pipe", "string", "inline", "file", "lines", "handle", "text", "cell", "pair"]}}
{"code": " \\n  \\n  \\n  directions = list(itertools.product([1, 0, -1], [1, 0, -1]))\\n  def count_neighbors(table, r, c):\\n      cols = len(table[0])\\n      rows = len(table)\\n      return sum(table[r + x][c + y] == \"*\" for x, y in directions \\n                  if r + x >= 0 and c + y >= 0 and cols > c + y and rows > r + x)\\n  \\n  def is_valid(table):\\n      cols = len(table[0])\\n      rows = len(table)\\n      for r in xrange(rows):\\n          for c in xrange(cols):\\n              has_zero = any(table[r + x][c + y] == 0 for x, y in directions \\n                              if r + x >= 0 and c + y >= 0 and cols > c + y and rows > r + x)\\n              if table[r][c] != \"*\" and not has_zero:\\n                  return False\\n  \\n      return True\\n  \\n  \\n  def draw_table(table, hide=False):\\n      cols = len(table[0])\\n      rows = len(table)\\n      ascii_table = \"\"\\n      for r in xrange(rows):\\n          for c in xrange(cols):\\n              if table[r][c] != \"*\":\\n                  ch = \"c\" if r == 0 and c == 0 else \".\"\\n                  table[r][c] = count_neighbors(table, r, c) if not hide else ch\\n  \\n              ascii_table += str(table[r][c])\\n  \\n          ascii_table += \"\\n\"\\n  \\n      return ascii_table[:-1]\\n  \\n  def solve(R, C, M):\\n      r = c = 0\\n      current_mines = R * C\\n      table = [[\"*\"] * C for k in xrange(R)]\\n      while M < current_mines:\\n          if table[r][c] == '*':\\n              table[r][c] = \".\"\\n              current_mines -= 1\\n  \\n          if current_mines > M and r + 1 < R and table[r+1][c] == \"*\":\\n              table[r+1][c] = \".\"\\n              current_mines -= 1\\n  \\n          draw_table(table)\\n          c += 1\\n          if c >= C:\\n              c = 0\\n              r += 1\\n  \\n      return table\\n  \\n  for i in xrange(readint()):\\n      R, C, M = readintarray()\\n  \\n      print \"Case #%d:\" % (i + 1)\\n      if M < (R * C) - 1:\\n          table = solve(R, C, M)\\n          if is_valid(table):\\n              print draw_table(table, hide=True)\\n          else:\\n              table = solve(C, R, M)\\n              rotated = [[\"*\"] * C for k in xrange(R)]\\n              for r in xrange(R - 1, -1, -1):\\n                  for c in xrange(C):\\n                      rotated[R - r - 1][c] = table[c][r]\\n  \\n              print draw_table(rotated, hide=True) if is_valid(rotated) else \"Impossible\"\\n  \\n      elif M == R * C:\\n          print \"Impossible\"\\n  \\n      else:\\n          table = [[\"*\"] * C for k in xrange(R)]\\n          table[0][0] = '.'\\n          print draw_table(table, hide=True)\\n", "substitutes": {"directions": ["directications", "governions", " directensions", "directensions", "directives", " directications", "governion", "Direction", "selectors", "projectors", "direction", "projection", "irectensions", "suggestion", "suggestions", "irectications", "directtions", "Directors", "draftensions", "governifiers", "draftories", "selection", "governtions", "suggestifiers", "projectives", "selectives", "irectories", "directors", "directifiers", "directories", "Directions", "draftions", "irections", "suggesttions", "selections", "Directtions", "draftications", "Directives", "Directifiers", " directories", "projections"], "table": ["empty", "function", "tmp", "console", "count", "t", "article", "error", "term", "option", "toc", "see", "page", "user", "cache", "module", "row", "port", "html", "sequence", "body", "tree", "batch", "template", "position", "output", "normal", "Table", "cell", "inner", "report", "source", "minute", "block", "problem", "key", "record", "td", "chain", "change", "tf", "summary", "json", "config", "expected", "number", "out", "attribute", "filter", "total", "form", "this", "column", "transform", "time", "history", "display", "public", "array", "style", "database", "TABLE", "info", "journal", "year", "point", "dict", "collection", "server", "query", "document", "file", "data", "stable", "minimum", "comment", "type", "frame", "note", "panel", "variable", "csv", "section", "result", "tr", "index", " Table", "entry", "interface", "db", "view", "scroll", "tab", "buffer", "chart", "figure", "qualified", "trace", "model", "text", "able", "list"], "r": ["p", "rem", "er", "fr", "re", "e", "t", "lr", "m", "h", "max", "rg", "ar", "item", "w", "d", "pr", "q", "row", "rar", "sr", "attr", "to", "vr", "a", "rn", "ir", "adr", "o", "ro", "run", "record", "rb", "id", "remote", "ru", "u", "rr", "hr", "rel", "dr", "mr", "v", "ry", "br", "rc", "root", "this", "err", "it", "n", "g", "f", "l", "rd", "right", "res", "range", "j", "ra", "rs", "rx", "nr", "rid", "self", "ren", "rl", "art", "result", "tr", "rect", "kr", "b", "cr", "usr", "rm", "rt"], "c": ["p", "count", "col", "e", "cut", "t", "m", "cur", "h", "bc", "code", "con", "ar", "name", "pc", "w", "cod", "d", "cb", "q", "_", "cache", "void", "cd", "fc", "ca", "ce", "gc", "ci", "cp", "lc", "ct", "cf", "cam", "nc", "conf", "chain", "cu", "u", "sc", "vc", "cin", "cc", "mc", "v", "rc", "cy", "z", "n", "g", "f", "arc", "cn", "ec", "ac", "join", "cor", "content", "l", "co", "more", "dc", "ic", "cm", "csv", "category", "can", "only", "cs", "uc", "b", "\u00e7", "cont", "cl", "unc", "cr", "chart", "tc", "com"], "cols": [" colings", "tabs", "columns", " colords", "coljs", " coles", "tabx", " colx", "COLs", "colds", "columnjs", "colS", " colses", "cmdjs", "Cols", "columnx", "llgs", "columngs", "ColS", " coljs", "llS", "columnses", "llings", "colx", "columnings", "columnords", "cmds", "colings", "Colords", "COLses", "llds", " colS", "cmdes", "columnS", "Colds", "colses", "tabgs", "tabes", "Colgs", "columnes", " colgs", "Coles", "cmdgs", "coles", "columnds", "colgs", "lls", " colds", "colords", "COLS"], "rows": ["values", "heads", "months", "images", "issues", "rs", "ms", "relations", "uds", "opens", "obs", "ways", "es", "ys", "results", "bys", "modules", "s", "ios", "files", "roots", "blocks", "papers", "rown", "ports", "rices", "users", "flows", "outs", "dates", "orders", "cs", "runs", "reads", "workers", "docs", "row", "boxes", "cells", "days", "fields", "reports", "bs", "posts", "groups", "rates", "ros", "ris", "sections", "orts", "types", "rooms", "ows", "views", "pages", "frames", "allows", "lines", "jobs", "ries", "eeks", "uploads", "tracks", "states", "tests"], "x": ["ux", "j", "xs", "col", "ctx", "X", "rx", "xes", "wx", "dx", "xp", "time", "element", "column", "ax", "ct", "ox", "h", "z", "path", "xc", "s", " X", "xa", " xx", "id", "image", "xt", "tx", "exp", "exclusive", "item", "w", "index", "mx", "gal", "xi", "left", "width", "axis", "cross", "sw", "row", "content", "yx", "ext", " dx", "lex", "xe", "xd", "ix", "xy", "px", "ex", "xx", "xml", "v", "lat", "fx", "step"], "y": ["vy", "yout", "yt", "j", "hy", "gy", "type", "col", "iy", "cy", "t", "io", "very", "ies", "client", "hey", "yy", "sim", "yr", "ys", "key", "z", "s", "hot", "ym", "ny", "ey", "uy", "oy", "my", "yn", "b", "ip", "yz", "sy", "content", "ay", "fy", "ty", "l", "ly", "Y", "kit", "sky", "ye", "yer", "yl", "xy", "ya", "yd", "dy", "sys", "v", "ry", "wy", "yi", "py"], "has_zero": ["hasnonzero", "has_one", "hasnonequal", " has_equal", "hasnonone", "hasnonZero", "has_equal", " has_Zero", "has_Zero", " has_one"], "hide": ["label", "clear", "ide", "isl", "leave", "frame", "pose", "Hidden", "err", "remove", "display", "h", "hid", "shown", "hover", "ride", "close", "see", " Hide", "use", "change", "set", " show", "visible", "scroll", "late", "hold", "hidden", "home", "Hide", "enable", "bid", "spin", "skip", "disable", "include", "reve", "Show", "ignore", "plot", "shadow", "free", "bare", "show"], "ascii_table": ["ascipi2buffer", "asciini_binary", "ascii8total", "ascipi_buffer", "ascii2Table", "ascipi2table", "asciiAuthdatabase", "asciiPTable", "ascii2table", "asciic8total", "ascii8Table", "asciic8stable", "ascipi_Table", "asciic_buffer", "ascipi2Table", "asciic_total", "ascii_stable", "asciiPbuffer", "ascipi_table", "ascii_Table", "ascii_buffer", "asciini_Table", "ascii_binary", "ascii2file", "ascii64database", "ascii64connection", "asciiPbinary", "ascii2buffer", "asciic_database", "asciini_buffer", "ascipi2file", "ascii64table", "asciiAuthconnection", "asciic_connection", "asciic8table", "asciiPtable", "asciic_Table", "ascii_database", "asciiAuthbuffer", "ascii_file", "asciic_stable", "ascii_total", "ascipi_file", "ascii8stable", "ascii8table", "asciini_table", "ascii64buffer", "asciiAuthtable", "ascii_connection", "asciic8Table", "asciic_table"], "ch": ["br", "j", "cho", "Ch", "och", "form", "str", "chn", "ih", "cur", "h", "ich", "how", "tch", "z", "f", "char", "he", "pr", "change", "kh", "q", " Ch", "b", "CH", "cl", "chi", "channel", "l", "sh", "text", "cht", "sch", "ech", "chid", "hair", "th", "chan", "che", "ach", "cell", "case"], "R": ["D", "G", "O", "X", "RA", "H", "L", "CR", "Q", "E", "DR", "B", "Mr", "F", "J", "V", "RO", "RS", "Row", "Y", "N", "NR", "RE", "TR", "GR", "RR", "Rs", "K", "I", "RM", "P", "RT", "T", "BR", "S", "MR"], "C": ["D", "G", "O", "BC", "CD", "COR", "X", "L", "U", "CR", "E", "A", "CM", "CN", "B", "CS", "CC", "F", "V", "EC", "Y", "N", "CT", "DC", "K", "I", "P", "W", "MC", "CU", "T", "S", "Cs"], "M": ["D", "G", "O", "AM", "Max", "H", "L", "m", "TM", "U", "E", "Q", "A", "CM", "CR", "MN", "NM", "B", "MM", "F", "J", "V", "RS", "Y", "N", "RE", "MI", "RR", "Rs", "K", "I", "RM", "P", "OR", "Ma", "DM", "W", "MC", "T", "S", "MR"], "current_mines": ["current_donions", "current_terminions", "current_menies", "current_minsions", "current_mesodes", "current_terminutes", "current_genions", "current_terminies", "current_meses", "current_mineions", "current_donets", "current_minutes", "current_menions", "current_minues", "current_minees", "current_mineores", "current_monues", "current_minores", "current_minies", "current_genues", "current_minsutes", "current_monutes", "current_minses", "current_mones", "current_genes", "current_minsues", "current_Minutes", "current_Minets", "current_mesutes", "current_mineets", "current_monions", "current_genries", "current_minsries", "current_minries", "current_dones", "current_monets", "current_minsets", "current_minions", "current_minsores", "current_mesions", "current_menutes", "current_monries", "current_donores", "current_minets", "current_Minodes", "current_Minions", "current_menes", "current_Mines", "current_minsies", "current_minodes", "current_termines", "current_minsodes"], "k": ["br", "fr", "rec", "m", "yr", "an", "rac", "n", "g", "ur", "run", "ar", "ru", "w", "cu", "pr", "tr", "ket", "b", "cr", "co", "th", "actor", "rd", "ach", "ak", "ir"]}}
{"code": " \\n  def readint():\\n      return int(sys.stdin.readline())\\n  \\n  def readintarray():\\n      return map(int, sys.stdin.readline().strip().split())\\n  \\n  def readpairs(start=0):\\n      elems = readintarray()[start:]\\n      return [elems[i:i+2] for i in xrange(0, len(elems), 2)]\\n  \\n  def readstring():\\n      return sys.stdin.readline()[:-1]\\n  \\n", "substitutes": {"start": ["pause", "next", "p", "origin", "shift", "root", "trans", "count", "end", "base", " Start", "part", "it", "begin", "sp", "stop", "z", "top", "art", "send", "index", "size", "set", "init", "current", "starting", "skip", "st", "add", "step", "offset", "first", "pos", "Start", "say"], "elems": [" elets", " elels", " elemes", "plems", "plets", "elecs", " elecs", "elemas", "elemn", " eleems", " elemn", "Elets", "elels", " elemas", "Elems", "Elemes", "eleems", "lemems", "plemn", "elets", "plels", "lemls", "Eleems", "lemcs", "elemes", "lemms", "lemmes", "lemmn", "Elemas", "Elecs", "lemmas", "lemts"], "i": ["gi", "ji", "hi", "p", "ic", "j", "uri", "li", "it", "id", "n", "s", "ui", "phi", "ei", "ti", "ini", "index", "si", "xi", "im", "mi", "y", "\u0438", "cli", "ai", "ip", "x", "pi", "ii", "ij", "iu", "oi", "ix", "iter", "di", "zi", "I", "c", "ind", "ci"]}}
{"code": " \\n  \\n  ncases = int(sys.stdin.readline().strip())\\n  \\n  def print_board(r, c, free):\\n      board = {}\\n      for row in range(0, r):\\n          board[row] = {}\\n          for col in range(0, c):\\n              board[row][col] = '*'\\n  \\n      pending = free\\n  \\n      if free == 1:\\n          board[0][0] = '.'\\n      elif r == 1 or c == 1:\\n          for row in range(0, r):\\n              for col in range(0, c):\\n                  if pending > 0:\\n                      pending -= 1\\n                      board[row][col] = '.'\\n      else:\\n          for row in range(0,2):\\n              for col in range(0,2):\\n                  board[row][col] = '.'\\n          pending -= 4\\n          col=2\\n          row=2\\n  \\n          while pending >= 2 and (col<c or row<r):\\n              if pending >= 2 and col<c:\\n                  board[0][col] = '.'\\n                  board[1][col] = '.'\\n                  col += 1\\n                  pending -= 2\\n              if pending >= 2 and row<r:\\n                  board[row][0] = '.'\\n                  board[row][1] = '.'\\n                  row += 1\\n                  pending -= 2\\n  \\n          for row in range(2, r):\\n              for col in range(2, c):\\n                  if pending > 0:\\n                      board[row][col] = '.'\\n                      pending -= 1\\n  \\n      board[0][0] = 'c'\\n  \\n      for row in range(0, r):\\n          line = ''\\n          for col in range(0, c):\\n              line += board[row][col]\\n          print(line)\\n  \\n  \\n  for t in range(1, ncases+1):\\n      values = sys.stdin.readline().strip().split()\\n      r = int(values[0])\\n      c = int(values[1])\\n      m = int(values[2])\\n  \\n      cells = r * c\\n      free = cells - m\\n  \\n      possible = False\\n  \\n      if r == 1 or c == 1:\\n          if free >= 1:\\n              possible = True\\n      elif r == 2 or c == 2:\\n          if free == 1 or (free >= 4 and free%2 == 0):\\n              possible = True\\n      else:\\n          if free == 1 or (free >= 4 and free != 5 and free != 7):\\n              possible = True\\n  \\n      print(\"Case #{0}:\".format(t))\\n  \\n      if possible:\\n          print_board(r, c, free)\\n      else:\\n          print(\"Impossible\")\\n", "substitutes": {"ncases": ["ecums", "uncases", "bcades", "ncasing", "NCases", "NCleases", "NCase", "ncleases", "ecases", "bcase", "NCums", "uncleases", "ncades", "bcasing", "ecase", "uncades", "bcases", "uncums", "ncums", "uncase", "NCades", "uncasing", "ecleases", "ncase", "NCasing"], "r": ["res", "range", "br", "p", "j", "rc", "ra", "er", "k", "re", "fr", "rs", "reg", "rec", "o", "nr", "h", "ro", "rid", "rg", "run", "n", "rb", "g", "z", "R", "f", "ri", "ar", "name", "ru", "w", "d", "pr", "u", "i", "kr", "ran", "b", "rator", "l", "rr", "cr", "hr", "rar", "co", "x", "sr", "attr", "dr", "mr", "a", "rn", "v", "rd", "rt", "rw", "ir", "right"], "c": ["res", "dc", "p", "ic", "rc", "k", "re", "cp", "e", "cm", "o", "cur", "lc", "ct", "bc", "h", "cf", "n", "s", "con", "g", "f", "cation", "pc", "cu", "d", "w", "cb", "sc", "u", "cs", "cache", "ec", "q", "cin", "_", "i", "y", "b", "ac", "l", "cr", "co", "x", "cc", "mc", "ch", "C", "ca", "fc", "ce", "a", "v", "tc", "cell", "com", "ci"], "free": ["empty", "clear", "used", "store", "bytes", "ent", "le", "domain", "alloc", "mouse", "max", "none", "reset", "code", "fine", "con", "ne", "use", "released", "full", "cache", "F", "blank", "when", "occupied", "bill", "filled", "Free", "clean", "min", "mem", "floor", "broad", "cell", "num", "done", "open", "Left", "no", "vol", "cold", "usage", "left", "score", "out", "Now", "confirmed", "valid", "FREE", "prime", "total", "rozen", "zero", "f", "conn", "current", "When", "grid", "co", "net", "new", "mate", "stable", "available", "All", "size", "res", "range", "next", "type", "note", "fail", "off", "index", "dead", "fee", "buffer", "float", "release", "un", "N", "locked", "OK", "ready", "non"], "board": ["flo", "bit", "form", "bo", "word", "foot", "lock", "deck", "oard", "public", "block", "disk", "ro", "layout", "zero", "past", "control", "database", "lib", "league", "ui", "chain", "book", "test", "uno", "loop", "boat", "lay", "pb", "rot", "builder", "blank", "bishop", "cross", "pad", "hold", "bank", "player", "buffer", "poll", "bang", "bench", "table", "pool", "co", "buff", "sequence", "anks", "front", "plate", "body", "back", "boards", "door", "box", "boarding", "runner", "ward", "bet", "Board", "bar", "bird", "mate", "bro", "student", "bug", "design", "bot", "bd", "square"], "row": ["re", "ob", "week", "node", "con", "name", "page", "item", "user", "ram", "ow", "batch", "height", "box", "void", "arrow", "cell", "num", "day", "bo", "prefix", "no", "coll", "block", "ox", "ro", "key", "run", "record", "id", "raw", "rown", "lay", "rank", "left", "rot", "sc", "byte", "rel", "th", "ows", "out", "ry", "hour", "rc", "form", "root", "rec", "column", "zero", "group", "f", "grow", "sw", "role", "Row", "co", "server", "x", "draw", "month", "runner", "ward", "bar", "round", "pos", "right", "our", "dir", "res", "post", "range", "next", "type", "frame", "off", "rid", "lo", "tr", "index", "entry", "rect", "scroll", "tab", "order", "loc", "roll", "rows", "list"], "col": ["label", "p", "cul", "win", "count", "chlor", "li", "foot", "cut", "lr", "cur", "fix", "con", "cos", "name", "pc", "char", "cat", "pr", "comp", "prop", "el", "ctrl", "fol", "box", "fc", "ill", "cell", "handle", "mon", "num", "color", "day", "word", "COL", "cp", "fl", "coll", "ct", "ox", "key", "cf", "chron", "icol", "field", "left", "rot", "rol", "on", "rel", "pool", "ell", "ch", "child", "pt", "gall", "ht", "pat", "str", "dial", "ll", "crypt", "column", "cond", "path", "n", "f", "ctl", "il", "coord", "y", "ol", "ac", "cor", "l", "channel", "co", "x", "table", "draw", "len", "ont", "pos", "aj", "cal", "fn", "dir", "res", "city", "act", "ref", "cmd", "crit", "Col", "int", "tr", "scroll", "cl", "val", "tab", "nt", "loc", "obj", "roll", "ind"], "pending": ["jpender", "npused", "preended", "psending", "spaged", " pension", "Pending", "psension", "opending", "preossible", "pused", " pressed", "Pended", "ipended", "Penny", "tpends", "npushing", "Pender", "ipender", "tpender", "spossible", " pended", "jpend", "npended", "npinning", "pinning", "pends", "pender", "ipending", "opossible", "preending", "penny", "opended", "prend", "spended", "Pend", "ipends", " pushing", " pused", " pinning", "prended", "praged", "Pension", "pension", "ppended", "paged", "Possible", "jpends", "jpended", "pressed", "jpending", "psressed", "preends", "prending", "spend", "npend", "spushing", "pended", "psossible", "ppushing", "tpended", "psended", "Pends", "psends", " pend", "spenny", "opends", "spending", "Pused", "npending", "pend", "Paged", "pushing", "opused", "Pinning", "ppending", "ppend", "jpossible", "Pushing", "Pressed", "tpending", "prenny", "opender", "prossible"], "line": ["range", "label", "Line", "day", "ide", "frame", "base", "lin", "column", "le", "eline", "LINE", "block", " Line", "online", "path", "code", "lo", "chain", "page", "lay", "ine", "user", "lane", "email", "mode", "link", "log", "limit", "point", "l", "buffer", "channel", "text", "ln", "liner", "string", "phrase", "out", "file", "inline", "lines", "cell", "lock", "comment", "pair"], "t": ["total", "e", "cut", "time", "token", "ct", "mat", "n", "td", "con", "f", "top", "let", "tr", "w", "counter", "y", "i", "set", "ket", "typ", "l", "table", "to", "mut", "ter", "mult", "out", "tc"], "values": ["lists", "makes", "weights", "bes", "settings", "ms", "ings", "times", "players", "years", "places", "iques", "results", "words", "ays", "blocks", "ples", "ports", "flows", "forms", "dates", "ires", "changes", "vi", "plays", "value", "maps", "days", "pins", "groups", "measures", "codes", "Values", "qs", " Values", "items", "points", "ices", "phones", "vs", "vals", "seconds", "states", "als", "tests", "ums", "terms", "frames", "ses", "series", "lines", "objects", "details", "videos", "icks", "actions"], "m": ["range", "p", "j", "mid", "count", "tm", "re", "e", "ms", "cm", "mol", "mat", "n", "mb", "z", "s", "f", "w", "d", "size", "i", "mi", "y", "b", "M", "l", "mc", "sm", "md", "rm", "mem", "mate", "rows", "v", "mod", "cell", "mon", "num"], "cells": ["res", "ns", "ms", "ells", "cm", "n", "files", "blocks", "keys", "faces", "oms", "flows", "outs", "cs", "mi", "runs", "ods", "parts", "gets", "classes", "cats", "mins", "bs", "hands", "items", "types", "points", "resources", "locks", "cons", "tones", "odes", "frames", "shots", "rows", "lines", "cell", "offs", "ones", "size", "num"], "possible": ["plosed", " possibly", "npossible", "repossibility", "paired", "plossibly", "npused", "repossibly", "pvalid", "reposed", "spossibility", " possibility", "repuppet", " pvalid", "repvalid", "spvalid", "spended", "pended", "posed", "Paired", " puppet", " pused", "repossible", "pused", " paired", "pluppet", " posed", "Possible", "Possibility", "spossible", "npaired", " pended", "Pused", "npossibility", "possibly", "puppet", "plossible", "repended", "possibility"]}}
{"code": " \\n  \\n  ncases = int(sys.stdin.readline().strip())\\n  \\n  def read_arrangement():\\n      arr = []\\n      for row in range(0,4):\\n          arr.append(sys.stdin.readline().strip().split(' '))\\n      return arr\\n  \\n  for t in range(1, ncases+1):\\n      answer1 = int(sys.stdin.readline().strip())\\n      arrang1 = read_arrangement()\\n      answer2 = int(sys.stdin.readline().strip())\\n      arrang2 = read_arrangement()\\n  \\n      row1 = arrang1[answer1-1]\\n      row2 = arrang2[answer2-1]\\n  \\n      intersect = set(row1) & set(row2)\\n  \\n      if len(intersect) == 1:\\n          print(\"Case #{0}: {1}\".format(t, intersect.pop()))\\n      elif len(intersect) == 0:\\n          print(\"Case #{0}: Volunteer cheated!\".format(t))\\n      else:\\n          print(\"Case #{0}: Bad magician!\".format(t))\\n", "substitutes": {"ncases": ["nages", "nnase", "cnaves", "nases", "NCases", "NCaves", "cnaps", "NCase", "NCages", "naps", "ncaps", "ncages", "cnases", "nnaps", "cnages", "ncaves", "nnages", "nase", "cnase", "naves", "ncase", "nnases"], "arr": ["res", "br", "bl", "avi", "fr", "dat", "buf", "str", "err", "rs", "img", "wx", "agg", "cur", "coll", "array", "z", "wav", "all", "ret", "ar", "aa", "Ar", " narr", "aaa", "ply", "pr", "arc", "lay", "r", "pl", "rep", "buff", "Array", "alph", " rearr", "elt", "ray", "list", "obj", "air", "ARR", "dr", "resp", "gr", "data", "plot", "ave", "ab", "our"], "row": ["rc", "col", "ou", "fl", "ob", "key", "ro", "rid", "rown", "rowd", "um", "lay", "set", "sw", "r", "val", "ay", "x", "ow", "usr", "ver", "ows", "roll", "rows", "ry", "cell", "sel", "num"], "t": ["tt", "p", "j", "type", "e", " typ", "it", "at", "o", " term", "m", "txt", "h", "n", "term", " T", "s", "f", " each", "det", "g", "ret", "name", "int", "ti", "tr", "dt", "w", "d", "q", "u", "y", "i", "ut", "r", "ab", "typ", "tw", "l", "ty", "tz", "x", "ot", "to", "te", "tree", "st", "title", "tor", "format", " ot", "tu", "ta", "c", "v", "wt", "tc", "ts", "T", "pt", "test"], "answer1": ["replyFirst", "reply01", "answerFirst", "row01", " answerOne", "order01", "answer01", "answer91", " answer01", "reply1", "rowOne", "response91", "answerOne", "response01", "response2", "order1", "response1", "responseFirst", "orderFirst", "responseOne", "reply91", "order91"], "arrang1": ["arrung2", "arrgateOne", "arrungOne", "alphang2", "grag3", "arrangle1", "arrangal", "arragOnce", "gragOne", "arrgate2", "alphangal", "arrangleal", "arrangle2", "arrgate1", "arrgate3", "arrANG1", "arrung3", "arrangOnce", "grag2", "arrangleOnce", "grang1", "arrag1", "arragOne", "grag1", "arrANGOnce", "arrANGal", "grang3", "arrung1", "grangOne", "alphang1", "alphANGOnce", "arragal", "alphANG2", "arrang3", "alphANG1", "alphangOnce", "grang2", "alphANGal", "arrag2", "arrANG2", "arrangOne", "arrag3"], "answer2": ["answer02", "answerTwo", "say02", "answer4", "answeredtwo", "response4", "say5", "row4", " answertwo", "answeredTwo", "responseTwo", "answertwo", "row5", "response2", "responsetwo", "answer5", "answered2", "row02", "say4", "response5", " answerTwo", " answer02", "response02", "answered02", "say2"], "arrang2": ["grang256", "arrag8", "arrayang2", "arrangTwo", "arroc1", "arrarg1", "arrag0", "arrang8", "arroc0", "arrlang2", "grag8", "arrag256", "arrayoc1", "arrocTwo", "arrayoc0", "arrongTwo", "arrarg256", "arrong0", "arrayangTwo", "arrang0", "arrayang1", "grag2", "grang1", "grang8", "arrag1", "grag1", "grag256", "arrong1", "arrang256", "arrayang0", "arrayocTwo", "grang2", "arrayoc2", "arrag2", "arrarg2", "arrarg8", "arrlang256", "arrong2", "arroc2", "arragTwo", "arrlang8", "arrlang1"], "row1": ["owone", " row5", "ro1", "ro01", "row01", "rowone", "ow01", "ow4", "ro11", "row11", " row11", "ow1", "row4", "roll5", "row5", "ro5", "roll1", " rowone", "ro4", " row4", "roll11", "roone", " row01"], "row2": ["rows2", "ro1", "ry4", "ry2", "owTwo", "roz", "ow2", "ro2", "rows1", "roTwo", "row8", "ow4", "ryTwo", "answer8", "answerz", "row4", "ro8", "rowTwo", "ow12", "row12", "rows8", "ro4", "rowsz", "ro12", "ry12", "rowz"], "intersect": ["intersection", "mirract", "disconnect", " interact", " intercoll", "interconnect", "Intersection", "airsection", "mirsection", "Interect", "Intersect", "miract", " intersection", "intsect", "itersect", "intercoll", " interect", "mirsect", "intsection", "airact", "disact", "itercoll", "dissection", "interract", "INTERsect", "Interact", "intact", "Interconnect", "interact", " interconnect", "airract", "iterect", "Intercoll", "dissect", "interect", "intconnect", "Interract", "itersection", "INTERact", "airsect", "INTERsection", "INTERconnect"]}}
{"code": " \\n  def read_word(f):\\n      return next(f).strip()\\n  \\n  def read_int(f, b=10):\\n      return int(read_word(f), b)\\n  \\n  def read_letters(f):\\n      return list(read_word(f))\\n  \\n  def read_digits(f, b=10):\\n      return [int(x, b) for x in read_letters(f)]\\n  \\n  def read_words(f, d=' '):\\n      return read_word(f).split(d)\\n  \\n  def read_ints(f, b=10, d=' '):\\n      return [int(x, b) for x in read_words(f, d)]\\n  \\n  def read_floats(f, d=' '):\\n      return [float(x) for x in read_words(f, d)]\\n  \\n  def read_arr(f, R, reader=read_ints, *args, **kwargs):\\n      return [reader(f, *args, **kwargs) for i in range(R)]\\n  \\n  def solve(solver, fn, out_fn=None):\\n      in_fn = fn + '.in'\\n      if out_fn is None:\\n          out_fn = fn + '.out'\\n      with open(in_fn, 'r') as fi:\\n          with open(out_fn, 'w') as fo:\\n              T = read_int(fi)\\n              for i in range(T):\\n                  case = read_case(fi)\\n                  res = solver(case)\\n                  write_case(fo, i, res)\\n  \\n  \\n  def read_case(f):\\n      return read_ints(f)\\n  \\n  def write_case(f, i, res):\\n      f.write('Case #%d: '%i)\\n      if isinstance(res, list):\\n          res[0][0] = 'c'\\n          res = '\\n'.join(''.join(c for c in r) for r in res)\\n      f.write('\\n%s'%res)\\n      f.write('\\n')\\n  \\n  \\n  def solve_small(case):\\n      (R, C, M) = case\\n      if R == 1:\\n          return 'c' + '.'*(C-M-1) + '*'*M\\n      if C == 1:\\n          return '\\n'.join(['c'] + ['.']*(R-M-1) + ['*']*M)\\n      m = R*C - M\\n      res = [['*']*C for r in range(R)]\\n      if m == 1:\\n          return res\\n      for r in range(2, R+1):\\n          c = m // r\\n          z = m % r\\n          if c < 2 or c + (z>0) > C:\\n              continue\\n          if z == 1 and (r < 3 or c < 3):\\n              continue\\n          for x in range(r):\\n              for y in range(c):\\n                  res[x][y] = '.'\\n          for y in range(z):\\n              res[y][c] = '.'\\n          if z == 1:\\n              res[z][c] = '.'\\n              res[r-1][c-1] = '*'\\n          return res\\n      return 'Impossible'\\n  \\n  def solve_large(case):\\n      return solve_small(case)\\n  \\n  DEBUG = 'f'\\n  \\n", "substitutes": {"f": ["fd", "p", "bf", "fr", "er", "e", "t", "fe", "h", "uf", "ed", "rf", "ret", "w", "full", "lf", "q", "ut", "F", "xf", "fm", "log", "fed", "fc", "a", "fw", "ft", "o", "orig", "fl", "ct", "cf", "conf", "fo", "far", "tf", "u", "fac", "out", "v", "fa", "alf", "form", "it", "g", "exp", "um", "l", "fp", "file", "test", "fx", "j", "fab", "af", "fg", "fb", "sf", "fer", "ff", "inf", "hl", "fs", "fi"], "b": ["br", "bf", "k", "ib", "base", "gb", "t", "sb", "ob", "bc", "bb", "rb", "mb", "n", "g", "ba", "fb", "bi", "bg", "w", "cb", "be", "eb", "nb", "db", "lb", "l", "bs", "bh", "back", "bis", "by", "bar", "a", "v", "wb", "xb", "ab", "bin", "bd", "bp"], "x": ["ux", "p", "xs", "k", "e", "xxxx", "X", "rx", "xes", "t", "wx", "dx", "xp", "qu", "ax", "ct", "ox", "key", "ross", "xc", "xa", "tx", "xt", "ey", "int", "mx", "w", "index", "xi", "inx", "xf", "on", "l", "val", "yx", "xe", "ix", "xy", "ex", "px", "xx", "v", "xb", "ci", "php"], "d": ["D", "p", "dom", "done", "sd", "dat", "de", "e", "er", "t", "o", "dx", "dec", "n", "s", "g", "td", "ed", "do", "ds", "dL", "div", "w", "dt", "ad", "des", "dd", "db", "l", "red", "days", "dict", "dh", "ld", "dra", "dep", "md", "did", "di", "dr", "debug", "a", "dy", "v", "rd", "dim", "dir", "bd", "da"], "R": ["Range", "D", "G", "O", "Right", "X", "RA", "Max", "H", "L", "A", "Q", "MR", "CR", "E", "DR", "RC", "B", "RF", "RG", "Res", "RL", "AR", "F", "V", "RO", "RS", "RB", "Y", "N", "NR", "RE", "GR", "RR", "Rs", "K", "I", "RM", "P", "OR", "Rat", "W", "RT", "Size", "Multiple", "BR", "S", "SR", "RP"], "reader": ["function", "adder", "func", "owner", "dd", "er", "worker", "source", "master", "handler", "editor", "ser", "style", "wrapper", "driver", "ner", "finder", "writer", "Reader", "interface", "creator", "role", "feature", "rator", "holder", "loader", "parser", "builder", "reading", "read", "actor", "runner", "definition", "callback", "method", "using", "rd", "handle", "test", "inner"], "i": ["gi", "p", "ic", "j", "k", "li", "e", "it", "t", "io", "o", "id", "n", "ri", "phi", "int", "ti", "ini", "w", "bi", "si", "index", "xi", "im", "mi", "ai", "ip", "l", "pi", "ii", "ij", "iu", "oi", "ix", "di", "I", "zi", "ie", "v", "fi", "ir", "ind", "ci"], "solver": ["Sol", "asolution", "asolve", "esolutions", " solution", "asolver", " solve", "esolution", "sol", "resol", "solutions", "Solutions", "resolve", "asol", "solve", "esolver", "resolution", "solution", " solutions", "Solver", "esolve", "Solution", "resolver", "Solve"], "fn": ["function", "fd", "ns", "func", "bf", "fr", "filename", "fl", "txt", "FN", "cf", "n", "nc", "path", "hn", "phy", "dl", "lf", "sf", "cn", "sn", "fun", "conn", "na", "fm", "ff", "fil", "dn", "ln", "bh", "nm", "format", "fp", "out", "file", "fc", "conv", "nn", "fi", "fa", "bin"], "out_fn": ["out_path", "out_filename", " out_filename", "out_file", "outorfilename", " out_file", "outoutln", " out_ln", "out_fm", " out_path", " out_fm", " out_con", "outfcos", "outoutfile", "outffp", "outoutfn", "out_cos", "outorfn", "outorpath", "outorfm", "outoutcon", "out_ln", " out_cos", " out_fp", "out_con", "out_fp", "outffn", "outfln"], "in_fn": ["in_fo", " in2fd", "inbasefo", "in67fd", "in2fo", " in_ln", "in_fd", " in2path", " in_fd", " in_path", "inbasefn", "inbasepath", "in2fn", "in67fo", "in67fn", "in2path", "in67path", "in_path", "in2fd", " in_fo", " in2fo", " in2fn", " in_fil", "inbasefd", "in_ln", " in_dn", "in_dn", "in_fil"], "T": ["D", "G", "O", "TT", "TN", "X", "t", "H", "L", "TM", "TY", "E", "Q", "Tab", "B", "Tu", "TS", "TA", "F", "J", "V", "Z", "Y", "NT", "N", "TR", "K", "I", "P", "W", "S"], "case": ["switch", "se", "trial", "p", "cho", "type", "li", "base", "cp", "block", "ct", "pe", "cf", "ace", "chain", "rule", "then", "info", "name", "condition", "use", "result", "sc", "line", "set", "me", "cor", "cl", "rial", "Case", "co", "instance", "st", "ch", "profile", "ice", "cases", "ase", "ce", "ion", "che", "zip", "fi", "pair", "test", "ci", "cas"], "res": ["rem", "os", "inv", "rc", "str", "rev", "re", "err", "rs", "ps", "reg", "ms", "ser", "ress", "success", "vre", "reset", "results", "us", "req", "s", "rest", "ret", "sol", "tx", "Res", "then", "chain", "pres", "rez", "result", "q", "RES", "cs", "respons", "ins", "rand", " Res", "val", "yes", "rep", "cl", "bs", "resolution", "resources", "vals", "ber", "obj", "cases", "resp", "out", "cons", "mem", "mr", "sys", "lines", "ts", "rh", "response", "des"], "c": ["p", "ic", "rc", "cp", "cm", "t", "rec", "cur", "lc", "ct", "h", "n", "g", "xc", "con", "pc", "cu", "w", "u", "sc", "cs", "ac", "unc", "cr", "co", "cc", "ch", "cd", "v", "tc", "ci"], "r": ["p", "j", "rc", "ra", "er", "re", "e", "err", "rs", "rx", "t", "rec", "h", "ro", "n", "ri", "ar", "pr", "q", "l", "rr", "co", "rar", "rm", "mr", "ry", "rd", "rt", "ir", "right"], "C": ["Co", "D", "G", "O", "COR", "X", "H", "L", "U", "E", "CR", "A", "CM", "B", "CS", "CC", "AR", "F", "V", "RS", "Y", "CNN", "N", "RE", "CO", "CT", "CP", "K", "I", "P", "RM", "W", "CU", "S", "Cs"], "M": ["D", "G", "O", "X", "H", "L", "TM", "E", "U", "Q", "CM", "MN", "MAN", "B", "PM", "MM", "MX", "F", "J", "V", "Y", "N", "MT", "MI", "K", "I", "RM", "P", "Mc", "W", "MC", "MS", "S", "MR", "MP"]}}
{"code": " \\n  def read_word(f):\\n      return next(f).strip()\\n  \\n  def read_int(f, b=10):\\n      return int(read_word(f), b)\\n  \\n  def read_letters(f):\\n      return list(read_word(f))\\n  \\n  def read_digits(f, b=10):\\n      return [int(x, b) for x in read_letters(f)]\\n  \\n  def read_words(f, d=' '):\\n      return read_word(f).split(d)\\n  \\n  def read_ints(f, b=10, d=' '):\\n      return [int(x, b) for x in read_words(f, d)]\\n  \\n  def read_floats(f, d=' '):\\n      return [float(x) for x in read_words(f, d)]\\n  \\n  def read_arr(f, R, reader=read_ints, *args, **kwargs):\\n      return [reader(f, *args, **kwargs) for i in range(R)]\\n  \\n  def solve(solver, fn, out_fn=None):\\n      in_fn = fn + '.in'\\n      if out_fn is None:\\n          out_fn = fn + '.out'\\n      with open(in_fn, 'r') as fi:\\n          with open(out_fn, 'w') as fo:\\n              T = read_int(fi)\\n              for i in range(T):\\n                  case = read_case(fi)\\n                  res = solver(case)\\n                  write_case(fo, i, res)\\n  \\n  \\n  def read_case(f):\\n      R1 = read_int(f)\\n      Q1 = read_arr(f, 4)\\n      R2 = read_int(f)\\n      Q2 = read_arr(f, 4)\\n      return (R1, Q1, R2, Q2)\\n  \\n  def write_case(f, i, res):\\n      f.write('Case #%d: '%i)\\n      f.write('%s'%res)\\n      f.write('\\n')\\n  \\n  \\n  def solve_small(case):\\n      (R1, Q1, R2, Q2) = case\\n      s = set(Q1[R1-1]) & set(Q2[R2-1])\\n      if len(s) == 0:\\n          return 'Volunteer cheated!'\\n      if len(s) == 1:\\n          return s.pop()\\n      return 'Bad magician!'\\n  \\n  def solve_large(case):\\n      return solve_small(case)\\n  \\n  DEBUG = 'i'\\n  \\n", "substitutes": {"f": ["fd", "p", "bf", "fr", "er", "e", "t", "fe", "m", "h", "of", "uf", "ed", "ret", "w", "full", "lf", "q", "F", "r", "xf", "fm", "log", "fed", "fc", "a", "c", "fw", "ft", "o", "orig", "fl", "ct", "cf", "conf", "fo", "far", "field", "tf", "fac", "out", "v", "fa", "alf", "form", "it", "z", "g", "exp", "info", "um", "l", "fp", "file", "test", "fx", "df", "fab", "af", "fg", "fb", "sf", "fer", "ff", "inf", "al", "ma", "hl", "fs", "fi"], "b": ["br", "p", "bf", "bl", "k", "ib", "e", "base", "gb", "t", "m", "sb", "ob", "bc", "bb", "rb", "mb", "n", "g", "ba", "bound", "fb", "bi", "bg", "w", "cb", "be", "y", "eb", "r", "nb", "db", "lb", "l", "bs", "bh", "back", "bis", "bar", "a", "c", "v", "wb", "ab", "bin", "bd", "bp"], "x": ["ux", "p", "xs", "e", "xxxx", "X", "rx", "xes", "t", "wx", "dx", "xp", "qu", "ax", "ct", "ox", "key", "z", "ross", "xc", "xa", "tx", "xt", "ey", "mx", "w", "index", "xi", "y", "inx", "xf", "on", "l", "val", "yx", "xe", "lex", "xd", "ix", "xy", "ex", "px", "c", "xx", "v", "fx", "ci", "php"], "d": ["D", "p", "dom", "done", "sd", "dat", "de", "e", "er", "t", "o", "dx", "m", "dec", "z", "n", "g", "td", "ed", "do", "ds", "dL", "div", "w", "dt", "ad", "des", "dd", "r", "db", "l", "days", "red", "dict", "dh", "ld", "dra", "dep", "md", "did", "di", "dr", "debug", "a", "dy", "c", "v", "rd", "dim", "dir", "bd", "da"], "R": ["Is", "D", "G", "O", "Right", "X", "RA", "L", "A", "Q", "B", "RG", "Res", "F", "r", "Type", "V", "RO", "M", "Y", "N", "NR", "RE", "C", "RR", "K", "I", "RM", "P", "RT", "Rat", "W", "Size", "Multiple", "BR", "S", "SR"], "reader": ["pick", "function", "adder", "owner", "er", "worker", "type", "source", "older", "handler", "editor", "ser", "style", "wrapper", "driver", "ner", "field", "finder", "writer", "Reader", "builder", "creator", "holder", "interface", "rator", "loader", "parser", "reading", "read", "actor", "runner", "definition", "callback", "method", "handle", "test", "inner", "maker"], "i": ["gi", "ki", "p", "ic", "j", "k", "li", "e", "it", "t", "io", "o", "m", "z", "n", "id", "ri", "phi", "int", "ti", "ini", "w", "index", "si", "bi", "xi", "q", "y", "im", "mi", "r", "ai", "ip", "ori", "l", "pi", "ii", "ij", "ix", "di", "I", "zi", "c", "v", "fi", "ir", "ci"], "solver": ["scolution", "sver", "sololver", "sololution", "soln", "resver", "resolve", "scoln", "solve", "scolve", "resoln", "sololve", "resolution", "solution", "Soln", "scolver", "Solver", "Solution", "resolver", "Solve", "Sver"], "fn": ["function", "fd", "ns", "func", "bf", "fr", "filename", "fl", "txt", "tn", "FN", "cf", "n", "nc", "path", "hn", "phy", "mn", "lf", "sf", "cn", "sn", "fun", "conn", "na", "fm", "ff", "dn", "ni", "ln", "bh", "nm", "format", "fp", "out", "file", "fc", "conv", "nn", "fi", "fa", "bin"], "out_fn": ["out_filename", " out_filename", "out_file", "out64fin", "outmmln", "outmmfi", " out_obj", " out_n", " out_file", "out_fc", " out_ln", "out_fm", "out64fn", " out_fm", "out_fin", "out_obj", "out_n", "out64fc", " out_fc", "outmmobj", "outffm", "outfn", "out_ln", " out_fin", "out64ln", " out_fi", " out_fp", "out_fi", "out_fp", "outffn", "outffp", "outmmfn"], "in_fn": ["in_form", "in_fo", "inkfn", " in_form", "in_file", " in_file", "inkfile", "in64ln", "in64fn", "in2fo", " in_ln", "inkfo", "in2ln", "in64form", "in2fn", " in2fo", " in_fo", " in2fn", "inkln", "in_fc", "in2file", " in2file", "in64fc", "in_ln", " in2ln", " in_fc"], "T": ["D", "G", "O", "TT", "TN", "X", "t", "L", "TY", "TM", "E", "Q", "Tab", "B", "TS", "TA", "F", "J", "V", "M", "Z", "Y", "NT", "N", "WT", "TR", "C", "K", "I", "P", "W", "The", "S"], "case": ["switch", "se", "match", "p", "cho", "lic", "li", "cp", "base", "frame", "space", "force", "cond", "block", "pe", "ace", "wrapper", "ride", "chain", "rule", "then", "info", "name", "condition", "use", "result", "line", "set", "core", "catch", "cont", "Case", "co", "sequence", "st", "ch", "profile", "ice", "cases", "ase", "ce", "c", "che", "test", "choice", "cas", "ci", "pair"], "res": ["rem", "os", "str", "rev", "re", "prefix", "ms", "reg", "ps", "rs", "crit", "cond", "block", "ser", "ress", "sim", "resource", "success", "reset", "rent", "results", "conf", "req", "rest", "ret", "sol", "tx", "Res", "chain", "info", "pres", "result", "test", "RES", "init", "r", "rand", "val", "rel", "resolution", "vec", "obj", "ver", "cases", "resp", "cons", "mem", "mate", "response", "mot", "details", "des"], "R1": ["QL", "RootOne", "r1", "Root71", "RAFIR", "Q3", "P2", "R3", "RA6", " RL", "R81", "R71", "QTS", "r71", "RA1", "Q71", "Q6", "RL", "RFIR", "RTS", "rOne", " RFIR", "R6", "PL", "P3", "RA2", "Root1", "RA3", "QFIR", "ROne", "RA81", "QOne", "P1", " R6", "Q81", " RTS", "P81", "RATS"], "Q1": [" Q01", " Qone", "QueryOne", "IQ01", "IQ1", "Q3", "Qual3", "QualOne", " Q4", "Query01", "Query3", "Query1", "MQ2", "IQOne", " QOne", "Qual1", "MQ01", "Q01", " Q3", "Q4", "R4", "MQOne", "Query2", "MQ1", "IQ2", "Queryone", "Qualone", "R01", "ROne", "MQ4", "QOne", "Qone"], "R2": [" R42", "RO2", "Q5", "Pg", " R5", " Rto", "RAto", "Q15", "ROB", "P2", "Q42", "R42", "RA15", " RB", "RA1", "QB", "RTwo", " R15", "R0", "Q0", "Q4", "QTwo", "R4", " R0", "P4", "RB", "Qto", "RA2", "RO1", "Qg", "RO42", " R4", "RA5", "Rto", " Rg", "R15", "P1", " RTwo", "Rg", "RATwo", "RA0", "R5"], "Q2": ["IQ22", "IQ1", "QUl", "MQ22", "Q14", " Q4", " Q22", "Query1", "Q22", "X4", "Rl", "MQ2", " Q0", "IQ14", "QU22", "R0", "QU2", "Q0", "Ql", "Query14", "Q4", "X2", "R4", "QU0", "Query2", "MQ1", "IQ2", "MQ0", "X0", "R22", "QU1", "X1", "R14", " Ql", "Query22"], "s": ["ns", "p", "os", "xs", "ats", "e", "rs", "ps", "t", "m", "h", "ss", "strings", "n", "g", "ls", "keys", "ds", "w", "y", "set", "cs", "r", "parts", "bs", "qs", "sts", "abs", "sv", "services", "a", "sq", "c", "v", "ts", "S", "sb", "stats", "gs"]}}
{"code": "__author__ = 'jrokicki'\\n  \\n  RL = lambda: sys.stdin.readline().strip()\\n  IA = lambda: map(int, RL().split(\" \"))\\n  LA = lambda: map(long, RL().split(\" \"))\\n  FA = lambda: map(float, RL().split(\" \"))\\n  \\n  T = int(sys.stdin.readline())\\n  \\n  def clear(R,C,b, x, y):\\n      b = b[:]\\n      n = 0\\n      for i in range(max(0,x-1), min(R,x+2)):\\n          for j in range(max(0,y-1), min(C, y+2)):\\n              if b[C*i+j] == '*':\\n                  n += 1\\n                  b = b[:C*i+j] + '.' + b[C*i+j+1:]\\n      return b, n\\n  mem = dict()\\n  def pb(R,C,b):\\n      for x in range(R):\\n          print b[x*C:x*C+C]\\n  \\n  def board(R,C,b,x,y,M,m):\\n      global mem\\n      print x\\n      key = (R,C,b,M,x,y,m)\\n      if key in mem: return mem[key]\\n      if x >= R or y >= C:\\n          mem[key] = None\\n      else:\\n          lb = b\\n          n = 0\\n          good = False\\n          for i in range(y,C):\\n              nb,nn = clear(R,C, lb, x, i)\\n              n += nn\\n              if m - n - M == 0:\\n                  mem[key] = nb\\n                  good = True\\n                  break\\n              elif m - n - M < 0:\\n                  break\\n              lb = bb\\n          mem[key] = board(R,C,bb,M,x+1,0,m-n)\\n      return mem[key]\\n  \\n  for CASE in range(T):\\n      R,C,M = IA()\\n      IMPOSSIBLE = \"Impossible\"\\n  \\n      b = \"\"\\n      cleared = R*C-M\\n      for x in range(R):\\n          b += \"*\" * C\\n      if M == R*C-1:\\n          b = \"c\" + b[1:]\\n          answer = b\\n      else:\\n          good = False\\n          x,y = 0,0\\n          q = [(b,0,0,0)]\\n          mem = {}\\n          while not good and q:\\n              board,total_cleared,x,y = q.pop(0)\\n              if (board,total_cleared,x,y) in mem:\\n                  continue\\n              mem[(board,total_cleared,x,y)] = True\\n              if x >= R: continue\\n              if y >= C:\\n                  q.append((last_board,total_cleared,x+1,0))\\n                  continue\\n              last_board = board\\n              new_board, cleared_mines = clear(R,C,last_board,x,y)\\n              total_cleared += cleared_mines\\n  \\n              if total_cleared == cleared:\\n                  good = True\\n                  last_board = new_board\\n                  q = []\\n                  break\\n              elif total_cleared - cleared == -1:\\n                  q.append((new_board,total_cleared,x,y+1))\\n                  q.append((new_board,total_cleared,x+1,0))\\n                  q.append((last_board,total_cleared-cleared_mines,x+1,0))\\n              elif total_cleared > cleared:\\n                  q.append((last_board,total_cleared-cleared_mines,x+1,0))\\n              else:\\n                  q.append((new_board,total_cleared,x,y+1))\\n              last_board = new_board\\n          if good:\\n              answer = last_board\\n          else:\\n              answer = None\\n      if not answer:\\n          answer = \"Impossible\"\\n      else:\\n          b = \"\"\\n          for x in range(R):\\n              b += answer[x*C:x*C+C] + \"\\n\"\\n          answer = \"c\" + b[1:-1]\\n      print \"Case #%d:\\n%s\" % (CASE+1, answer)\\n  \\n", "substitutes": {"__author__": ["__Author___", "__authors____", "__authors___", "__authors__", "___Author__", "___Author____", "___Author___", "__Author__", "__author____", "__author___", "__Author____", "___author___", "___author____", "___author__"], "RL": ["UR", "OGR", "RD", "L", "Pull", "CR", "DR", "TL", "RC", "WAR", "LR", "UL", "LC", "rl", "RF", "FL", "ULL", "NL", "SL", "OL", "HR", "RS", "STR", "RB", "PL", " ML", "XL", "YL", "TR", "ML", "LS", "LL", "RR", "BL", "DERR", "VR", "DL", "REL", "CL", "BR", "SR", "HL"], "IA": ["BI", "LI", "SI", "BA", "MA", "RA", "IB", "AI", "TY", "IO", "IL", "ICA", "IP", "SY", "AU", "CA", "IC", "AR", "TA", "CI", "IM", "SA", "AF", "Y", "GI", "IF", "IE", "MI", "II", "I", "RI", "IJ", "ISA", "IR", "NI"], "LA": ["LI", "BA", "LE", "MA", "AA", "L", "LT", "LAN", "LR", "LC", "La", "LP", "TA", "SL", "LD", "NL", "PA", "SA", "PL", "LG", "LY", "LM", "ML", "LL", "DL", "LS", "LU"], "FA": ["IFA", "FG", "AA", "WA", "FB", "FN", "FR", "FP", "FL", "FU", "EF", "TA", "Fa", "GF", "F", "AF", "FI", "FFFF", "FF", "FE", "FS", "NF", "CF", "FIN", "HA", "VA", "fa", "FD"], "T": ["Time", "TI", "TT", "TN", "X", "t", "TM", "L", "TY", "E", "TV", "XT", "TH", "B", "TC", "TS", "TA", "PT", "TIT", "J", "V", "TW", "Z", "Y", "NT", "WT", "GT", "N", "TB", "CT", "I", "P", "TO", "VT", "TG"], "R": ["D", "G", "O", "Right", "Ren", "X", " r", "RA", "H", "L", "U", "CR", "A", "MR", "Q", "DR", "RC", "Remote", "B", "RG", "RF", "Res", "RH", "AR", "HR", "F", "r", "J", "Reader", "KR", "Rec", "V", "RO", "RS", "RN", "Rot", "Z", "Y", "Cor", "N", "NR", "RE", "TR", "GR", "RR", "Rs", "K", "I", "RM", "P", "RT", "RI", "W", "RW", "S", "BR", "IR", "SR", "ER", "RP"], "C": ["Co", "D", "G", "O", "CD", "JC", "Ch", "COR", "X", "H", "L", "HC", "CR", "A", "E", "CM", "Cr", "CN", "AC", "Count", "Chain", "LC", "B", "CS", "CA", "Cl", "CV", "CE", "IC", "CC", "CI", "WC", "F", "CON", "J", "Code", "SC", "V", "Craig", "Ca", "EC", "Y", "CNN", "N", "Cu", "CO", "CT", "CG", "CP", "CF", "DC", "K", "I", "YC", "P", "CB", "GC", "c", "CL", "CCC", "Size", "CU", "MC", "S", "Cs"], "b": ["p", "bf", "base", "t", "A", "ob", "bc", "d", "cb", "_", "r", "J", "body", "to", "a", "c", "bd", "bo", "gb", "o", "bb", "rb", "s", "B", "bi", "u", "bs", "v", "wb", "bt", "sb", "br", "bl", "ib", "binary", "z", "g", "f", "ba", "be", "pb", "BB", "reb", "l", "Y", "new", "ab", "bin", "bp", "ble", "bu", "bit", "BA", "E", "all", "bm", "fb", "bg", "eb", "db", "erb"], "x": ["hex", "p", "xs", "k", "ic", "e", "xxxx", "X", "rx", "ctx", "t", "o", "wx", "dx", "xp", "ax", "ct", "ox", "z", "xc", "s", " X", "f", "xa", " xx", "xt", "tx", "exp", "int", "ey", "mx", "w", "index", "d", "item", "xi", "u", "im", "r", "xf", "inx", "on", "l", "ty", "yx", "lex", "xe", "xd", "ix", "xy", "a", "ex", "c", "xx", "v", "fx", "ci", "pair"], "y": ["yt", "p", "ic", "k", "gy", "er", "col", "e", "iy", "cy", "t", "o", "ia", "no", "ies", "yy", "h", "ox", "ys", "yr", "z", "g", "hot", "ym", "ny", "axy", "ey", "oy", "any", "im", "my", "r", "yn", "ip", "sy", "l", "ay", "ty", "Y", "ly", "ot", "ye", "ch", "height", "yl", "xy", "out", "ya", "by", "a", "c", "wy", "v", "ry", "sys", "yi", "py"], "n": ["ns", "p", "k", "count", "gn", "e", "t", "o", "long", "no", "tn", "nr", "h", "none", "an", "z", "nc", "g", "ne", "f", "s", "node", "en", "name", "nan", "mn", "w", "d", "index", "sn", "cn", "na", "conn", "names", "r", "yn", "nor", "nu", "l", "dn", "np", "nl", "un", "N", "ln", "nt", "min", "nm", "len", "out", "a", "rn", "c", "v", "fn", "size", "num"], "i": ["gi", "ki", "hi", "ic", "p", "li", "e", "it", "iy", "ia", "ite", "o", "io", "ik", "t", "h", "id", "g", "z", "ui", "phi", "info", "int", "ti", "ini", "bi", "d", "si", "xi", "im", "mi", "u", "r", "ai", "ip", "l", "pi", "ii", "ij", "iu", "ix", "di", "zi", "I", "a", "ie", "c", "v", "ir", "yi", "ci"], "j": ["ji", "p", "jj", "k", "jl", "fr", "er", "li", "e", "it", "jp", "t", "o", "h", "ox", "z", "g", "f", "ja", "si", "uj", "json", "r", "J", "kj", "dj", "l", "ij", "jc", "ch", "out", "js", "jump", "c", "ie", "v", "je", "aj", "pt", "ind"], "mem": ["tmp", "rem", "store", "mac", "norm", "lim", "ret", "jac", "process", "w", "_", "local", "set", "cache", "link", "ram", "log", "gram", "thread", "mp", "gc", "med", "em", "reg", "txt", "ct", "usage", "raw", "hist", "tx", "ond", "mc", " memories", "erm", "resp", "cfg", "tm", "err", "time", "mm", "display", "mb", "f", "um", "man", "my", "tem", "tim", "mt", "member", "EM", "met", "Mem", " Mem", "mind", "sum", "dim", "memory", "size", "temp", "pair", "res", "cmd", "note", "metadata", "mat", "all", "bm", "result", "dem", "index", "mi", "ems", "db", "me", "tab", "val", "buff", "adj", "md", "msg", "rm", "ge", "sys", "mod", "ind"], "M": ["D", "G", "O", "mA", "X", "MA", "cm", "H", "L", "MD", "E", "TM", "Q", "CM", "A", "U", "MN", "BM", "NM", "bm", "B", "Mi", "MM", "F", "J", "IM", "Multi", "V", "Me", "Y", "N", "Ms", "MT", "MI", "K", "I", "My", "P", "RM", "DM", "W", "MC", "MS", "S", "AM"], "m": ["p", "k", "em", "dm", "tm", "e", "ms", "cm", "t", "o", "mm", "h", "an", "z", "g", "f", "bm", "am", "mn", "mx", "d", "gm", "im", "mi", "mo", "r", "on", "l", "mc", "mu", "min", "sm", "nm", "ma", "c", "v", "num"], "key": ["Key", "p", "check", "er", "col", "at", "mac", "error", "code", "node", "option", "keys", "name", "char", "item", "ke", "set", "prop", "link", "row", "by", "step", "num", "prefix", "ox", "record", "id", "kw", "chain", "slot", "any", "KEY", "number", "ver", "ry", "tag", "str", "it", "cond", "info", "my", "mode", "ay", "member", "net", "new", "ice", "phrase", "sum", "case", "pair", "next", "one", "k", "type", "note", "bm", "ey", "index", "entry", "ip", "rand", "val", "value", "bool", "te", "obj", "title", "xy", "py"], "lb": ["lu", "bl", "bf", "la", "li", "ll", "lab", "lr", "L", "ob", "lc", "bb", "rb", "lo", "LB", "ls", "rl", "B", "fb", "ub", "dl", "lf", "cb", "BB", "eb", "lp", "pl", "db", "bn", "lt", "l", "nl", "ln", "ld", "zb", "lbs", "wb", "bt", "sb", "bp"], "good": ["Bad", "win", "done", "ok", "sent", "used", "Good", "fail", "doc", "kind", "cond", "success", "id", "bad", "acc", "dev", " Good", "important", "big", "green", "same", " GOOD", " bad", "dead", "found", "yes", "poor", "gu", "comment", "score", "desc", "clean", "md", "broken", "msg", "mad", "debug", "best", "quick", "ready", "stable", "med", "high", "low", "bug", "mod", "nice", "valid", "ind", "buy"], "nb": ["abb", "bf", "bl", "ib", "gb", "sb", "tn", "nr", "bb", "rb", "mb", "bm", "fb", "bi", "bg", "cn", "cb", "pb", "eb", "db", "nu", "bn", "np", "NR", "ln", "zb", "NB", "nv", "wb", "bj", "kb", "bd", "nd", "ble"], "nn": ["ns", "NN", "gn", "nah", "ll", "tn", "nr", "bb", "nc", "ne", "inn", "ny", "nan", "mn", "sn", "cn", "wn", "na", "cb", "pn", "nz", "yn", "nu", "bn", "kn", "np", "nl", "dn", "ni", "ln", "NR", "nt", "nv", "rn", "xx", "nd"], "CASE": ["Ctime", "RASE", "Rase", "JCtime", "Btime", "RODE", "JCASE", "CODE", "JCase", "Rtime", "Case", "BODE", "BASE", "JCODE", "Base"], "IMPOSSIBLE": ["IMPOSSibility", "IMSPossibility", "IMSPOSSibility", "IMPASSibility", "IMPASSible", "IMPESSible", "IMPossibility", "IMSPOSSIBLE", "IMPOSSBILITY", "IMSPOSSBILITY", "IMPossible", "IMPESSIBLE", "IMPossIBLE", "IMPossBILITY", "IMPESSBILITY", "IMSPOSSible", "IMPASSIBLE", "IMSPossBILITY", "IMPASSBILITY", "IMSPossible", "IMPESSibility", "IMPOSSible", "IMSPossIBLE"], "cleared": [" cleined", "cleined", "cleanned", "declared", "uncleanned", " cleaned", "declaned", "declined", " cleanned", "uncleined", "cleaned", "uncleared", "uncleaned", "declanned"], "answer": ["bridge", "update", "exit", "err", "note", " ba", "repl", "abin", "bm", "eni", "up", "fb", "result", "be", "eb", "write", "ab", "ac", "une", "rr", "ben", "adj", "Answer", "back", "rn", "ak", "test", "ble"], "q": ["p", "k", "qv", "iq", "t", "qa", "qu", "Q", "qq", "z", "qual", "g", "f", "qi", "w", "quit", "d", "u", "r", "ue", "l", "query", "qs", "qt", "dq", "sq", "queue", "ql"], "board": ["bit", "bo", "mac", "butt", "oard", "block", "code", "ck", "control", "shell", "stroke", "chain", "loop", "lay", "line", "row", "bang", "bank", "player", "buffer", "co", "flow", "back", "boards", "ack", "comb", "box", "boarding", "ward", "click", "Board", "button", "land", "bird", "paste", "cell", "lock", "play", "bd"]}}
{"code": "__author__ = 'jrokicki'\\n  \\n  RL = lambda: sys.stdin.readline().strip()\\n  IA = lambda: map(int, RL().split(\" \"))\\n  LA = lambda: map(long, RL().split(\" \"))\\n  \\n  T = int(sys.stdin.readline())\\n  \\n  for CASE in range(T):\\n      g1 = IA()[0]-1\\n      board1 = []\\n      for i in range(4):\\n          board1.append(IA())\\n      g2 = IA()[0]-1\\n      board2 = []\\n      for i in range(4):\\n          board2.append(IA())\\n  \\n      r1 = board1[g1]\\n      r2 = board2[g2]\\n  \\n      answer = set(r1).intersection(r2)\\n      if len(answer) > 1:\\n          answer = \"Bad magician!\"\\n      elif len(answer) == 0:\\n          answer = \"Volunteer cheated!\"\\n      else:\\n          answer = list(answer)[0]\\n  \\n      print \"Case #%d: %s\" % (CASE+1, answer)\\n  \\n", "substitutes": {"__author__": ["__creator_", "__Author___", "__author_", "__creator__", "__authors_", "__authors___", "__authors__", "_author__", "_Author__", "__Author_", "_Author___", "_Author_", "__creator___", "__Author__", "_author_", "__author___", "_author___"], "RL": ["RD", "LI", "LE", "L", "TY", "LT", "DR", "TL", "RC", "LR", "R", "LC", "rl", "RF", "LP", "FL", "ULL", "AR", "NL", "SL", "LD", "OL", "HR", "LED", "LIN", "RS", "RB", "PL", "XL", "YL", "DERR", "ML", "LL", "RR", "BL", "VR", "DL", "REL", "RI", "CL", "LS", "IR", "SR", "ER", "HL"], "IA": ["IFA", "BI", "NA", "LI", "SI", "IME", "MA", "RA", "IB", "AA", "AI", "ATA", "TY", "IO", "LAN", "EMA", "ICA", "TV", "ANA", "RAY", "LR", "ICO", "INA", "CA", "AR", "TA", "ILA", "CIA", "VI", "ARE", "IM", "SA", "GA", "GI", "IE", "II", "MI", "JA", "I", "IAN", "RI", "CLA", "HA", "ISA", "AMI", "IR", "API", "ERA"], "LA": ["AMA", "NA", "BA", "LI", "FA", "MA", "AA", "L", "IL", "KA", "LAN", "SPA", "ANA", "LR", "MAL", "AU", "CA", "ZA", "ILA", "TA", "PA", "SA", "LG", "GA", "ACY", "HA", "VA", "LU", "HI"], "T": ["Time", "D", "G", "O", "TI", "TT", "TN", "t", "TM", "TY", "L", "E", "Q", "TON", "Tab", "R", "TC", "TS", "TA", "TIT", "PT", "J", "V", "M", "TW", "Y", "NT", "N", "WT", "GT", "TR", "TB", "C", "I", "P", "VT", "S"], "CASE": ["BCASE", "LCCase", "CCase", "REST", "BCALLY", "RALLY", "DCase", "PANK", "RANK", "RASE", "PEST", "PASE", "Dcase", "CANK", "Dase", "DASE", "CEST", "LCase", "LCcase", "LCASE", "Case", "BCEST", "BASE", "Bcase", "Base", "CALLY", "BCANK", "Ccase", "PALLY", "BCase"], "g1": ["game11", " gFirst", "g11", "gp7", "game1", "gain11", "game51", "gi1", " g51", "gpFirst", "gain1", "giFirst", "gi7", " g001", " g7", "g001", "gp1", "gain51", "g51", "g7", " g11", "gFirst", "gp001", "gi001"], "board1": ["Board2", "board001", "oard6", "chain001", "boardFirst", "leagueone", "tub1", " board001", "tub8", "board0", " board8", "tubFirst", "tub6", "league001", "plate1", "boardone", "chain1", " boardFirst", "chain2", "Board001", "plate0", "league1", "league0", "Board1", "board6", "oard1", " boardone", "oard8", " board6", " board0", "board8", "plateone", "plate001", "oardFirst"], "i": ["gi", "ki", "ji", "p", "ic", "j", "li", "e", "it", "io", "ik", "iti", "g", "phi", "ei", "il", "ti", "bi", "si", "xi", "ai", "adi", "pi", "ii", "ij", "ati", "di", "zi", "I", "c", "fi", "yi", "ind", "ci"], "g2": [" gTwo", "ggSecond", "gSecond", "ggTwo", "Gsecond", "g02", " gSecond", "gTwo", " g02", "g5", "gsecond", "rg2", "argsecond", "G1", "arg2", "arg02", " g5", "rg5", "rgTwo", "arg1", "gg5", " gsecond", "gg2", "G02", "rgSecond", "G2"], "board2": ["Board2", "deck1", " board5", "wardtwo", "ward2", "lay1", "boardb", "bench102", "board102", "boarding02", "boardtwo", "boards2", "bench02", "lay2", "roomtwo", "deck2", "lay5", "boarding1", "boards1", "room02", "room102", "board42", "board02", "boardingb", "ward102", "lay42", "board5", "room2", "boarding2", "ward02", "bench2", "deckb", "boards02", "Board1", "Board5", "benchtwo", "boardsb", "Board42", " board42", "deck02"], "r1": ["rp", "er1", "ro1", "R2", "erp", "rowone", "roOne", "er001", " rp", "R71", "r71", "ro001", "r001", "rs1", "rOne", "row71", "rone", "rop", "rsone", " rOne", "row1", "rs2", "R1", "row2", "erOne", "Rone", " r001", "rs71"], "r2": ["R02", "er1", "R2", "r02", "er02", " r02", "R1", "er2"], "answer": ["empty", "swers", "about", "option", " answered", "see", "era", "oe", "ze", "q", "answered", "ae", "sequence", "review", "output", "search", "voice", "ave", "description", "notice", "ask", "image", "ache", "archive", " unanswered", "onse", "consider", "ell", "ver", "offer", "evaluate", "ry", "accept", "response", "issue", "approximately", "array", "example", "ve", "question", "vote", "be", "poll", "echo", "query", "remember", "oa", "many", "mate", "test", "comment", "interpret", "case", "ee", "au", "one", "request", "rent", "reply", "ace", "quest", "result", "WER", "again", "entry", "wer", "value", "Answer", "version", "string", "said", "say", "message", "list"]}}
{"code": "class Sweeper(object):\\n      def __init__(self, r, c, m):\\n          self.matrix = [['.' for j in range(0, c)] for i in range(0, r)]\\n          self.matrix[0][0] = 'c'\\n  \\n          self.r = r\\n          self.c = c\\n          self.m = m\\n          self.current_r = r\\n          self.current_c = c\\n          self.current_m = m\\n  \\n      def fill_row(self):\\n          if self.current_r >= 3 and self.current_m >= self.current_c:\\n              for i in range(0, self.current_c):\\n                  self.matrix[self.current_r - 1][i] = '*'\\n              self.current_r -= 1\\n              self.current_m -= self.current_c\\n              return True\\n          return False\\n  \\n      def fill_col(self):\\n          if self.current_c >= 3 and self.current_m >= self.current_r:\\n              for i in range(0, self.current_r):\\n                  self.matrix[i][self.current_c - 1] = '*'\\n              self.current_c -= 1\\n              self.current_m -= self.current_r\\n              return True\\n          return False\\n  \\n      def fill_partial(self):\\n          if self.current_r >= 3:\\n              fill_num = min(self.current_m, self.current_c - 2)\\n              for i in range(0, fill_num):\\n                  self.matrix[self.current_r - 1][self.current_c - 1 - i] = '*'\\n              self.current_m -= fill_num\\n              if fill_num > 0:\\n                  self.current_r -= 1\\n          if self.current_c >= 3:\\n              fill_num = min(self.current_m, self.current_r - 2)\\n              for i in range(0, fill_num):\\n                  self.matrix[self.current_r - 1 - i][self.current_c - 1] = '*'\\n              self.current_m -= fill_num\\n              if fill_num > 0:\\n                  self.current_c -= 1\\n          if self.current_m > 0:\\n              return False\\n          else:\\n              return True\\n  \\n      def fill_special_one(self):\\n          if self.current_r * self.current_c == self.current_m + 1:\\n              for i in range(0, self.current_r):\\n                  for j in range(0, self.current_c):\\n                      self.matrix[i][j] = '*'\\n              self.matrix[0][0] = 'c'\\n              self.current_r = 0\\n              self.current_c = 0\\n              self.current_m = 0\\n              return True\\n          return False\\n  \\n      def fill_special_col(self):\\n          if self.current_c == 1 and self.current_r > self.current_m:\\n              for i in range(0, self.current_m):\\n                  self.matrix[self.current_r - 1 - i][0] = '*'\\n              self.matrix[0][0] = 'c'\\n              self.current_m = 0\\n              self.current_r = 0\\n              self.current_c = 0\\n              return True\\n          return False\\n  \\n      def fill_special_row(self):\\n          if self.current_r == 1 and self.current_c > self.current_m:\\n              for i in range(0, self.current_m):\\n                  self.matrix[0][self.current_c - 1 - i] = '*'\\n              self.matrix[0][0] = 'c'\\n              self.current_m = 0\\n              self.current_r = 0\\n              self.current_c = 0\\n              return True\\n          return False\\n  \\n  def print_matrix(matrix):\\n      for row in matrix:\\n          s = ''\\n          for col in row:\\n              s += col\\n          print s\\n  \\n      \\n  def solve_case(t):\\n      r, c, m = [int(num) for num in raw_input().strip().split()]\\n      sweeper = Sweeper(r, c, m)\\n      print 'Case #%d:' % (t,)\\n      if sweeper.fill_special_one() or sweeper.fill_special_col() or sweeper.fill_special_row():\\n          print_matrix(sweeper.matrix)\\n          return\\n      f_result = True\\n      while sweeper.current_m > 0 and f_result:\\n          f_result = False\\n          f_result |= sweeper.fill_row()\\n          f_result |= sweeper.fill_col()\\n      if sweeper.current_m > 0:\\n          sweeper.fill_partial()\\n      if sweeper.current_m > 0:\\n          print 'Impossible'\\n      else:\\n          print_matrix(sweeper.matrix)\\n  \\n  def main():\\n      t = int(raw_input().strip())\\n      for i in range(1, t + 1):\\n          solve_case(i)\\n  \\n  if __name__ == '__main__':\\n      main()\\n", "substitutes": {"self": ["app", "se", "python", "hi", "rem", "tmp", "empty", "cho", "console", "func", "p", "args", "esh", "what", "ih", "error", "h", "old", "complete", "results", "about", "req", "term", "here", "close", "name", "spec", "proc", "axy", "page", "item", "shape", "w", "full", "q", "local", "eth", "user", "comp", "cache", "help", "_", "ial", "var", "log", "el", "ae", "html", "instance", "attr", "body", "review", "template", "output", "mp", "debug", "ssl", "quick", "diff", "views", "mem", "terms", "by", "par", "short", "details", "urn", "default", "open", "soc", "go", "private", "part", "agg", "util", "txt", "coll", "block", "cmp", "disk", "sql", "\u00e4", "conf", "final", "github", "raw", "parent", "params", "sis", "tx", "change", "both", "own", "json", "dd", "config", "changes", "where", "sect", "rel", "ln", "pkg", "lex", "gh", "th", "math", "print", "resp", "hw", "also", "xml", "thus", "attribute", "exc", "response", "context", "good", "select", "series", "serial", "small", "warning", "form", "this", "load", "rec", "history", "graph", "your", "time", "public", "sp", "path", "asm", "event", "group", "before", "info", "conn", "my", "sw", "work", "expr", "through", "auto", "query", "table", "mix", "make", "them", "new", "add", "eff", "news", "data", "test", "right", "show", "res", "next", "ref", "api", "space", "cmd", "start", "compl", "client", "request", "all", "ren", "system", "dev", "subject", "book", "ws", "result", "entry", "view", "me", "cl", "chart", "replace", "nt", "you", "obj", "md", "look", "wh", "get", "ready", "sys", "method", "model", "com", "py", "other", "Self"], "r": ["range", "res", "br", "p", "rc", "ra", "er", "re", "e", "rs", "h", "nr", "ro", "rid", "rb", "n", "ur", "g", "R", "rate", "f", "ar", "ru", "w", "d", "tr", "b", "l", "cr", "hr", "rar", "x", "sr", "dr", "rm", "mr", "a", "v", "rd", "rt", "ir"], "c": ["dc", "p", "rc", "e", "cp", "cm", "cur", "lc", "ct", "h", "cf", "n", "conf", "con", "f", "category", "cos", "cat", "cu", "d", "cn", "cb", "u", "cs", "ec", "cache", "cin", "b", "ac", "l", "cr", "co", "cc", "mc", "ch", "C", "cd", "ca", "ce", "v", "tc", "com", "ci"], "m": ["p", "em", "tm", "e", "ms", "cm", "o", "mm", "h", "mat", "n", "g", "z", "f", "bm", "am", "um", "w", "d", "gm", "u", "q", "mi", "b", "M", "mt", "l", "mk", "mc", "mu", "ma", "rm", "mr", "a", "v"], "matrix": ["mattable", "dimrix", "mMatrix", "macmat", "moduleMatrix", "dimMatrix", "scherie", "matMatrix", "modulerie", " matpack", "matprint", "macrix", "schepack", "mrix", "catMatrix", "dimrices", "transrix", "transmat", "modulepack", "matrie", "manrix", " matprint", "catrices", "modulerix", "tmrix", "macrices", "tmmat", "scherices", " matrie", "scheprint", "tmtable", "transtable", "atrix", "scheMatrix", "atmat", "catrix", "matpack", "mrices", "mutMatrix", "mutrices", "transrices", "manmat", " matMatrix", "mutrix", "scherix", "atrices", "attable", "mmat", "matrices", "manrices", "tmrices", "matmat", " matrices", "mprint"], "j": ["ji", " cx", "ic", " di", " cc", " cu", " ni", "n", " vi", "ei", " il", " li", "q", " iii", " mi", " cs", " bi", "oj", "ij", " ic", " ch", "jc", "ix", " ca", "zi", " ja", " Xi", " chi"], "i": ["gi", "ki", "ji", "p", "ic", "k", "hi", "er", "li", "e", "it", "iy", "ia", "o", "ih", "ik", "h", "iti", "id", "n", "iri", "z", "ri", "phi", "ui", "ei", "il", "ti", "ini", "index", "si", "xi", "im", "y", "mi", "u", "cli", "ai", "b", "me", "ip", "ori", "l", "ski", "x", "pi", "ii", "ij", "iu", "oi", "ix", "di", "I", "zi", "v", "fi", "ir", "yi", "ind", "ci"], "current_r": ["currently_l", " currentedr", "reported_dr", "reported_m", "reported__row", "currentcurrentr", "current__row", "current__rc", "reported__h", "current___p", "currentcurrentp", "current64c", "current_rd", "current0sr", "current8c", "current00r", "complete1rc", "current8r", "active_r", "current64rc", "current8p", "currentcurrentl", "running_ir", "current_h", "this___r", "currently_c", "reported_c", "current_re", " currentedrect", "this_fr", "currentptrd", "reported_rt", "this___fr", "current8raw", "this_p", "complete_rc", "this___p", "currentedi", "current_n", "current___n", "currentjraw", "current8m", "currentcurrenti", "this___ro", "current00rg", "current___rect", "current___t", "current_ir", "current_rt", "currentjm", "current00m", "reported__c", "reported_sr", "reported_ro", "currentcurrentrow", "reported_h", "running8r", "complete1r", "currently_u", "currentedu", "current___rt", "current__ir", "current_rg", "reported__r", "complete1ro", "reported_re", "reported_rg", "current8ir", "this_r", "currently_row", " current_rect", "current__i", "currentlyedp", "current___ro", "reported_row", "current___r", "current1t", "current_l", "current__h", "current1ro", "currently_i", "complete1t", "currentjr", "complete_r", "currentlyedu", "current0r", "current__ro", "current_fr", "current__m", "reported_r", "currentedrd", "current1r", "currentptmr", "current_mr", "active_m", "current__t", "active_e", "running_c", "reported_raw", "reported_p", " current_mr", "reported_rc", "currently_p", "currentcurrentc", "currentedr", "current_i", "running8ir", "current_t", " current_rd", "current_raw", "reported_n", "current___fr", "current0re", "current64r", "current_dr", "currently_r", "running_r", "current1c", "current0c", "current__c", "running8c", "currentedp", "currentedrect", "current_e", "current_rc", "currentedmr", "current_p", "current_ro", " currentedmr", "current1rc", " currentedrd", "current_sr", "current1row", "current_u", "current1h", "current00ro", "currentjp", "current_rect", "currentptr", "current64dr", "current__r", "currentptrect", "complete_t", "current_row", "currentlyedi", "complete_ro", "current___rd", "this_ro", "active_i", "current___rc", "currentlyedr", "current__e", "currentcurrentu", "current___mr"], "current_c": ["current__cl", "current_cache", "reported__rc", "reported_m", "currently__co", "current__rc", "current64g", "currently_m", "current5m", "w", "current64c", "current_cf", "_", "current_cm", "current_con", "current_cy", "currently_c", "reported_c", "current_tc", "currently2c", "currently2m", "current2sc", "reported_g", "current64cur", "reported__cp", "client_c", "current_ce", "current_lc", "current5cs", "current__l", "reported__c", "currentSetcache", "reported_b", "current_b", "currentSetm", "reported_tc", "current__cy", "current__cp", "current5c", "currentSetcf", "currently_co", "current_g", "present_c", "currentablecu", "currently_cs", "currently__m", "current_cu", "reported_cm", "current_cp", "current_cs", "current_l", "currentablecm", "current2r", "current__cs", "present_p", "client_cache", "client_m", "n", "g", "current__m", "reported_cp", "currentabletc", "reported_r", "reported_cs", "current64con", "reported__m", "current64b", "current1cp", "current64l", "reported_rc", "currently_p", "currently__c", "currently__p", "client_cf", "currently2sc", "current2c", "current_co", "current_mc", "current2cs", "reported_lc", "current1c", "ic", "reported_ce", "cm", "current__c", "current1m", "current_cur", "current_rc", "current__cur", "current_p", "present_cp", "currently_sc", "current64m", "current1rc", "current2mc", "reported_mc", "current__co", "reported_cl", "currently2cs", "reported_cu", "current5sc", "present_cy", "current_cl", "reported_con", "current__p", "current2m", "reported_cur", "currentablec", "reported_l", "currentSetc", "current_sc"], "current_m": ["reported_rm", "current_rm", "reported_m", "current11mid", "reported_me", "currentxe", "currently_m", "current5m", "current__man", "current64c", "current_cm", "current_dm", "currently_c", "reported_c", "current5rm", "reported_v", "currentxc", "current_n", "reported_perm", "current__l", "currentxperm", "current_man", "current00m", "current_me", "current64mat", "current00rm", "current11m", "current00me", "current5c", "currentptc", "next_p", "cur_mt", "cur_m", "reported_cm", "current_l", "reported_dm", "currentxm", "next_m", "current__m", " current_mid", "reported_r", "currentJmt", "cur_c", "currentptdm", "current_mid", " current_mt", "current_mc", "currentptmc", "currentJr", "cur_r", "current64n", "current_perm", "currently_n", "currentJc", "current_mt", "current5me", "currentJm", "current__c", "reported_e", "current__perm", "current_e", "current11c", "current00c", "current_p", "current64m", "reported_mc", "next_man", "current11mt", "next_c", "current__r", "current_v", "current__p", "currently_mat", "current_mat", "currentptm", "reported_l", "current__e"], "fill_num": [" fill_nam", "fillsetmean", "fill_number", "kill_nam", "fill7min", "fill_mon", "kill_num", "fill10mon", "replace10num", "replace_num", "filllysum", "fill67buf", "fill_nu", "fill_cum", "fill67nom", " fill_sum", "kill_mon", "fillsetnum", "fill8mon", "fill67min", "fill_sum", "filllyrat", " fill_number", "fillsetalph", "fill_mun", "replace10nam", "fill_nam", "fill67nam", "replace10mon", "fillsetmun", "fill67nu", " fill2min", "fill67mean", " fill_buf", "fill8nam", "fill10num", "fill_rat", "train_alph", "fill1mon", "fill_alph", " fill_mon", "fill10nam", "fill1number", "fill_eng", "filllycum", "fill_min", "fill67mun", "fill2sum", "filllynam", "fill67num", " fill_eng", "fill10number", "fill_nom", "fill_mean", "trainsetalph", "fill1num", "replace_number", " fill2num", " fill2mon", "replace_mon", " fill_nu", "fill2min", "fill2mon", "trainsetmun", " fill2nu", "fill8num", " fill_cum", "fill2nam", "fill67alph", "fill7mon", "fill7num", "fill_buf", "replace_nam", " fill_min", "fill2num", "filllynm", "fill1nam", "kill_sum", "train_mean", "fill67mon", "fill7nu", "fill67eng", "trainsetnum", "train_num", "filllynumber", "replace10number", " fill_rat", "filllynum", " fill_nom", " fill_nm", "fill8eng", "fill_nm", "fill2nu", "train_mun", "trainsetmean"]}}
{"code": "def solve_case(t):\\n      interested_row = int(raw_input().strip())\\n      i = 1\\n      while i <= 4:\\n          row = raw_input()\\n          if i == interested_row:\\n              first_set = set(row.strip().split())\\n          i += 1\\n      interested_row = int(raw_input().strip())\\n      i = 1\\n      while i <= 4:\\n          row = raw_input()\\n          if i == interested_row:\\n              second_set = set(row.strip().split())\\n          i += 1\\n      ans_set = first_set & second_set\\n      if len(ans_set) == 1:\\n          print 'Case #%d: %s' % (t, ans_set.pop(),)\\n      elif len(ans_set) > 1:\\n          print 'Case #%d: Bad magician!' % (t,)\\n      else:\\n          print 'Case #%d: Volunteer cheated!' % (t,)\\n  \\n  def main():\\n      t = int(raw_input().strip())\\n      for i in range(1, t + 1):\\n          solve_case(i)\\n  \\n  if __name__ == '__main__':\\n      main()\\n", "substitutes": {"t": ["p", "j", "tt", "k", "total", "type", "e", "it", "at", "tick", "o", "m", "time", "h", "ct", "id", "n", "g", "z", "s", "f", "chain", "int", "ti", "test", "w", "d", "dt", "q", "y", "r", "b", "l", "ty", "tp", "tz", "ot", "nt", "to", "te", "tree", "st", "th", "title", "ten", "trace", "tu", "a", "c", "ta", "v", "tc", "wt", "ts", "T", "rt", "pt", "tw", "num"], "interested_row": ["interested2col", "interest2set", " interested_set", "interested_rows", "interest_job", " interested_ro", "interested___cell", "interested___col", "interested_set", "interested_col", "interest_row", "interested2set", "interested_ro", "interested_server", "interested_job", "interested___ro", "interest2col", "interest_rows", "interested2rows", "interest2row", "interested_cell", "interest2rows", " interested_server", " interested_cell", "interested2row", "interested___row", "interest_set", " interested_col", "interested_record", "interest_record", "interest_col"], "i": ["gi", "hi", "p", "ic", "q", "j", "k", "li", "api", "err", "it", "m", "rame", "sim", "iti", "id", "n", "g", "s", "f", "phi", "ui", "ei", "name", "ti", "ini", "bi", "iat", "si", "index", "xi", "im", "mi", "multi", "y", "cli", "ai", " ti", "set", "b", "on", "ip", "l", "ski", "x", "pi", "ii", "ij", "iu", "oi", "you", "ni", "ati", "batch", "aci", "ix", "di", "zi", "I", "ion", "ta", "ie", "v", "c", "yi", "ind", "ci"], "row": ["post", "rc", "form", "reader", "frame", "col", "re", "column", "block", "ser", "ro", "week", "record", "sync", "group", "raw", "rown", "page", "item", "tr", "wheel", "field", "copy", "line", "set", "rot", "entry", "r", "rew", "tab", "Row", "query", "x", "ow", "month", "batch", "th", "uu", "iter", "ows", "roll", "feed", "ward", "first", "rows", "ry", "cell", "pair", "list"], "first_set": ["top_start", "upper_loc", "upper_col", "first64loc", "top_class", "first_Set", "first_col", "first0set", "first0Set", "upper64loc", "upper64set", "upper64col", "first_start", "first64col", "upper_set", "firstlySet", "firstlyset", "upper_Set", "top_Set", "first0class", "upper64Set", "firstlyloc", "first0start", "top_set", "firstlycol", "first_loc", "first64Set", "first64set", "first_class"], "second_set": ["seconderSET", "bottomersetting", "bottom_SET", "second_SET", "bottom_sets", "second_sets", "secondersets", "Second_Set", "bottomersets", "second_setting", "second2set", "bottom_setting", "second_Set", "bottom_set", "bottomerSET", "seconderset", "second2setting", "second2sets", "second2SET", "secondersetting", "Second_SET", "Second_block", "second_block", "Second_set", "bottomerset"], "ans_set": ["ans2pair", "ans2Set", "ans_Set", "ans_save", "ansallsite", "ans2save", "ants_site", "ann_match", "ansallet", "ANS2save", "ANS_save", "ans2et", "ans7list", "ansallset", " ans_list", "ann_et", "ans2site", " ans_dict", "ans7set", "anslogset", "ans_case", "ans2list", "anslogsave", "ants_list", "ANS_set", "ans7pair", "ANS2Set", "ANS_et", "ANS2set", "ANS2et", "ans_match", "ans_pair", "ann_set", "ANS_Set", "ans_dict", "ansalllist", "ants_et", "anslogSet", "ann_case", "ans2dict", "ans_list", "ans2set", " ans_pair", "ans_et", "ants_set", "ans7dict", "ans_site", "ansloget"]}}
{"code": " \\n  \\n  def read_str(): return stdin.readline().rstrip('\\n')\\n  def read_int(): return int(stdin.readline())\\n  def read_ints(): return map(int, stdin.readline().split())\\n  def read_floats(): return map(float, stdin.readline().split())\\n  \\n  \\n  def atos(A):\\n      return '\\n'.join([''.join(row) for row in A])\\n      \\n  \\n  def get_field(r, c):\\n      field = [['.'] * c for i in range(r)]\\n      field[0][0] = 'c'\\n      return field\\n      \\n      \\n  def is_forbidden(i, j):\\n      return i == 0 and j == 0 or i == 0 and j == 1 or \\\\n          i == 1 and j == 0 or i == 1 and j == 1\\n      \\n      \\n  def fill(field, r, c, m):\\n      left = m\\n      for ii in range(r - 1, -1, -1):\\n          i = ii\\n          j = c - 1\\n          while i < r and j >= 0:\\n              if is_forbidden(i, j):\\n                  i += 1\\n                  j -= 1\\n                  continue\\n              if left == 0:\\n                  return 0\\n              field[i][j] = '*'\\n              left -= 1\\n              \\n              i += 1\\n              j -= 1\\n              \\n          if ii == 0:\\n              for jj in range(c - 2, 1, -1):\\n                  i = ii\\n                  j = jj\\n                  while i < r and j >= 0:\\n                      if is_forbidden(i, j):\\n                          i += 1\\n                          j -= 1\\n                          continue\\n                      if left == 0:\\n                          return 0\\n                      field[i][j] = '*'\\n                      left -= 1\\n                      \\n                      i += 1\\n                      j -= 1\\n              \\n      if r * c == m + 1:\\n          if r > 1:\\n              field[1][0] = '*'\\n          if c > 1:\\n              field[0][1] = '*'\\n          if r > 1 and c > 1:\\n              field[1][1] = '*'\\n          return 0\\n              \\n      return left\\n  \\n      \\n  def solve_case():\\n      r, c, m = read_ints()\\n      \\n      field = get_field(r, c)\\n          \\n      left = fill(field, r, c, m)\\n          \\n      return 'Impossible' if left != 0 else atos(field)\\n      \\n      \\n  def main():\\n      cases = read_int()\\n      for case in range(1, cases + 1):\\n          print('Case #{}:\\n{}'.format(case, solve_case()))\\n  \\n          \\n  main()\\n", "substitutes": {"A": ["D", "G", "O", "mA", "One", "Area", "X", "AA", "H", "L", "E", "array", "R", "An", "B", "Ar", "AU", "CA", "This", "J", "V", "SA", "M", "AB", "Row", "GA", "Z", "Y", "Array", "C", "I", "P", "a", "W", "T", "S", "All"], "row": ["post", "match", "rc", "word", "col", "rs", "ser", "ob", "ox", "ro", "record", "raw", "rown", "name", "char", "tr", "item", "star", "line", "entry", "join", "Row", "x", "ow", "instance", "list", "th", "ows", "roll", "may", "data", "rows", "cell", "right", "pair"], "r": ["range", "res", "br", "p", "rc", "ra", "er", "fr", "re", "str", "err", "rs", "rx", "it", "rec", "o", "t", "lr", "h", "nr", "ro", "rg", "rb", "g", "n", "R", "f", "ri", "ar", "ru", "tr", "d", "pr", "w", "u", "q", "b", "l", "rr", "cr", "hr", "rar", "co", "x", "sr", "attr", "dr", "gr", "rm", "mr", "vr", "a", "rn", "v", "rh", "rt", "rd", "ir", "right"], "c": ["dc", "p", "ic", "rc", "k", "col", "e", "cp", "cm", "t", "o", "cur", "lc", "ct", "h", "bc", "cf", "n", "z", "con", "g", "f", "xc", "rb", "cos", "ar", "cat", "w", "d", "cu", "cn", "cb", "u", "q", "cs", "y", "cache", "cin", "b", "ac", "l", "cr", "co", "cc", "mc", "ch", "C", "cd", "ca", "fc", "ce", "a", "gc", "v", "tc", "com", "ci"], "field": ["function", "label", "tmp", "force", "base", "command", "fe", "domain", "fix", "term", "node", "name", "rule", "item", "user", "line", "local", "cache", "link", "job", "position", "mp", "length", "cell", "match", "default", "word", "service", "prefix", "part", "util", "Field", "lc", "key", "record", "control", "json", "config", "byte", "player", "fields", "back", "child", "attribute", "FIELD", "level", "answer", "tag", "form", "load", "this", "column", "display", "stack", "group", "f", "league", "arg", "join", "member", "table", "query", "ld", "document", "map", "file", "button", "data", "component", "test", "right", "comment", "pair", "post", "storage", "relation", "self", "section", "condition", "result", "index", "entry", "db", "pad", "buffer", "value", "input", "message", "list"], "i": ["ki", "hi", "p", "li", "e", "io", "iti", "ai", "pi", "ati", "iam", "zi", "a", "ie", "ir", "ci", "gi", "ji", "o", "id", "ini", "bi", " I", "xi", "u", "\u0438", "ij", "iu", "ix", "di", "v", "ib", "it", "n", "g", "f", "ui", "info", "ti", "y", "l", "x", "oi", "ni", "ic", "ami", "ia", "iri", "ri", "phi", "ei", "qi", "int", "index", "si", "im", "mi", "multi", "init", "b", "ip", "ori", "aci", "I", "ind"], "j": ["p", "jl", "fr", "er", "li", "jp", "t", "h", "jac", "then", "w", "d", "pr", "q", "_", "J", "dj", "job", "jc", "a", "ie", "ji", "o", "ress", "s", "uj", "u", "json", "ij", "ver", "di", "out", "js", "v", "pt", "br", "str", "err", "it", "z", "n", "g", "f", "y", "l", "x", "ion", "jas", "je", "aj", "test", "res", "og", "k", "note", "ja", "dt", "kj", "b", "db", "jack", "adj", "obj", "jump", "bj", "ger", "ian"], "m": ["p", "k", "em", "dm", "e", "ms", "cm", "t", "o", "mm", "h", "z", "n", "g", "s", "pm", "f", "am", "w", "d", "gm", "q", "im", "mi", "y", "u", "man", "b", "M", "mt", "l", "mc", "min", "sm", "ma", "mp", "rm", "mr", "mem", "a", "v", "vm", "arm"], "left": ["p", "li", "long", "le", "wrong", "old", "none", "top", "down", "name", "w", "full", "local", "set", "line", "to", "min", "diff", "length", "low", "inner", "default", "op", "missing", "Left", "no", "lc", " Left", "width", "lp", "lt", "center", "out", "level", "form", "this", "Right", "err", "ll", "mask", "lower", "L", "mm", "path", "n", "found", "join", "l", "co", "x", "net", "format", "minimum", "right", "pair", "start", "url", "self", "all", "lo", "joined", "only", "index", "cont", "after", "ml", "lock", "list"], "ii": ["gi", "ji", "hi", "ifi", "igi", "jl", "li", "gif", "iy", "ia", "io", "ih", "ort", "irrel", "iw", "ire", "irm", "ail", "iri", "inite", "qq", "ios", "ri", "ei", "nil", "arb", "ti", "ini", "cu", "iat", "si", "uj", "aaa", "\u012b", "init", "ai", "iii", "iona", "itime", "ially", "ski", "pi", "ij", "ni", "ati", "wife", "iam", "II", "ix", "di", "ice", "false", "sv", "iro", "zy", "ie", "ta", "ir", "ci", "iso", "ee"], "jj": ["ji", "ju", "jl", "k", "circ", "it", "jp", "cm", "ia", "t", "jam", "mm", "ind", "yy", "nr", "bb", "aq", "n", "jad", "g", "f", "ja", "hn", "jac", "aaa", "uj", "y", "json", " iii", "kj", "iii", "b", "dj", "ctr", "vv", "rr", "cc", "ij", "jc", "uu", "bah", "jas", "aj", "jah"], "cases": ["values", "cycles", "xs", "rs", "times", "ids", "results", "errors", "ces", "sets", "cs", "features", "runs", "changes", "his", "fields", "codes", "sections", "items", "checks", "ends", "uses", "ups", "terms", "rows", "lines", "tests"], "case": ["the", "of", "n", "ed", "all", "_", "cont", "join", "just", "more", "get", "inner"]}}
{"code": " \\n  def read_str(): return stdin.readline().rstrip('\\n')\\n  def read_int(): return int(stdin.readline())\\n  def read_ints(): return map(int, stdin.readline().split())\\n  \\n  def read_cards():\\n      cards = []\\n      for i in range(4):\\n          cards.append(read_ints())\\n      return cards\\n  \\n  def main():\\n      cases = read_int()\\n      for case in range(1, cases + 1):\\n          row = read_int() - 1\\n          cards = read_cards()\\n          candidates1 = set(cards[row])\\n          \\n          row = read_int() - 1\\n          cards = read_cards()\\n          candidates2 = set(cards[row])\\n          \\n          candidates = candidates1.intersection(candidates2)\\n          if len(candidates) == 1:\\n              ans = list(candidates)[0]\\n          elif len(candidates) == 0:\\n              ans = 'Volunteer cheated!'\\n          else:\\n              ans = 'Bad magician!'\\n          \\n          print('Case #{}: {}'.format(case, ans))\\n          \\n  main()\\n", "substitutes": {"cards": ["values", "args", "lists", "olds", "lands", "comments", "months", "guards", "images", "packs", "cars", "photos", "levels", "ands", "games", "ways", "rings", "cf", "craft", "cos", "ds", "bags", "ims", "letters", "ports", "ws", "Card", "cs", "houses", "multi", "lights", "amps", "ards", "tags", "rollers", "plays", "cont", "boxes", "cells", "days", "fields", "bits", "groups", "holders", "chains", "codes", "posts", "hands", "card", "items", "members", "points", "caps", "checks", "boards", "clips", "balls", "roll", "lets", "cons", "planes", "services", "pieces", "sticks", "dds", "gc", "rows", "steps", "lines", "cas", "tests", "windows", "gs"], "i": ["p", "ic", "ico", "li", "it", "io", "id", "il", "ti", "ini", "item", "index", "char", "im", "ai", "ip", "x", "pi", "ii", "ix", "I", "zi", "ie", "c", "ind", "ci"], "cases": ["values", "cycles", "xs", "aps", "ps", "times", "ids", "results", "blocks", "ls", "ces", " Cases", "cs", "names", "runs", "classes", "changes", "cells", "fields", "codes", "Case", "sections", "chains", "items", "caps", "checks", "ends", "terms", "ases", "rows", "lines", "steps", "pes", "limits", "rules", "tests", "cas"], "case": ["ance", "race", "su", "col", "cp", "seat", "lc", "code", "id", "ace", "example", "nce", " CASE", "name", "cation", "rule", "section", "condition", "index", "line", "cs", "core", "catch", "mode", "Case", "co", "cycle", "instance", "num", "hyp", "ice", "ase", "ca", "ce", "cer", "c", "tc", "cell", "test", "size", "cas"], "row": ["res", "post", "rc", "ref", "bo", "col", "rs", "cur", "client", "seat", "ser", "ro", "key", "week", "zero", "rown", "pc", "tr", "index", "sc", "line", "set", "rot", "sw", "r", "tab", "Row", "co", "room", "ow", "x", "month", "server", "order", "loc", "batch", "th", "box", "ver", "ows", "roll", "ward", "px", "round", "rows", "ry", "pos", "cell", "pair", "mod", "step", "num"], "candidates1": ["candatoes2", "candonents0", "candidates001", "valands001", "Candidates0", "candands2", "candients3", "candonents1", "Candidate1", "candatoes1", "candidate1", "validates001", "candands001", "candands3", "candients001", "Candidate2", "candidate2", "candonents001", "candidates3", "validates1", "Candidates001", "candients1", "candidates0", "candidate001", "candidate3", "validates2", "Candidate001", "validates3", "candands1", "candonents2", "valands2", "Candidate0", "Candidates2", "valands3", "candidate0", "candatoes001", "Candidates1", "candients2", "candatoes0", "valands1"], "candidates2": ["candplates6", "callands2", "CandidatesTwo", "Candidates6", "candidateTwo", "candidates6", "candandsTwo", "candands2", "canduments2", "candplates2", "CandidateTwo", "callidates1", "Candidate1", "candidate1", "candands02", "candidates02", "callidates02", "candplates1", "Candidate2", "candidate2", "candumentsTwo", "candidatesTwo", "candlesTwo", "callandsTwo", "candles2", "candands1", "Candidates2", "callidatesTwo", "callands1", "canduments1", "candles02", "callands02", "Candidate6", "Candidates1", "candplatesTwo", "callidates2", "candidate02", "candidate6", "candles1", "canduments6"], "candidates": ["candicates", "validles", "catries", "centents", "Candents", "catidates", "mintidates", "mandents", "candries", "centsters", "centicates", "validicates", "centances", "Candidates", "mandries", "candsters", "Candants", "charents", "counteters", "candeters", "charants", "charances", "candles", "Candidate", "charidates", "charidate", "catents", "catsters", "mandidates", "countances", "centidates", "minticates", "mintles", "candants", "centidate", "candances", "valididates", "chareters", "mandsters", "centles", "centeters", "centates", "candents", "centries", "countents", "validates", "candates", "centants", "countidates", "mintates", "candidate"], "ans": ["ants", "ams", "ns", "works", "ks", "olds", "os", "aus", "ands", "ents", "ids", "ANS", "lan", "an", "ann", "anc", "eds", "uns", "ars", "ces", "cn", "cks", "mails", "amps", "asks", "ran", "arms", "aos", "ras", "anes", "ins", "irms", "rans", "anas", "anks", "avor", "ens", "angs", "ean", "arts", "vals", "san", "ians", "ines", "offs", " means", "ons", "rors", "books", "eps", "ats", "helps", "tes"]}}
{"code": "T = int(input())\\n  \\n  def solve(R,C,M):\\n      if R>C:\\n          flipboard = solve(C,R,M)\\n          if flipboard:\\n              return [[flipboard[j][i] for j in range(C)] for i in range(R)]\\n          else:\\n              return\\n      if M==0:\\n          board = [['.']*C for i in range(R)]\\n          board[-1][-1] = 'c'\\n          return board\\n      if R == 1:\\n          board = ['*' if i<M else '.' for i in range(R*C)]\\n          board[-1] = 'c'\\n          return [board]\\n      if R == 2:\\n          if R*C==M+1:\\n              board = [['*']*C for i in range(R)]\\n              board[-1][-1] = 'c'\\n              return board\\n          if (M%2) or (M+2)==(R*C):\\n              return\\n          board = [['*' if i<(M/2) else '.' for i in range(C)] for j in range(R)]\\n          board[-1][-1] = 'c'\\n          return board\\n      if M>=R:\\n          subboard = solve(R,C-1,M-R)\\n          if subboard:\\n              return [['*']+r for r in subboard]\\n          return\\n      if (R,C,M) == (3,3,2):\\n          return\\n      k = min(M,C-2)\\n      board = [['*']*k+['.']*(C-k)]\\n      for i in range(M-k):\\n          board.append(['*']+['.']*(C-1))\\n      while len(board)<R:\\n          board.append(['.']*(C))\\n      board[-1][-1] = 'c'\\n      return board\\n      \\n           \\n      \\n  \\n  for case in range(1,T+1):\\n      print(\"Case #\",case,\": \",sep='')\\n      R,C,M = (int(x) for x in input().split())\\n      ans = solve(R,C,M)\\n      if ans:\\n          for r in ans:\\n              print(''.join(r))\\n      else:\\n          print('Impossible')\\n  \\n  \\n", "substitutes": {"T": ["Time", "D", "G", "O", "TI", "TT", "TN", "IT", "t", "L", "TY", "TM", "E", "Q", "A", "B", "TC", "TS", "TA", "F", "Type", "V", "Z", "Y", "N", "TR", "TB", "K", "I", "P", "W", "VT", "S"], "R": ["Range", "D", "G", "O", "Right", "JR", "X", "Run", "RA", "H", "L", "U", "CR", "Q", "A", "E", "ro", "RC", "Remote", "DR", "IR", "B", "RG", "Res", "AR", "Mr", "J", "Reader", "F", "V", "RO", "RS", "Rot", "Row", "Repl", "Y", "N", "RE", "TR", "RR", "ER", "K", "Rs", "I", "RM", "P", "RT", "W", "RW", "S", "MR", "Role"], "C": ["COM", "Co", "D", "G", "O", "JC", "Ch", "COR", "X", "H", "L", "U", "CR", "A", "Q", "CM", "E", "Cr", "CN", "Chain", "CS", "B", "CA", "Cl", "CE", "CV", "CC", "WC", "F", "CON", "Craig", "J", "V", "EC", "Con", "Y", "CNN", "N", "CO", "CT", "CG", "VC", "CP", "DC", "K", "I", "Cache", "P", "Mc", "W", "c", "CL", "CCC", "MC", "CU", "S", "Cs", "CW"], "M": ["D", "G", "O", "X", "MA", "cm", "H", "TM", "m", "L", "U", "E", "Q", "MR", "CM", "A", "MN", "REM", "NM", "BM", "OM", "Mon", "MAN", "B", "Mi", "MM", "JM", "MX", "F", "J", "IM", "Multi", "V", "Z", "Y", "LM", "EM", "N", "RE", "MT", "MI", "K", "I", "RM", "P", "Mc", "DM", "W", "c", "MC", "Mouse", "ME", "MS", "S", "AM"], "flipboard": ["flippedback", "FlippedBoard", "flippingBoard", "flippback", "Flippback", "FlipBoard", "flippingline", "Flipbox", "flippedrow", "flipline", "slipBoard", "flippline", "flclipbox", "Flippedline", "fllipback", "slipboard", "slipprow", "flippboard", "flippedbox", "flipback", "flippingboard", "flippingrow", "flipBoard", "flippbox", "flippedline", "flclipBoard", "FlippBoard", "flipprow", "Flippedbox", "slippBoard", "flclipboard", "slippboard", "flippedboard", "Flipline", "flippedBoard", "flclipline", "slipback", "Flippedboard", "Flippline", "fllipBoard", "flippingback", "Flipboard", "flippBoard", "fllipline", "flipbox", "sliprow", "fliprow", "Flippboard", "fllipboard", "Flipback", "slippback"], "j": ["ji", "p", "jj", "ju", "li", "it", "jp", "t", "o", "m", "ik", "z", "n", "g", "ja", "bi", "si", "uj", "q", "im", "y", "J", "ai", "kj", "b", "ip", "l", "oj", "ij", "job", "jc", "ix", "js", "jump", "a", "c", "ie", "v", "aj"], "i": ["gi", "ji", "ki", "p", "ic", "li", "e", "it", "ia", "t", "o", "io", "m", "ik", "ior", "iti", "n", "ri", "phi", "ei", "ti", "ini", "bi", "il", "si", "ili", "xi", "u", "y", "mi", "im", "\u0438", "ai", "b", "\u00ed", "ip", "ori", "l", "pi", "ii", "ij", "iu", "ni", "oi", "ati", "di", "I", "zi", "c", "ie", "v", "fi", "ir", "yi", "ci", "ian"], "board": ["empty", "function", "p", "menu", "cho", "check", "base", "piece", "t", "deck", " boards", "ner", "full", "line", "local", "head", "blank", "hold", "row", "sequence", "stream", "body", "clean", "door", "box", "void", "length", "Board", "c", "rain", "inner", "program", "bo", "word", "block", "ro", "run", "control", "chain", "loop", "lay", "rank", "rot", "stone", "bang", "bank", "player", "pool", "anks", "back", "bro", "valid", "square", "form", "video", "oard", "zone", "layout", "zero", "f", "database", "aco", "random", "ac", "poll", "join", "channel", "bench", "co", "flow", "runner", "ward", "bar", "land", "controller", "mate", "way", "test", "bin", "range", "ard", "bridge", "bit", "won", "system", "lo", "uno", "core", "builder", "rect", "cross", "view", "b", "pad", "buffer", "plate", "room", "chart", "boards", "ack", "boarding", "boot", "black", "bird", "bug", "lock", "bot", "list"], "subboard": ["childBoard", "subback", "subbox", "sumback", "ubBoard", "subboards", "ubbo", " subback", "ubrow", "ubboards", "childboard", "sumboards", " subrow", "subBoard", "setbo", "subbo", "Subloop", "SubBoard", "Subbox", " subboards", "childbox", "ubboard", "subloop", "setBoard", "sumbo", "subrow", " subloop", "ubback", " subbo", "Subboard", " subBoard", "sumboard", "Subbo", "setbox", "childbo", "ubloop", "Subrow", "setboard"], "r": ["range", "ard", "br", "p", "rc", "er", "ra", "re", "rer", "err", "rs", "cut", "t", "rec", "m", "h", "ro", "run", "z", "n", "s", "ur", "rb", "f", "ror", "ar", "ru", "ner", "w", "d", "pr", "q", "u", "rank", "runs", "kr", "ran", "b", "ras", "row", "l", "rr", "cr", "rar", "ros", "rat", "runner", "dr", "rm", "ring", "out", "mr", "a", "c", "rows", "rd", "ir", "rt", "right", "inner", "pair"], "k": ["ki", "kan", "ks", "p", "tk", "ic", "t", "o", "ek", "m", "ik", "max", "h", "key", "z", "n", "ck", "ikk", "g", "uk", "kw", " K", "kk", "w", "d", "ke", "q", "kh", "y", "kr", "ka", "ko", "kj", "b", "mk", "l", "ku", "mc", "ack", "K", "km", "c", "v", "kl", "ak", "unk"], "case": ["trial", "switch", "one", "race", "type", "block", "pe", "code", "ace", "example", " CASE", "rule", "name", "chain", "section", "line", "mode", "me", "row", "cor", "rial", "Case", "cycle", "instance", "cases", "ice", "ring", "ase", "ce", "c", "tc", "test", "choice", "ind", "cas"], "x": ["ux", "p", "ic", "xs", "e", "ctx", "X", "rx", "at", "t", "wx", "xes", "dx", "xp", "ox", "z", "ross", "s", "xc", "xa", "tx", "xt", "mx", "w", "q", "xi", "y", "xf", "el", "l", "xe", "ix", "xy", "ex", "px", "v", "xx", "xb", "fx", "pair"], "ans": ["ants", "res", "ns", "os", "aces", "aus", "ms", "rs", "rons", "aps", "relations", " fans", "ents", "ANS", "unes", "an", "ann", "s", "ays", "ls", "anc", "An", "can", "uns", "ars", "acers", "amps", "ran", "ai", "ras", "ins", "rans", "anas", "anks", "rates", "ros", "ens", "orts", "angs", "AN", "arts", "ians", "cases", "ons", "ats", "actions"]}}
{"code": "T = int(input())\\n  for case in range(1,T+1):\\n      row1 = int(input())\\n      for i in range(1,5):\\n          l = input()\\n          if i==row1:\\n              first = set(int(x) for x in l.split())\\n      row2 = int(input())\\n      for i in range(1,5):\\n          l = input()\\n          if i==row2:\\n              second = set(int(x) for x in l.split())\\n      poss = first & second\\n      if len(poss) ==0:\\n          ans = 'Volunteer cheated!'\\n      elif len(poss) >1:\\n          ans = 'Bad magician!'\\n      else:\\n          ans = min(poss)\\n      print(\"Case #\",case,\": \",ans,sep = '')\\n", "substitutes": {"T": ["Time", "D", "G", "O", "TT", "TN", "X", "t", "L", "TY", "E", "Q", "A", "Tab", "R", "B", "TC", "TS", "TA", "F", "J", "Type", "V", "M", "TW", "Z", "Y", "N", "C", "K", "I", "P", "W", "S"], "case": ["trial", "switch", "one", "One", "type", "lic", "X", "ite", "U", "L", "E", "pe", "id", "ace", "example", "name", "section", "CE", "change", "line", "CI", "row", "Case", "Y", "sequence", "instance", " Case", "version", "C", "ice", "cases", "ASE", "ase", "I", "P", "ce", "ie", "c", "context", "test", "ci", "cas"], "row1": ["ro1", " rowA", "rows0", "ow11", "rows1", "ow4", "ro0", "ro11", "row11", "rowsA", " row11", "owA", "ow1", "row4", "row0", "ow0", "row3", " row3", "rowA", "ow3", "ro4", " row4", "rows3", " row0"], "i": ["gi", "p", "ic", "j", "er", "li", "isi", "it", "ia", "t", "o", "m", "ici", "iti", "n", " ii", "phi", "int", "ti", "il", "ini", "iat", "si", "xi", "im", "mi", "ine", "y", "ai", "there", "ip", "\u00ed", "itime", "pi", "ii", "ij", "iu", "ati", "iam", "di", "zi", "I", "ie", "v", "ir", "yi", "ind", "ci"], "l": ["lu", "p", "j", "la", "li", "ll", "it", "t", "lin", "long", "L", "m", "fl", "le", "sl", "lc", "h", "z", "n", "g", "f", "lo", "ls", "rl", "lit", "dl", "ner", "q", "line", "left", "u", "r", "lp", "pl", "b", "lb", "lt", "el", "cl", "nl", "ly", "ln", "ld", "ch", "hl", "c", "v", "ml", "lock", "list"], "first": ["third", "next", "p", "one", "single", "frame", "initial", "start", "master", "part", "lower", "alt", "minute", "pre", "success", "lead", "First", "all", "before", "f", "top", "name", "art", "then", "last", "only", "full", "main", "current", "sort", "row", "prem", "split", "primary", "st", "min", "th", "normal", "a", "short", "front", "must", "small", "fifth", "fourth"], "x": ["hex", "ux", "p", "ic", "xs", "e", "ctx", "X", "rx", "xes", "t", "wx", "xp", "php", "lc", "h", "z", "ross", "xc", "n", "xa", "f", "xt", "tx", "w", "xi", "line", "y", "q", "u", "left", "inx", "xf", "r", "el", "yx", "xe", "lex", "ix", "xy", "a", "ex", "c", "xx", "v", "xml", "fx", "ci"], "row2": [" row5", "ow5", "owTwo", " rowtwo", "ow2", "ro2", "roTwo", "owtwo", "rtwo", "ow4", "ro0", "r4", "row4", "r5", "rowTwo", "row5", "row0", "ow0", "row3", "r2", "ro3", " row3", "ow3", " rowTwo", " row4", " row0", "rowtwo"], "second": ["third", "next", "south", "account", "forth", "video", "common", "secondary", "billion", "shell", "last", "section", "future", "test", "another", "left", "two", "sequent", "sec", "follow", "double", "latest", "split", "member", "server", "female", "bottom", "bis", "seconds", "bowl", "beta", "secret", "minimum", "lower", "Second", "small", "fifth", "fourth"], "poss": ["Pass", "pess", " possible", "paess", "repass", "repOSS", "Posit", " prav", " possession", " pess", "reposs", "repossession", "psossession", "Poss", "psos", "reprav", "Pos", "psossible", "psass", " posit", " pos", "possession", " pOSS", "repossible", "posit", "psoss", "repos", "parav", "paOSS", "pOSS", "psonse", "repess", "Ponse", " ponse", "reposit", "prav", "Possession", "pos", "ponse", "possible", "paoss"], "ans": ["ants", "ams", "ns", "olds", "ks", "os", "oss", "aus", "ms", "ands", "ents", "ANS", "lan", "idents", "an", "ann", "ls", "eds", "ds", "nan", "uns", "ars", "cs", "arms", "amps", "mails", "ran", "aos", "actions", "ras", "ins", "rans", "anas", "posts", "ads", "anks", "ens", "angs", "arts", "vals", "san", "offs", "cons", "ums", "ons", "books", "uploads", "eps", "ats", "said"]}}
{"code": "filename = raw_input(\"Name of file: \")\\n  infile = open(filename, \"r\")\\n  outfile = open(filename + \".out\", \"w\")\\n  \\n  \\n  T = int(infile.readline()[:-1])\\n  \\n  def addMinesDiagonally(r, c, m):\\n      field = []\\n      for i in range (r):\\n          row = []\\n          for j in range(c):\\n              row += [\".\"]\\n          field += [row]\\n          \\n      for i in range (r + c):\\n          ver = min (i, r - 1)\\n          hor = max (0, 1 + i - r)\\n          while ver >= 0 and hor <= c - 1 and m > 0:\\n              if m == 1 and hor == c - 2 and ver == r - 2:\\n                  ver -= 1\\n                  hor += 1\\n              field[ver][hor] = \"*\"\\n              ver -= 1\\n              hor += 1\\n              m -= 1\\n          \\n      return field\\n  \\n  def isPossible(field):\\n      if field[-1][-1] != \".\":\\n          return False\\n      up = True\\n      left = True\\n      diag = True\\n      if len(field) > 1 and field[-2][-1] != \".\":\\n              up = len(field[-1]) <= 1\\n      if len(field[-1]) > 1 and field[-1][-2] != \".\":\\n              left = len(field) <= 1\\n      if len(field) > 1 and len(field[-1]) > 1 and field[-2][-2] != \".\":\\n          diag = False\\n      return (up and left and diag) or \\\\n             ((not up) and (not left) and (not diag))\\n      \\n  \\n  for t in range(1, T + 1):\\n      items = infile.readline()[:-1].split(\" \")\\n      r = int(items[0])\\n      c = int(items[1])\\n      m = int(items[2])\\n      field = addMinesDiagonally(r, c, m)\\n      if isPossible(field):\\n          field[-1][-1] = \"c\"\\n          s = \"\"\\n          for line in field:\\n              for cell in line:\\n                  s += cell\\n              s += \"\\n\"\\n          outfile.write(\"Case #%d:\\n%s\\n\" %(t, s[:-1]))\\n      else:\\n          s = \"IMPOSSIBLE!!!!\\n\"\\n          for line in field:\\n              for cell in line:\\n                  s += cell\\n              s += \"\\n\"\\n          outfile.write(\"Case #%d:\\n%s\\n\" %(t, s[:-1]))\\n      \\n          \\n      \\n  \\n  outfile.close()\\n  infile.close()\\n", "substitutes": {"filename": ["tek", "nw", "prefix", "knife", "txt", "mson", "nc", "isa", "unction", "f", "lua", "til", "username", "nil", "name", "phy", "jen", "Filename", "knit", "fle", "wire", "rake", "println", "fil", "there", "instead", "tp", "text", "ername", "figure", "directory", "nm", "string", "title", "SourceFile", "sword", "fp", "out", "file", "FILE", "kl", "wr", "wright", "fn", "aka", "ename"], "infile": ["inqueue", "outFile", "Inout", "innfile", " inFile", " inqueue", "Infile", " infiles", "Infiles", "inout", "outline", "InFile", " informat", "innfiles", "infiles", "inFile", "innformat", "outout", "innerqueue", "innerline", "Informat", "innerfile", "iniout", "inifile", "inline", "iniline", "Inqueue", "informat", "innerFile", " inline", "innFile", "iniFile", "Inline"], "outfile": ["inwrite", "outFile", " outto", "overto", " outline", "overline", "otline", "outto", " outwrite", "outline", "into", "otwrite", "otfile", "overfile", "inFile", " outFile", "inline", "otFile", "outwrite", "overFile"], "T": ["Time", "D", "O", "TP", "TI", "TN", "IT", "H", "L", "TM", "Q", "R", "B", "TC", "TS", "TA", "F", "J", "Type", "V", "M", "Y", "N", "WT", "GT", "TR", "TB", "C", "K", "Total", "I", "P", "W", "TO", "VT", "S"], "r": ["res", "p", "ra", "rc", "er", "fr", "re", "e", "rs", "lr", "o", "h", "nr", "ro", "rid", "n", "rb", "ren", "R", "g", "ri", "f", "ar", "ru", "pc", "tr", "d", "w", "u", "q", "b", "l", "cr", "rar", "x", "sr", "dr", "mr", "vr", "a", "v", "rd", "rt", "ir", "rh", "right"], "c": ["dc", "p", "rc", "k", "col", "e", "cp", "cm", "o", "cur", "coll", "lc", "ct", "h", "z", "n", "cf", "con", "g", "f", "cos", "cu", "d", "w", "cn", "cb", "u", "cs", "ec", "y", "cin", "cache", "b", "ac", "cl", "l", "cr", "co", "x", "cc", "mc", "ch", "C", "cd", "ca", "fc", "ce", "a", "v", "tc", "com", "ci"], "m": ["p", "k", "dm", "tm", "er", "e", "re", "ms", "cm", "o", "mm", "h", "z", "n", "g", "all", "f", "bm", "am", "mn", "w", "d", "gm", "u", "im", "mi", "y", "man", "b", "on", "M", "mt", "l", "x", "mc", "pi", "min", "ter", "ma", "rm", "mr", "a", "v", "vm", "mon", "arm"], "field": ["label", "p", "er", "col", "force", "command", "domain", "error", "term", "node", "option", "here", "rule", "name", "spec", "proc", "char", "user", "set", "comp", "cache", "link", "var", "job", "position", "box", "length", "inner", "vector", "match", "word", "prefix", "part", "Field", "block", "lc", "key", "record", "config", "byte", "player", "ment", "fields", "back", "child", "out", "v", "attribute", "FIELD", "filter", "level", "answer", "tag", "form", "load", "column", "butt", "time", "display", "stack", "event", "group", "f", "exp", "arg", "grid", "point", "member", "dict", "table", "co", "query", "ld", "ter", "format", "file", "data", "header", "component", "play", "test", "comment", "bin", "case", "pair", "range", "post", "bit", "storage", "type", "frame", "flag", "relation", "param", "section", "condition", "result", "index", "wire", "feature", "entry", "db", "pad", "tab", "value", "layer", "input", "version", "obj", "string", "method", "message", "good", "list"], "i": ["ic", "p", "er", "li", "e", "it", "ia", "o", "h", "rid", "id", "n", "f", "ri", "inter", "int", "il", "ti", "bi", "d", "si", "index", "u", "im", "y", "mi", "b", "ip", "l", "x", "pi", "ii", "ij", "iu", "oi", "I", "a", "ie", "v", "ir", "ind", "ci"], "row": ["range", "res", "rc", "col", "re", "rs", "ser", "ox", "ro", "group", "rown", "name", "tr", "index", "w", "rot", "co", "x", "ow", "order", "num", "box", "ter", "ows", "roll", "th", "out", "vr", "rows", "ry", "pos", "pair"], "j": ["k", "cm", "cut", "z", "code", "g", "ck", "jac", "cod", "q", "b", "cont", "cl", "oj", "cr", "co", "cc", "mc", "ij", "car", "jc", "ch", "rm", "cd", "gc", "aj", "mod"], "ver": ["res", "er", "fr", "li", "re", "type", "lr", "ser", "h", "rid", "vert", "con", "ve", "inter", "um", "vet", "vers", "tr", "pr", "rot", "b", "var", "aver", "over", "val", "hr", "browser", "server", "co", "Ver", "version", "ter", "ever", "iter", "dr", "gr", "vr", "mr", "iver", "v", "ir", "VER", "test", "av"], "hor": ["hi", "mil", "fr", "mir", "hel", "ho", "hal", "lr", "hd", "ser", "h", "den", "rid", "vert", "con", "lo", "Hor", "phi", "hang", "inter", "en", "tr", "vers", "pr", "hei", "mi", "rot", "eth", "hold", "mt", "hr", "dh", "bh", "hair", "len", "hl", "ha", "ter", "dr", "iter", "orth", "vr", "mr", "her", "hard", "floor", "v", "high", "ir", "mot", "dir", "ind", "hom"], "up": ["au", "post", " Up", "ouch", "p", "ap", "ra", "UP", "op", "space", "sup", "prom", "upid", "ou", "ud", "push", "success", "all", "top", "down", "um", "upt", "upper", "user", "own", "u", "y", "uc", "ip", "over", "home", "ow", "flow", "upload", "omp", "back", "uph", "mp", "ups", "out", "ote", "ex", "Up", "ump", "high", "low", "pos", "sum", "upp"], "left": ["level", "p", "done", "la", "leave", "li", "lic", "open", "start", "Left", "fail", "lock", "L", "le", "wrong", "long", "cond", "push", "path", "all", "lo", "shell", "top", "down", "small", "dl", "only", "ner", "full", "lit", "both", "local", "own", "pl", "cont", "lt", "log", "l", "nl", "rel", "below", "net", "body", "loc", "bottom", "min", "len", "false", "out", "length", "broad", "low", "pos", "ml", "lower", "right", "com", "inner", "list"], "diag": ["diagger", " diang", " diagger", "diags", "giagg", "duags", "Diags", "Diag", "giig", "diig", "Diagg", "liig", "duig", "liag", "liags", "duag", "Diig", "duagger", "liagg", "diang", " diagg", "giag", "diagg", "Diang", "Diagger", " diags", "liang", " diig", "giagger"], "t": ["p", "tt", "total", "k", "type", "tm", "e", "at", "o", "time", "h", "n", "g", "f", "ti", "w", "d", "dt", "q", "y", "b", "typ", "l", "ty", "tp", "x", "ot", "to", "te", "out", "tip", "ta", "v", "tc", "ts", "wt", "size"], "items": ["args", "ops", "os", "aps", "times", "ics", "ids", "ips", "files", "ites", "keys", "ls", "ims", "users", "els", "flows", "orders", "amps", "workers", "its", "ers", "airs", "docs", "ins", "cats", "cells", "bits", "groups", "sections", "qs", "points", "phones", "aux", "vals", "ows", "lets", "Items", "pages", "terms", "rows", "lines", "objects", "jobs", "links", "plugins", "ues", "tests", "stats"], "s": ["se", "args", "p", "er", "the", "col", "e", "of", "ed", "ls", "w", "d", "_", "set", "ins", "a", "num", "o", "ers", "fields", "sid", "ix", "sand", "js", "v", "es", "S", "sam", "sb", "ns", "os", "form", "ms", "X", "ss", "strings", "n", "g", "f", "ds", "y", "sit", "its", "cells", "l", "x", "sm", "new", "lines", "ats", "sat", "sv", "gs", "sd", "type", "rs", "ps", "ies", "us", "mat", "ws", "si", "sf", "cs", "b", "cont", "string", "get", "ge", "sys", "rows", "fs", "ts"], "line": ["range", "se", "Line", "match", "ide", "open", "load", "end", "frame", "li", "start", "col", "note", "lin", "block", "code", "vert", "lined", "ner", "change", "lay", "set", "ine", "email", "write", "link", "l", "ln", "age", "liner", "box", "inline", "ge", "lines", " inline", "lock", "edge", "case"], "cell": ["label", "check", "er", "word", "col", "form", "cy", "cut", "butt", "code", "ck", "shell", "null", "name", "char", "ner", "ad", "lay", "_", "entry", "pad", "cells", "Cell", "tab", "cel", "co", "call", "table", "draw", "batch", "ell", "obj", "slice", "ter", "string", "new", "box", "inline", "nel", "v", "inner", "case"]}}
{"code": "filename = raw_input(\"Name of file: \")\\n  f = open(filename, \"r\")\\n  o = open(filename + \".out\", \"w\")\\n  \\n  \\n  T = int(f.readline()[:-1])\\n  \\n  many_possible = \"Bad magician!\"\\n  zero_possible = \"Volunteer cheated!\"\\n  \\n  for t in range(1, T + 1):\\n      first = int(f.readline()[:-1]) - 1\\n      grid1 = []\\n      for i in range(4):\\n          grid1 += [f.readline()[:-1].split(\" \")]\\n          \\n      second = int(f.readline()[:-1]) - 1\\n      grid2 = []\\n      for i in range(4):\\n          grid2 += [f.readline()[:-1].split(\" \")]\\n  \\n      possible = []\\n      for num in grid1[first]:\\n          if num in grid2[second]:\\n              possible += [num]\\n  \\n      if len(possible) == 1:\\n          o.write(\"Case #%d: %s\\n\" %(t, possible[0]))\\n      elif len(possible) == 0:\\n          o.write(\"Case #%d: %s\\n\" %(t, zero_possible))\\n      else:\\n          o.write(\"Case #%d: %s\\n\" %(t, many_possible))\\n          \\n      \\n  \\n  o.close()\\n  f.close()\\n", "substitutes": {"filename": ["bas", "nw", "prefix", "life", "knife", "txt", "mson", "ame", "n", "nc", "unction", "isa", "til", "username", "nil", "name", "phy", "jen", "uno", "Filename", "knit", "fle", "println", "fil", "nu", "nom", "there", "np", "nl", "tp", "text", "jin", "figure", "tain", "nm", "string", "title", "which", "fp", "out", "file", "FILE", "kl", "fn", "ames", "ename"], "f": ["ft", "fd", "p", "bf", "j", "fx", "form", "fr", "df", "e", "it", "ent", "m", "fl", "fe", "h", "of", "cf", "n", "fo", "uf", "s", "conf", "rf", "elf", "af", "g", "fg", "exp", "info", "fb", "w", "d", "full", "lf", "tf", "sf", "q", "y", "F", "r", "xf", "fm", "b", "l", "inf", "x", "ln", "iu", "fed", "obj", "fast", "fp", "file", "fc", "a", "fs", "c", "v", "fi", "fn", "fa"], "o": ["po", "oo", "p", "O", "os", "flo", "open", "bo", "op", "k", "go", "e", "ho", "io", "no", "ob", "h", "ox", "n", "fo", "final", "g", "s", "do", "up", "ome", "ao", "om", "w", "u", "y", "r", "aos", "b", "ko", "auto", "l", "co", "ow", "ot", "oa", "to", "output", "obj", "ma", "yo", "oos", "out", "onet", "v", "object", "iso"], "T": ["Time", "D", "G", "O", "TP", "TT", "TN", "H", "L", "TM", "A", "Q", "E", "R", "B", "TC", "TS", "F", "OT", "Type", "V", "M", "Z", "Y", "N", "TR", "C", "K", "I", "P", "W", "VT", "S"], "many_possible": ["many_Pressed", "many_provressed", "many_peossible", "many_pmitted", "many_peressed", "many_nenty", "many_persressed", "many_compressed", "many_persosed", "many_peosed", "many_pressed", "many_compossible", "many_provosed", "many_nressed", "many_posed", "many_provmitted", "many_penty", "many_possibility", "many_nossibility", "many_persossible", "many_persmitted", "many_compossibility", "many_Possible", "many_pemitted", "many_nossible", "many_Possibility", "many_Penty", "many_compenty", "many_provossible"], "zero_possible": ["zero5paowered", "zero_opossibly", "zero5paused", "zero_pused", "zero_Possible", "zero_powered", "zero5pected", "zero_paossibility", "zero5powered", "zero_Pused", "zero_impured", "zero_opossibility", "zero_paected", "zero_paused", "zero5pused", "zero_cected", "zero_impossibility", "zero_opured", "zero_Pected", "zero_impossible", "zero_possibility", "zero_impossibly", "zero_cused", "zero_pected", "zero5possible", "zero5paossible", "zero_Powered", "zero_opossible", "zero_cowered", "zero_cossible", "zero_paossibly", "zero_possibly", "zero_paured", "zero_paowered", "zero_pured", "zero_paossible", "zero5paected"], "t": ["tt", "ic", "p", "k", "total", "j", "tm", "e", "it", "at", "m", "alt", "txt", "h", "ct", "n", "g", "td", "let", "int", "ti", "w", "d", "dt", "q", "y", "set", "r", "on", "typ", "l", "tp", "un", "tz", "ot", "te", "st", "ten", "tu", "ta", "c", "v", "wt", "tc", "ts", "rt", "tw"], "first": ["third", "next", "basic", "one", "single", "frame", "half", "start", "part", "initial", "lower", "time", "minute", "pre", "success", "zero", "path", "First", "id", "before", "top", "last", "then", "index", "full", "main", "same", "head", "current", "sort", "each", "primary", "st", "min", "th", "prev", "major", "short", "front"], "grid1": ["dimone", "grid71", "rid3", "lay1", "idge1", "sheet91", " grid91", "lay01", "idge60", " grid0", "idgeone", "sheetone", " gridone", "grid91", "chainAP", "gridone", "idge91", "idge71", "layAP", "lagone", "ridAP", "lay3", "chain1", "chain01", "chain3", "dim1", "lag60", "dim60", "sheet1", "grid0", "dim71", "sheet0", "grid01", "gridAP", "lag71", "rid01", "grid60", "grid3", "rid1", "idge0", "lag1"], "i": ["gi", "p", "ic", "j", "li", "it", "iy", "m", "iti", "ei", "il", "ti", "int", "ini", "si", "xi", "im", "ai", "ip", "x", "pi", "ii", "ij", "ati", "di", "zi", "ir", "yi", "ci"], "second": ["se", "third", "next", "south", "course", "minute", "secondary", "father", "final", "s", "shell", "foreign", "last", "then", "SEC", "another", "left", "current", "two", "sequent", "sec", "double", "split", "latest", "server", "below", "bottom", "st", "bis", "seconds", "ter", "lower", "Second", "small", "fifth", "fourth"], "grid2": ["lay4", "rid3", "domaintwo", "Grid1", " grid4", " grid02", "Gridtwo", "lay2", "gridtwo", "Grid02", "group1", " gridtwo", "group02", "grid256", " grid3", "domain2", "rid4", "lay3", "grid4", "grid02", "domain1", "Grid2", "grid3", "Grid256", " grid256", "group2", "rid2", "grouptwo", "domain256"], "possible": ["cpossible", "pbable", "repossibility", "powered", "paossibility", "pined", "paossibly", "repossibly", "pressed", " pcould", " pected", " pined", "pected", "pained", " possibility", "pingected", "pingcould", "psossible", "peossibility", "xpossibility", "xpossibly", "pcould", "peressed", "pusted", "peossible", "repossible", "psossibility", "expossibly", "expossible", "peossibly", "expcould", "paowered", "expressed", "cpusted", "pausted", "psowered", "expected", " pbable", "xpressed", "Pined", "Possible", "Pected", "Possibility", "psected", "paossible", "repusted", "xpossible", "cpossibility", "paected", "Pbable", "pingossible", "possibly", "cpossibly", "pabable", "pingossibility", "expossibility", "possibility", "Powered"], "num": ["mon", "one", "enum", "check", "note", "success", "none", "mat", "n", "node", "id", "nil", "name", " som", "um", " number", "item", "index", "coord", "multi", "tim", "nu", "nom", "unit", "np", "don", "sym", "number", "text", "umn", "draw", "NUM", "mark", "exist", "alph", "nm", "ord", "Number", "th", "new", "mom", "tu", "nam", "sum", "cal", "dim", "test", "valid", "Num", "hom"]}}
{"code": " \\n  def DrawMines( R, C, M, Flip, gridMines, sideMines, bottomMines ):\\n    x = []\\n    numSpaces = 0\\n    numMines = 0\\n  \\n    gridRows = max( R-2, 0 )\\n    gridCols = max( C-2, 0 )\\n  \\n    for r in xrange( 0, R ):\\n      x.append( [] )\\n      for c in xrange( 0, C ):\\n        x[ r ].append( '.' )\\n        numSpaces += 1\\n  \\n    if gridMines > 0:\\n      for r in xrange( 0, gridRows ):\\n        if numMines >= gridMines:\\n          break;\\n        for c in xrange( 0, gridCols ):\\n          x[ r ][ c ] = '*'\\n          numMines += 1\\n          numSpaces -= 1\\n          if numMines >= gridMines:\\n            break;\\n  \\n    for r in xrange( 0, R ):\\n      if sideMines <= 0:\\n        break\\n      for c in xrange( gridCols, C ):\\n        x[ r ][ c ] = '*'\\n        numMines += 1\\n        numSpaces -= 1\\n        sideMines -= 1\\n        if sideMines <= 0:\\n          break\\n  \\n    for c in xrange( 0, C ):\\n      if bottomMines <= 0:\\n        break\\n      for r in xrange( gridRows, R ):\\n        x[ r ][ c ] = '*'\\n        numMines += 1\\n        numSpaces -= 1\\n        bottomMines -= 1\\n        if bottomMines <= 0:\\n          break\\n      \\n    x[ R - 1][ C - 1 ] = 'c'\\n    \\n    if numMines != M and ( R * C ) - M != 1:\\n      print \"ERROR!!!!!!!!!!!!!!!!!!!!!!!!\"\\n      print ( R * C ) - M\\n  \\n  \\n    o = \"\"\\n  \\n    if Flip:\\n      for c in xrange( 0, C ):\\n        for r in xrange( 0, R ):\\n           o += x[ r ][ c ]\\n        o += '\\n'\\n    else:\\n      for r in xrange( 0, R ):\\n        for c in xrange( 0, C ):\\n           o += x[ r ][ c ]\\n        o += '\\n'\\n  \\n    return o[:-1] #strip the extra newline\\n  \\n  \\n  \\n  \\n  numCases = input()\\n  for case in xrange( 1, numCases + 1 ):\\n    R, C, M = [int(x) for x in raw_input().split()]\\n  \\n    Output = None\\n  \\n    Flip = C > R\\n    if Flip:\\n      temp = R\\n      R = C\\n      C = temp\\n  \\n    NonMines = ( R * C ) - M\\n    if ( NonMines == 0 ):\\n      Output = \"Impossible\"\\n    elif ( C == 1 ):\\n      gridMines = 0\\n      extraMines = M - gridMines\\n      Output = DrawMines( R, C, M, Flip, gridMines, extraMines, 0 )\\n    elif ( NonMines == 2 or  NonMines == 3 ):\\n      Output = \"Impossible\"\\n    else:\\n      maxGridCols = max( 0, C - 2 )\\n      maxGridRows = max( 0, R - 2 )\\n      gridMines = min( M, maxGridCols * maxGridRows )\\n      extraMines = M - gridMines\\n      extraPairs = ( extraMines + 1 ) / 2\\n      extraPairsSide = max( min( extraPairs, maxGridRows - 1 ), 0 )\\n      extraPairsBottom = max( min( extraPairs - extraPairsSide, maxGridCols - 1 ), 0 )\\n      safeExtraPairs = extraPairsSide + extraPairsBottom\\n      blockingPairsSide = max( min( extraPairs - safeExtraPairs, 1 ), 0 )\\n      blockingPairsBottom = max( min( extraPairs - blockingPairsSide - safeExtraPairs, 1 ), 0 )\\n      blockingPairs = blockingPairsSide + blockingPairsBottom\\n      totalPairs = safeExtraPairs + blockingPairs\\n  \\n      \\n      if ( gridMines > 0 and extraMines % 2 != 0 and blockingPairs == 0 ):\\n        extraMines += 1\\n        gridMines -= 1\\n  \\n      if ( NonMines == 1 ):\\n        if extraMines % 2 != 0:\\n          extraMines += 1\\n        blockingPairsSide += 1\\n        blockingPairsBottom += 1\\n      \\n      if extraMines % 2 == 0:\\n        sideMines = 2 * ( extraPairsSide + blockingPairsSide )\\n        bottomMines = 2 * ( extraPairsBottom + blockingPairsBottom )\\n        Output = DrawMines( R, C, M, Flip, gridMines, sideMines, bottomMines )\\n      else:\\n        Output = \"Impossible\"\\n  \\n    output = \"\\n\" + Output\\n    print 'Case #' + str( case ) + ': ' + str( output )\\n", "substitutes": {"R": ["D", "G", "O", "Right", "JR", "X", "RA", "H", "L", "U", "CR", "Q", "MR", "A", "E", "DR", "RC", "RG", "RF", "B", "Res", "RL", "AR", "F", "V", "RO", "RS", "Rot", "Y", "N", "NR", "RE", "TR", "GR", "RR", "Rs", "I", "RM", "P", "RT", "OR", "W", "T", "S", "BR", "IR", "SR", "Re", "ER"], "C": ["Co", "D", "G", "O", "BC", "JC", "Ch", "CD", "COR", "X", "Cow", "L", "U", "CR", "E", "Q", "CM", "HC", "A", "CN", "AC", "Chain", "CS", "B", "H", "CAR", "TC", "IC", "CE", "CV", "CC", "WC", "F", "CON", "SC", "V", "EC", "Y", "CNN", "N", "CO", "CT", "CG", "CP", "CF", "DC", "K", "I", "P", "CB", "W", "CL", "CCC", "MC", "Charlie", "CU", "T", "S", "Cs"], "M": ["D", "G", "O", "One", "X", "Max", "H", "L", "m", "E", "U", "Q", "CM", "MR", "TM", "A", "NM", "Mon", "MAN", "B", "MM", "ONE", "F", "J", "Multi", "V", "Z", "Y", "N", "Length", "MD", "MT", "MI", "OK", "K", "I", "RM", "P", "Ma", "W", "DM", "Size", "MC", "T", "S", "AM", "All", "Num"], "Flip": ["FLop", "FLipe", "Flim", "Swipe", " Fllip", "Swlip", "FLim", " Flipe", "FLlip", "flip", "Swip", "Swim", "Flop", "Fllip", " Flop", "FLIP", "Flipe", "flop", " Flipping", " FlIP", "FlIP", "Flipping", "flIP", "FLip", "flipping", " Flim", "FLipping"], "gridMines": ["numRiners", "gridPine", "gridRains", "numMiners", "gridMutiners", " gridManes", "numMine", "gridPanes", "gridMikes", "drawNappers", "gridBiners", "gridGikes", "gridMeiners", " gridGanes", "gridMappers", "gridNanes", "gridMutins", "gridLine", "gridRines", " gridMiners", "gridRikes", "drawMins", "gridMeines", "drawManes", "drawMines", "gridManes", "gridMutanes", "numManes", " gridGikes", "gridLains", "gridMeolds", "numRanes", "gridMolds", "gridRiners", "gridMiners", "gridNappers", "gridGanes", "gridBikes", "gridMains", "gridBanes", " gridGiners", "gridNines", "numRine", " gridMikes", "gridPains", "drawNines", " gridGines", "gridBines", "gridRine", "gridPines", "gridLanes", "numRains", "gridMutolds", "gridRappers", "gridMutappers", "drawNanes", "numRolds", "gridMeanes", "gridGines", "gridGiners", "numRines", "drawMappers", "numMains", "gridLines", "gridMins", "numMolds", "gridMine", "gridMutines", "drawNins", "gridRolds", "gridRins", "gridRanes", "gridNins"], "sideMines": ["sectionNines", "sideSanes", "sideVains", "sideNelines", "sideMelines", "sideRins", "sideEMelines", "sideBaces", "sectionMins", "sideEMines", "bottomNiners", "bottomMaces", "SideNins", "sectionMines", "bottomManes", "SideNines", "sideDiners", "sideBines", "sideMains", "sideHins", "sideVanes", "sideBanes", "bottomNines", "sideFaces", "sectionMiners", "sideNaces", "sideHines", "sideEManes", "SideMins", "sideRines", "sideNiners", "sideRanes", "sideFines", "sideDins", "SideMines", "sideRains", "sideSins", "sectionNiners", "sideManes", "sideSelines", "bottomNaces", "sideFanes", "sideNins", "sideDanes", "sideSines", "sideVines", "sideBiners", "sectionManes", "sideEMins", "SideMelines", "sideMiners", "sideVins", "sideHiners", "sideDines", "SideNains", "bottomNanes", "bottomMiners", "sideNanes", "sideFiners", "SideMains", "sideMins", "sectionNins", "sideHanes", "SideNelines", "sideMaces", "SideManes", "sideNines", "sideNains", "SideNanes", "sectionNanes"], "bottomMines": ["bottomAminers", "topModes", "bottomLines", "bottomNaults", "topMaces", "bottomNine", "bottomPine", "bottomMizes", "topNaces", "bottomMaces", "bottomModes", "bottomPanes", "bottomNiners", "topNine", "bottomMMizes", "bottomSodes", "sideLizes", "bottomManes", "topNines", "bottommizes", "topNodes", "sideMizes", "bottomLizes", "topNanes", "bottomSanes", "bottomAniners", "bottomPaces", "bottomMresses", "bottomNines", "bottomAnanes", "topMiners", "bottomSaces", "topNresses", "bottomPodes", "topMaults", "topNaults", "bottommodes", "topManes", "sideModes", "sideManes", "topMine", "bottomMine", "bottomEanes", "bottomNaces", "bottomEine", "sideLines", "bottomAmresses", "sideLodes", "bottomAmines", "bottomAnines", "bottomEaults", "bottomPines", "bottomLodes", "bottomPaults", "bottomNodes", "bottomSines", "topNiners", "bottomAmanes", "sideLanes", "bottomNanes", "bottomMaults", "bottomMiners", "bottomMManes", "bottomNresses", "bottommanes", "bottomEines", "bottomAnresses", "topMines", "bottommines", "bottomMModes", "bottomLanes", "topMresses", "bottomMMines"], "x": ["ux", "p", "xs", "check", "e", "xxxx", "X", "rx", "xes", "t", "wx", "xxx", "xp", "m", "h", "ct", "ox", "z", "n", "xc", "f", "xa", "tx", "xt", "exp", "w", "index", "xi", "y", "i", "xf", "work", "l", "xe", "lex", "xd", "xy", "a", "ex", "px", "xx", "xml", "v", "xb", "fx"], "numSpaces": ["numSPpaces", "numberSPats", " numSacing", " numSaces", "numPlaces", "numspats", "numspace", "numSPapes", "numberSpats", "numberSPace", "numSpaceans", "numberSPapes", "numSpacing", "numPlines", "numSPines", "numberSpace", "numberSPaces", "numSPace", "numSpices", "numSpots", "numStices", "numberSpines", "numStapes", "numSpaceacing", "numSPots", "numSpaceaces", "numberSpacing", "numberSPpaces", "numberSpaces", "numSPaces", "numPlace", "numspapes", "numspices", "numSPices", " numSpots", "numspots", "numberSpices", "numberSPans", "numberSpans", "numSpats", "numberSPices", " numSpacing", "numSPans", "numSans", "numspaces", "numSpines", "numSacing", "numSaces", "numSots", " numSans", "numspines", " numSots", "numberSPines", "numSpacepaces", "numSpans", "numSpaceats", "numberSPacing", "numberSpapes", " numSpans", "numsppaces", "numSppaces", "numberSppaces", "numspans", "numPlans", "numSpaceices", "numStans", "numSPacing", "numStaces", "numSpace", "numSpapes", "numSPats", "numspacing"], "numMines": ["numMaces", "numMine", "gridNenes", "numEmines", "numSikes", "gridNanes", "gridRines", "numNisters", "numPelines", "nNikes", "nMines", "numMices", "numMears", "numMsines", "numPaces", "nPanes", "numNine", "numAManes", "nMices", "numberMines", "numberNine", "numSices", "numberNisters", "numKines", "numNenes", "nPaces", "nPices", "numNines", "numMsaces", "numVears", "nMaces", "gridMenes", "numMselines", "numEmisters", "numSines", "nNanes", "numMsices", "numPine", "nPelines", "nNines", "numMenes", "numVines", "numNaces", "numRines", "numMikes", "numMisters", "numNears", "numMelines", "gridRelines", "numRelines", "numberNines", "numPines", "gridMelines", "nNaces", "numPisters", "numPanes", "gridNears", "nMelines", "gridManes", "numAMines", "numMsanes", "numberMaces", "nManes", "numKelines", "gridNines", "numberManes", "numAMears", "numKine", "nMikes", "numPikes", "numKanes", "numberNaces", "numSine", "numVanes", "nPines", "numManes", "numEmanes", "numberMine", "numRanes", "numSelines", "numRine", "numSaces", "numberNanes", "gridRine", "numPices", "numNanes", "numEmaces", "gridMears", "numAMenes", "numVenes", "numNikes", "numberMisters", "gridMine", "numSanes", "gridRanes"], "gridRows": ["gridLoles", "gridLows", "gridMoots", "gridRsrows", "gridColes", "gridLrows", "gridRorts", "gridRsOWS", "GridLights", "gridLanks", "GridRights", "gridRoots", "gridSorts", "GridRows", "gridRights", "gridCOWS", "gridCorts", "gridRsoots", "gridLorts", "GridLoots", " gridROWS", "gridMrows", " gridLrows", "gridSoles", " gridCows", "gridRoles", " gridLows", "GridRrows", "gridSows", " gridColes", "GridLrows", " gridLanks", "gridRsows", "gridRsanks", "gridRrows", " gridLOWS", " gridCorts", "GridLows", "gridLights", " gridRrows", "gridRsights", " gridRoles", "GridRoots", "gridSOWS", " gridRanks", "gridROWS", "gridMows", " gridRorts", "gridMights", "gridLoots", " gridCOWS", "gridRanks", "gridCows", "gridLOWS"], "gridCols": ["numColumnabs", " gridChabs", "gridColts", "gridColows", "gridChes", " gridColols", " gridColabs", "gridColumnes", "gridColes", "gridColumnols", " gridcolabs", "numColabs", "gridOptrows", "gridColabs", " gridColows", "gridChabs", "gridOpts", " gridChes", "numColrows", " gridChs", "gridColumns", "gridChs", "gridOptabs", "numCols", "gridColumnts", "gridOptts", "gridChows", "gridHows", "numColumnts", "gridColumnows", "numColumns", "gridRectrows", "gridcolols", " gridColes", "gridRects", " gridcolols", "gridcolabs", " gridcolows", "gridRectabs", "gridRectts", "gridHabs", " gridcols", "gridColrows", "gridcols", "gridcoles", "numColumnrows", "gridColumnrows", "gridHols", "gridColumnabs", "gridHs", "gridColols", " gridChows", "numColts", "gridcolows"], "r": ["p", "rem", "er", "fr", "re", "e", "col", "cut", "t", "lr", "m", "cur", "h", "rg", "ar", "pc", "w", "d", "pr", "q", "row", "byter", "rar", "sr", "attr", "vr", "a", "rn", "ir", "adr", "reg", "ct", "ro", "run", "rb", "nc", "chain", "ru", "cu", "rr", "hr", "rel", "ch", "dr", "gr", "mr", "v", "br", "rc", "root", "str", "rec", "n", "g", "f", "l", "co", "rd", "res", "range", "j", "k", "rs", "ur", "ren", "can", "art", "result", "tr", "b", "cl", "unc", "cr", "rt"], "c": ["dc", "p", "ic", "ced", "rc", "k", "count", "col", "cp", "cm", "rec", "t", "cut", "m", "cur", "cy", "lc", "ct", "bc", "h", "cf", "n", "g", "con", "nc", "f", "code", "ar", "can", "pc", "chain", "div", "cat", "cu", "d", "arc", "sc", "cs", "cache", "ec", "y", "uc", "i", "cus", "ac", "b", "cont", "cor", "content", "unc", "l", "cl", "cr", "co", "cc", "mc", "call", "loc", "ch", "fc", "ce", "a", "gc", "v", "tc", "ci"], "o": ["po", "oo", "vo", "p", "O", "os", "cho", "ic", "bo", "go", "ho", "e", "oin", "t", "io", "ato", "m", "no", " i", "h", "off", "ox", "ro", "ano", "z", "n", "f", "lo", "do", "ando", "ao", "d", "w", "uo", "u", "line", "i", "y", "mo", "so", "auto", "l", "co", "oto", "ot", "oa", "to", " mo", "output", "yo", "di", "xy", "out", "onet", "a", "data", "ooo", "v", "iso"]}}
{"code": " \\n  numCases = input()\\n  for case in range( 1, numCases + 1 ):\\n    row1 = input()\\n    grid1 = []\\n    for i in range( 0, 4 ):\\n      grid1.append( raw_input().split() )\\n  \\n    cards = grid1[ row1 - 1 ]\\n  \\n    row2 = input()\\n    grid2 = []\\n    for i in range( 0, 4 ):\\n      grid2.append( raw_input().split() )\\n  \\n    bad = True\\n        \\n    cards2 = grid2[ row2 - 1 ]\\n  \\n    numPossibleAnswers = 0\\n    for card in cards:\\n      for card2 in cards2:\\n        if ( card == card2 ):\\n          if numPossibleAnswers == 0:\\n            output = card\\n          numPossibleAnswers += 1\\n          break\\n  \\n    if numPossibleAnswers == 0:\\n      output = \"Volunteer cheated!\"\\n    elif numPossibleAnswers > 1:\\n      output = \"Bad magician!\"\\n  \\n    print 'Case #' + str( case ) + ': ' + str( output )\\n", "substitutes": {"numCases": ["numConases", "numClased", "numCodes", "numClASE", "numberClase", "numClase", "numCase", "numConASE", "numCased", "numBodes", "numBASE", " numCASE", "numConodes", "numberCases", "numCASE", "numSASE", "numberCodes", "numBases", " numCase", "numberCase", "numClases", "numClodes", "numberClodes", "numSase", "numSased", "numberCASE", "numSases", "numConase", " numCased", "numBase", "numberClases", "numberClASE"], "case": ["trial", "switch", "se", "ance", "match", "day", "su", "ide", "force", "client", "block", "code", "ace", "example", "nce", "ride", "rule", "chain", "cation", "can", "CE", "use", "index", "line", "core", "catch", "row", "board", "Case", "uce", "number", "instance", " Case", "C", "cases", "ice", "ASE", "ase", "ca", "ce", "cell", "test", "cas"], "row1": ["rowName", "roll41", "record11", "row01", "recordOne", "ow01", "record01", "owName", "ryName", "record1", "row11", " row11", "grid11", "ow1", "rollName", "gridOne", "rowOne", "row41", "ry01", "ry41", "grid01", "ow41", "roll1", "ry1", "roll01", " rowOne", " row01"], "grid1": [" grid48", "cloudFirst", "clientFirst", "raid1", "grid71", "layOne", "lay1", "cloud1", "client1", " grid4", "client4", "screen0", "chain71", "card01", "screenOne", "client48", "row001", " gridFirst", "cloud48", "lay0", "gridOne", "rowOne", "grid4", "cloud4", "grid48", "screen001", "chain1", "chain01", "raid71", "row0", "screen1", "grid0", "card1", "grid01", "grid001", "chainOne", "card71", "cardOne", "raidOne", "raid01", "lay001", "gridFirst"], "i": ["gi", "ki", "ic", "li", "it", "iy", "iti", "iri", "ri", "ei", "il", "ti", "ini", "si", "xi", "im", "ai", "\u00ed", "ip", "pi", "ii", "oi", "iu", "ij", "ati", "di", "I", "zi", "fi", "ir", "ci"], "cards": ["values", "comments", "custom", "olds", "lands", "cars", "stars", "units", "compl", "games", "ways", "cf", "files", "ls", "keys", "ims", "letters", "users", "Card", "cs", "names", "ards", "tags", "cont", "cats", "boxes", "fields", "groups", "codes", "cc", "hands", "types", "checks", "caps", "phones", "cases", "lets", "pieces", "c", "gc", "cas"], "row2": [" rowtwo", "gridtwo", " row21", "rolltwo", "row21", "row4", "roll2", "grid4", "rowTwo", "roll21", "Row4", "grid02", "Row2", "row02", " rowTwo", "Row02", " row4", "RowTwo", " row02", "gridTwo", "grid21", "rowtwo"], "grid2": ["lay4", "client6", "client2", " grid4", "client4", "lay2", "lat4", "gridtwo", "cards02", " gridtwo", "lat2", " grid6", "row4", "grid4", "boxTwo", "box2", "grid6", "lay02", "box02", "grid02", "lattwo", "cardsTwo", "cards4", "box4", "gridTwo", "clienttwo", "lat6", "layTwo", "rowtwo"], "bad": ["Bad", "done", "written", "ok", "used", "fail", "wrong", "no", "sub", "big", "failed", "some", " good", "log", "deg", "negative", "dis", "handled", "got", "gone", "broken", "like", "bug", "valid", "buy", "good", "odd"], "cards2": [" card12", "cards3", " cards4", " fields02", " fields4", " fields12", " card02", "cards02", " card4", " fields2", " cards02", "fields1", "card1", " cards12", " cards3", " cards1", "cards4", "fields2", "fields3", "card3", "cards1", "cards12"], "numPossibleAnswers": ["numPossibleAizes", "numPossibleConAnswer", "numPentialAnAnswer", "numPableAnizes", "numPacedConswers", "numPentialAntions", "numPossibleCannotations", "numPentialConAnswer", "numPacedConnotations", "numPacedAnwered", "numPossibilityAnnotations", "numPossibleAnnnotations", "numPossibleAswers", "numPossibleAnwered", "numPossibleAnotations", "numPentialAnswers", "numPossibilityAnAnswer", "numPableAnAnswer", "numPossibleAnnAnswer", "numPossibleContions", "numPossibleAnAnswer", "numPossibleAnakens", "numPossibleANakens", "numPossibleAnnotations", "numPableAnswers", "numPossibilityAnswers", "numPossibleAnizes", "numPossibleAAnswer", "numPossibleAnnswers", "numPossibleAntions", "numPossibleANswers", "numPentialContions", "numPossibleConnotations", "numPossibleANAnswer", "numPacedConwered", "numPossibleConswers", "numPacedAnnotations", "numPacedAnswers", "numPossibleCanswers", "numPossibleAwered", "numPossibleCanwered", "numPossibleConizes", "numPentialConswers", "numPossibleConwered", "numPableAnakens", "numPossibleANtions"], "card": ["ard", "custom", "match", "day", "tag", "default", "word", "piece", "winner", "column", "game", "success", "code", "record", "event", "cf", "null", " Card", "name", "can", "char", "field", "condition", "Card", "arc", "man", "holder", "ards", "character", "cont", "player", "value", "board", "member", "cast", "co", "number", "cc", "draw", "car", "order", "hand", "ARD", "list", "ord", "string", "guard", "controller", "c", "gc", "cell", "good", "comment", "cas"], "card2": [" card1", " cardsboth", " cards4", "card0", "cardboth", " card4", "Card4", "cards0", "cardsboth", "Card0", "card4", "Card2", "card1", " card0", " cards1", "cards4", " cardboth", "cards1"], "output": ["answer", "label", "next", "icon", "console", "default", "written", "exit", "cut", "issue", "what", "column", "ou", "display", "wrong", "that", "error", "csv", "pretty", "result", "oe", "line", "config", "write", "log", "value", "hidden", "comment", "put", "net", "target", "input", "four", "come", "string", "format", "position", "print", "out", "data", "tip", "plot", "component", "accept", "voice", "response", "text", "Output", "message", "status"]}}
{"code": " \\n  def mines_refill(board, xr, xc, nfree):\\n      to_refill = xr*xc - nfree\\n      for r in reversed(range(2, xr)):\\n          for c in reversed(range(2, xc)):\\n              if not to_refill:\\n                  return\\n              assert(board[r][c] == '.')\\n              board[r][c] = '*'\\n              to_refill -= 1\\n      for r in reversed(range(xr)):\\n          for c in reversed(range(xc)):\\n              if not to_refill:\\n                  return\\n              if board[r][c] == '.':\\n                  board[r][c] = '*'\\n                  to_refill -= 1\\n      assert(to_refill == 0)\\n      \\n  def generate_board(nrows, ncols, nmines):\\n      nfree = nrows*ncols - nmines\\n      xr=1; xc=1;\\n      while True:\\n          if xr*xc >= nfree:\\n              break\\n          if xr < nrows:\\n              xr += 1\\n          if xr*xc >= nfree:\\n              break\\n          if xc < ncols:\\n              xc += 1\\n      board = [['*' for c in range(ncols)] for r in range(nrows)]\\n      for r in range(xr):\\n          for c in range(xc):\\n              board[r][c] = '.'\\n      mines_refill(board, xr, xc, nfree)\\n      board[0][0] = 'c'\\n      return board\\n          \\n  def find_click_point(board):\\n      nrows = len(board)\\n      ncols = len(board[0])\\n      for r in range(nrows):\\n          for c in range(ncols):\\n              if board[r][c] == 'c':\\n                  return (r,c)\\n      raise ValueError('Start point not present')\\n  \\n  def enum_neighbour_coords(r0, c0, nrows, ncols):\\n      for r in range(r0-1, r0+2):\\n          if r<0 or r>=nrows:\\n              continue\\n          for c in range(c0-1, c0+2):\\n              if c<0 or c>=ncols:\\n                  continue\\n              yield (r,c)\\n  \\n  def click_board(board, click_coords):\\n      nrows = len(board)\\n      ncols = len(board[0])\\n      points = [click_coords]\\n      while points:\\n          r0,c0 = points.pop()\\n          mines_cnt = 0\\n          for r,c in enum_neighbour_coords(r0, c0, nrows, ncols):\\n              if board[r][c] == '*':\\n                  mines_cnt += 1\\n          board[r0][c0] = str(mines_cnt)\\n          if not mines_cnt:\\n              for r,c in enum_neighbour_coords(r0, c0, nrows, ncols):\\n                  if board[r][c] == '.':\\n                      points.append((r,c))\\n  \\n  def all_fields_checked(board):\\n      nrows = len(board)\\n      ncols = len(board[0])\\n      for r in range(nrows):\\n          for c in range(ncols):\\n              if board[r][c] == '.':\\n                  return False\\n      return True\\n  \\n  def is_board_oneclick(original_board):\\n      board = [row[:] for row in original_board] # deep copy\\n      assert(board[0][0] == 'c')\\n      r,c = find_click_point(board)\\n      click_board(board, (r,c))\\n      is_oneclick = all_fields_checked(board)\\n      return is_oneclick\\n  \\n  def board2result(board):\\n      return [''.join(row) for row in board]\\n  \\n  def process_case(nrows, ncols, nmines):\\n      board = generate_board(nrows, ncols, nmines)\\n      if is_board_oneclick(board):\\n          result = board2result(board)\\n      else:\\n          result = ['Impossible']\\n      return result\\n  \\n  def result_gen(lines):\\n      ncases = int(next(lines))\\n      for ci in range(1,ncases+1):\\n          R, C, M = line_of_numbers(next(lines))\\n          result = process_case(R, C, M)\\n          yield 'Case #{0}:\\n'.format(ci, result)\\n          for res_line in result:\\n              yield res_line + '\\n'\\n      \\n  def line_of_numbers(s):\\n      return [int(sub) for sub in s.split()]\\n  \\n  def input_gen(f_in):\\n      for line in f_in:\\n          if line.endswith('\\n'):\\n              line = line[:-1]\\n          yield line\\n  \\n  def start(basename):\\n      infile = basename + '.in'\\n      outfile = basename + '.out'\\n      f_in = open(infile, 'r')\\n      f_out = open(outfile, 'w')\\n      f_out.writelines(result_gen(input_gen(f_in)))\\n      f_in.close()\\n      f_out.close()\\n  \\n  start('C-small-attempt0')\\n", "substitutes": {"board": ["p", "check", "piece", "command", "deck", "mouse", "node", "full", "user", "line", "local", "_", "split", "call", "sequence", "stream", "body", "review", "clean", "position", "door", "box", "du", "void", "fc", "Board", "library", "cell", "front", "inner", "bd", "bo", "word", "private", "block", "ro", "control", "chain", "loop", "sc", "rank", "rot", "left", "rol", "bang", "player", "bank", "back", "out", "bro", "select", "square", "flo", "rc", "form", "butt", "video", "oard", "display", "public", "layout", "zero", "n", "style", "database", "lib", "wheel", "poll", "channel", "bench", "table", "dict", "co", "x", "runner", "ward", "bar", "component", "test", "comment", "case", "pair", "range", "bit", "frame", "client", "system", "book", "uno", "core", "rect", "builder", "b", "pad", "cont", "cl", "buffer", "chart", "buff", "boards", "ack", "boarding", "boot", "xy", "black", "bird", "bug", "lock", "bot", "message", "list"], "xr": [" xn", "wxrt", "exrb", "ixr", "mxr", " xrar", "axr", "oxrb", "xxrt", "fxrt", " xrd", "lexr", "axc", "xn", "lexra", "xrar", "xl", "fxR", " xor", "uxr", "oxsr", "xxor", "xfr", "ixrt", "oxar", "ixrs", "ixsr", " xm", "xmlra", "xmr", "hexra", "oxm", "oxn", "uxor", "hexR", " xra", "axor", "rxrt", "oxdr", "wxor", "mxrd", "dxrt", "wxrd", " xsr", "xm", "rxrs", " xrt", "xor", "xrs", "xdr", "xR", " xR", "ixrb", "wxrb", "ixar", "xprt", "xpl", "yr", "axrar", "wxr", "xmlsr", "xxrb", "hexrt", "xxrd", "fxr", "dxdr", "rxr", "oxr", "xrt", "xmlr", "exrt", "rxor", "rxra", "rxar", "exr", "xra", "xpR", "wxar", "ixrd", "exsr", " xl", "xrb", "ym", "xfmr", "dxr", "uxrar", "xrd", "mxrt", "xfsr", " xmr", "xxar", "xar", "lexR", "hexr", "yn", "lexrt", "exdr", "fxl", "mxrs", "dxrb", "exar", "xpr", "uxc", "xmlmr", "xxr", " xrs", "xsr", "oxrt", "xmlrs"], "xc": ["dc", "ic", "xs", "rc", "tm", "lic", "cp", "xxxx", "ctx", "xes", "wx", "ape", "xp", "oc", "lc", "ct", "ox", "bc", "xff", "cf", "nc", "con", "xa", "phi", "exp", "ffff", "pc", "colm", "mx", "cb", "nz", "pb", "ec", "vc", "cin", "xb", "xf", "uc", "wic", "cow", "ac", "cox", "sec", "nuts", "unc", "yx", "co", "x", "mc", "cum", "xe", "jc", "xd", "cone", "cloud", "xy", "conv", "fc", "etc", "ce", "ex", "px", "gc", "tc", "wt", "coe", "abc", "ci", "xon"], "nfree": [" nfine", "nnspace", "Nfree", "ntdone", "namefree", " ntotal", "anFree", "NFree", "anbytes", "Navailable", "anfloor", "nsfree", "nsFree", "npfine", "ntfree", "nnFree", " nspace", "namefine", "ntFree", "nstotal", "Nbytes", "Nfine", " nleft", "Ntotal", "nfloor", "nsavailable", "nleft", "nameFree", " nFree", " nbytes", "npFree", "ndone", "nspace", "ntotal", "npavailable", "nFree", "navailable", "nsspace", "nnleft", " ndone", "anfree", "nnfree", " navailable", "nbytes", " nfloor", "Ndone", "namebytes", "nfine", "npfree", "Nfloor", "nsleft"], "to_refill": ["to_filling", "to_reiller", "to_referenceil", "to_defill", "to_defiller", "to_rebild", "to_refil", "to_rebil", "to_fil", "to_relil", "to_restfill", "to_referenceild", "to_relill", "to_defresh", "to_referenceill", "to_referenceresh", "to_Refilling", "to_frild", "to_fill", "to_restresh", "to_rebiller", "to_reill", "to_relild", "to_restild", "to_defilling", "to_frresh", "to_relresh", "to_Refill", "to_fril", "to_defil", "to_rewill", "to_refiller", "to_reilling", "to_rebilling", "to_rewild", "to_rebfill", "to_rewfill", "to_relilling", "to_reresh", "to_Refiller", "to_frill", "to_restill", "to_rewresh", "to_refresh", "to_rebresh", "to_reffill", "to_filler", "to_refilling", "to_rebill", "to_Refresh", "to_refild", "to_reliller"], "r": ["p", "er", "fr", "re", "e", "t", "lr", "m", "h", "rg", "R", "ar", "w", "d", "pr", "q", "rar", "sr", "attr", "vr", "a", "rn", "ir", "adr", "reg", "o", "ro", "run", "rb", "ru", "u", "rr", "hr", "rel", "ver", "dr", "gr", "mr", "v", "ry", "arr", "br", "rc", "root", "str", "err", "rad", "n", "g", "f", "i", "l", "x", "rd", "right", "range", "res", "ard", "j", "k", "rs", "nr", "ur", "art", "result", "tr", "rect", "kr", "b", "cr", "usr", "rm", "rt", "rw"], "c": ["p", "cul", "count", "col", "e", "cut", "t", "m", "cur", "bc", "code", "con", "ar", "name", "pc", "cat", "cod", "d", "cb", "cache", "const", "usc", "ca", "fc", "cd", "ce", "gc", "enc", "cell", "ci", "cp", "lc", "ct", "conf", "nc", "s", "chain", "cu", "sc", "vc", "cin", "cc", "mc", "ch", "C", "v", "rc", "n", "g", "f", "colm", "arc", "i", "ec", "ac", "cor", "l", "co", "x", "dc", "ic", "type", "cm", "can", "div", "cs", "uc", "b", "\u00e7", "cl", "unc", "cr", "loc", "tc"], "nrows": ["unrow", "sows", "srows", "Nfree", "nbtracks", "unrows", "Nrows", "Npages", "onrow", "ntfiles", " npages", "susers", "untracks", "onruns", " nruns", "sruns", " nrow", "nows", "nbrow", "nusers", "ntracks", "nfiles", "Nruns", "nruns", " ncells", "Nrow", "ncells", "uncells", "nrs", "nsrow", "onfree", "nsows", "nsruns", "Nrs", "onrs", "onpages", "nbcells", "onows", "ntows", " ntracks", "Nows", " nows", "nsrs", "onusers", "npages", "Nfiles", "ntruns", "nsfiles", "onrows", " nrs", "nsusers", "nsrows", "nrow", "nbrows", "ntrows"], "ncols": ["ncolts", "nColums", "ncolumni", "nColS", "nptes", "onCols", "nservts", "nwidthes", "nCOLs", "nptows", "nColows", "oncolumnabs", "oncolts", "Ncolumnts", "ncolumnows", "ncolS", "nroundds", "oncolumnts", "nroundums", "ncmds", "ncolumnS", " ncolumnts", "ntabS", "ncmdes", "nwidths", "Ncoles", "Ncols", "nwidthums", " ncolS", " ncolumnes", "ncolumnabs", "ncolumns", "Ncolumnows", "ntabs", "ntabts", "Ncolumnums", "nwidthts", "nrounds", " ncoles", "Ncolumnes", "Ncolumns", "nColi", "oncols", "oncolS", "ncolumnds", "Ncoli", "nservs", "nconds", "nptums", " ncolumns", "nservabs", "Ncolumni", "nCOLabs", "Ncolumnds", "nColes", "ncondes", "onColums", "oncolabs", "ncoles", "ncolows", "ncoli", "Ncolums", "Ncolows", "nCols", "ncmdi", "Ncolts", "ncolumnts", "onColS", "ncolds", "ncolabs", "nColts", "nroundes", "ncolumnums", "nCOLts", " ncolts", "ncolumnes", "oncolums", "nColds", "Ncolds", " ncolumnS", "oncolumns", "ntabes", "npts", "ncolums"], "nmines": ["nserve", "nmenes", "nmaxe", "nmaxeds", " nserve", " nserves", "nservES", "nmine", "NmaxES", "nmenions", "nminES", "nmineds", " nservES", "NminES", "nminions", " nmine", "nmeneds", "nMines", "nserves", "nservions", "nmaxions", "nMinions", " nservions", " nminions", "ncoles", "nmaxes", "nMinES", "Nmaxes", "Nminions", "Nmaxions", "nmaxES", "ncolions", "nMine", "Nmineds", "nmenES", "ncolES", "Nmaxeds", "ncoleds", "Nmines", " nminES"], "r0": ["R2", "r1", "rt000", "rc000", " r1", "rbZero", "x000", "rect7", "r30", "rr1", "x5", "rect00", "r000", "rect000", "R0", "row000", "rb5", "rZero", "rt7", "r5", "rect0", " r2", "rt00", "rcZero", "row00", "row0", "rc5", "rb000", "xZero", "rb0", "r00", "row7", "x0", "rr2", "r2", "rc0", "R30", "R1", "rr0", "rr30", "rt0", "r7", " r30"], "c0": [" c1", "bc000", "carg", "pc1", "cr1", "cu000", "cuZero", " cZero", "bcarg", "c000", "cZero", "cuarg", "xc00", "o050", "c00", "bc0", "con000", "c1", "xcid", "conarg", "con0", " cid", "pcid", "bcZero", "cr050", "cr0", "xc0", " c050", "xc1", "pc0", "conZero", "pc00", "o1", "crZero", "cid", " c00", "oZero", "c050", "o0", "cu0"]}}
{"code": " \\n  def process_case(row1, tab1, row2, tab2):\\n      s1 = set(tab1[row1])\\n      s2 = set(tab2[row2])\\n      xset = s1 & s2\\n      if len(xset) == 1:\\n          result = xset.pop()\\n      elif len(xset) == 0:\\n          result = 'Volunteer cheated!'\\n      else:\\n          result = 'Bad magician!'\\n      return result\\n  \\n  def result_gen(lines):\\n      ncases = int(next(lines))\\n      for ci in range(1,ncases+1):\\n          row1 = int(next(lines)) - 1\\n          tab1 = [line_of_numbers(next(lines)) for i in range(4)]\\n          row2 = int(next(lines)) - 1\\n          tab2 = [line_of_numbers(next(lines)) for i in range(4)]\\n          result = process_case(row1, tab1, row2, tab2)\\n          yield 'Case #{0}: {1}\\n'.format(ci, result)\\n      \\n  def line_of_numbers(s):\\n      return [int(sub) for sub in s.split()]\\n  \\n  def input_gen(f_in):\\n      for line in f_in:\\n          if line.endswith('\\n'):\\n              line = line[:-1]\\n          yield line\\n  \\n  def start(basename):\\n      infile = basename + '.in'\\n      outfile = basename + '.out'\\n      f_in = open(infile, 'r')\\n      f_out = open(outfile, 'w')\\n      f_out.writelines(result_gen(input_gen(f_in)))\\n      f_in.close()\\n      f_out.close()\\n  \\n  start('A-small-attempt0')\\n", "substitutes": {"row1": [" row10", "server51", "roll9", "caseone", "rowone", "case7", "lineOne", "rows1", "rollone", "tab7", "row10", "line1", "server9", "rowOne", "tabone", "rollOne", "roll3", "row7", "tab51", "line10", "row3", "ry3", "ry51", "row9", "tab9", "roll1", " row3", "roll51", "ryOne", "server1", "rows51", "rows10", "ry1", "row51", "line3", "rowsOne", "rows3", "roll7", "case1", " rowOne"], "tab1": ["toolOne", "tool1", "rowone", "table1", "stabone", "tab3", "Tab3", "stab10", "lab16", " tab_", "row10", "tool_", "bag4", "stab4", "tcName", "bag10", "bagone", "row4", "tab10", "tabOne", "tableName", "tabName", "tableFirst", "tabone", "bag1", "lab_", "tableOne", "row3", "tab4", "Tab2", "stab1", " tabName", "tab16", "tc1", "tabFirst", "tool16", " tab16", "lab1", "labOne", "Tab1", " tabOne", "tcOne", "tcFirst", " tab3", "tab_", " tabFirst"], "row2": [" row5", "pair62", "pair1", "row52", "ow02", "ro02", "rotwo", "ow2", "pair2", "ro2", " row12", "roll4", "ro0", "rowlet", "rolltwo", "row4", "roll2", " row7", "ro7", "roll5", "row5", "ow7", "pair5", "row0", "ow0", "ow12", "row7", "tab4", "row12", "ro52", "row02", "roll1", "owlet", "rolet", "ro4", " row52", "roll62", "ro12", " row02", "ow52", " rowlet", " row0", "tabtwo", " row62", "row62", "rowtwo"], "tab2": ["stab7", "tab0", "cellt", " tab4", " tab256", "stab8", "cell2", " tab02", "stab02", "tabt", "cell1", "bag8", "tab7", "tab256", "table02", "stab2", " tabt", "ab4", "stab0", "ab256", "tab8", "ab2", "bag2", "tab02", "row0", "table256", "bag7", "tab4", "stab1", "table4", " tab8", "row02", " tab7", "table2", "cell0", "cell02", "ab02", "rowt"], "s1": ["sone", " s3", "x3", "s3", "sau", "t1", "x1", " sone", "tau", " s01", " sOne", "sOne", "rs1", "xOne", "xone", "rsone", "xau", "x01", "rs3", " sau", "rs01", "tone", "s01", "tOne"], "s2": ["ss3", "xs2", " s3", "s3", "ss62", " s0", "s0", "xs1", "S1", " s4", "s4", "xs0", "js4", "S0", "js3", "ss2", "ss4", "js2", "stwo", " s62", "xstwo", "s62", "Stwo", " stwo", "S2", "js62"], "xset": ["uxSet", "xfsets", "crossset", "xfset", "Xsan", "xlist", "rxet", "axSet", "xnot", "x2", "x1", "Xtest", "rxSET", "xsets", "crossSet", "ox1", "oxset", " x1", " xSET", "XSet", "rx1", "oxsets", "uxnot", "Xet", "xsan", " xlist", "ox2", " xsets", "uxset", "xflist", "rxset", "axet", "oxSET", "oxlist", "rxSet", "xf2", "xet", "oxet", "xSet", "axtest", " x2", "rxtest", "crossnot", "xSET", "xtest", "Xnot", "Xset", " xet", "uxsan", "crosssan", "axset"], "result": ["res", "function", "answer", "reason", "match", "default", "reverse", "type", "word", "report", "re", "su", "correct", "command", "ful", "cur", "relation", "success", "results", "code", "final", "term", "true", "ret", "name", "process", "description", "summary", "set", "json", "r", "cert", "successful", "successfully", "row", "Result", "value", "table", "co", "sequence", "com", "output", "string", "format", "title", "date", "new", "phrase", "out", "ver", "status", "confidence", "data", "mate", "method", "response", "text", "test", "comment", "message", "case", "pair"], "lines": ["works", "ns", "lists", "cycles", "xs", "sels", "lins", "rs", "ms", "bytes", "rings", "strings", "results", "blocks", "ls", "eds", "ds", "grades", "ports", "users", "reads", "cs", "mails", "lights", "its", "ers", "docs", "plays", "ins", "elines", "boxes", "cells", "l", "pins", "codes", "chains", "rates", "items", "points", "phones", "vs", "vals", "nets", "ends", "pps", "ines", "iter", "cases", "lets", "pages", "ses", "frames", "rows", "steps", "mes", "links", "limits", "les", "posts", "gs"], "ncases": ["uncases", "ntaps", "NCases", "nsases", "bcities", "ncaches", "bcodes", "ncodes", "uncaches", "uncodes", "NCaps", "ncaps", "uncities", "ncities", "bcaps", "nsaches", "nsaps", "ncades", "uncades", "bcases", "ntades", "nsades", "uncaps", "ntaches", "NCodes", "ntases", "NCities"], "ci": ["trial", "ki", "cul", "li", "uci", "course", "cgi", "lc", "iti", "nc", "iri", "cci", "nic", "chain", "ti", "ini", "cu", "bi", "si", "index", "cit", "mi", "cs", "CI", "cin", "cli", "ai", "cr", "co", "pi", "aci", "ni", "ii", "ati", "num", "di", "zi", "ca", "ce", "c", "oci", "tc", "iki", "ind", "case", "cia"], "i": ["gi", "ki", "p", "ic", "li", "it", "io", "iti", "iri", "ri", "phi", "ei", "il", "ti", "ini", "si", "xi", "im", "cli", "ai", "ip", "x", "pi", "ii", "ij", "oi", "ni", "ix", "ice", "di", "zi", "c", "ir"], "s": ["se", "ns", "comments", "p", "ats", "rs", "ps", "ms", "t", "sb", "ids", "ss", "strings", "n", "csv", "ls", "ds", "ws", "cs", "r", "its", "parts", "b", "ins", "fields", "sections", "tes", "a", "ses", "c", "series", "ts", "S", "sts", "gs"], "sub": ["se", "su", "sup", "ind", "sim", "seq", "bc", "submit", "name", "sing", "super", "div", "ub", "bi", "section", "sc", "bed", "set", "Sub", "sec", "sed", "bs", "job", "desc", "st", "stri", "step", "slice", "string", "new", "obj", "du", "sq", "uni", "mod", "text", "sat", "sam", "sel", "sb", "case"], "f_in": ["f__inn", "f2din", "f__in", " f_inner", "h_inn", " f_ins", "f_ins", " f_cin", "f__din", "f2out", "f_nin", "f2in", "f_din", "f_cin", " f_nin", "f_inn", " f_din", "f__ins", "f__out", " f_inn", "h_in", "f_inner", "h_out", "f2ins"], "line": ["range", "se", "Line", "day", "ide", "str", "word", "li", "end", "frame", "part", "lin", "lock", "le", "eline", "LINE", "block", "error", "none", "record", "pe", "node", "code", "lo", "stroke", "name", "chain", "pair", "section", "page", "char", "field", "item", "sample", "lay", "ine", "entry", "lane", "byte", "link", "row", "log", "point", "l", "nl", "text", "ln", "body", "pipe", "liner", "slice", "string", "iter", "ice", "out", "inline", "file", " inline", "cell", "side", "edge", "handle", "comment", "message", "case", "list"], "basename": ["namestyle", "baselist", "baseestyle", "modestyle", "filename", " basername", " basame", "basestyle", "filestyle", "namame", "modelist", " basestyle", " baseline", "modername", "baseername", "sitestamp", "sitername", "sitestyle", "siteline", "Basename", "baseelist", "namename", "baseename", "filame", "basername", "basestamp", "basame", "filestamp", "baseline", "Basame", "sitename", " baselist", "sitame", "namestamp", "Baseline", "Basername", "modename"], "infile": ["insfile", "innerfilename", "innfile", "initfile", "outfilename", " inFile", "initstring", "outstring", " inile", "insile", "inname", "infilename", "initname", "insFile", "inFile", "inile", "insfilename", "innname", "instring", "innerfile", "innfilename", "outname", "innerFile", "innerile", "innstring", "initfilename", " infilename"], "outfile": ["outfolder", "Outfile", "Outfolder", "outFile", " outfilename", "outfilename", "exname", "newFile", "Outfilename", "inname", "Outname", "outline", " outfolder", "OUTFile", " outname", "exfile", "newname", "inFile", "OUTfile", "OUTline", "exfilename", "newline", "newfile", "inline", "outname", "exfolder", "OUTname"], "f_out": ["f7out", "f_int", "f_ou", "of_ou", "of_can", "f_gen", "of_inner", " f_int", " f_w", "f7inner", "f_w", " f_ou", "of_out", "f7can", "f_inner", "f_can", " f_gen", "f7ou"]}}
{"code": " \\n  \\n  \\n  \\n  \\n  \\n  \\n  class memoize(object):\\n     \"\"\"Decorator. Caches a function's return value each time it is called.\\n     If called later with the same arguments, the cached value is returned\\n     (not reevaluated).\\n     \"\"\"\\n     def __init__(self, func):\\n        self.func = func\\n        self.cache = {}\\n     def __call__(self, *args):\\n        if not isinstance(args, collections.Hashable):\\n           return self.func(*args)\\n        if args in self.cache:\\n           return self.cache[args]\\n        else:\\n           value = self.func(*args)\\n           self.cache[args] = value\\n           return value\\n     def __repr__(self):\\n        '''Return the function's docstring.'''\\n        return self.func.__doc__\\n     def __get__(self, obj, objtype):\\n        '''Support instance methods.'''\\n        return functools.partial(self.__call__, obj)\\n  \\n  \\n  def precalculate():\\n      \"\"\"Perform any calculations that need to be performed before the main path\\n      (e.g., preparing lookup tables, etc.)\\n      \\n      N.B. Make sure you make any important variables global so that other\\n      functions can access them.\\n      \"\"\"\\n      pass\\n  \\n  def read_input(infile):\\n      \"\"\"This function should take an open input file, load in all of the\\n      relevant information for a single case of the problem, and output it\\n      as a single object.    \\n      \"\"\"\\n      def read_int():\\n          return int(infile.readline().strip())\\n      def read_ints():\\n          return np.array(infile.readline().split(), dtype=int)\\n      def read_bigints(): #For ints that won't fit directly in an int32 array\\n          line = infile.readline().split()\\n          return np.array(map(lambda x: int(x), line))\\n      def read_float():\\n          return float(infile.readline().strip())\\n      def read_floats():\\n          return np.array(infile.readline().split(), dtype=float)\\n      def read_string():\\n          return infile.readline().strip()\\n      def read_strings():\\n          return np.array(infile.readline().split(), dtype=object) #N.B. general dtype\\n      \\n      R, C, M = read_ints()\\n      \\n      return R, C, M\\n  \\n  def solve_case(case):\\n      \"\"\"Take the input data (structured in case) and perform any necessary\\n      calculations to obtain the desired output, formatted as the appropriate\\n      string.    \\n      \"\"\"\\n      R, C, M = case\\n      \\n      free = R * C - M\\n      assert free >= 1\\n      \\n      board = np.zeros((R, C), dtype=int) - 1\\n      \\n      def write_board(board):\\n          d = {0:'.', 1:'c', 2:'*'}\\n          s = \"\\n\"\\n          for row in board:\\n              for num in row:\\n                  try:\\n                      s += d[num]\\n                  except KeyError:\\n                      raise ValueError(\"Board not filled in!\")\\n              s += \"\\n\"\\n          return s\\n      \\n      board[0,0] = 1\\n      \\n      if M == 0:\\n          board[board == -1] = 0\\n          return write_board(board)\\n      \\n      if free == 1:\\n          board[board == -1] = 2\\n          return write_board(board)\\n          \\n      \\n      while min(R, C) <= M:\\n          if R < C:\\n              board[:,C-1] = 2\\n              C -= 1\\n              M -= R\\n          elif C <= R:\\n              board[R-1,:] = 2\\n              R -= 1\\n              M -= C\\n      \\n      def cascades(board, r, c):\\n          rows = [i for i in (r-1, r, r+1) if (i >= 0 and i < board.shape[0])]\\n          cols = [i for i in (c-1, c, c+1) if (i >= 0 and i < board.shape[1])]\\n          for r in rows:\\n              for c in cols:\\n                  if board[r,c] == 2: #Mine next to given position\\n                      return False\\n          return True\\n      \\n      if M == 0:\\n          board[board == -1] = 0\\n          if cascades(board, 0, 0):\\n              return write_board(board)\\n          else:\\n              return \"\\nImpossible\"\\n      \\n      \\n      if M > (R + C - 5):\\n          return \"\\nImpossible\"\\n          \\n      if M > 0 and (R <= 2 or C <= 2):\\n          return \"\\nImpossible\"\\n          \\n      print M, R + C - 5\\n      fill_num = min(M, R - 2)\\n      print M, fill_num\\n      board[(R - fill_num):,C-1] = 2\\n      M -= fill_num\\n      \\n      fill_num = min(M, C - 3)\\n      print M, fill_num\\n      board[R-1,(C - fill_num - 1):] = 2\\n      M -= fill_num\\n      \\n      board[board == -1] = 0\\n      return write_board(board)\\n  \\n  \\n  if __name__ == \"__main__\":\\n      precalculate()\\n      \\n      assert len(sys.argv) == 2 #only one argument\\n      assert sys.argv[1][-3:] == \".in\" #input must end with .in\\n      infile = open(\"%s\" % sys.argv[1], 'r')\\n      outfile = open(\"%s.out\" % sys.argv[1][:-3], 'w')\\n      \\n      cases = int(infile.readline().strip('\\n'))\\n      for i in range(cases):\\n          \\n          case = read_input(infile)\\n          \\n          output = solve_case(case)\\n          \\n          outfile.write('Case #%i: %s\\n' % (i+1, output))\\n          print 'Case #%i: %s\\n' % (i+1, output)\\n      \\n      infile.close()\\n      outfile.close()\\n", "substitutes": {"self": ["empty", "app", "se", "p", "python", "rem", "console", "ctx", "t", "h", "results", "req", "wrapper", "ls", "close", "proc", "item", "w", "full", "q", "local", "eth", "user", "r", "cert", "ae", "instance", "attr", "output", "mp", "debug", "today", "details", "default", "operator", "private", "prefix", "agg", "util", "sub", "cmp", "rb", "s", "github", "parent", "raw", "remote", "params", "tx", "config", "parts", "pl", "rel", "pkg", "th", "ix", "print", "resp", "also", "context", "root", "__", "this", "ms", "your", "public", "n", "pub", "wn", "conn", "my", "sw", "x", "pp", "add", "new", "round", "first", "links", "au", "res", "k", "ref", "rs", "always", "compl", "patch", "ren", "dev", "subject", "errors", "ws", "view", "me", "cl", "sh", "just", "replace", "nt", "weak", "sys", "method", "object", "py", "Self"], "func": ["partial", "function", "fx", "apply", "cmd", "go", "ctx", "what", "agg", "orig", "util", "cur", "dec", "cf", "conf", "nc", "con", "f", "wrapper", "closure", "kw", "spec", "proc", "ws", "exec", "cu", "cn", "coord", "cb", "imp", "fun", "conn", "cs", "init", "impl", "grid", "expr", "sec", "var", "unc", "val", "cast", "co", "call", "cc", "attr", "pkg", "aux", "gen", "fac", "fam", "conv", "fc", "map", "callback", "c", "method", "fs", "fn"], "cache": ["acl", "count", "storage", "api", "store", "history", "client", "pre", "metadata", "allow", "conf", "group", "cos", "spec", "chain", "driver", "use", "ache", "index", " Cache", "cs", "module", "config", "state", "db", "ac", "buffer", "ae", "aches", "dict", "table", "co", "cycle", "release", "filter", "cv", "template", "output", "hash", "proxy", "map", "ca", "session", "ready", "data", "c", "sum", "parse", "lock", "memory", "Cache", "size", "temp", "list"], "value": ["python", "values", "function", "vector", "p", "total", "next", "default", "root", "expression", "it", "other", "package", "alt", "property", "key", "variable", "ret", "name", "widget", "result", "field", "process", "item", "sample", "commit", "set", "current", "json", "write", "unit", "content", "val", "Value", "instance", "to", "output", "ter", "new", "void", "VALUE", "get", "bar", "data", "v", "we", "response", "test", "object", "message", "pair"], "args": ["bytes", "results", "ips", "ays", "ls", "keys", "w", "ords", "gets", "ins", "qs", "terms", "actions", " arguments", "xs", "ids", "files", "params", "any", "apps", "names", "amps", "parts", "changes", "fields", "bs", "groups", "items", "members", "points", "vals", "tests", "arr", "values", "ns", "Args", "ms", "words", "ds", "arg", "ars", "els", "annot", "ras", "flags", "uments", "GS", "ig", "ags", "now", "pos", "ats", "stats", "gs", "aws", "cmd", "rs", "ps", "atts", "ys", "aults", "ims", "extra", "cs", "tags", "ians", "abs", "md", "fs", "rows", "ts", "posts"], "obj": ["res", "tmp", "act", "ref", "bo", "type", "this", "ctx", "t", "o", "orig", "kind", "obs", "ob", "oid", "node", "arg", "item", "expr", "typ", "auto", "val", "x", "instance", "attr", "inst", "ot", "nt", "elt", "Obj", "out", "js", "ex", "object", "other"], "objtype": ["objtypes", "xtypes", " objType", "objectType", " objtyp", " objtypes", "objecttypes", "xType", "objType", "objtyp", "xtyp", "objecttyp", "xtype", "objecttype"], "infile": ["inplace", "cinfile", "outFile", "inputline", "inpath", "Infile", "Infiles", "infp", "outline", " infp", "inputfiles", "InFile", "Inplace", "cinFile", "outfp", "infiles", "outfiles", "cinline", "Inpath", "inFile", "outpath", "inifile", "inline", "iniline", "outfile", "cinpath", "inputfile", " inline", "inputplace", "inifp", "Inline", "outplace"]}}
{"code": " \\n  \\n  \\n  \\n  \\n  \\n  \\n  class memoize(object):\\n     \"\"\"Decorator. Caches a function's return value each time it is called.\\n     If called later with the same arguments, the cached value is returned\\n     (not reevaluated).\\n     \"\"\"\\n     def __init__(self, func):\\n        self.func = func\\n        self.cache = {}\\n     def __call__(self, *args):\\n        if not isinstance(args, collections.Hashable):\\n           return self.func(*args)\\n        if args in self.cache:\\n           return self.cache[args]\\n        else:\\n           value = self.func(*args)\\n           self.cache[args] = value\\n           return value\\n     def __repr__(self):\\n        '''Return the function's docstring.'''\\n        return self.func.__doc__\\n     def __get__(self, obj, objtype):\\n        '''Support instance methods.'''\\n        return functools.partial(self.__call__, obj)\\n  \\n  \\n  def precalculate():\\n      \"\"\"Perform any calculations that need to be performed before the main path\\n      (e.g., preparing lookup tables, etc.)\\n      \\n      N.B. Make sure you make any important variables global so that other\\n      functions can access them.\\n      \"\"\"\\n      pass\\n  \\n  def read_input(infile):\\n      \"\"\"This function should take an open input file, load in all of the\\n      relevant information for a single case of the problem, and output it\\n      as a single object.    \\n      \"\"\"\\n      def read_int():\\n          return int(infile.readline().strip())\\n      def read_ints():\\n          return np.array(infile.readline().split(), dtype=int)\\n      def read_bigints(): #For ints that won't fit directly in an int32 array\\n          line = infile.readline().split()\\n          return np.array(map(lambda x: int(x), line))\\n      def read_float():\\n          return float(infile.readline().strip())\\n      def read_floats():\\n          return np.array(infile.readline().split(), dtype=float)\\n      def read_string():\\n          return infile.readline().strip()\\n      def read_strings():\\n          return np.array(infile.readline().split(), dtype=object) #N.B. general dtype\\n      \\n      ans1 = read_int()\\n      grid1 = np.zeros((4,4), dtype=int)\\n      for i in range(4):\\n          grid1[i] = read_ints()\\n      \\n      ans2 = read_int()\\n      grid2 = np.zeros((4,4), dtype=int)\\n      for i in range(4):\\n          grid2[i] = read_ints()\\n      \\n      \\n      case = (ans1, grid1, ans2, grid2)\\n      \\n      return case\\n  \\n  def solve_case(case):\\n      \"\"\"Take the input data (structured in case) and perform any necessary\\n      calculations to obtain the desired output, formatted as the appropriate\\n      string.    \\n      \"\"\"\\n      \\n      ans1, grid1, ans2, grid2 = case\\n      \\n      valid = set(grid1[ans1-1]) & set(grid2[ans2-1])\\n      \\n      \\n      if len(valid) == 1:\\n          output = valid.pop()\\n      elif len(valid) > 1:\\n          output = \"Bad magician!\"\\n      elif len(valid) < 1:\\n          output = \"Volunteer cheated!\"\\n      return output\\n  \\n  \\n  if __name__ == \"__main__\":\\n      precalculate()\\n      \\n      assert len(sys.argv) == 2 #only one argument\\n      assert sys.argv[1][-3:] == \".in\" #input must end with .in\\n      infile = open(\"%s\" % sys.argv[1], 'r')\\n      outfile = open(\"%s.out\" % sys.argv[1][:-3], 'w')\\n      \\n      cases = int(infile.readline().strip('\\n'))\\n      for i in range(cases):\\n          \\n          case = read_input(infile)\\n          \\n          output = solve_case(case)\\n          \\n          outfile.write('Case #%i: %s\\n' % (i+1, output))\\n          print 'Case #%i: %s\\n' % (i+1, output)\\n      \\n      infile.close()\\n      outfile.close()\\n", "substitutes": {"self": ["empty", "app", "se", "p", "python", "rem", "console", "ctx", "t", "h", "results", "req", "wrapper", "ls", "close", "proc", "item", "w", "full", "q", "local", "eth", "user", "r", "cert", "ae", "instance", "attr", "output", "mp", "debug", "today", "details", "default", "operator", "private", "prefix", "agg", "util", "sub", "cmp", "rb", "s", "github", "parent", "raw", "remote", "params", "tx", "config", "parts", "pl", "rel", "pkg", "th", "ix", "print", "resp", "also", "context", "root", "__", "this", "ms", "your", "public", "n", "pub", "wn", "conn", "my", "sw", "x", "pp", "add", "new", "round", "first", "links", "au", "res", "k", "ref", "rs", "always", "compl", "patch", "ren", "dev", "subject", "errors", "ws", "view", "me", "cl", "sh", "just", "replace", "nt", "weak", "sys", "method", "object", "py", "Self"], "func": ["partial", "function", "fx", "apply", "cmd", "go", "ctx", "what", "agg", "orig", "util", "cur", "dec", "cf", "conf", "nc", "con", "f", "wrapper", "closure", "kw", "spec", "proc", "ws", "exec", "cu", "cn", "coord", "cb", "imp", "fun", "conn", "cs", "init", "impl", "grid", "expr", "sec", "var", "unc", "val", "cast", "co", "call", "cc", "attr", "pkg", "aux", "gen", "fac", "fam", "conv", "fc", "map", "callback", "c", "method", "fs", "fn"], "cache": ["acl", "count", "storage", "api", "store", "history", "client", "pre", "metadata", "allow", "conf", "group", "cos", "spec", "chain", "driver", "use", "ache", "index", " Cache", "cs", "module", "config", "state", "db", "ac", "buffer", "ae", "aches", "dict", "table", "co", "cycle", "release", "filter", "cv", "template", "output", "hash", "proxy", "map", "ca", "session", "ready", "data", "c", "sum", "parse", "lock", "memory", "Cache", "size", "temp", "list"], "value": ["python", "values", "function", "vector", "p", "total", "next", "default", "root", "expression", "it", "other", "package", "alt", "property", "key", "variable", "ret", "name", "widget", "result", "field", "process", "item", "sample", "commit", "set", "current", "json", "write", "unit", "content", "val", "Value", "instance", "to", "output", "ter", "new", "void", "VALUE", "get", "bar", "data", "v", "we", "response", "test", "object", "message", "pair"], "args": ["bytes", "results", "ips", "ays", "ls", "keys", "w", "ords", "gets", "ins", "qs", "terms", "actions", " arguments", "xs", "ids", "files", "params", "any", "apps", "names", "amps", "parts", "changes", "fields", "bs", "groups", "items", "members", "points", "vals", "tests", "arr", "values", "ns", "Args", "ms", "words", "ds", "arg", "ars", "els", "annot", "ras", "flags", "uments", "GS", "ig", "ags", "now", "pos", "ats", "stats", "gs", "aws", "cmd", "rs", "ps", "atts", "ys", "aults", "ims", "extra", "cs", "tags", "ians", "abs", "md", "fs", "rows", "ts", "posts"], "obj": ["res", "tmp", "act", "ref", "bo", "type", "this", "ctx", "t", "o", "orig", "kind", "obs", "ob", "oid", "node", "arg", "item", "expr", "typ", "auto", "val", "x", "instance", "attr", "inst", "ot", "nt", "elt", "Obj", "out", "js", "ex", "object", "other"], "objtype": ["objtypes", "xtypes", " objType", "objectType", " objtyp", " objtypes", "objecttypes", "xType", "objType", "objtyp", "xtyp", "objecttyp", "xtype", "objecttype"], "infile": ["inplace", "cinfile", "outFile", "inputline", "inpath", "Infile", "Infiles", "infp", "outline", " infp", "inputfiles", "InFile", "Inplace", "cinFile", "outfp", "infiles", "outfiles", "cinline", "Inpath", "inFile", "outpath", "inifile", "inline", "iniline", "outfile", "cinpath", "inputfile", " inline", "inputplace", "inifp", "Inline", "outplace"]}}
{"code": " \\n  T = int(raw_input())\\n  for test_case in xrange(1, T + 1):\\n      R, C, M = map(int, raw_input().split())\\n      N = R * C\\n      B = N - M\\n  \\n      W, H = (C, R) if R <= C else (R, C)\\n  \\n      if H == 1:\\n          answer = [['c'] + ['.'] * (B - 1) + ['*'] * M]\\n      elif M == N - 1:\\n          answer = [['*'] * W for r in xrange(H)]\\n          answer[0][0] = 'c'\\n      elif B < 4 or B in (5, 7):\\n          answer = None\\n      elif H == 2:\\n          if M % 2 == 0:\\n              bw = B / 2\\n              answer = [\\n                  ['c'] + ['.'] * (bw - 1) + ['*'] * (W - bw),\\n                  ['.'] * bw + ['*'] * (W - bw),\\n              ]\\n          else:\\n              answer = None\\n      else:\\n          answer = [['*'] * W for y in xrange(H)]\\n          answer[0][0] = 'c'\\n          answer[0][1] = answer[1][0] = answer[1][1] = '.'\\n          left = B - 4\\n          if 2 <= left:\\n              answer[0][2] = answer[1][2] = '.'\\n              left -= 2\\n          if 2 <= left:\\n              answer[2][0] = answer[2][1] = '.'\\n              left -= 2\\n  \\n          x = y = 3\\n          while (x < W or y < H) and 2 <= left:\\n              if x < W and 2 <= left:\\n                  answer[0][x] = answer[1][x] = '.'\\n                  left -= 2\\n                  x += 1\\n              if y < H and 2 <= left:\\n                  answer[y][0] = answer[y][1] = '.'\\n                  left -= 2\\n                  y += 1\\n  \\n          y = 2\\n          while 0 < left and y < H:\\n              x = 2\\n              while 0 < left and x < W:\\n                  answer[y][x] = '.'\\n                  left -= 1\\n                  x += 1\\n              y += 1\\n  \\n      if answer is None:\\n          answer = 'Impossible'\\n      else:\\n          if W == R:\\n              answer = map(list, zip(*answer))\\n          assert len(answer) == R\\n          assert len(answer[0]) == C\\n          assert sum(row.count('*') for row in answer) == M\\n          answer = '\\n'.join([''.join(row) for row in answer])\\n      print 'Case #{}:\\n{}'.format(test_case, answer)\\n", "substitutes": {"T": ["D", "G", "O", "TT", "TN", "X", "t", "L", "TM", "E", "Q", "A", "TH", "TC", "TS", "F", "J", "V", "Z", "Y", "NT", "WT", "TB", "K", "I", "P", "S"], "test_case": ["test_test", " test_x", " test_test", "test_c", "test_x", " test_c"], "R": ["D", "G", "X", "RA", "L", "CR", "Q", "A", "E", "RC", "RF", "Res", "F", "J", "V", "RO", "RS", "Y", "NR", "RE", "TR", "RR", "Rs", "I", "RM", "P", "RT", "BR", "S", "MR", "ER"], "C": ["D", "G", "O", "X", "L", "U", "HC", "CR", "A", "Q", "CM", "E", "CS", "CC", "WC", "F", "V", "CH", "Y", "CO", "CT", "CP", "K", "I", "P", "CB", "c", "MC", "CU", "S", "Cs", "CW"], "M": ["D", "G", "O", "AM", "X", "MA", "TM", "m", "L", "MD", "E", "Q", "A", "CM", "MN", "BM", "NM", "MAN", "MM", "FM", "F", "J", "V", "Y", "MT", "MI", "K", "I", "RM", "P", "MC", "ME", "MS", "S", "MR", "MP"], "N": ["D", "G", "O", "NN", "TN", "NA", "X", "L", "A", "Q", "E", "CR", "CN", "NS", "n", "NM", "Ns", "Ni", "F", "J", "SN", "V", "Z", "Y", "NT", "NR", "NB", "AN", "K", "I", "P", "NC", "S", "Num"], "B": ["D", "G", "O", "BC", "bl", "Ch", "IB", "L", "Sp", "A", "Q", "E", "SB", "WB", "Bs", "BM", "Be", "Cl", "Fl", "GB", "BB", "Comb", "F", "J", "b", "V", "BW", "Th", "AB", "Z", "Y", "NB", "TB", "If", "K", "BT", "I", "P", "Rat", "CB", "Tw", "wb", "BR", "Bl", "S", "DB"], "W": ["WH", "D", "G", "Win", "O", "X", "MW", "L", "U", "HT", "WA", "A", "Q", "E", "EW", "NW", "WB", "WP", "Width", "w", "WC", "F", "J", "V", "VW", "SW", "TW", "BW", "West", "Z", "Y", "WT", "Widget", "WW", " w", "Word", "K", "I", "P", "WS", "DW", "Wh", "RW", "S", "We", "WR", "CW"], "H": ["D", "G", "O", "IT", "X", "L", "HT", "HC", "E", "Q", "A", "h", "HO", "GH", "HS", "TH", "He", "RH", "HR", "F", "J", "V", "CH", "HE", "HL", "HTTP", "Y", "HH", "K", "High", "I", "OH", "P", "MH", "HA", "S", "HB", "HI"], "answer": ["swers", "leave", "store", "energy", "seat", "about", "term", "option", "see", "era", "cache", " Answer", "answered", "call", "sequence", "review", "equ", "output", "position", "second", "search", "description", "rage", "urn", "rue", "prefix", "record", "ask", "hang", "image", "any", "archive", "write", "player", "rep", "consider", "come", "offer", "attribute", "accept", "response", "iterator", "delete", "form", "either", "issue", "video", "array", "address", "example", "ve", "question", "vote", "take", "two", "my", "poll", "echo", "install", "query", "remember", "environment", "many", "phrase", "ion", "mate", "queue", "test", "memory", "interpret", "case", "ee", "bridge", "next", "one", "storage", "space", "exit", "expression", "request", "aq", "reply", "quest", "eni", "do", "section", "result", "again", "entry", "wer", "env", "value", "release", "order", "Answer", "you", "version", "place", "get", "said", "say", "message", "list"], "r": ["rc", "ra", "er", "re", "rs", "rx", "ro", "run", "rb", "ri", "ar", "ru", "rw", "pr", "q", "rew", "rr", "red", "cr", "hr", "rel", "rm", "rn", "ry", "rd", "rt", "ir"], "bw": ["gwp", "bW", "hwd", "lwt", "wwt", "gkw", "bbk", " bsw", " bwh", "bwh", "yh", "hws", "lh", " bW", "bbW", "abkw", "bbsw", "bwt", "hh", "lwin", "bbwt", "bkw", "lW", "bbwh", "abw", " bkw", "bwd", "Bwin", "bbwin", "ww", "gw", "Bwh", "wk", "lwd", "BW", "lw", "bws", "wW", "ywd", "gwt", "Bsw", "bh", " bk", "lws", "Bw", "abwt", "bk", "bwp", "yws", " bwp", "hw", "Bwt", "bsw", "yw", "abwp", "bwin", "bbw", " bwt"], "y": ["p", "e", "t", "m", "yy", "h", "hot", "ny", "axy", "uy", "w", "d", "q", "to", "ya", "by", "a", "ie", "c", "yt", "o", "ox", "key", "s", "any", "on", "sy", "ly", "ch", "yo", "yl", "out", "ry", "v", "ady", "gy", "cy", "yr", "z", "n", "i", "my", "l", "ay", "Y", "ye", "dy", "wy", "vy", "j", "type", "iy", "iny", "ies", "ys", "ym", "ey", "index", "oy", "yn", "b", "yes", "ty", "fy", "yer", "xy", "yd", "yi", "py"], "left": ["function", "li", "used", "long", "le", "wrong", "error", "old", "h", "none", "shell", "top", "down", "w", "full", "local", "flex", "tree", "min", "length", "low", "front", "inner", "open", "lic", "LE", "Left", "xp", "no", " Left", "loop", "width", "where", "lt", "center", "out", "small", "level", "this", "str", "Right", "ll", "lock", "L", "time", "sp", "path", "join", "limit", "l", "bottom", "format", "minimum", "pos", "localhost", "right", "well", "exit", "all", "lo", "joined", "only", "entry", "scroll", "cont", "value", "text", "hit", "locked", "st", "ex", "high", "lower", "php", "list"], "x": ["j", "p", "xs", "e", "xxxx", "X", "rx", "xxx", "t", "o", "wx", "dx", "xp", "no", "m", "time", "ax", "h", "ox", "key", "z", "n", "g", "xc", "id", "xa", "true", "xt", "tx", "exp", "ey", "int", "name", "item", "w", "d", "index", "ick", "xi", "nz", "i", "width", "inx", "on", "b", "point", "l", "el", "yx", "ext", "lex", "xe", "min", "xd", "ix", "title", "xy", "a", "ex", "px", "c", "v", "xx", "lat", "step"]}}
{"code": " \\n  T = int(raw_input())\\n  for test_case in xrange(1, T + 1):\\n      N1 = int(raw_input())\\n      for i in xrange(4):\\n          if i + 1 == N1:\\n              R1 = map(int, raw_input().split(' '))\\n          else:\\n              raw_input()\\n      N2 = int(raw_input())\\n      for i in xrange(4):\\n          if i + 1 == N2:\\n              R2 = map(int, raw_input().split(' '))\\n          else:\\n              raw_input()\\n      assert 1 <= N1 <= 4\\n      assert 1 <= N2 <= 4\\n      assert len(R1) == len(R2) == 4\\n  \\n      num = set(R1) & set(R2)\\n      if len(num) == 1:\\n          answer = num.pop()\\n      elif 1 < len(num):\\n          answer = 'Bad magician!'\\n      else:\\n          answer = 'Volunteer cheated!'\\n      print 'Case #{}: {}'.format(test_case, answer)\\n", "substitutes": {"T": ["Time", "D", "G", "O", "TT", "TN", "X", "t", "L", "TM", "E", "Q", "A", "TON", "TV", "Test", "R", "B", "TC", "TS", "TA", "F", "J", "V", "M", "Z", "Y", "N", "WT", "GT", "TR", "TB", "C", "K", "I", "P", "TO", "S"], "test_case": ["test_test", "testtesttest", "testbookstep", "testbookblock", "testteststep", "testbookcase", " test_test", "testtestcase", " test_block", "test_step", "testtestinstance", "test_block", "test_instance", " test_step", "test_Case", "testtestCase", "testtestblock", " test_instance", " test_Case"], "N1": ["NOne", " N30", " N0", "NN30", "NN1", "NFirst", "NNOne", "NA51", "T1", "SN51", "N30", "SN1", " NFIR", "NAFIR", " NFirst", "T2", " NX", "NN001", "R0", " NOne", "NAFirst", "NFIR", "N001", "R001", "RX", "NX", "N0", " N51", "SNFirst", "N51", "NA1", "R30", "SNFIR", "ROne", "TX", " N001", "T0"], "i": ["gi", "asi", "ji", "j", "ic", "ami", "li", "it", "iy", "ia", "o", "ik", "id", "n", " ii", "phi", "il", "ti", "ini", "iat", " j", "si", "xi", "im", "y", "\u0438", "ai", "\u00ed", "ip", "ori", "x", "pi", "oi", "ij", "ii", "ati", "di", "zi", "I", "a", "ir", "yi", "ind", "ci"], "R1": ["REL001", "RA51", "REL2", "RL2", "RL1", "ER1", "ER51", "P2", "R51", "RL001", "R81", "RICT", "P0", "RA1", "Nml", "RE81", "RE1", "R0", "ER81", "REICT", " R0", "N001", "R001", "N0", "Rml", "RE51", "REL1", " Rml", "RA81", "Pml", "P1", "ERICT", "RAICT"], "N2": [" N0", "N4", "NM1", "NM42", " N12", "R42", "L0", " N4", " N42", "SN2", "R0", "SN4", " NB", "R4", "R12", "RB", "N12", "NM2", "N42", "N0", "SN12", "NB", "L1", "SNB", "L4", "L2"], "R2": ["RO2", "REL2", "r1", "RE2", "RE6", "Ntwo", " Rtwo", "RNOT", "rtwo", "RELNOT", "rTwo", "DRNOT", "RTwo", "DRtwo", "NTwo", "ROtwo", "RG6", " RNOT", "R6", "REtwo", "RO6", "Rtwo", "RO1", "DR2", "r2", "RGtwo", "R7", "RELtwo", "RG2", "ROTwo", "RE7", "RG7", "RO7"], "num": ["hex", "rem", "enum", "str", "reg", "mask", "snap", "orig", "sub", "zero", "n", "en", "name", "rub", "um", "comm", "prim", "result", "index", "na", "set", "multi", "nu", "nom", "np", "phone", "number", "un", "NUM", "alph", "nm", "box", "ver", "new", "msg", "gen", "th", "Num", "mem", "data", "nam", "sum", "non", "cal", "text", "test", "valid", "sam", "mon"], "answer": ["bridge", "next", "swers", "exit", "err", "issue", "request", "error", "turn", "reply", "about", "ve", "example", "eni", "ask", "username", "image", "name", "see", "result", "question", "vote", "uno", "ain", "archive", "again", " Answer", "onse", "entry", " unanswered", "notice", "me", "wer", "echo", "interpret", "value", "answered", "ae", "don", "query", "yes", "remember", "sequence", "Answer", "review", "output", "version", "offer", "format", "know", "status", "said", "accept", "response", "description", "comment", "say", "message", "case"]}}
{"code": " \\n  def put_mines_last_step(R, C, M, grid):\\n  \tif M == 0:\\n  \t\treturn\\n  \tR -= 1\\n  \tC -= 1\\n  \tgrid[R][C] = '*'\\n  \tM -= 1\\n  \tr = R - 1\\n  \tc = C - 1\\n  \twhile M > 0:\\n  \t\tif r > c:\\n  \t\t\tgrid[r][C] = '*'\\n  \t\t\tr -= 1\\n  \t\telse:\\n  \t\t\tgrid[R][c] = '*'\\n  \t\t\tc -= 1\\n  \t\tM -= 1\\n  \\n  def put_mines(R, C, M, grid):\\n  \tif R > C:\\n  \t\tif M < C:\\n  \t\t\tput_mines_last_step(R, C, M, grid)\\n  \t\t\treturn\\n  \t\tfor i in range(C):\\n  \t\t\tgrid[R - 1][i] = '*'\\n  \t\tput_mines(R - 1, C, M - C, grid)\\n  \t\treturn\\n  \tif M < R:\\n  \t\tput_mines_last_step(R, C, M, grid)\\n  \t\treturn\\n  \tfor i in range(R):\\n  \t\tgrid[i][C - 1] = '*'\\n  \tput_mines(R, C - 1, M - R, grid)\\n  \treturn\\n  \\n  def process(R, C, M):\\n  \trlt = ''\\n  \tgrid = []\\n  \tfor i in range(R):\\n  \t\tgrid.append(['.'] * C)\\n  \tput_mines(R, C, M, grid)\\n  \tif not C == 1:\\n  \t\tfor i in range(R):\\n  \t\t\tif not grid[i][0] == '.':\\n  \t\t\t\tbreak\\n  \t\t\tif not grid[i][1] == '.':\\n  \t\t\t\treturn '\\nImpossible'\\n  \tif not R == 1:\\n  \t\tfor i in range(C):\\n  \t\t\tif not grid[0][i] == '.':\\n  \t\t\t\tbreak\\n  \t\t\tif not grid[1][i] == '.':\\n  \t\t\t\treturn '\\nImpossible'\\n  \tgrid[0][0] = 'c'\\n  \tfor i in grid:\\n  \t\trlt += '\\n' + ''.join(i)\\n  \treturn rlt\\n  \\n  input_file = open(sys.argv[1], 'r')\\n  T = int(input_file.readline())\\n  for i in range(T):\\n  \t(R, C, M) = map(int, input_file.readline().split())\\n  \tprint 'Case #%d:' % (i + 1), process(R, C, M)\\n", "substitutes": {"R": ["res", "D", "G", "O", "Right", "JR", "X", "Run", "RA", "H", "L", "U", "CR", "Q", "A", "E", "CM", "DR", "RC", "Remote", "IR", "B", "RG", "SR", "Res", "Root", "RL", "RH", "AR", "Mr", "HR", "J", "F", "Reader", "V", "RO", "RS", "Rot", "Row", "Y", "Cor", "N", "NR", "RE", "TR", "GR", "RR", "Rs", "K", "I", "RM", "P", "RT", "Rat", "RI", "OR", "BR", "S", "MR", "Re", "ER"], "C": ["D", "CD", "U", "A", "Count", "CAR", "Cl", "IC", "CC", "F", "J", "VC", "CF", "K", "MC", "Co", "G", "Ch", "CM", "CN", "Chain", "CS", "B", "Cons", "CE", "CI", "WC", "CON", "EC", "Config", "CO", "CT", "CG", "CP", "CU", "S", "Cache", "JC", "COR", "X", "Cow", "L", "CA", "Y", "CNN", "Cu", "Car", "DC", "P", "Mc", "Cs", "O", "H", "CR", "Q", "E", "Cr", "Craig", "SC", "V", "Con", "cr", "N", "I", "CB", "W", "CCC", "CL"], "M": ["D", "G", "O", "Ch", "New", "X", "Memory", "cm", "MA", "L", "m", "TM", "U", "H", "Q", "MR", "CM", "MD", "E", " m", "CR", "MN", "REM", "NM", "OM", "Mon", "MAN", "B", "Mi", "PM", "MM", "JM", "AR", "F", "J", "Multi", "IM", "V", "Min", "Man", "Me", "Manager", "Y", "mc", "LM", "N", "EM", "RE", "Ms", "MT", "MI", "MS", "My", "RM", "P", "I", "Mc", "DM", "W", "MC", "Rem", "S", "AM"], "grid": ["raid", "media", "clear", "func", "band", "wei", "domain", "sim", "week", "window", "fine", "node", "req", "wrapper", "jac", "user", "line", "cache", "set", "module", "link", "hold", "row", "network", "pi", "windows", "age", "box", "dq", "gc", "rain", "lat", "cell", "power", "hash", "status", "gi", "rage", "gru", "stock", "iq", "reg", "util", "rix", "block", "medium", "manager", "mg", "id", "record", "tile", "image", "chain", "scan", "lay", "rank", "xi", "gpu", "config", "via", "pool", "back", "pipe", "ix", "gr", "device", "out", "fac", "edge", "filter", "this", "master", "mask", "graph", "array", "stack", "zero", "g", "group", "coord", "work", "cells", "dict", "query", "table", "flow", "net", "gate", "fixed", "map", "lag", "bar", "data", "now", "queue", "gray", "res", "range", "bridge", "storage", "Grid", "gain", "client", "cgi", "slave", "addr", "rid", "mat", "result", "index", "gm", "wire", "multi", "entry", "cli", "db", "browser", "order", "input", "xy", "get", "bag", "good", "list"], "r": ["res", "br", "p", "j", "rc", "er", "re", "e", "rs", "reg", "cm", "t", "o", "rx", "m", "h", "nr", "ro", "n", "g", "rb", "f", "rest", "ar", "d", "q", "u", "b", "l", "rr", "cr", "rar", "x", "sr", "rm", "mr", "a", "v", "ir", "rt"], "c": ["res", "p", "j", "rc", "k", "col", "e", "re", "cp", "cm", "t", "o", "m", "lc", "ct", "h", "Cr", "z", "n", "g", "f", "ar", "w", "d", "u", "y", "cs", "b", "l", "red", "cr", "co", "x", "mc", "a", "ce", "v", "ci"], "i": ["ki", "hi", "p", "li", "e", "t", "io", "m", "iti", "IC", "w", "q", "ai", "pi", "ii", "ati", "Xi", "zi", "RI", "a", "ie", "ir", "ci", "status", "gi", "ji", "uri", "o", "ik", "id", "s", "chain", "ini", "bi", "xi", "u", "\u0438", "\u00ed", "adi", "ij", "iu", "ix", "di", "out", "v", "this", "it", "array", "z", "n", "g", "f", "ui", "eri", "info", "ti", "y", "l", "x", "oi", "res", "j", "ic", "ia", "iri", "ri", "phi", "ei", "qi", "int", "index", "si", "gm", "im", "mi", "multi", "cli", "b", "me", "ip", "ori", "aci", "I", "fi", "yi", "list"], "rlt": ["dlt", "erlt", "ergt", "mwt", "dli", "mformat", " rformat", "rli", "Rlt", "mlt", "Rrt", "rrt", "rgt", "mLT", "rlit", " rLT", "dLT", "Rformat", " rgt", "rlet", "Rwt", "rwt", "rcgt", "mli", "rLT", "mgt", "rformat", "dgt", " rli", " rlet", "mrt", " rwt", "rclet", "rclt", "erlit", "erlet", " rrt", " rlit", "rclit"], "input_file": ["feed_file", "inputfstream", "Input_dir", "inputlockFile", "input1dir", " input_fp", "input__open", "inputLockFile", "input_filename", "inputlockopen", " input_File", "Input_stream", "inputLockopen", "input_dir", "inputLockfile", " input2fp", " input2open", "feedlockopen", "Input_FILE", "input1FILE", "input_open", "input__File", " input2file", "inputfFILE", "feed_File", "input1stream", "input__fp", "input_fp", " input_open", "inputlockfilename", "inputLockfilename", "input_stream", "inputfdir", "Input_file", "feedlockFile", "input2fp", "feedlockfilename", "input2file", "feed_filename", "input2open", "input__file", "feedlockfile", "input_File", "input_FILE", "input2File", "input1file", " input2File", "inputffile", "feed_open", "inputlockfile"], "T": ["Time", "Ct", "D", "G", "O", "TI", "TP", "TT", "TN", "t", "TM", "L", "TY", "E", "Q", "TL", "B", "TC", "TS", "TA", "F", "OT", "J", "V", "Y", "NT", "N", "WT", "GT", "TR", "TB", "K", "Total", "I", "TX", "P", "S"]}}
{"code": " \\n  \\n  def process(chosen_row_1, arrange_1, chosen_row_2, arrange_2):\\n  \trlt = 'Volunteer cheated!'\\n  \tfound = False\\n  \tfor i in arrange_1[chosen_row_1]:\\n  \t\tif i in arrange_2[chosen_row_2]:\\n  \t\t\tif not found:\\n  \t\t\t\trlt = i\\n  \t\t\t\tfound = True\\n  \t\t\telse:\\n  \t\t\t\trlt = 'Bad magician!'\\n  \t\t\t\tbreak\\n  \treturn rlt\\n  \\n  input_file = open(sys.argv[1], 'r')\\n  T = int(input_file.readline())\\n  for i in range(T):\\n  \tchosen_row_1 = int(input_file.readline()) - 1\\n  \tarrange_1 = []\\n  \tarrange_1.append(map(int, input_file.readline().split()))\\n  \tarrange_1.append(map(int, input_file.readline().split()))\\n  \tarrange_1.append(map(int, input_file.readline().split()))\\n  \tarrange_1.append(map(int, input_file.readline().split()))\\n  \tchosen_row_2 = int(input_file.readline()) - 1\\n  \tarrange_2 = []\\n  \tarrange_2.append(map(int, input_file.readline().split()))\\n  \tarrange_2.append(map(int, input_file.readline().split()))\\n  \tarrange_2.append(map(int, input_file.readline().split()))\\n  \tarrange_2.append(map(int, input_file.readline().split()))\\n  \tprint 'Case #%d:' % (i + 1), process(chosen_row_1, arrange_1, chosen_row_2, arrange_2)\\n", "substitutes": {"chosen_row_1": ["chosen_row__5", "chosen_row_01", "chosen_row__1", "chosen_rows_one", "chosen_rows_01", "chosen_col_0", "chosen_col_id", "chosen_rows_1", "chosen_col_1", "chosen_col_4", "chosen_row_9", "chosen_row14", "chosen_col_9", "chosen_rows_3", "chosen_row__2", "chosen_row10", "chosen_row_id", "chosen_row_5", "chosen_col_2", "chosen_row_0", "chosen_row_one", "chosen_row_3", "chosen_col_3", "chosen_row12", "chosen_row__id", "chosen_col_5", "chosen_row11", "chosen_row_4"], "arrange_1": ["arrand_1", "arrrage_2", "arrange_n", "arrange_4", "arrange_91", "arrrange_9", "arrack_01", "arrange_51", "arrange_single", "arrangeList1", "arrangeList11", "arrrage_1", "arrange_ONE", "arrack_91", "arrrange_11", "arrange_11", "arrrange_2", "arrand_2", "arrange642", "arrange2a", "arrange_a", "arrrange_single", "arrangeList2", "arrrange_1", "arrange_01", "arrack_2", "arrangeListONE", "arrange_7", "arrange643", "arrange_9", "arrange_one", "arrack_1", "arrange_3", "arrrage_n", "arrange641", "arrange_6", "arrrange_6", "arrand_51", "arrand_one", "arrange64single", "arrrange_4", "arrange21", "arrrage_6", "arrrange_7", "arrange22", "arrrange_3", "arrrange_a", "arrange27", "arrrange_ONE"], "chosen_row_2": ["chosen_row_7", "chosen_col_two", "chosen_rows_5", "chosen_rows_1", "chosen_col_1", "chosen_cell_1", "chosen_row1two", "chosen_row17", "chosen_col_7", "chosen_row_5", "chosen_col_2", "chosen_row_0", "chosen_rows_4", "chosen_rows_2", "chosen_row_3", "chosen_cell_4", "chosen_row12", "chosen_row_two", "chosen_rows_0", "chosen_cell_2", "chosen_row11", "chosen_row_4", "chosen_cell_3"], "arrange_2": ["arrange_4", "arrangeable2", "arrrange_8", "arrange_two", "arrrange_left", "arrrange_two", "arrrange_5", "arrangeable8", "arrange23", "arrrange_2", "arrange_12", "arrange_02", "arrrange_1", "arrrange_02", "arrange_7", "arrange_8", "arrange_3", "arrange202", "arrange242", "arrange_5", "arrange2two", "arrange_left", "arrrange_4", "arrangeableleft", "arrange21", "arrrange_42", "arrrange_7", "arrange22", "arrrange_12", "arrrange_3", "arrangeable1", "arrange_42"], "rlt": ["vrstr", "errlr", "rlr", "erlt", "errmt", "errelt", "rrlamm", "krstr", "krilt", "arelt", "rrt", "erelt", "vrfol", " rLT", "armt", " relt", " rlr", "krfol", "rrilt", "arlt", "errt", "errrt", "erralt", "rLT", "krlt", "erlr", "vrlt", "vrilt", "relt", "rrlt", "rilt", "rrelt", "errLT", " rlamm", "rrLT", "rrfol", "rstr", "ralt", "errlt", " rmt", "errlamm", "rmt", "aralt", "rlamm", " rrt", "rrstr", "rfol", " ralt"], "found": ["installed", "done", "matched", "count", "type", "err", "sent", "used", "t", " Found", "success", "z", "conf", "ed", "f", "seen", "started", "present", "info", "failed", "field", "result", "index", "released", "full", "set", "finder", "loaded", "left", "created", "l", "required", "read", "body", "loc", "find", "ailed", "new", "printed", "fixed", "Found", "search", "sold", "pos", "test", "valid", "good"], "i": ["gi", "ki", "hi", "ji", "p", "Is", "k", "ic", "j", "q", "li", "e", " di", "iy", "it", "t", "m", "aii", "iti", "id", "iri", "s", "z", "n", " ii", "f", "ri", "phi", "g", "ei", "nil", "info", "ti", "ini", " Ai", "d", "si", " I", "xi", "im", "y", "multi", "mi", " ti", "ai", "r", "me", "\u00ed", "ip", "u", "l", "x", "pi", "oi", "ij", "ii", "ati", "iter", "di", "zi", "I", "a", "c", "v", "ir", "yi", "ind", "list"], "input_file": ["interface_folder", "act_file", " input_body", "inputobjfiles", "inputdbtable", "input32ile", " input_data", "input_dir", "interface_to", "inputfiledata", " input_stream", "input64body", "int_table", "input_body", "int_line", "input64db", "input2file", "input_bytes", "input2line", " input_ile", "input_data", "inputletfile", "input12dir", "inputdbfile", "inputdbconsole", "input32file", "input64File", " input_bytes", "input12file", "inputfiletxt", "inputletbytes", "input_db", " input64body", "input2dir", "input_line", " input64db", "inputfilefile", "input_stream", "input8folder", " input_dir", "input_where", "inputdbline", "check_channel", " input_where", " input_FILE", "inputletweb", "inputletFile", "input_web", "input_function", "interface_file", "inputfilestream", "input_channel", "inputobjto", "act_chain", "check_file", "check_function", " input_File", "input12channel", "input_txt", "int_console", "inputobjfolder", "input_files", "input_table", "input64file", " input_channel", "check_files", "interface_files", " input_console", " input64File", "inputletfiles", "input8file", " input_folder", "input2files", " input_web", " input_db", "int_file", " input_txt", "input_to", "input2table", "inputobjfile", "act_web", "input12files", "inputletfunction", "input8where", "input32console", " input64file", "inputletchannel", "input_console", "input_File", "input_FILE", " input_files", "input2console", "input_ile", "input_folder", "input_chain", "input8File"], "T": ["Time", "D", "O", "TI", "TP", "TT", "TN", "t", "TM", "L", "TY", "Q", "R", "TH", "It", "B", "TPS", "TC", "TS", "TA", "F", "J", "V", "M", "NT", "N", "WT", "GT", "TR", "TB", "C", "K", "I", "P", "S"]}}
{"code": "inputFile = open('C-small-attempt8.in', 'r')\\n  lines = inputFile.readlines()\\n  inputFile.close()\\n  \\n  outputFile = open('C-small-attempt8.out', 'w')\\n  \\n  numTests = int(lines[0])\\n  \\n  for i in range(1, numTests+1):\\n      [r, c, m] = map(lambda x: int(x), lines[i].split())\\n  \\n      openCells = r*c - m\\n  \\n      works = False\\n      matrix = [['*']*c for j in range(r)]\\n      if r >= 3 and c >= 3:\\n          order = [(0,0), (0,1), (1,0), (1,1), (0,2), (1,2),\\n                   (2,0), (2,1)]\\n          if openCells == 1 or openCells == 4 or openCells == 6:\\n              works = True\\n              for (x,y) in order[:openCells]:\\n                  matrix[x][y] = '.'\\n              matrix[0][0] = 'c'\\n              \\n          elif openCells >= 8:\\n              works = True\\n              filledRows = openCells / c\\n              if filledRows >= 2:\\n                  if filledRows == r:\\n                      matrix = [['.']*c for j in range(r)]\\n                      matrix[0][0] = 'c'\\n                  else:\\n                      remainder = openCells%c\\n                      if not remainder == 1:\\n                          for j in range(filledRows):\\n                              matrix[j] = ['.']*c\\n                          matrix[filledRows] = ['.']*remainder + ['*'] * (c-remainder)\\n                      elif filledRows > 2:\\n                          for j in range(filledRows-1):\\n                              matrix[j] = ['.']*c\\n                          matrix[filledRows-1] = ['.']*(c-1) + ['*']\\n                          matrix[filledRows] = ['.', '.'] + ['*']*(c-2)\\n                      else:\\n                          matrix[0] = ['.']*(c-1) + ['*']                        \\n                          matrix[1] = ['.']*(c-1) + ['*']\\n                          matrix[2] = ['.', '.', '.'] + ['*']*(c-3)\\n                      matrix[0][0] = 'c'\\n                  \\n              else:\\n                  for (x,y) in order:\\n                      matrix[x][y] = '.'\\n                  remainingOpen = openCells - 8\\n                  if remainingOpen % 2 == 0:\\n                      for j in range(remainingOpen/2):\\n                          matrix[0][j+3] = '.'\\n                          matrix[1][j+3] = '.'\\n                  else:\\n                      matrix[2][2] = '.'\\n                      remainingOpen -= 1\\n                      for j in range(remainingOpen/2):\\n                          matrix[0][j+3] = '.'\\n                          matrix[1][j+3] = '.'\\n                  matrix[0][0] = 'c'\\n  \\n      elif r == 1:\\n          works = True\\n          matrix[0] = ['.']*(c-m) + ['*']*m\\n          matrix[0][0] = 'c'\\n      elif c == 1:\\n          works = True\\n          for j in range(r-m):\\n              matrix[j][0] = '.'\\n          matrix[0][0] = 'c'\\n  \\n      elif r == 2 and c == 2:\\n          if m == 3:\\n              works = True\\n              matrix[0][0] = 'c'\\n          elif m == 0:\\n              works = True\\n              matrix = [['c', '.'], ['.', '.']]\\n      elif r == 2:\\n          if m % 2 == 0 and r*c-m > 2:\\n              works = True\\n              matrix[0] = ['.']*(c-m/2) + ['*']*(m/2)\\n              matrix[1] = ['.']*(c-m/2) + ['*']*(m/2)\\n              matrix[0][0] = 'c'\\n          elif r*c-m == 1:\\n              works = True\\n              matrix[0][0] = 'c'\\n      elif c == 2:\\n          if m % 2 == 0 and r*c-m > 2:\\n              works = True\\n              for j in range((r*c-m)/2):\\n                  matrix[j] = ['.', '.']\\n              matrix[0][0] = 'c'\\n          elif r*c-m == 1:\\n              works = True\\n              matrix[0][0] = 'c'\\n      \\n  \\n      outputFile.write('Case #'+str(i)+':\\n')\\n      '''if len(matrix) != r:\\n          print i, matrix\\n      count = 0\\n      for j in range(len(matrix)):\\n          for k in range(len(matrix[j])):\\n              if matrix[j][k] == '*':\\n                  count += 1\\n      if count != m:\\n          print i, matrix'''\\n      if not works:\\n          outputFile.write('Impossible\\n')\\n      else:\\n          for x in range(len(matrix)):\\n              for y in range(len(matrix[0])):\\n                  outputFile.write(matrix[x][y])\\n              outputFile.write('\\n')\\n  outputFile.close()\\n              \\n", "substitutes": {"inputFile": [" inputfile", "openFile", "openfile", "inputFormat", "inPath", " inputDir", "Inputfile", "inFiles", " inputFormat", "outputFiles", "infile", "InputFiles", "outputLine", " inputFiles", "inputDir", "inLine", "InputLine", "openFormat", "inputFiles", "inFile", "inputPath", "openPath", "InputFile", "InputDir", "inputLine", "inFormat", "inputfile", "outputDir", " inputPath", "outputfile"], "lines": ["values", "comments", "olds", "cycles", "issues", "rs", "bytes", "prints", "years", "rings", "strings", "words", "files", "blocks", "ls", "headers", "ds", "outs", "forms", "dates", "line", "its", "parts", "gets", "docs", "plays", "elines", "cells", "l", "reports", "pins", "codes", "bs", "sections", "qs", "rates", "points", "vs", "vals", "notes", "ines", "tests", "frames", "rows", "steps", "details", " Lines", "posts", "gs"], "outputFile": ["OutputFile", "OutputFiles", "outFile", "outfile", " outputPath", "OutputPath", " outputFiles", "outputPath", "Outputfile", "outFiles", "outputFiles", "outputfile", "outPath", " outputfile"], "numTests": ["numMatets", " numRches", "numRakes", "numMatiments", "numTest", " numTiments", "numTrees", " numRiments", "numTiments", "numRrees", " numTrees", "numRiments", "numLakes", " numRets", "numMatches", "numPest", "numNests", "numRets", "numNches", "numLests", "numNets", "numRest", "numTakes", "numLrees", "numRests", "numPrees", " numRest", "numPakes", "numRches", " numTakes", "numTets", "numMatests", "numTches", "numNiments", "numLest", " numTest", "numPests", " numRakes", " numTets", " numRrees", " numTches", " numRests"], "i": ["gi", "ic", "p", "li", "e", "t", "o", "z", "id", "n", "ri", "ti", "ini", "bi", "index", "si", "xi", "im", "mi", "ai", "l", "pi", "ii", "ij", "ix", "di", "I", "zi", "v", "ind", "ci", "num"], "r": ["res", "p", "rc", "er", "re", "e", "rs", "t", "o", "h", "nr", "ro", "z", "n", "rb", "g", "s", "R", "f", "ar", "ru", "w", "d", "q", "u", "b", "l", "cr", "co", "rar", "sr", "mr", "a", "v", "rd", "rt", "right"], "c": ["p", "col", "e", "re", "t", "h", "con", "close", "cos", "pc", "w", "d", "cache", "cd", "length", "fc", "ce", "gc", "ci", "comments", "cp", "o", "lc", "ct", "cf", "conf", "chain", "cu", "u", "sc", "cin", "cc", "mc", "cum", "ch", "C", "etc", "v", "rc", "cy", "z", "n", "g", "f", "anc", "arc", "current", "ac", "l", "co", "chains", "right", "dc", "cm", "self", "xc", "category", "cs", "b", "cont", "cl", "unc", "cr", "tc", "com"], "m": ["p", "k", "em", "tm", "e", "cm", "t", "o", "mm", "h", "mat", "n", "g", "f", "bm", "am", "w", "d", "gm", "im", "mi", "b", "M", "l", "mk", "cr", "mc", "sm", "mut", "rm", "mr", "a", "v"], "x": ["ux", "p", "xs", "e", "X", "rx", "t", "wx", "dx", "xp", "ax", "h", "ox", "z", "n", "xc", "s", "xa", "f", "tx", "xt", "mx", "w", "xi", "xf", "on", "row", "l", "yx", "xe", "xd", "ix", "xy", "a", "ex", "px", "v", "xx", "ry", "fx"], "openCells": ["openCsells", "openCoells", "openCcells", "emptyConell", "OpenRows", "openClels", " openPells", "OpenCcells", " openNcells", "openPells", " openClells", "openSell", "openPows", "openConows", "freePows", "openButaxies", "OpenCods", "openClods", " openClows", "openCaxies", "freeCels", "openClcells", "emptyCell", " openNhips", "openNcells", "openCoows", "openButells", "openPods", "openCoell", "openNalls", "openScells", " openPows", "openSells", "openConells", "openCships", "freeCows", "openCsries", " openPcells", " openCels", "emptyCells", "openShips", "openConods", "openRods", "emptyCods", "openRalls", "openChips", "OpenRcells", "openConell", "openCods", "emptyConells", " openPels", "openCoods", " openChips", "openCels", "openClries", "openSodes", "openButows", " openNalls", "OpenRodes", "openCsows", "openRells", "openClows", "openButels", "openWhenels", " openCows", "OpenRods", "openCell", "openCscells", "openRries", "openWhenells", "openPaxies", "OpenCells", "emptyCows", "openCalls", "OpenRells", "openRcells", "openPcells", "openNows", "OpenCows", "freePells", " openCries", "openSods", "openPalls", "openWhenows", " openCalls", "openNhips", "openRodes", "OpenCodes", " openClries", " openCcells", "openNels", "openCows", "openSows", " openNels", "openCries", " openNells", "emptyConods", "freeCaxies", " openNows", "openClells", "openWhenaxies", "freeCells", "openRows", "openPels", "openRels", "emptyConows", "openNells", "freePaxies", "freePels", "openCodes"], "works": ["weights", "makes", "cycles", "ops", "check", "aces", "Works", "WORK", "ists", "ways", "results", "words", "worked", " passes", "grades", "ws", " networks", "full", "working", "outs", "forms", "dates", "cs", "features", "runs", "acts", "work", "workers", "poses", "parts", "changes", "plays", "yes", "shows", "groups", "has", "chains", "hands", "orts", "points", "helps", "checks", "ends", "marks", "alks", "pps", "cases", "falls", " checks", " matches", "links", "es", " runs", "hops"], "matrix": ["memric", "plotrench", "statrix", "memrix", "mrier", "plotric", "matchrics", "projectrix", "metrix", "matrics", "atrics", "patprint", " matprint", "modulerix", "patrier", " matension", "atrice", "moduleric", "patrix", "listrics", "monress", "timerix", "matric", "monrices", " matrice", "transrices", "atrices", " matric", "matrices", "modulection", "monric", "plotprint", "mross", "patrices", "patric", "Matrice", "memrice", "metrics", "transross", " matrixribution", "listrix", "metitude", "Matction", "projectprint", "metric", "scheress", "Matrix", "matchric", "matrier", "documentrice", "matrice", "projectribution", "matction", "atric", "projectix", "memrics", "matross", "documentrics", "matribution", "twise", "matrench", "matix", "mric", " matribution", "Matension", " matrixix", "timerics", "matress", "docace", "monrix", "timeric", "mrix", "patrench", "timeitude", "documentension", "Matace", "atrier", "mrics", "monrics", "Matross", "trix", "statension", "mrices", "scheric", " matress", "scherix", "docrix", "docplex", "plotrix", "listrice", "tric", "matwise", " matrixprint", "matchrix", "memrices", "matprint", "transric", " matrench", "Matrices", "Matwise", "matace", "docension", "transrix", "Matric", "statplex", "modulewise", "matitude", "matchitude", "matension", "statace", "scherics", "documentrix", "Matrics", "atrix", " matrixrix", "tction", " matix", " matrics", "listric", "Matplex", "matplex"], "j": ["ji", "br", "p", "jj", "k", "jl", "str", "fr", "li", "it", "jp", "o", "jam", "h", "ct", "z", "n", "g", "ja", "jac", "d", "pr", "uj", "q", "json", "J", "kj", "dj", "l", "oj", "cr", "ij", "job", "jc", "ch", "obj", "ver", "ix", "xy", "js", "jump", "ie", "jas", "v", "aj", "bj", "ind"], "order": ["der", "type", "orient", "er", "graph", "direction", "array", "Order", "address", "id", "group", "scale", "rule", "era", "info", "condition", "index", "random", "rank", "orders", "ordered", "set", "ords", "sort", "align", "grid", "where", "table", "cycle", "ord", "position", "ice", "map", "rows", "dir", "case", "list"], "y": ["yt", "p", "gy", "col", "iy", "cy", "t", "o", "ies", "yy", "h", "yr", "z", "n", "s", "ym", "ny", "ey", "yn", "b", "sy", "ay", "yx", "ty", "Y", "ij", "ch", "yl", "xy", "wy", "ry", "v", "xx", "py"], "filledRows": ["fillRRow", "filledRsates", "filledRells", "fillNrows", "filledSells", "filledRorts", "fillNRow", "illedProws", "filledPrs", "illedSells", "filledNrows", "occupiedRows", "filledSows", "illedSows", " filledROWS", "filledBRells", "filledSrows", "filledCells", "filledNows", "illedROWS", "filledLorts", "filledPows", "illedPows", "filledRanks", "filledNrs", "fillNrs", "illedRrows", "fillRates", "fillRorts", "filledProws", "filledBRRow", "filledLOWS", "filledCorts", "filledROWS", "filledLates", "fillNells", "filledRrows", "occupiedRrows", " filledCells", "filledRrs", "fillNows", "filledNanks", " filledCrows", "fillRells", "illedPanks", " filledCows", "filledDells", "filledDows", "fillRrs", "filledRates", "illedRows", "filledPOWS", "occupiedRays", "filledCrs", "filledNells", "fillROWS", "filledNorts", "filledCrows", "filledPells", "filledRRow", "filledPanks", "filledLows", " filledRanks", "illedRanks", " filledLrs", " filledRrows", "filledRsOWS", "illedRells", "filledNRow", "filledBRows", "filledLells", "filledRsows", "filledLrs", " filledRells", "occupiedRrs", "filledRsrows", "filledRays", " filledCanks", "filledCanks", "filledDRow", "filledSanks", " filledLOWS", "illedSanks", "filledBRorts", "fillRows", "filledDorts", " filledRrs", "filledCows", "filledLays", " filledLows", "illedSrows", "illedPOWS", "fillRrows", "filledLrows", " filledLrows", "fillNorts"], "remainder": ["remainner", "remainsner", "remainsger", "remainedner", "remainsDER", "REMainster", "REMainsDER", "remraindr", "remainedDER", "Remaindr", "remainsdr", "REMainder", "remainsder", "Remainsder", "remainger", "Remrainger", "remainedder", " remainingder", "REMainDER", "remrainner", "Remainter", "Remrainter", " remaindr", "Remrainder", "remaindr", "remainster", "REMainter", "Remainsger", "remainingter", " remainingdr", "remainDER", "Remainsdr", "REMainsner", "Remainger", " remainingger", "remrainDER", "remainedger", "Remainder", "RemrainDER", "RemainDER", "remainingdr", "remainingger", " remainingDER", "Remainster", "remainedter", "REMainsder", " remainger", "REMainner", "remrainter", "remrainger", "remainter", "remainingder", "remrainder", " remainDER", "remainingDER"]}}
{"code": "inputFile = open('A-small-attempt0.in', 'r')\\n  lines = inputFile.readlines()\\n  inputFile.close()\\n  \\n  outputFile = open('A-small-attempt0.out', 'w')\\n  \\n  numTests = int(lines[0])\\n  \\n  \\n  currLine = 1\\n  for i in range(1, numTests+1):\\n      firstRow = lines[int(lines[currLine])+currLine]\\n      currLine += 5\\n      secondRow = lines[int(lines[currLine])+currLine]\\n      currLine += 5\\n  \\n      firstNums = map(lambda x: int(x), firstRow.split())\\n      secondNums = map(lambda x: int(x), secondRow.split())\\n      \\n      intersect = [v for v in firstNums if v in secondNums]\\n  \\n      outputFile.write('Case #'+str(i)+': ')\\n      if len(intersect) == 1:\\n          outputFile.write(str(intersect[0])+'\\n')\\n      elif len(intersect) == 0:\\n          outputFile.write('Volunteer cheated!\\n')\\n      else:\\n          outputFile.write('Bad magician!\\n')\\n  \\n  outputFile.close()\\n      \\n", "substitutes": {"inputFile": [" inputfile", "openFile", "openfile", "inPath", "initialfile", "Inputfile", "initialPort", "outputFiles", " inputFilename", "initialPath", "infile", "InputFiles", " inputFiles", "outputLine", " inputPort", "inPort", "openLine", "inputFiles", "outputFilename", "inFile", "InputFilename", "outputfile", "inputPath", "InputFile", "inputFilename", "inputLine", "initialFile", "inputPort", "inputfile", " inputPath", "openFilename", " inputLine"], "lines": ["works", "args", "lists", "olds", "values", "xs", "issues", "rs", "photos", "los", "packages", "rings", "strings", "files", "blocks", "ls", "eds", "ds", "ports", "users", "els", "sets", "outs", "forms", "dates", "reads", "orders", "workers", "parts", "styles", "docs", "elines", "boxes", "cells", "pins", "codes", "bs", "sections", "groups", "rates", "qs", "items", "members", "points", "phones", "breaks", "vals", "pps", "ines", "locks", "views", "tests", "pages", "frames", "ses", "rows", "links", "details", "models", "posts", "gs"], "outputFile": ["OutputDirectory", "putLe", "outputChannel", " outputLe", "outFile", "byteFiles", "putPort", "putStream", " outputFine", "PUTDisk", " outputFiles", " outputDirectory", "byteDirectory", "outputFiles", "responsePlace", "PUTStream", "outputStream", "outputPlace", "outChannel", "detailFile", "outputEmail", "responseDirectory", "outputLine", "soundChannel", "outputForce", "responseDisk", "soundFile", " outputDisk", "outputLe", "putFile", "putFiles", " outputPort", "outputFine", " outputLine", "fourFile", "detailForce", "OutputStream", "outputDisk", "detailEmail", "fourBuffer", "byteLe", "putfile", "OutputLine", "PUTFile", "OutputDisk", "responseStream", "fourDirectory", "Outputfile", "outEmail", "outputDirectory", "responseLine", "outBuffer", "OutputFile", "outFine", " outputBuffer", "responseFile", "byteFile", "outForce", "detailChannel", "OutputPort", " outputfile", "fourFine", "outputBuffer", "soundEmail", "PUTPlace", "outDirectory", " outputStream", "soundForce", "outputPort", "outputfile", "putDirectory", " outputPlace"], "numTests": ["numTuakes", "numGrees", "numSches", "numSequests", "numSaves", "numSests", " numNakes", "numGits", "numTrees", "numTaves", "numTuaves", " numTrees", "numNaves", " numNests", "numTuests", " numTits", "numSequets", " numNits", "numNests", "numTits", "numNches", "numNrees", "numTuches", "numSakes", "numSequits", "numNets", " numNrees", "numTakes", "numGests", " numTakes", " numNaves", "numTets", "numTches", "numNits", " numNches", " numTaves", " numTets", "numGets", "numSequrees", " numNets", " numTches", "numNakes"], "currLine": ["currSection", "curbrLine", "CurrLine", " currsPos", "currtLine", "currtCode", " currPos", "curroLine", "CurrbRow", "curattrNode", "curbrline", "currerLin", "currsPos", "currPos", " currbCode", "curpLin", "currbRow", "curiAuto", " currAuto", "currCode", "currdPos", "curiline", " currNode", " curpLine", "CurrbLine", "curattrLin", " curpNode", "currerLine", "currAuto", "currsAuto", " currdRow", " currSection", " currsAuto", "currtRow", "currdRow", " currsRow", "currbline", "currbPos", " currsline", "currerNode", " currLin", "curattrLine", "currsline", "CurrRow", " currdLine", "currsRow", " currbRow", "currerRow", "currdLine", " curpLin", " curpRow", " currCode", "Currbline", "Currline", "curpNode", " currsSection", " currRow", "currLin", "currsLine", " currdline", " currsLine", "currsSection", "curiLine", " currline", "currbLine", "currRow", "currbCode", "curroRow", "currline", "curattrRow", "currdline", "curroSection", "curiRow", "curbrRow", "currbSection", "curroline", "currbAuto", "curpLine", " currbLine", "curpRow", "currdCode", "currNode"], "i": ["j", "p", "k", "li", "e", "it", "ite", "t", "m", " m", "n", "s", "g", " ii", " vi", "f", " j", "ti", " d", "d", " I", "u", " e", "y", "mi", "b", " t", "l", " c", "x", "pi", "oi", "ii", "iu", "ix", " k", "I", "c", " f", " it", "ci"], "firstRow": ["lastWeek", "nextRow", "lastRow", "firstWeek", "startArea", " firstArea", " firstWeek", " firstRes", " firstPost", "startWeek", "startRes", "firstPost", "firstArea", "nextArea", "lastPost", "nextLine", "startPost", "nextRes", "firstLine", "lastLine", "firstRes", "startLine", "startRow", " firstLine"], "secondRow": ["secondaryRow", " secondRes", "secondColumn", "secondaryWeek", "secondLine", "secondaryLine", "SecondLine", "secondaryRes", "secondWeek", "twoLine", "twoWeek", " secondLine", "SecondColumn", " SecondColumn", "SecondBox", "secondRes", "secondBox", "twoRow", " secondColumn", " SecondBox", " SecondLine", " secondBox", " SecondRow", "SecondRow", " secondWeek", "twoRes"], "firstNums": ["firstNumers", "firstNames", "firstnums", " firstNamesums", "firstRenumer", "topRows", "topRumbers", "firstNamesums", " firstNomes", "firstCums", "firstNomes", "firstNumer", " firstNumer", "firstNamesomes", "topNows", "firstSumbers", " firstNames", "firstRums", "firstCumers", " firstNamesames", " firstNamesomes", "firstSums", "firstCows", "firstRenomes", "firstRumbers", " firstNamesumer", "firstnames", "firstNows", "firstRumers", "topNumbers", "firstRenums", "firstNumbers", "firstRows", "firstnomes", "firstSows", "firstNamesames", "firstnumer", "topRumers", "firstRenames", "topNums", "firstSumers", "firstCumbers", "topNumers", "topRums", "firstNamesumer"], "secondNums": ["SecondNumbers", " secondNamesomes", "SecondSumbers", "secondSows", "SecondSums", "secondSums", " secondNamesoms", "secondnums", "SecondNums", "SecondNomes", "secondSumbers", " secondNamesows", "secondTums", "secondNoms", "secondNamesomes", "secondNomes", "secondNamesows", "SecondSoms", " secondNomes", "secondnomes", "secondNumbers", " secondNows", "secondTomes", "secondNamesums", "secondNamesoms", "SecondNoms", "secondnumbers", " secondNamesums", "SecondSomes", "secondnoms", " secondNoms", "secondNows", "secondTows", "secondSoms", "secondSomes", "secondToms"], "intersect": ["intersection", "Intersector", "intsector", "interconnect", "Intersection", "oversector", "Interchange", "Intersect", " intersection", "intsect", "intersract", "intract", "INTERchange", "interdiff", "intersections", "consections", "conract", "intsection", "overract", "interssection", "Intersections", "Interdiff", "interssect", "interract", "oversection", "Interact", "intersector", "INTERsect", " intersections", "Interconnect", "condiff", "consection", "interact", " interconnect", "oversect", " interchange", "conact", " interdiff", "intersact", "consect", "Interract", "interchange", "INTERsection", "INTERconnect"], "v": ["switch", "values", "j", "p", "inv", "k", "fill", "type", "li", "e", "t", "m", "qu", "h", "lv", "n", "g", "s", "vert", "f", "ve", "va", "div", "w", "d", "q", "y", "r", "b", "V", "vi", "env", "var", "l", "value", "val", "gu", "vt", "vv", "x", "tv", "cv", "equ", "vs", "version", "nv", "mut", "vis", "c", "uv", "av", "sv"]}}
{"code": " \\n  INPUT = 'C-small-attempt0.in'\\n  OUTPUT = 'C-small-attempt0.out'\\n  \\n  \\n  def solve(R, C, M):\\n      grid = [[0 for c in range(C)] for r in range(R)]\\n  \\n      def get_cell(cell_r, cell_c):\\n          if not(0 <= cell_r < R):\\n              return None\\n          if not(0 <= cell_c < C):\\n              return None\\n          return grid[cell_r][cell_c]\\n  \\n      def for_each_neighbour(cell_r, cell_c, func):\\n          ret = []\\n          coords = (\\n              (cell_r - 1, cell_c - 1), (cell_r - 1, cell_c), (cell_r - 1, cell_c + 1),\\n              (cell_r, cell_c - 1), (cell_r, cell_c + 1),\\n              (cell_r + 1, cell_c - 1), (cell_r + 1, cell_c), (cell_r + 1, cell_c + 1)\\n          )\\n          for nb in coords:\\n              if get_cell(nb[0], nb[1]) is not None:\\n                  ret.append(func(nb[0], nb[1]))\\n          return ret\\n  \\n      def mark_dirty(cell_r, cell_c):\\n          if grid[cell_r][cell_c] != '*':\\n              grid[cell_r][cell_c] += 1\\n      \\n      def unmark_dirty(cell_r, cell_c):\\n          if grid[cell_r][cell_c] != '*':\\n              grid[cell_r][cell_c] -= 1\\n  \\n      def check_empty_neighbours(cell_r, cell_c):\\n          return (0 in for_each_neighbour(cell_r, cell_c, lambda r, c: get_cell(r, c)))\\n  \\n      def click():\\n          for i, row in enumerate(grid):\\n              for j, cell in enumerate(row):\\n                  if cell != '*':\\n                      if cell == 0 or ((R * C - M) == 1):\\n                          grid[i][j] = 'c'\\n                          return\\n  \\n      def place_mine():\\n          for i, row in enumerate(grid):\\n              for j, cell in enumerate(row):\\n                  if cell == '*':\\n                      continue\\n                  prevstate = grid[i][j]\\n                  grid[i][j] = '*'\\n                  for_each_neighbour(i, j, mark_dirty)\\n                  if not (True in for_each_neighbour(i, j, check_empty_neighbours)):\\n                      grid[i][j] = prevstate\\n                      for_each_neighbour(i, j, unmark_dirty)\\n                  else:\\n                      return True\\n          return False\\n  \\n      for m in range(M):\\n          if not place_mine():\\n              return 'Impossible\\n'\\n  \\n      click()\\n  \\n      ret = ''\\n      for row in grid:\\n          ret = ret + ''.join(map(lambda c: '.' if isinstance(c, int) else c, row)) + '\\n'\\n  \\n      return ret\\n  \\n  \\n  if __name__ == '__main__':\\n      inp = open(INPUT)\\n      out = open(OUTPUT, 'w')\\n      \\n      T = int(inp.readline())\\n  \\n      for case in range(T):\\n          sol = solve(*map(int, inp.readline().split()))\\n          out.write('Case #%i:\\n%s' % (case + 1, sol))\\n", "substitutes": {"INPUT": ["InPUT", "InFIX", "INFORMATION", "INFIX", "CONCEPT", "InFORMATION", "INCEPT", "ANFIX", "InCEPT", "ANFORMATION", "CONFORMATION", "CONFIX", "CONPUT", "ANCEPT", "ANPUT"], "OUTPUT": ["OUSPODE", "OUSPUT", "OUDPODE", " OUTTPPUT", "OUDPUTE", "OUSPUTE", "OUTPODE", "OUPUTUT", "OUTPUTE", "OUPUTUTE", " OUTPUTUT", " OUTPUTPUT", " OUTTPUT", "OUDPPUT", "OUSPPUT", "OUTPPUT", " OUTPUTUTE", " OUTPUTODE", " OUTTPODE", "OUDPUT", "OUPUTPUT", " OUTTPUTE", "OUPUTODE"], "R": ["D", "G", "X", "RA", "H", "L", "U", "CR", "Q", "A", "E", "DR", "B", "RG", "SR", "Res", "RF", "AR", "HR", "F", "V", "RO", "RS", "N", "NR", "RE", "TR", "GR", "RR", "Rs", "I", "RM", "P", "RT", "RI", "S", "MR"], "C": ["Co", "D", "G", "COR", "X", "H", "L", "U", "CR", "E", "A", "CM", "Q", "Count", "B", "CS", "CV", "CE", "CC", "CI", "WC", "F", "CON", "V", "CH", "EC", "Y", "CNN", "N", "CO", "CT", "CP", "K", "I", "P", "W", "CL", "CCC", "MC", "CU", "S", "Cs"], "M": ["D", "G", "O", "X", "cm", "H", "TM", "L", "E", "Q", "A", "CM", "NM", "B", "F", "J", "V", "Y", "LM", "N", "K", "I", "RM", "P", "W", "MC", "S", "MR"], "grid": ["raid", "clear", "domain", "fine", "window", "node", "wrapper", "jac", "ad", "line", "cache", "set", "module", "hold", "filled", "age", "box", "dq", "ssl", "gc", "lat", "hash", "stock", "gb", "reg", "block", "mg", "disk", "manager", "tile", "remote", "image", "chain", "managed", "lay", "pool", "sky", "gr", "device", "free", "square", "form", "graph", "cart", "stack", "g", "group", "work", "cells", "table", "query", "server", "net", "fixed", "map", "lag", "data", "queue", "wd", "res", "range", "fill", "storage", "Grid", "client", "site", "addr", "rid", "mat", "gm", "wire", "db", "adj", "order", "layer", "rows", "list"], "c": ["p", "rc", "re", "col", "cp", "cm", "t", "cur", "lc", "ct", "h", "cf", "n", "xc", "con", "g", "f", "ar", "cos", "pc", "cu", "cb", "u", "cs", "y", "ec", "cin", "b", "ac", "cont", "cl", "unc", "l", "cr", "co", "cc", "ch", "cd", "ce", "v", "tc", "com", "ci"], "r": ["res", "br", "p", "rc", "ra", "er", "re", "rs", "rx", "t", "h", "rid", "ro", "rb", "n", "g", "ur", "f", "ar", "ru", "w", "pr", "y", "b", "l", "rr", "cr", "hr", "rar", "x", "sr", "dr", "gr", "rm", "mr", "ry", "rd", "ir", "rt", "rh", "right"], "cell_r": ["cell___rs", "cellablert", "cell2ar", "reportingreg", "cell5r", "component10lr", " cell_rr", "cell_rd", "cellingrar", "cel__er", "cell10lr", "cellpyright", "cell9r", "process_r", "areaingrar", "cellpyrb", "cell_rg", "nel_r", "component_rg", "process_rr", "cellptrt", "pixel_rt", "cel_o", "cell_right", "cell8br", "cell___rt", "shell5l", "cell10ar", "cell_lr", "process7rr", "cell_dr", "tab_br", "cell9ir", "cellpyreg", "cell10rg", "areaingr", "nel_l", "node_ar", "cell5d", "cel_vr", "cellpylr", "cand_rc", "cellingrb", "process_ir", "cell_rc", "shell5r", "cell_rr", "cel_r", "cell_ar", "tab_c", "pixel_res", "module_r", "cell_d", "cellingrc", "pixel_rd", " cell_rc", "cell8adr", "conn_ur", "process8rb", "area_nr", "cell7rr", "pixel_or", "areaingir", "conn_r", "report_lr", "cell_b", "area_ir", "entry_r", "cell__vr", "nel___l", "cell10ra", "cellableor", "cellptrect", "cand_c", "cell_ro", "cell_l", "shell_d", "cel_rs", "cell2l", "cell8rar", "entry_l", "cellpyrar", "celldbr", "process8r", "shell5d", "cellingr", "cellablerd", "nel_rc", "cell2ro", "nel___r", "report_r", "cell___l", "cell7rect", "cellpyc", "cell_o", "moduleingrc", "cell2rs", "shell_rc", "cell8res", "reportingrt", "pixel_adr", "process_rect", "cell2o", "cell2rc", "process_rt", "cellingnr", "celldblr", "component_r", "cell_or", "cand_d", "cel__r", "cellpyir", "cell_reg", "entry_c", "cell_re", "nel___rc", "cell64r", "node_right", "nel___rs", "process_rb", "cellingrt", "cellabler", "process8rar", "cell_ra", "cell_rs", "cell__dr", "cel_rt", "shell5rc", "cellpyar", "conn_rel", "cell_br", "entry_ur", "cell64ir", "cell10rb", "tab_b", "module_rb", "cell9re", "cell10r", "entry_ir", "entry_lr", "cell8rb", "cellpyr", "cell___rb", "cell64c", "cell64nr", "pixel_br", "process7rect", "cel_er", "module_rc", "cell7rt", "area_r", "cellingvr", "cel_ro", "cell64rr", "pixel_r", "cell_vr", "cell10right", "cel_ar", "cell_rect", "areaingnr", "cell___rc", "node_rb", "moduleingr", "cel_dr", "node_r", "component10r", "process_rar", "cell_rel", "cand_r", "cell2r", "cell___vr", "cell__rc", "process8ir", "cell_rb", "cell___r", "report_rt", "report_reg", "cell8r", "cell_nr", "cell7r", "entry_re", "area_rar", "cel__rs", "cell_rt", "cell__rb", "cell5l", "cel__dr", "process7rt", "cell8ir", "cellingir", "tab_r", "process7r", "cell__er", "cell_er", "cellpyl", "cell_adr", "cell_ir", "cell9ur", "cell5rc", "cell__r", "moduleingvr", "cell_ur", "celldbrg", "component_lr", "cellinglr", "cell_res", "cel_rb", "reportingr", "cell__rs", "shell_l", "conn_br", "nel_rs", "moduleingrb", "cellpyrt", "cellptrr", "cell_rar", "component10ra", "cell64rc", "component_ra", "cell64rar", "shell_r", "reportinglr", "celldbra", "module_vr", "cellingreg", "cellptr", "component10rg"], "cell_c": ["Cell_cu", "cell64cu", "cell9c", "area_ec", "cell_p", "cel_ic", "cell_cd", "cell8cf", "component_c", "cel_p", "ell_ac", "cell64ce", " cell_p", "area09ec", "cell23cont", "cell2c", "area09c", "cell64cr", "ell_rc", "cel_cache", "cel1c", "cel1ic", "cell2p", "cellablec", "cell64ac", " cell2cm", "char_rc", "cell_rc", "cell_cont", "cell_ec", " cell2C", "cell_ct", "cell1cache", "cell09cm", "char0c", "char5con", " cell_cm", "tile_c", "cell_ic", " cell2ec", "char_c", "cell2C", "cell_e", "cell_cn", "cell_mc", " cell_ce", "cell0rc", "cell1ic", "cell_b", "cell9co", "char_e", "cell_ci", "area_c", "cell_cu", "cell2cm", "component_cu", "cell23cc", "cellYc", "cell0lc", "cell64ec", "cell_l", "char5h", "area09cont", "cellJcd", "cellYname", "cell2l", "cell5cc", "char_cc", "cell8tc", "Cell_c", "cell1lc", " cell_col", "command_lc", "char5c", "char0rc", "node64ac", "char0lc", "cell2col", "cellYcs", "cell5c", " cell_ci", "ell_cc", "cel_ct", "ell_cs", "cell5ct", "component_cm", "cell9cc", " cell_ec", "command_cc", "shell_rc", "cel_rc", "tile_tc", "cell_cm", " cell_cn", "cell_cr", "ell_cu", "command9lc", "cell_cs", "cell5cache", "area09cc", "cellaxyci", " cell2l", " cell2p", "cell_con", "cell09C", "cell1rc", "cell_cache", "cell_cc", "ell_mc", "cell0c", "command_co", "cell_lc", " cell_l", "cellJcf", "component64cu", "cell0p", "cel1cache", "cel_lc", "cell09cc", "ell_co", "cell09l", "cell_ce", "node_co", "cell_h", "node_cr", "ell_c", "cell_col", "cell09c", "cell_f", "cell64c", "cell64lc", "cell2ec", " cell_f", "char_con", "cell1ct", "node_c", "node_ac", "cell5p", "char5cc", "cellYac", "cellaxyf", "cell_C", "ell_ct", " cell_C", "cellJc", "cell_co", "Cell_lc", "cellablecn", "cell0ec", "node64co", "cell_cf", "area_cc", "cell09ec", "cell1c", "cell5con", "component_ce", "cel_C", "node64cr", " cell2c", "tile_cd", "cellJtc", "cell8c", "cell0col", "cell1tc", "shell_cf", "tile_cf", "area_cont", "cell9col", "cell23c", "node64c", "cell9p", "cell23ec", "cel_col", "cell64cc", "Cell_r", "cellablece", "cel_b", "cellaxyc", "command9c", "cell_name", "shell_lc", "cell64cf", "command9co", "cell9lc", "cel_tc", "char_lc", "component64c", "cell9ec", "cellablef", " cell2col", "shell_c", "command9cc", "cell_ac", "ell_name", "cell5cu", "char_h", "char0e", "cel_c", "cell5h", "cell64rc", "cell64co", "command_c", "cell09cont", "cell64cont", "cell_tc", "cell0e", "component64cm", "cel1rc", "cell8cd", "component64ce", "cellaxyp", "cell64cm"], "func": ["function", "apply", "str", "cmd", "df", "ctx", "package", "mac", "agg", "util", "cf", "nc", "con", "f", "closure", "kw", "proc", "ws", "cb", "cs", "fun", "conn", "cin", "ac", "sec", "unc", "val", "cast", "cc", "ln", "aux", "obj", "fac", "conv", "fc", "callback", "sys", "fs", "fn"], "ret": ["res", "ft", "args", "br", "rem", "re", "it", "reg", "jp", "quad", "t", "agg", "alt", " Ret", "tn", "reset", "rg", "union", "nil", "rets", "result", "tr", "full", "utils", "rect", "ary", "mt", "val", "nl", "ext", "usr", "nt", "net", "back", "list", "mont", "elt", "ter", "RET", "print", "bar", "ts", "Ret", "gt", "rt", "az", "arr"], "coords": ["Coord", "Coords", "conords", "oorders", " coord", " coels", "oats", "conels", "coord", "coinates", "Coorders", "conord", "Coinates", " coats", " coinates", "coorders", "Coels", " coorders", "oinates", "coats", "Coats", "oords", "coels", "conorders"], "nb": ["ns", "abb", "ib", "adr", "binary", "gb", "img", "note", "sb", "ob", "nr", "tn", "bb", "rb", "node", "n", "nc", "ne", "mb", "ny", "name", "cb", "nz", "pb", "conn", "db", "b", "nob", "nu", "lb", "bn", "nit", "dn", "np", "erb", "bs", "buff", "ln", "nt", "zb", " neb", "NB", "batch", "nm", "obj", "nv", "xy", "resp", "wb", "bj", "kb", "nn", "bd", "nd"], "i": ["ic", "p", "ami", "li", "it", "iri", "ri", "ui", "phi", "int", "ti", "ini", "bi", "si", "xi", "y", "mi", "ip", "l", "x", "pi", "ii", "ij", "ix", "I", "zi", "a", "v", "ir", "ci"], "row": ["range", "res", "rc", "form", "col", "re", "rec", "block", "array", "ox", "ro", "node", "group", "rl", "rown", "rowd", "item", "tr", "field", "w", "sc", "line", "entry", "rect", "rr", "Row", "ow", "box", "new", "ows", "roll", "rows", "ry", "edge", "sel", "pair"], "j": ["ji", "br", "p", "jj", "k", "er", "col", "it", "jp", "t", "o", "z", "n", "g", "ja", "tr", "uj", "q", "y", "J", "kj", "b", "dj", "l", "x", "ij", "jc", "v", "aj", "ind"], "cell": ["function", "col", "cy", "column", "n", "node", "con", "tile", "ck", "char", "field", "cod", "cb", "cin", "entry", "b", "ac", "cont", "cells", "Cell", "unc", "cel", "co", "call", "cc", "child", "ell", "obj", "slice", "pixel", "ice", "fc", "ce", "ion", "nel", "edge", "ind", "sel"]}}
{"code": " \\n  INPUT = 'A-small-attempt0.in'\\n  OUTPUT = 'A-small-attempt0.out'\\n  \\n  \\n  def solve(answer1, arr1, answer2, arr2):\\n      ret = None\\n  \\n      for card in arr1[answer1 - 1]:\\n          if card in arr2[answer2 - 1]:\\n              if ret is not None:\\n                  return 'Bad magician!'\\n              else:\\n                  ret = card\\n      if ret is None:\\n          return 'Volunteer cheated!'\\n      return ret\\n  \\n  if __name__ == '__main__':\\n      inp = open(INPUT)\\n      out = open(OUTPUT, 'w')\\n      \\n      T = int(inp.readline())\\n  \\n      def read_answer_and_arr():\\n          answer = int(inp.readline())\\n          arr = []\\n          for i in range(4):\\n              arr.append( map(int, inp.readline().split()) )\\n          return answer, arr\\n  \\n      for case in range(T):\\n          answer1, arr1 = read_answer_and_arr()\\n          answer2, arr2 = read_answer_and_arr()\\n  \\n          out.write('Case #%i: %s\\n' % \\\\n                          (case + 1, solve(answer1, arr1, answer2, arr2)))\\n", "substitutes": {"INPUT": ["ININ", "inFIX", "INInput", "INFIX", "InInput", "INOUT", "InIN", "inJECT", "inOUT", "inInput", "inIN", "inPUT", " INFILE", "SOURCEPUT", "inFILE", " INOUT", "InFIX", "INJECT", "SOURCEJECT", "SOURCEFIX", "InPUT", "InFILE", "SOURCEInput", "INFILE", " ININ", "InJECT", "InOUT"], "OUTPUT": ["OUSPut", "OUSPUT", "EXTPURE", "OUCPut", "OUSPURE", "OUTPET", "OUSPUTE", "INTPut", "EXCPUT", "OUCPUTE", "OUDPET", "INTPPUT", "EXCPURE", "OUMPPUT", "OUDPut", "OUCPURE", "EXTPUT", "OUTPUTE", "OUMPut", "INLPPUT", "EXTPut", "EXCPUTE", "EXCPut", "OULPET", "OUTPut", "OUPPut", "INLPET", "OUDPPUT", "OUPPUTE", "OULPUT", "OUMPET", "OUMPUT", "OUTPPUT", "INLPut", "OUPPUT", "OULPut", "EXTPUTE", "INTPET", "OULPPUT", "OUTPURE", "OUCPUT", "OUDPUT", "INTPUT", "INLPUT", "OUPPURE"], "answer1": ["Answer0", "AnswerOnce", "caseOnce", "question1", " answerOne", "Answer9", "question81", "answer51", "answer91", "answer81", "case2", " answer3", "vote91", "response51", "eni91", "voteOne", "answerOnce", "answer0", "Answer3", "question51", " answer51", " answer0", "response91", "Answer2", "answerOne", "case0", " answer9", "response3", "response81", "response2", "Answer1", " answer91", "order51", "question91", "order1", "response9", "answer3", "eniOne", "response1", "vote51", "vote1", "order81", "answer9", " answerOnce", "eni51", "eni1", "order91", "case1"], "arr1": ["str2", "arb1", " arr01", "dict51", "alphFirst", "coll01", "arr001", "dict30", "array0", "img1", " arr51", "arb30", "arb01", "str0", "arrOnce", "coll001", " arr0", "arrayFirst", "alph1", "rdFirst", "arr30", "coll1", "rd1", "arb51", " arrOnce", "arrFirst", "img001", "rd01", "arrayOnce", " arr3", "arr01", "imgFirst", "dict1", "rdOnce", "img01", "arr51", "str1", "dict01", "collFirst", "array1", "alph01", "alph001", "str3", "arr0", " arr30", "arr3", "array01", " arrFirst", "array2", "array3"], "answer2": ["version5", "voteSecond", "Answer0", "vote5", "answerTwo", "example0", "question1", "questionTwo", "votetwo", "orderTwo", "Answertwo", "question2", "ordertwo", "vote2", "equSecond", "answer0", "version2", "vert2", "area1", "areatwo", " answertwo", " answer0", "versionSecond", "answertwo", "Answer1", "order2", "versiontwo", "answer5", "equtwo", "vertTwo", "exampletwo", "equ2", "equ5", " answerTwo", "example1", "area2", "answerSecond", "areaTwo", "questiontwo", "verttwo", "example2", "Answer2"], "arr2": ["errtwo", "coll0", "err1", " arr4", "objtwo", "arr02", "array0", "expr2", " arrtwo", "obj0", " arr0", "objTwo", "arr4", "elttwo", "arg2", "array4", "arg02", "elt1", "argtwo", "exprTwo", "coll3", "coll2", "arrayB", "expr02", "obj02", "obj3", "obj2", "collB", "elt2", "arrtwo", "obj1", "arrTwo", "obj4", "array1", "objB", "arr0", "arrB", "exprtwo", "argTwo", "arr3", "err2", "array2", "array3"], "ret": ["res", "ft", "ard", "clear", "rem", "match", "default", "ref", "str", "er", "re", "err", "jp", "t", "fail", "crit", "alt", "compl", "txt", "pret", "what", "url", "reset", "reply", "mat", "quest", "true", "nil", "xt", "rets", "arg", "result", "pet", "test", "cont", "mt", "val", "red", "rep", "value", "vt", "rar", "nt", "read", "back", "deep", "elt", "requ", "rat", "ver", "RET", "ter", "print", "get", "mem", "terror", "ry", "Ret", "gt", "pt", "rt", "details", "Return", "mel"], "card": ["ard", "clear", "valid", "default", "aqu", "check", "camp", "nah", "e", "t", "crit", "cap", "cards", "compl", "no", "photo", "capt", "what", "cf", "record", "z", "g", "n", "f", " Card", "can", "cop", "char", "field", "w", "Card", "arc", "d", "cue", "copy", "man", "cert", "cont", "var", "who", " cards", "car", "hand", "msg", "center", "void", "guard", "par", "c", "play", "cell", "comment", "php", "cas"], "inp": ["Inps", "inpp", "Inp", "Insp", "cinpt", "innpp", "innl", " insp", " inpt", "ginpp", "INpt", "insp", "innpt", "innsp", "Inpt", "INh", "inpt", "cinsp", "inl", "INp", " inps", "innp", "ginpt", "ginh", "cinp", "inh", "innps", "Inh", "INpp", " inl", "Inpp", "inps", " inpp", "ginp", "Inl"], "out": ["res", "p", "os", "oss", "Out", "end", "at", "t", "o", "io", "outer", "ou", "max", "n", "OU", "up", "w", "outs", "write", "log", "over", "co", "nt", "ot", "net", "to", "output", "obj", "gen", "OUT", "file", "ex", "v", "we", "gt"], "T": ["Time", "D", "O", "TT", "TN", "t", "L", "TY", "A", "Q", "E", "R", "B", "TC", "TS", "TA", "PT", "TIT", "F", "Type", "V", "M", "Case", "NT", "Y", "WT", "N", "GT", "TR", "TB", "C", "TION", "K", "I", "P", "S"], "answer": ["urn", "rage", "next", "swers", "br", "rue", "su", "e", "err", "area", "array", "aq", "about", "address", "record", "vert", "name", "int", "result", "question", "index", "vote", "archive", "q", " unanswered", "erv", "wer", "value", "val", "answered", "query", "remember", "Answer", "equ", "ever", "ver", "offer", "v", "ave", "response", "test", "say"], "arr": ["args", "br", "bl", "fr", "str", "buf", "dat", "err", "rs", "img", "iq", "agg", "ress", "array", "repl", "rb", "ar", "aa", "unch", " narr", "arg", "aaa", "ply", "arc", "my", "r", "pl", "ev", "rr", "np", "rep", "dict", "adj", "Array", "attr", "ij", "vec", "alph", "ray", "list", "batch", "air", "dr", "gr", "map", "resp", "abc", "enc", "pair", "ab"], "i": ["j", "p", "ic", "k", "li", "e", "it", "t", "id", "n", "s", "ti", "q", "im", "y", "r", "b", "ip", "l", "x", "ix", "I", "c", "ind"], "case": ["trial", "switch", "se", "one", "cho", "ide", "su", "lic", "ite", "client", "code", "pe", "id", "ace", " CASE", "name", "chain", "cation", "section", "use", "set", "CI", "catch", "me", "rial", "bite", "Case", "tri", "instance", "come", "cases", "ice", "ASE", "ase", "I", "ca", "ce", "ie", "tc", "context", "test", "choice", "ci", "cas"]}}
{"code": " \\n  \\n  \\n  def check(R, C, M, _board):\\n      board = [line[:] for line in _board]\\n  \\n      pos = [(0, 0)]\\n      while pos:\\n          row, col = pos.pop()\\n          neighbor = []\\n          for r in (-1, 0, 1):\\n              r += row\\n              for c in (-1, 0, 1):\\n                  c += col\\n                  if r >= 0 and r < R and c >= 0 and c < C:\\n                      neighbor.append((r, c))\\n          count = len([1 for r, c in neighbor if board[r][c] == '*'])\\n          board[row][col] = str(count)\\n          if count == 0:\\n              for r, c in neighbor:\\n                  if board[r][c] == '.':\\n                      pos.append((r, c))\\n  \\n      flat = ''.join(''.join(line) for line in board)\\n      result = not flat.count('.')\\n      if not result and False: # for DEBUG\\n          print '-' * 20\\n          print R, C, M\\n          print '\\n'.join(''.join(line) for line in _board)\\n          print '-' * 20\\n      assert flat.count('*') == M\\n      return result\\n  \\n  \\n  def solve(R, C, M):\\n      board = [['.'] * C for row in range(R)]\\n      board[0][0] = 'c'\\n      row = R\\n      col = C\\n      mine = M\\n  \\n      while mine:\\n          if 0 < row <= col and mine >= row:\\n              for r in range(row):\\n                  board[row - r - 1][col - 1] = '*'\\n              mine -= row\\n              col -= 1\\n          elif 0 < col <= row and mine >= col:\\n              for c in range(col):\\n                  board[row - 1][col - c - 1] = '*'\\n              mine -= col\\n              row -= 1\\n          else:\\n              break\\n  \\n      if mine:\\n          while mine and row > 2:\\n              for r in range(min(mine, row - 2)):\\n                  board[row - r - 1][col - 1] = '*'\\n                  mine -= 1\\n              col -= 1\\n          while mine and col > 2:\\n              for c in range(min(mine, col - 2)):\\n                  board[row - 1][col - c - 1] = '*'\\n                  mine -= 1\\n              row -= 1\\n  \\n      if mine:\\n          if mine:\\n              board[1][1] = '*'\\n              mine -= 1\\n          if mine:\\n              board[1][0] = '*'\\n              mine -= 1\\n          if mine:\\n              board[0][1] = '*'\\n              mine -= 1\\n  \\n      assert mine == 0\\n      return '\\n'.join(''.join(line) for line in board) if check(R, C, M, board) else 'Impossible'\\n  \\n  \\n  def main(IN, OUT):\\n      T = int(IN.readline())\\n      for index in range(T):\\n          R, C, M = map(int, IN.readline().split())\\n          OUT.write('Case #%d:\\n%s\\n' % (index + 1, solve(R, C, M)))\\n  \\n  \\n  def makesample(maxSize=5, T=230):\\n      print T\\n      for index in range(T):\\n          R = random.randint(1, maxSize)\\n          C = random.randint(1, maxSize)\\n          print R, C, random.randint(0, R * C - 1)\\n  \\n  \\n  def makesample():\\n      pattern = []\\n      for R in range(1, 5+1):\\n          for C in range(1, 5+1):\\n              for M in range(R * C):\\n                  pattern.append((R, C, M))\\n      print len(pattern)\\n      for R, C, M in pattern:\\n          print R, C, M\\n  \\n  \\n  if __name__ == '__main__':\\n      if '-makesample' in sys.argv[1:]:\\n          makesample()\\n      else:\\n          main(sys.stdin, sys.stdout)\\n  \\n", "substitutes": {"R": ["D", "G", "O", "X", "RA", "H", "L", "U", "A", "E", "CR", "Q", "B", "RG", "F", "V", "RO", "RS", "Y", "N", "RE", "TR", "GR", "RR", "I", "P", "RT", "W", "T", "S", "MR"], "C": ["D", "G", "H", "L", "U", "E", "CR", "A", "CM", "CS", "B", "CE", "CC", "CI", "WC", "F", "V", "CH", "Y", "N", "CT", "CP", "DC", "K", "I", "YC", "P", "CB", "MC", "CU", "T", "S", "Cs"], "M": ["D", "G", "O", "p", "X", "H", "L", "m", "U", "A", "Q", "E", "n", "Mon", "B", "Mr", "F", "V", "Z", "N", "I", "RM", "P", "OR", "W", "T", "S"], "_board": ["_stream", "_deck", "pline", "\u00a0deck", "_boards", "_line", "_base", "pboard", " _frame", " _boards", "pstream", " _base", " _deck", "\u00a0frame", "pboards", " _stream", "\u00a0base", " _line", "_frame"], "board": ["range", "empty", "flo", "bit", "form", "bo", "frame", "base", "bus", "deck", "block", "ro", "layout", "node", "style", "control", "lo", "database", "league", "loop", "full", "boat", "lay", "rank", "rot", "user", "view", "bang", "player", "bank", "buffer", "channel", "plate", "table", "pool", "co", "stream", "body", "back", "clean", "boards", "position", "ack", "box", "runner", "ward", "out", "Board", "bar", "black", "bird", "bro", "bug", "play", "lock", "bot", "square", "list"], "line": ["range", "se", "Line", "day", "ide", "word", "frame", "load", "end", "store", "note", "lin", "lock", "m", "LINE", "block", "online", "kin", "code", "node", "lo", "lined", "rule", "chain", "name", "page", "ner", "move", "change", "verse", "lay", "ine", "left", "live", "lane", "email", "write", "link", "player", "point", "l", "text", "cycle", "draw", "ln", "liner", "iter", "out", "inline", "lines", "cell", "model", "play", "list"], "pos": ["po", "range", "res", "next", "p", "tmp", "os", "trans", "op", "pose", "bo", "bit", "ps", "at", "cond", "block", "off", "path", "conf", "all", "Pos", "up", "cos", "pro", "present", "spec", "ports", "POS", "pr", "local", "rot", "pl", "point", "yes", "port", "rel", "pid", "pack", "pi", "nt", "body", "loc", "list", "points", "position", "ack", "obj", "abs", "gen", "resp", "out", "pt", "size", "neg"], "row": ["range", "res", "br", "ra", "rc", "fr", "re", "rs", "ob", "ox", "rid", "ro", "ri", "rown", "ru", "tr", "index", "rank", "rot", "rect", "val", "Row", "co", "sur", "ow", "room", "month", "x", "order", "th", "ver", "rod", "ows", "roll", "dr", "vr", "rows", "ry", "arrow", "cell", "rt", "rd", "our", "pair"], "col": ["cul", "cmd", "cp", "COL", "foot", "cy", "cut", "column", "fl", "coll", "client", "ct", "key", "fn", "path", "con", "icol", "Col", "cos", "pc", "char", "cat", "y", "rot", "ol", "cs", "character", "prop", "rol", "scroll", "cor", "point", "val", "port", "l", "cl", "co", "loc", "ch", "th", "roll", "fc", "cell", "pt", "cal", "num"], "neighbor": ["noteigbor", "neighne", "neIGHbit", "noigler", "neigerbor", "neigne", "neIGHbor", " neldbour", "neigbour", "noteighbor", "noteighne", "neagleor", "neigbors", "neoothbor", "noteigbour", "neigerne", " neighbour", "noigbour", " neighor", "neighor", "neaglebors", "neigler", " neldbor", "neldor", "neaglebor", "neearbors", "neldbour", "nelderler", "nelderbors", "neearbor", "neighler", "noteighbour", "neighbors", "neighbour", "neighbit", "noteigne", "noteigbit", "noighler", "noigbor", "noigbors", "noighbors", "noighbour", "neearler", " neighbors", "neldbor", "neaglebour", "neIGHbour", "neigerbit", "neIGHne", "noighbor", "neldbors", " neldbors", "noteighbit", "nelderbour", "nelderbor", "neigor", " neldor", "neoothbors", "neigerbour", "neearbour", "neoothbour", "neoothor", "neigbit", "neigbor"], "r": ["res", "range", "br", "p", "j", "race", "rc", "ra", "fr", "er", "re", "e", "adr", "rs", "reg", "err", "t", "o", "lr", "m", "yr", "h", "ro", "rid", "run", "rg", "rb", "n", "ur", "g", "ren", "rate", "rl", "ar", "art", "ru", "tr", "d", "pr", "w", "q", "u", "i", "rect", "kr", "b", "l", "rr", "hr", "rel", "rar", "cr", "x", "usr", "sr", "attr", "dr", "rm", "ring", "mr", "vr", "v", "rd", "rt", "ir", "rh"], "c": ["dc", "p", "ic", "rc", "k", "cp", "cm", "t", "o", "m", "cur", "lc", "ct", "bc", "cf", "n", "g", "xc", "z", "f", "con", "anc", "cos", "chain", "pc", "cat", "cu", "cod", "arc", "cn", "d", "sc", "u", "i", "cs", "ec", "vc", "cin", "uc", "cache", "b", "ac", "cor", "cl", "unc", "l", "cr", "co", "x", "mc", "cc", "ch", "ca", "fc", "cd", "ce", "gc", "v", "tc", "ach", "cell", "com", "ci"], "count": ["select", "delete", "total", "match", "shift", "check", "flag", "unique", "display", "depth", "common", "max", "ct", "code", "n", "conf", "Count", "z", "collect", "close", "last", "only", "index", "change", "counter", "cache", "conn", "nb", "stat", "found", "ount", "cont", "ctr", "rand", "amount", "number", "call", "replace", "nt", "score", "deep", "list", "find", "loc", "ch", "len", "cloud", "connect", "cd", "length", "more", "get", "first", "sum", "search", "test", "ind", "size", "mount", "num"], "flat": ["bit", "functional", "at", "ful", "fl", "layout", "plant", "dot", "vert", "final", "att", "frac", "f", "cat", "plan", "full", "straight", "boat", "atten", "pal", "plain", "ran", "animate", "plane", "unit", "who", "float", "pack", "wide", "clean", "complex", "format", "fast", "feed", "pure", "out", "hat", "mate", "oat", "short", "lat", "sat", "flush"], "result": ["res", "match", "total", "force", "correct", "mask", "flag", "product", "degree", "error", "relation", "success", "ure", "zero", "run", "final", "goal", "case", "process", "set", "feature", "work", "successful", "Result", "number", "mark", "currency", "make", "know", "contact", "date", "debug", "fac", "void", "mult", "trace", "diff", "false", "mate", "power", "test", "comment", "status"]}}
{"code": " \\n  \\n  \\n  def solve(arrange):\\n      board, row = arrange[0]\\n      before = board[row - 1]\\n      board, row = arrange[1]\\n      after = board[row - 1]\\n      dup = set(before) & set(after)\\n      if len(dup) == 1:\\n          return dup.pop()\\n      elif len(dup) >= 2:\\n          return 'Bad magician!'\\n      else:\\n          return 'Volunteer cheated!'\\n  \\n  \\n  def main(IN, OUT):\\n      T = int(IN.readline())\\n      for index in range(T):\\n          arrange = []\\n          for n in range(2):\\n              row = int(IN.readline())\\n              board = []\\n              for line in range(4):\\n                  board.append(map(int, IN.readline().split()))\\n              arrange.append((board, row))\\n          OUT.write('Case #%d: %s\\n' % (index + 1, solve(arrange)))\\n  \\n  \\n  def makesample(T=100):\\n      print T\\n      for index in range(T):\\n          for n in range(2):\\n              print random.randint(1, 4)\\n              board = list(range(1, 16+1))\\n              random.shuffle(board)\\n              while board:\\n                  print ' '.join(map(str, board[:4]))\\n                  board = board[4:]\\n  \\n  \\n  if __name__ == '__main__':\\n      if '-makesample' in sys.argv[1:]:\\n          makesample()\\n      else:\\n          main(sys.stdin, sys.stdout)\\n  \\n", "substitutes": {"arrange": ["grace", "drange", "arranges", "strange", "strang", "devicate", "strrange", "devrange", "arrace", "prace", "prang", "array", "unchange", "addranne", "errang", "errange", " arranne", "erranges", "devanne", "errrange", "pray", "prrange", "sprang", "stranges", "drrange", "sprange", "addrace", "devange", "strrang", "grange", "sprrange", "arranne", "arrrange", " arricate", "stranne", " arrrange", " rearrrage", "dranges", "strrage", " rearrrang", " arrrang", "unchrange", "arrrage", "addrrange", "stricate", "arricate", "arang", "arange", "prange", "aray", "granne", "grrange", "addrange", " rearrrange", "unchace", "pranges", "arrrang", "arrang", " rearrange", "unchanges", "spray", "strace", " arrrage", "drang"], "board": ["col", "foot", "ud", "deck", "ob", "old", "fine", "window", "down", "ner", "full", "set", "hold", "sequence", "body", "review", "batch", "clean", "door", "box", "Board", "floor", "cell", "inner", "ide", "bo", "beat", "block", "ro", "control", "chain", "loop", "rank", "rot", "bang", "bank", "player", "setup", "pool", "back", "comb", "out", "bro", "BO", "flo", "form", "worker", "butt", "video", "oard", "public", "layout", "ball", "zero", "lib", "vote", "random", "poll", "table", "co", "card", "runner", "ward", "bar", "data", "controller", "play", "test", "range", "ard", "bit", "well", "frame", "won", "panel", "lo", "present", "uno", "builder", "da", "buffer", "plate", "room", "stick", "boards", "ack", "boarding", "roll", "boot", "bird", "tub", "ta", "bug", "lock", "bot", "list"], "row": ["range", "post", "next", "rc", "form", "bo", "word", "frame", "col", "foot", "fail", "column", "block", "ob", "ox", "ro", "run", "zero", "record", "node", "term", "week", "rown", "field", "tr", "user", "rank", "set", "rot", "head", "entry", "r", "rect", "rew", "scroll", "success", "Row", "port", "server", "room", "ow", "number", "x", "order", "co", "to", "batch", "loc", "back", "box", "ver", "iter", "ows", "roll", "offset", "out", "bar", "round", "arrow", "rows", "ry", "pos", "cell", "right", "our", "num"], "before": ["initial", "start", "prefix", "lower", "time", "old", "pre", "reset", "self", "zero", "Before", "top", "name", "last", "then", "both", "left", "set", "head", "init", "fore", "when", "above", "setup", "below", "back", "len", "first", "short", "front", "list"], "after": ["post", "next", "update", "end", "pre", "off", "After", "append", "dot", "vert", "later", "last", "then", "future", "tr", "full", "set", "writer", "on", "when", "follow", "fter", "over", "ext", "tail", "draw", "order", "ot", "format", "pattern", "out", "aft", "right", "step"], "dup": ["slepa", "deping", "dedpa", " dupa", "Dupes", "duP", "slep", "dedps", "Dup", "tuap", "tuP", "dupe", "depa", "stroping", "dupes", "cepes", " duap", "stropa", " duP", "duping", "strope", "cep", "strop", "aupes", "dedp", "cepa", "DuP", "Dupa", "Duap", "dedP", "dups", "aups", "dep", "Dups", "sleP", "dupa", "Duping", "tup", "sleps", "duap", "ceps", "tupa", "aupa", "depe", "Dupe", "aup"], "IN": ["Out", "FIL", "IT", "GER", "SOURCE", "L", "PIN", "IL", "MN", "UL", "OM", "OU", "STDOUT", "INAL", "IC", "NL", "PUT", "URL", "LIN", "ALL", "INS", "RO", "PL", "DIR", "IND", "INT", "In", "RE", "MIT", "AN", "ML", "Input", "RAW", "out", "BL", "FILE", "CL", "AL", "EN", "ILL", "INE", "GEN", "inner", "ER", "READ"], "OUT": ["NULL", "O", "LIST", "TEXT", "Out", "TN", "IT", "SOURCE", "NER", "outer", "IL", "OS", "Writer", "UL", "TH", "OU", "STDOUT", "AT", "TABLE", "INAL", "LOG", "PUT", "OT", "UT", "PATH", "USER", "BUS", "DIR", "INT", "DERR", "RET", "RAW", "out", "FILE", "TO", "NOTE", "GROUP", "AL", "GEN", "BOX"], "T": ["Time", "D", "G", "O", "TP", "TT", "TN", "IT", "X", "t", "H", "L", "TY", "TM", "A", "E", "Q", "R", "B", "TC", "TS", "TA", "F", "OT", "Type", "V", "M", "Z", "Y", "N", "GT", "WT", "NB", "TB", "C", "K", "Total", "I", "P", "W", "Size", "VT", "S", "TD"], "index": ["seed", "count", "initial", "foot", "ite", "note", "long", "column", "error", "ox", "key", "run", "zero", "node", "name", "chain", "see", "int", "page", "loop", "set", "i", "head", "axis", "on", "scroll", "link", "Index", "unit", "val", "table", "x", "number", "draw", "cycle", "un", "find", "position", "len", "thread", "connection", "connect", "new", "second", "nn", "out", "length", "ion", "pos", "test", "object", "ind", "size", "num"], "n": ["ns", "k", "t", "no", "ind", "an", "nc", "ne", "all", "en", "name", "nan", "mn", "ner", "int", "ng", "sn", "d", "na", "nor", "on", "el", "l", "nl", "N", "ln", "nt", "nm", "len", "ned", "c", "nn", "nd", "num"], "line": ["se", "Line", "ide", "e", "ite", "note", "lin", "node", "ne", "lined", "nee", "name", "ner", "ine", "link", "point", "l", "ane", "nl", "x", "ln", "len", "out", "inline", "ate", "ode", "ind"]}}
{"code": " \\n  \\n  def neighbours(grid, (i, j), n, m):\\n      for a in range(max(i-1, 0), min(i+2, n)):\\n          for b in range(max(j-1, 0), min(j+2, m)):\\n              if (a != i or b != j):\\n                  yield (a, b)\\n  \\n  def isGridCorrect(grid):\\n      g = list(grid)\\n      n = len(g)\\n      m = len(g[0])\\n      queue = [(0, 0)]\\n  \\n      while queue:\\n          v = queue.pop(0)\\n          g[v[0]][v[1]] = 'r'\\n          bomb = False\\n          for (i, j) in neighbours(g, v, n, m):\\n              if g[i][j] == '*':\\n                  bomb = True\\n          if not bomb:\\n              for (i, j) in neighbours(g, v, n, m):\\n                  if g[i][j] != 'r':\\n                      queue.append((i, j))\\n  \\n      for i in range(n):\\n          for j in range(m):\\n              if g[i][j] != 'r' and g[i][j] != '*':\\n                  return 'WRONG'\\n  \\n      return 'Right'\\n  \\n  def createGrid(R, C, s):\\n      field = []\\n      for i in range(R):\\n          field.append([s] * C)\\n      field[0][0] = 'c'\\n      return field\\n  \\n  def draw(grid):\\n      s = \"\"\\n      for row in grid:\\n          s += \"\\n\" + ''.join(row)\\n      return s\\n  \\n  def reduceRows(grid, k, l, M):\\n      if k <= 2:\\n          return (grid, k, l, M)\\n      \\n  \\n      for j in range(l):\\n          grid[k-1][j] = '*'\\n      k -= 1\\n      M -= l\\n      return (grid, k, l, M)\\n  \\n  def reduceCols(grid, k, l, M):\\n      if l <= 2:\\n          return (grid, k, l, M)\\n      \\n  \\n      for i in range(k):\\n          grid[i][l-1] = '*'\\n      l -= 1\\n      M -= k\\n      return (grid, k, l, M)\\n  \\n  def solve(R, C, M):\\n      mp = M\\n      if M == 0:\\n          f = createGrid(R, C, '.')\\n          return draw(f)\\n      elif M == R*C - 1:\\n          f = createGrid(R, C, '*')\\n          return draw(f)\\n      elif (R == 2 or C == 2) and (M % 2 == 1 or M == R*C - 2):\\n          return \"\\n\" + 'Impossible' #+ '1: ' + str(R) + ' ' + str(C) + ' ' + str(mp)\\n      elif R > 2 and C > 2 and (M == R*C - 2 or M == R*C - 3 or M == R*C - 5 or M == R*C - 7):\\n          return \"\\n\" + 'Impossible' #+ '2: ' + str(R) + ' ' + str(C) + ' ' + str(mp)\\n      else:\\n          grid = createGrid(R, C, '.')\\n  \\n  \\n          k = R\\n          l = C\\n  \\n          while (M >= l and k > 2) or (M >= k and l > 2):\\n              if l >= k:\\n                  (grid, k, l, M) = reduceCols(grid, k, l, M)\\n              elif k > l:\\n                  (grid, k, l, M) = reduceRows(grid, k, l, M)\\n  \\n  \\n          if M == 0:\\n              return draw(grid)\\n          if M < l - 1 and k > 2:\\n              for j in range(l - M, l):\\n                  grid[k-1][j] = '*'\\n          elif M < k - 1 and l > 2:\\n              for i in range(k - M, k):\\n                  grid[i][l-1] = '*'\\n          elif l > 3 and k > 3:\\n              for i in range(2, k):\\n                  grid[i][l-1] = '*'\\n              M -= k - 2\\n              for j in range(l - M - 1, l - 1):\\n                  grid[k-1][j] = '*'\\n          else:\\n              return \"\\n\" + 'Impossible' #+ '3: ' + str(R) + ' ' + str(C) + ' ' + str(mp)\\n  \\n          return draw(grid)\\n  \\n  def main():\\n      N = int(sys.stdin.readline()) # number of testcases\\n      for i in range(N):\\n          [R, C, M] = [int(x) for x in sys.stdin.readline().rstrip().split()]\\n  \\n          result = solve(R, C, M)\\n          print (\"Case #%s:%s\" % (i+1, result))\\n  \\n  if __name__ == '__main__':\\n      main()\\n", "substitutes": {"grid": ["raid", "clear", "p", "console", "er", "e", "domain", "window", "fine", "wrapper", "jac", "item", "w", "ad", "d", "q", "cache", "r", "network", "http", "age", "output", "box", "dq", "c", "gc", "cell", "lat", "gi", "stock", "reg", "util", "mg", "manager", "record", "tile", "raw", "remote", "chain", "lay", "config", "via", "fields", "back", "gr", "out", "form", "this", "modified", "sheet", "cart", "array", "stack", "group", "y", "work", "ay", "table", "x", "query", "server", "card", "net", "gate", "bar", "data", "now", "play", "gray", "gs", "res", "range", "storage", "frame", "Grid", "client", "addr", "rid", "mat", "ace", "result", "gm", "cs", "wire", "cli", "db", "sh", "browser", "input", "ge", "sys", "game", "list"], "n": ["ns", "p", "nw", "t", "o", "no", "h", "nr", "an", "z", "nc", "ne", "ny", "en", "nan", "mn", "w", "d", "ng", "sn", "cn", "na", "q", "y", "names", "r", "nb", "nor", "nu", "np", "nl", "x", "N", "ln", "nt", "net", "nm", "min", "len", "nia", "out", "c", "fn", "nn", "size", "num"], "m": ["p", "em", "dm", "tm", "ms", "cm", "t", "o", "mm", "h", "z", "mat", "bm", "am", "perm", "um", "mn", "mx", "om", "d", "gm", "q", "im", "mi", "y", "r", "mt", "mc", "mu", "min", "sm", "ma", "rm", "mr", "mem", "c", "vm", "dim", "mod"], "a": ["au", "ap", "sa", "p", "la", "at", "ia", "A", "ax", "sta", "aq", "an", "z", "af", "ba", "am", "ar", "aa", "ja", "anta", "va", "ao", "aaa", "na", "ai", "ka", "ac", "aff", "ae", "ata", "eas", "aw", "ea", "ma", "ca", "ta", "c", "aj", "ak", "ab", "da"], "b": ["br", "bl", "abb", "ib", "bf", "e", "t", "o", "sb", "ob", "bc", "bb", "z", "mb", "ba", "B", "aa", "fb", "bi", "d", "be", "y", "eb", "r", "db", "lb", "erb", "bis", "by", "c", "bj", "ab", "bd"], "g": ["gi", "G", "p", "og", "gent", "go", "e", "gb", "reg", "gain", "t", "gas", "graph", "fl", "mg", "h", "gam", "z", "eg", "group", "gg", "google", "d", "bg", "gm", "q", "gd", "r", "config", "db", "ac", "ga", "deg", "gu", "tg", "gp", "pg", "back", "gate", "gre", "gh", "vg", "di", "msg", "gr", "ig", "alg", "ge", "c", "gc", "gt", "ger", "cfg", "erg", "game", "gs"], "queue": ["next", "menu", "qv", "count", "update", "worker", "priority", "buf", "check", "store", "history", "Q", "wait", "nr", "array", "block", "stack", "event", "league", "rl", "ued", "quote", "loop", "index", "q", "line", "archive", "counter", "forced", "late", "ue", "hold", "enabled", "buffer", "channel", "required", "bench", "Queue", "sequence", "que", "trigger", "age", "order", "batch", "card", "position", "layer", "pipe", "dq", "iter", "file", "timer", "plot", "test", "tube", "message", "status", "list"], "v": ["vy", "vector", "p", "inv", "vic", "qv", "it", "t", "o", "vol", "h", "lv", "z", "ve", "va", "q", "u", "vc", "r", "V", "vi", "env", "ev", "vv", "vt", "tv", "cv", "vs", "nv", "ver", "vp", "conv", "vr", "c", "uv", "vm", "iv", "av", "sv"], "bomb": ["bo", "piece", "Attack", "butt", "beat", "fuck", "Buzz", "Ball", "attack", "claimer", "Dynamic", "Battery", "zz", "aaa", "charge", "BALL", "healthy", "threat", "beard", "kick", "bang", "rick", "buffer", "board", "blow", "burst", "bolt", "nt", "bill", "Bomb", "card", "Controller", "ack", "Invalid", "rike", "boot", "bard", "Break", "Board", "bird", "controller", "Failure", "possibly", "BO", " bombs", "bug", "Fail"], "i": ["gi", "ki", "hi", "ic", "ji", "p", "ami", "li", "e", "it", "at", "ia", "t", "o", "io", "ik", "h", "id", "z", "ri", "ui", "ei", "info", "int", "ti", "ini", "bi", "il", "si", "u", "im", "y", "mi", "xi", "r", "ai", "q", "left", "me", "on", "ip", "ori", "x", "pi", "ii", "ij", "iu", "ix", "di", "I", "zi", "ion", "ie", "c", "ir", "yi", "ci"], "j": ["ji", "br", "p", "jj", "jl", "str", "rev", "ju", "e", "fr", "it", "at", "jp", "t", "o", "note", "li", "sp", "jo", "h", "off", "key", "z", "ja", "jac", "bi", "d", "dt", "uj", "q", "u", "y", "json", "r", "J", "ai", "kj", "db", "dj", "when", "oj", "bs", "x", "ij", "adj", "job", "jc", "obj", "di", "false", "js", "jump", "ion", "c", "ie", "je", "ll", "aj", "bj"], "R": ["func", "D", "G", "Right", "X", "RA", "H", "L", "CR", "Q", "A", "E", "self", "of", "ed", "B", "full", "_", "multi", "F", "r", "J", "V", "RO", "RS", "cont", "join", "Row", "Y", "N", "NR", "GR", "RR", "Rs", "K", "I", "get", "P", "W", "c", "T", "BR", "S"], "C": ["Co", "D", "G", "Ch", "X", "H", "L", "CR", "Q", "E", "CM", "Cr", "A", "B", "CS", "CC", "F", "J", "V", "Z", "Y", "N", "K", "DC", "I", "P", "W", "c", "T", "S", "Cs"], "s": ["res", "ns", "p", "ges", "str", "ats", "er", "e", "space", "rs", "ps", "ments", "t", "ings", "h", "ss", "strings", "z", "ls", "eds", "ds", "ws", "w", "d", "sets", "sc", "q", "y", "cs", "set", "r", "its", "ers", "fields", "ing", "bs", "x", "types", "string", "js", "sq", "c", "fs", "ts", "lines", "rows", "sys", "es", "S", "status", "gs"], "field": ["level", "function", "label", "vector", "tag", "band", "form", "load", "force", "word", "str", "flag", "column", "butt", "handler", "Field", "relation", "array", "key", "record", "window", "node", "group", "control", "z", "league", "rule", "char", "result", "line", "r", "pad", "join", "player", "buffer", "fields", "value", "message", "table", "number", "ld", "layer", "instance", "attr", "complex", "obj", "string", "file", "length", "bar", "data", "c", "attribute", "component", "cell", "FIELD", "comment", "mount", "pair"], "row": ["post", "rc", "col", "frame", "rs", "rec", "error", "array", "record", "node", "raw", "rown", "name", "item", "tr", "star", "line", "set", "entry", "r", "Row", "board", "ow", "usr", "instance", "card", "job", "obj", "box", "ows", "roll", "fc", "rows", "ry", "cell", "our", "step", "case", "pair"], "k": ["ki", "ks", "ic", "tk", "p", "ok", "it", "ek", "ijk", "o", "ik", "kind", "h", "key", "z", "ck", "id", "kid", "sk", "kt", "keys", "kw", "uk", "dk", "kk", "w", "d", "kh", "ke", "q", "u", "y", "r", "kr", "wk", "ka", "ko", "ac", "kj", "mk", "kn", "ku", "x", "ch", "kat", "K", "kg", "ky", "km", "kar", "c", "kl", "ak"], "l": ["lu", "p", "jl", "la", "li", "ll", "t", "o", "lin", "L", "le", "fl", "sl", "lis", "lc", "h", "lv", " L", "z", "lo", "ls", "il", "dl", "u", "line", "left", "ol", "r", "lp", "pl", "lb", "lt", "el", "nl", "ln", "ld", "al", "len", "hl", "yl", "ul", "c", "ml", "kl", "list"], "M": ["D", "G", "O", "Method", "Ch", "X", "Memory", "H", "L", "TM", "U", "A", "Q", "Motion", "CM", "NM", "Message", "MAN", "B", "Mi", "PM", "JM", "MM", "MX", "Matrix", "F", "J", "IM", "V", "Men", "Manager", "Y", "LM", "N", "Length", "Ms", "MT", "MI", "K", "My", "RM", "I", "P", "DM", "W", "Size", "MC", "T", "MS", "S", "AM", "All", "Num"]}}
{"code": " \\n  \\n  def solve(row1, row2):\\n      common = [x for x in row1 if x in row2]\\n      num_common = len(common)\\n      if num_common == 0:\\n          return 'Volunteer cheated!'\\n      elif num_common > 1:\\n          return 'Bad magician!'\\n      else:\\n          return common[0]\\n  \\n  def main():\\n      N = int(sys.stdin.readline()) # number of testcases\\n      for i in range(N):\\n          row_index1 = int(sys.stdin.readline())\\n          row1 = list()\\n          for j in range(4):\\n              if row_index1 == j + 1:\\n                  row1 = [int(x) for x in sys.stdin.readline().rstrip().split()]\\n              else:\\n                  sys.stdin.readline()\\n  \\n          row_index2 = int(sys.stdin.readline())\\n          row2 = list()\\n          for j in range(4):\\n              if row_index2 == j + 1:\\n                  row2 = [int(x) for x in sys.stdin.readline().rstrip().split()]\\n              else:\\n                  sys.stdin.readline()\\n  \\n          result = solve(row1, row2)\\n          print (\"Case #%s: %s\" % (i+1, result))\\n  \\n  if __name__ == '__main__':\\n      main()\\n", "substitutes": {"row1": ["cell3", "Row3", "rows01", "row01", "ow2", "cell2", "rows1", "cell1", "ow1", "Row1", "row3", "Row2", "cell01", " row3", "ow3", "rows3", " row01"], "row2": ["Row3", "col2", "cell2", "cell1", "colTwo", "col1", "col0", "row4", "rowTwo", "col4", "row0", "col3", "row3", "Row2", " row3", "cell4", " rowTwo", "RowTwo", " row4", " row0", "cell0"], "common": ["shared", "basic", "rem", "one", "default", "total", "initial", "used", "long", "unique", "m", "util", "public", "standard", "ordinary", "con", "all", "final", "seen", "general", "free", "official", "present", "specific", "full", "extra", "summary", "local", "same", "current", "generic", "similar", "required", "Common", "co", "members", "qualified", "bare", "tree", "san", "new", "normal", "onet", "may", "recent", "broad", "stable", "known", "com", "other", "good", "num"], "x": ["ux", "p", "xs", "check", "e", "ctx", "X", "rx", "xes", "t", "wx", "dx", "xp", " tx", "ax", "ox", "z", "ross", "xc", "s", "f", "xa", "tx", "xt", "mx", "w", "full", "xi", "y", "cross", "xf", "el", "yx", "Tx", " ax", "xe", "lex", "xd", "ix", "xy", "news", "a", "ex", "px", "xx", "v", "lat", "test", "fx"], "num_common": ["Num_global", "numobjCommon", "num2Common", " num_comm", "num_total", "num2comm", "num_Common", "numobjtotal", " num2common", "num2con", "num_basic", "Num_Common", "num2common", " num2comm", "numobjcommon", "numurecon", "num_comm", " num2Common", " num_con", "Num_basic", " num2con", " num_unique", "num_con", "num_global", "numurecommon", "numureCommon", " num_Common", "numobjunique", "num_unique", "Num_common", " num_total", "numurecomm"], "N": ["D", "O", "X", "H", "L", "E", "Q", "A", "NS", "n", "R", "B", "name", "size", "F", "NAME", "V", "M", "Z", "NUM", "NR", "C", "K", "I", "P", "T", "S", "Num"]}}
{"code": "CACHE = {(1, 1, 0): ['c'],\\n   (1, 2, 0): ['c.'],\\n   (1, 2, 1): ['*c'],\\n   (1, 3, 0): ['c..'],\\n   (1, 3, 1): ['*.c'],\\n   (1, 3, 2): ['**c'],\\n   (1, 4, 0): ['c...'],\\n   (1, 4, 1): ['*.c.'],\\n   (1, 4, 2): ['**.c'],\\n   (1, 4, 3): ['***c'],\\n   (1, 5, 0): ['c....'],\\n   (1, 5, 1): ['*.c..'],\\n   (1, 5, 2): ['**.c.'],\\n   (1, 5, 3): ['***.c'],\\n   (1, 5, 4): ['****c'],\\n   (2, 1, 0): ['c', '.'],\\n   (2, 1, 1): ['*', 'c'],\\n   (2, 2, 0): ['c.', '..'],\\n   (2, 2, 1): None,\\n   (2, 2, 2): None,\\n   (2, 2, 3): ['**', '*c'],\\n   (2, 3, 0): ['c..', '...'],\\n   (2, 3, 1): None,\\n   (2, 3, 2): ['*.c', '*..'],\\n   (2, 3, 3): None,\\n   (2, 3, 4): None,\\n   (2, 3, 5): ['***', '**c'],\\n   (2, 4, 0): ['c...', '....'],\\n   (2, 4, 1): None,\\n   (2, 4, 2): ['*.c.', '*...'],\\n   (2, 4, 3): None,\\n   (2, 4, 4): ['**.c', '**..'],\\n   (2, 4, 5): None,\\n   (2, 4, 6): None,\\n   (2, 4, 7): ['****', '***c'],\\n   (2, 5, 0): ['c....', '.....'],\\n   (2, 5, 1): None,\\n   (2, 5, 2): ['*.c..', '*....'],\\n   (2, 5, 3): None,\\n   (2, 5, 4): ['**.c.', '**...'],\\n   (2, 5, 5): None,\\n   (2, 5, 6): ['***.c', '***..'],\\n   (2, 5, 7): None,\\n   (2, 5, 8): None,\\n   (2, 5, 9): ['*****', '****c'],\\n   (3, 1, 0): ['c', '.', '.'],\\n   (3, 1, 1): ['*', '.', 'c'],\\n   (3, 1, 2): ['*', '*', 'c'],\\n   (3, 2, 0): ['c.', '..', '..'],\\n   (3, 2, 1): None,\\n   (3, 2, 2): ['**', '..', 'c.'],\\n   (3, 2, 3): None,\\n   (3, 2, 4): None,\\n   (3, 2, 5): ['**', '**', '*c'],\\n   (3, 3, 0): ['c..', '...', '...'],\\n   (3, 3, 1): ['*.c', '...', '...'],\\n   (3, 3, 2): None,\\n   (3, 3, 3): ['***', '...', 'c..'],\\n   (3, 3, 4): None,\\n   (3, 3, 5): ['***', '*..', '*.c'],\\n   (3, 3, 6): None,\\n   (3, 3, 7): None,\\n   (3, 3, 8): ['***', '***', '**c'],\\n   (3, 4, 0): ['c...', '....', '....'],\\n   (3, 4, 1): ['*.c.', '....', '....'],\\n   (3, 4, 2): ['**.c', '....', '....'],\\n   (3, 4, 3): ['*.c.', '*...', '*...'],\\n   (3, 4, 4): ['****', '....', 'c...'],\\n   (3, 4, 5): None,\\n   (3, 4, 6): ['****', '*...', '*.c.'],\\n   (3, 4, 7): None,\\n   (3, 4, 8): ['****', '**..', '**.c'],\\n   (3, 4, 9): None,\\n   (3, 4, 10): None,\\n   (3, 4, 11): ['****', '****', '***c'],\\n   (3, 5, 0): ['c....', '.....', '.....'],\\n   (3, 5, 1): ['*.c..', '.....', '.....'],\\n   (3, 5, 2): ['**.c.', '.....', '.....'],\\n   (3, 5, 3): ['***.c', '.....', '.....'],\\n   (3, 5, 4): ['**.c.', '*....', '*....'],\\n   (3, 5, 5): ['*****', '.....', 'c....'],\\n   (3, 5, 6): ['**.c.', '**...', '**...'],\\n   (3, 5, 7): ['*****', '*....', '*.c..'],\\n   (3, 5, 8): None,\\n   (3, 5, 9): ['*****', '**...', '**.c.'],\\n   (3, 5, 10): None,\\n   (3, 5, 11): ['*****', '***..', '***.c'],\\n   (3, 5, 12): None,\\n   (3, 5, 13): None,\\n   (3, 5, 14): ['*****', '*****', '****c'],\\n   (4, 1, 0): ['c', '.', '.', '.'],\\n   (4, 1, 1): ['*', '.', 'c', '.'],\\n   (4, 1, 2): ['*', '*', '.', 'c'],\\n   (4, 1, 3): ['*', '*', '*', 'c'],\\n   (4, 2, 0): ['c.', '..', '..', '..'],\\n   (4, 2, 1): None,\\n   (4, 2, 2): ['**', '..', 'c.', '..'],\\n   (4, 2, 3): None,\\n   (4, 2, 4): ['**', '**', '..', 'c.'],\\n   (4, 2, 5): None,\\n   (4, 2, 6): None,\\n   (4, 2, 7): ['**', '**', '**', '*c'],\\n   (4, 3, 0): ['c..', '...', '...', '...'],\\n   (4, 3, 1): ['*.c', '...', '...', '...'],\\n   (4, 3, 2): ['*.c', '*..', '...', '...'],\\n   (4, 3, 3): ['***', '...', 'c..', '...'],\\n   (4, 3, 4): ['***', '*..', '..c', '...'],\\n   (4, 3, 5): None,\\n   (4, 3, 6): ['***', '***', '...', 'c..'],\\n   (4, 3, 7): None,\\n   (4, 3, 8): ['***', '***', '*..', '*.c'],\\n   (4, 3, 9): None,\\n   (4, 3, 10): None,\\n   (4, 3, 11): ['***', '***', '***', '**c'],\\n   (4, 4, 0): ['c...', '....', '....', '....'],\\n   (4, 4, 1): ['*.c.', '....', '....', '....'],\\n   (4, 4, 2): ['**.c', '....', '....', '....'],\\n   (4, 4, 3): ['**.c', '*...', '....', '....'],\\n   (4, 4, 4): ['****', '....', 'c...', '....'],\\n   (4, 4, 5): ['****', '*...', '..c.', '....'],\\n   (4, 4, 6): ['****', '**..', '...c', '....'],\\n   (4, 4, 7): ['****', '*...', '*.c.', '*...'],\\n   (4, 4, 8): ['****', '****', '....', 'c...'],\\n   (4, 4, 9): None,\\n   (4, 4, 10): ['****', '****', '*...', '*.c.'],\\n   (4, 4, 11): None,\\n   (4, 4, 12): ['****', '****', '**..', '**.c'],\\n   (4, 4, 13): None,\\n   (4, 4, 14): None,\\n   (4, 4, 15): ['****', '****', '****', '***c'],\\n   (4, 5, 0): ['c....', '.....', '.....', '.....'],\\n   (4, 5, 1): ['*.c..', '.....', '.....', '.....'],\\n   (4, 5, 2): ['**.c.', '.....', '.....', '.....'],\\n   (4, 5, 3): ['***.c', '.....', '.....', '.....'],\\n   (4, 5, 4): ['***.c', '*....', '.....', '.....'],\\n   (4, 5, 5): ['*****', '.....', 'c....', '.....'],\\n   (4, 5, 6): ['*****', '*....', '..c..', '.....'],\\n   (4, 5, 7): ['*****', '**...', '...c.', '.....'],\\n   (4, 5, 8): ['*****', '***..', '....c', '.....'],\\n   (4, 5, 9): ['*****', '**...', '*..c.', '*....'],\\n   (4, 5, 10): ['*****', '*****', '.....', 'c....'],\\n   (4, 5, 11): ['*****', '**...', '**.c.', '**...'],\\n   (4, 5, 12): ['*****', '*****', '*....', '*.c..'],\\n   (4, 5, 13): None,\\n   (4, 5, 14): ['*****', '*****', '**...', '**.c.'],\\n   (4, 5, 15): None,\\n   (4, 5, 16): ['*****', '*****', '***..', '***.c'],\\n   (4, 5, 17): None,\\n   (4, 5, 18): None,\\n   (4, 5, 19): ['*****', '*****', '*****', '****c'],\\n   (5, 1, 0): ['c', '.', '.', '.', '.'],\\n   (5, 1, 1): ['*', '.', 'c', '.', '.'],\\n   (5, 1, 2): ['*', '*', '.', 'c', '.'],\\n   (5, 1, 3): ['*', '*', '*', '.', 'c'],\\n   (5, 1, 4): ['*', '*', '*', '*', 'c'],\\n   (5, 2, 0): ['c.', '..', '..', '..', '..'],\\n   (5, 2, 1): None,\\n   (5, 2, 2): ['**', '..', 'c.', '..', '..'],\\n   (5, 2, 3): None,\\n   (5, 2, 4): ['**', '**', '..', 'c.', '..'],\\n   (5, 2, 5): None,\\n   (5, 2, 6): ['**', '**', '**', '..', 'c.'],\\n   (5, 2, 7): None,\\n   (5, 2, 8): None,\\n   (5, 2, 9): ['**', '**', '**', '**', '*c'],\\n   (5, 3, 0): ['c..', '...', '...', '...', '...'],\\n   (5, 3, 1): ['*.c', '...', '...', '...', '...'],\\n   (5, 3, 2): ['*.c', '*..', '...', '...', '...'],\\n   (5, 3, 3): ['***', '...', 'c..', '...', '...'],\\n   (5, 3, 4): ['***', '*..', '..c', '...', '...'],\\n   (5, 3, 5): ['***', '*..', '*.c', '...', '...'],\\n   (5, 3, 6): ['***', '***', '...', 'c..', '...'],\\n   (5, 3, 7): ['***', '***', '*..', '..c', '...'],\\n   (5, 3, 8): None,\\n   (5, 3, 9): ['***', '***', '***', '...', 'c..'],\\n   (5, 3, 10): None,\\n   (5, 3, 11): ['***', '***', '***', '*..', '*.c'],\\n   (5, 3, 12): None,\\n   (5, 3, 13): None,\\n   (5, 3, 14): ['***', '***', '***', '***', '**c'],\\n   (5, 4, 0): ['c...', '....', '....', '....', '....'],\\n   (5, 4, 1): ['*.c.', '....', '....', '....', '....'],\\n   (5, 4, 2): ['**.c', '....', '....', '....', '....'],\\n   (5, 4, 3): ['**.c', '*...', '....', '....', '....'],\\n   (5, 4, 4): ['****', '....', 'c...', '....', '....'],\\n   (5, 4, 5): ['****', '*...', '..c.', '....', '....'],\\n   (5, 4, 6): ['****', '**..', '...c', '....', '....'],\\n   (5, 4, 7): ['****', '**..', '*..c', '....', '....'],\\n   (5, 4, 8): ['****', '****', '....', 'c...', '....'],\\n   (5, 4, 9): ['****', '****', '*...', '..c.', '....'],\\n   (5, 4, 10): ['****', '****', '**..', '...c', '....'],\\n   (5, 4, 11): ['****', '****', '*...', '*.c.', '*...'],\\n   (5, 4, 12): ['****', '****', '****', '....', 'c...'],\\n   (5, 4, 13): None,\\n   (5, 4, 14): ['****', '****', '****', '*...', '*.c.'],\\n   (5, 4, 15): None,\\n   (5, 4, 16): ['****', '****', '****', '**..', '**.c'],\\n   (5, 4, 17): None,\\n   (5, 4, 18): None,\\n   (5, 4, 19): ['****', '****', '****', '****', '***c'],\\n   (5, 5, 0): ['c....', '.....', '.....', '.....', '.....'],\\n   (5, 5, 1): ['*.c..', '.....', '.....', '.....', '.....'],\\n   (5, 5, 2): ['**.c.', '.....', '.....', '.....', '.....'],\\n   (5, 5, 3): ['***.c', '.....', '.....', '.....', '.....'],\\n   (5, 5, 4): ['***.c', '*....', '.....', '.....', '.....'],\\n   (5, 5, 5): ['*****', '.....', 'c....', '.....', '.....'],\\n   (5, 5, 6): ['*****', '*....', '..c..', '.....', '.....'],\\n   (5, 5, 7): ['*****', '**...', '...c.', '.....', '.....'],\\n   (5, 5, 8): ['*****', '***..', '....c', '.....', '.....'],\\n   (5, 5, 9): ['*****', '***..', '*...c', '.....', '.....'],\\n   (5, 5, 10): ['*****', '*****', '.....', 'c....', '.....'],\\n   (5, 5, 11): ['*****', '*****', '*....', '..c..', '.....'],\\n   (5, 5, 12): ['*****', '*****', '**...', '...c.', '.....'],\\n   (5, 5, 13): ['*****', '*****', '***..', '....c', '.....'],\\n   (5, 5, 14): ['*****', '*****', '**...', '*..c.', '*....'],\\n   (5, 5, 15): ['*****', '*****', '*****', '.....', 'c....'],\\n   (5, 5, 16): ['*****', '*****', '**...', '**.c.', '**...'],\\n   (5, 5, 17): ['*****', '*****', '*****', '*....', '*.c..'],\\n   (5, 5, 18): None,\\n   (5, 5, 19): ['*****', '*****', '*****', '**...', '**.c.'],\\n   (5, 5, 20): None,\\n   (5, 5, 21): ['*****', '*****', '*****', '***..', '***.c'],\\n   (5, 5, 22): None,\\n   (5, 5, 23): None,\\n   (5, 5, 24): ['*****', '*****', '*****', '*****', '****c']}\\n  \\n  \\n  T = int(input())\\n  for i in range(T):\\n  \tR, C, M = map(int, input().split())\\n  \tprint('Case #{}:'.format(i + 1))\\n  \ttry:\\n  \t\tprint('\\n'.join(CACHE[(R, C, M)]))\\n  \texcept:\\n  \t\tprint('Impossible')\\n", "substitutes": {"CACHE": ["CACHCH", "STACCH", "CACHA", "CAGACH", "STACHE", "STACACH", "STAGHE", "CAGHE", "CASHA", "STAGACH", "CAGCH", "CACACH", "CASCH", "CACHHA", "CACHHE", "CACCH", "CAGHA", "STAGCH", "CACHACH", "CASACH", "STACHA", "CASHE", "STAGHA"]}}
{"code": "T = int(input())\\n  \\n  for i in range(T):\\n      a1 = int(input())\\n      mat1 = [list(map(int, input().split())) for k in range(4)]\\n      a2 = int(input())\\n      mat2 = [list(map(int, input().split())) for k in range(4)]\\n      final_set = set(mat1[a1 - 1]) & set(mat2[a2 - 1])\\n      if not len(final_set):\\n          s = 'Volunteer cheated!'\\n      elif len(final_set) > 1:\\n          s = 'Bad magician!'\\n      else:\\n          s = list(final_set)[0]\\n      print('Case #{}: {}'.format(i + 1, s))\\n", "substitutes": {"T": ["D", "G", "O", "TT", "TN", "X", "t", "L", "TM", "TY", "E", "Q", "R", "B", "TC", "TS", "TA", "F", "J", "V", "M", "Z", "Y", "N", "TR", "TB", "C", "K", "I", "P", "W", "S"], "i": ["gi", "hi", "j", "p", "li", "ite", "t", "m", "ik", "key", "id", "n", " ii", " vi", "f", "phi", " ki", " j", "ti", "d", " I", "si", "xi", "im", "y", "mi", "multi", " ti", "\u00ed", "l", " Ki", "x", "pi", "ii", "ij", "iu", " x", "ix", "di", "I", "zi", "ion", "c", "v", " Xi"], "a1": ["aa01", "a10", "aa1", " a4", "sha01", "sha1", " a01", " a10", "sha10", "alpha1", "aaone", "alphaone", "a4", "aaart", "alpha4", "aa10", "a01", "aone", " aart", "shaart", " aone", "alpha01", "aart", "aa4"], "mat1": [" mat3", "mat0", "mat10", "mit10", "hat10", "mit1", "hat1", "mot0", "Mat8", "mot001", "Mat2", "mot1", "pat1", "pat3", "Mat3", "mat8", "mot10", "pat8", "Mat1", "mit001", "hat001", "hat0", "pat2", " mat8", "mat3", "mat001", "mit0"], "k": ["ki", "kan", "ks", "tk", "kok", "ok", "ek", "ijk", "ik", "kin", "ikk", "sk", "dk", "uk", "kid", "kt", "kw", "kk", "ke", "kh", "ka", "ko", "ked", "kn", "ake", "ku", "kil", "ken", "kar", "isk", "kl", "ak"], "a2": ["a7", "A2", "ma7", "aoTwo", "A4", " a4", "va2", "ma2", "staTwo", "A7", "a4", "sta8", " a7", "ao8", "ma1", "ma4", "alo", "ao2", "valo", "A1", "sta2", "aolo", "va8", "a8", "vaTwo", "aTwo", "stalo"], "mat2": ["hatalt", " mat3", "mt7", "matalt", "hat3", "hat8", "mt2", "pat5", "hat7", "pat3", "mmtwo", "patalt", "mat8", "mm8", " matalt", "mat5", "hattwo", "mm7", "mttwo", " mat5", "pat2", "hat2", "mat3", "hat5", "mattwo", "mm2", "mat7", "mt8"], "final_set": ["finalntset", "Final_Set", "final2ver", "final_com", "finalvalsets", "finalisedset", "Final_com", "final___store", "finalisedSet", "final2Set", "final2list", "standard___sum", "final_setting", "finalifcom", "Final_SET", "final_list", "Final_set", "finalvalsum", "final_sets", "final___sets", "finalifsetting", "standard_set", "finalifset", "standard_store", "final_ver", "final_site", "final___set", "final_Set", "Final_setting", "final_SET", "final2set", "standard___store", "finalntstore", "finalntsets", "standard___set", " final_ver", "finalvalstore", "finalisedsite", "final_store", "standard_sum", "standard_sets", "Final_site", "finalisedSET", "finalifSet", "finalntsum", " final_list", " final_Set", "finalvalset", "standard___sets", "final_sum", "final___sum"], "s": ["se", "ns", "comments", "p", "os", "gs", "str", "less", "ats", "south", "rs", "ps", "t", "m", "sql", "ss", "strings", "g", "n", "f", "ls", "spec", "ds", "ws", "summary", "set", "des", "cs", "tags", "state", "b", "ins", "hs", "l", "sym", "just", "string", "sq", "fs", "c", "v", "short", "ts", "series", "details", "S", "sb", "stats", "sv"]}}
